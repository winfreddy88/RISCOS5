/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "Licence").
 * You may not use this file except in compliance with the Licence.
 *
 * You can obtain a copy of the licence at
 * cddl/RiscOS/Sources/FileSys/ADFS/ADFS/LICENCE.
 * See the Licence for the specific language governing permissions
 * and limitations under the Licence.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the Licence file. If applicable, add the
 * following below this CDDL HEADER, with the fields enclosed by
 * brackets "[]" replaced with your own identifying information:
 * Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2015 Ben Avison.  All rights reserved.
 * Use is subject to license terms.
 */

/** \file module.c
 * Module entry point dispatch.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"

#include "Global/CMOS.h"
#include "Global/FSNumbers.h"
#include "Global/OsBytes.h"
#include "Global/ModHand.h"
#include "Global/RISCOS.h"
#include "Global/SWIs.h"
#include "Interface/FileCore.h"
#include "Interface/FileCoreErr.h"
#include "Interface/ADFSErr.h"
#include "Interface/ATA.h"

#include "SyncLib/synclib.h"

#undef Module_Title /* unfortunate clash between CMHG and Hdr:ModHand */
#include "ADFSHdr.h"
#include "command.h"
#include "discop.h"
#include "drive.h"
#include "globals.h"
#include "message.h"
#include "miscop.h"
#include "swi.h"

/* This function is autogenerated by ResGen, and returns a pointer to a
 * ResourceFS resource file data block */
extern void *Resources(void);

_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *e;
  uint32_t drive_handle = 0;
  uint32_t drive_spec;
  uint32_t num_winnies = 0;
  uint32_t default_drive = 0;
  uint32_t dir_cache = 0;
  uint32_t file_cache = 0;
  IGNORE(cmd_tail);
  IGNORE(podule_base);

  g_module_pw = pw;

#ifndef ROM_MODULE
  e = _swix(ResourceFS_RegisterFiles, _IN(0), Resources());
  if (e != NULL)
    return e;
#else
  /* In ROM builds, all resource files live in the Messages module instead */
#endif

  e = _swix(MessageTrans_OpenFile, _INR(0,2), &g_message_fd, "Resources:$.Resources.ADFS.Messages", 0);
  if (e != NULL)
  {
#ifndef ROM_MODULE
    _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif
    return e;
  }

  synclib_init();
#ifdef DEBUGLIB
  /* Set up debugging */
  debug_initialise(Module_Title, "", "");
  debug_set_device(DADEBUG_OUTPUT);
  debug_set_unbuffered_files(TRUE);
#endif

  /* Initialise global variables */
  message_lookup_buffer("Disc", g_media_type_name, MEDIA_TYPE_NAME_LEN);

  /* Query SATADriver to see how many drives are attached. For now, we don't
   * support hot-plugging, so we can save FileCore from allocating more
   * map dynamic areas than we need by doing this before we call FileCore_Create */
  while (!_swix(ATA_Enumerate, _INR(0,1)|_OUTR(1,2),
                ATAEnumerate_Drives, drive_handle,
                &drive_handle, &drive_spec) &&
         drive_handle != 0)
  {
    drive_attached((drive_spec & ATAEnumerate_CPIDMask) >> ATAEnumerate_CPIDShift,
                   (drive_spec & ATAEnumerate_DeviceIDMask) >> ATAEnumerate_DeviceIDShift,
                   drive_spec & ATAEnumerate_PacketDevice);
    if ((drive_spec & ATAEnumerate_PacketDevice) == 0 &&
        num_winnies < NUM_WINNIES)
      num_winnies++;
  }

  /* Read default drive from CMOS byte 11, bits 0-2 */
  _swix(OS_Byte, _INR(0,1)|_OUT(2), OsByte_ReadCMOS, DEFAULT_DRIVE_BYTE, &default_drive);
  default_drive = ((default_drive & DEFAULT_DRIVE_MASK) >> DEFAULT_DRIVE_SHIFT);

  /* Use OS_ReadMemMapInfo to discover the RAM size, rather than relying on an
   * undocumented return register from OS_SetEnv like old ADFS did! */
  uint32_t page_size, num_pages, ram_size;
  _swix(OS_ReadMemMapInfo, _OUTR(0,1), &page_size, &num_pages);
  ram_size = page_size * num_pages;

  /* Read dir cache from CMOS byte 199 */
  _swix(OS_Byte, _INR(0,1)|_OUT(2), OsByte_ReadCMOS, DIR_CACHE_BYTE, &dir_cache);
  if (dir_cache == 0)
  {
    /* There's a chance we might be back-ported to tiny machines one day, so
     * honour the rules for value 0 as with old ADFS. */
#ifdef ENABLE_BACKGROUND_TRANSFERS
    if (ram_size <= 1024*1024)
      dir_cache = ram_size / 512;
    else
      dir_cache = ram_size / 256;
#else
    dir_cache = ram_size / 128;
#endif
    dir_cache = MIN(dir_cache, 255*1024);
  }
  else
    dir_cache *= 1024;

#ifdef ENABLE_BACKGROUND_TRANSFERS
  /* Read file cache from CMOS byte 137 */
  _swix(OS_Byte, _INR(0,1)|_OUT(2), OsByte_ReadCMOS, FILE_CACHE_BYTE, &file_cache);
  if (file_cache == 1)
  {
    /* There's a chance we might be back-ported to tiny machines one day, so
     * honour the rules for value 1 as with old ADFS. */
    if (ram_size <= 1024*1024)
      file_cache = ram_size / 512 / 1024;
    else
      file_cache = ram_size / 256 / 1024;
    file_cache = MIN(file_cache, 255*1024);
  }
#endif

  /* Register with FileCore */
  e = _swix(FileCore_Create, _INR(0,6)|_OUTR(0,3),
          (uint32_t []) {
              /* not CreateFlag_FixedDiscNeedsFIQ */
              /* TODO: CreateFlag_FloppyNeedsFIQ depends on whether floppies use DMA */
              /* not CreateFlag_NoBigBuf - only currently used by RAMFS, probably
               *     most useful there because you don't get a speed benefit by
               *     doing additional RAM buffering of a RAM filing system */
              /* not CreateFlag_FixedDiscsMountLikeFloppy */
              /* not CreateFlag_FixedDiscPollChangeSupport */
              CreateFlag_FloppyEjects |
              /* not CreateFlag_FixedDiscEjects */
              CreateFlag_DriveStatusWorks |
              CreateFlag_BigDiscSupport |
              CreateFlag_NewErrorSupport |
              /* not CreateFlag_FloppyDiscsMountLikeFixed */
              ((uint32_t)fsnumber_adfs << (Create_Id * 8)),
              FILING_SYSTEM_TITLE - MODULE_BASE_ADDRESS,
              FILING_SYSTEM_AUTHOR " " FILING_SYSTEM_TITLE - MODULE_BASE_ADDRESS,
              (const char *)module_discop_veneer - MODULE_BASE_ADDRESS,
              (const char *)module_miscop_veneer - MODULE_BASE_ADDRESS
          },
          MODULE_BASE_ADDRESS,
          g_module_pw,
          NUM_FLOPPIES | (num_winnies << 8) | (default_drive << 16),
          dir_cache,
          file_cache,
          -1,         /* obsolete parameter - pass -1 for consistency with ADFS etc */
          &g_filecore_pw,
          &g_filecore_callback_floppy_op_completed,
          &g_filecore_callback_winnie_op_completed,
          &g_filecore_callback_release_fiq);
  if (e) goto failed_init;

  return NULL;

failed_init:
  _swix(OS_Module, _INR(0,1), ModHandReason_Delete, "FileCore%" FILING_SYSTEM_TITLE);
  _swix(MessageTrans_CloseFile, _IN(0), &g_message_fd);
#ifndef ROM_MODULE
  _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif
  return e;
}

_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{
  IGNORE(fatal);
  IGNORE(podule);
  IGNORE(pw);

  /* Kill our supporting FileCore instantiation */
  _swix(OS_Module, _INR(0,1), ModHandReason_Delete, "FileCore%" FILING_SYSTEM_TITLE);

  /* Free dynamic memory allocations */
  while (g_drive_list_head)
    drive_detached(g_drive_list_head->cpid, g_drive_list_head->deviceid, g_drive_list_head->packet_device);

  _swix(MessageTrans_CloseFile, _IN(0), &g_message_fd);
#ifndef ROM_MODULE
  _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif
  return 0;
}

_kernel_oserror *module_command(const char *arg_string, int argc, int cmd_no, void *pw)
{
  IGNORE(pw);

  size_t max_args = cmd_no != CMD_ADFS ? 8 : argc; /* argc not valid for *Configure commands */
  char *argv[MAX(max_args,1)];
  char arg_buffer[1024]; /* command line length limit - can't need more than that */

  /* Parse arguments */
  size_t args = 0;
  if (arg_string != arg_CONFIGURE_SYNTAX && arg_string != arg_STATUS)
  {
    const char *in = arg_string;
    char *out = arg_buffer;
    while (args < max_args) /* should always be true, except for *Configure commands with lots of arguments */
    {
      /* Skip leading / separating / trailing spaces */
      while (*in == ' ') ++in;
      if (*in == 0 || *in == 10 || *in == 13)
        break; /* end of command line */
      argv[args++] = out;
      bool arg_is_quoted = *in == '"'; /* quote rules only apply if first char is a quote */
      bool quote_active = false;
      while (true)
      {
        if (*in == 0 || *in == 10 || *in == 13 || (*in == ' ' && !quote_active))
          break; /* end of argument */
        if (arg_is_quoted && *in == '"')
        {
          if (quote_active && in[1] == '"')
            *out++ = '"'; /* two quote characters is an escaped quote */
          --quote_active; /* toggle quote state */
        }
        else
          *out++ = *in;
        ++in;
      }
      *out++ = '\0'; /* terminate our copy of the argument */
    }
  }

  switch (cmd_no)
  {
    case CMD_ADFS:
      return command_adfs();

#ifdef ENABLE_BACKGROUND_TRANSFERS
    case CMD_ADFSbuffers:
      if (arg_string == arg_CONFIGURE_SYNTAX)
        return command_configure_syntax_adfsbuffers();
      if (arg_string == arg_STATUS)
        return command_status_adfsbuffers();
      if (args != 1)
        return command_syntax_adfsbuffers();
      else
        return command_configure_adfsbuffers(argv[0]);
#endif

    case CMD_ADFSDirCache:
      if (arg_string == arg_CONFIGURE_SYNTAX)
        return command_configure_syntax_adfsdircache();
      if (arg_string == arg_STATUS)
        return command_status_adfsdircache();
      if (args != 1)
        return command_syntax_adfsdircache();
      else
        return command_configure_adfsdircache(argv[0]);

    case CMD_Drive:
      if (arg_string == arg_CONFIGURE_SYNTAX)
        return command_configure_syntax_drive();
      if (arg_string == arg_STATUS)
        return command_status_drive();
      if (args != 1)
        return command_syntax_drive();
      else
        return command_configure_drive(argv[0]);
  }
  /* Shouldn't get here */
  return NULL;
}

_kernel_oserror *module_swi(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);

  switch (swi_offset)
  {
#define PASS_TO_FILECORE(entry)                                 \
    case ADFS_##entry - ADFS_00:                                \
    {                                                           \
      int orig_r8 = r->r[8];                                    \
      r->r[8] = (int) g_filecore_pw;                            \
      _kernel_oserror *e = _kernel_swi(FileCore_##entry, r, r); \
      r->r[8] = orig_r8;                                        \
      return e;                                                 \
    }

    PASS_TO_FILECORE(DiscOp)
    PASS_TO_FILECORE(Drives)
    PASS_TO_FILECORE(FreeSpace)
    PASS_TO_FILECORE(DescribeDisc)
    PASS_TO_FILECORE(MiscOp)
    PASS_TO_FILECORE(SectorDiscOp)
    PASS_TO_FILECORE(FreeSpace64)
    PASS_TO_FILECORE(DiscOp64)

    //case ADFS_HDC - ADFS_00:  obsolete (ST506 only)

    case ADFS_Retries - ADFS_00:
      return swi_retries(r->r[0], (uint32_t *)&r->r[1], (uint32_t *)&r->r[2], (uint32_t *)&r->r[3]);

    //case ADFS_VetFormat - ADFS_00:  TODO: floppy support
    //case ADFS_FlpProcessDCB - ADFS_00:  TODO: floppy support

    case ADFS_ControllerType - ADFS_00:
      return swi_controller_type(r->r[0], (uint32_t *)&r->r[0]);

    case ADFS_PowerControl - ADFS_00:
      switch (r->r[0])
      {
      case 0:
        return swi_power_control_read_spin_state(r->r[1], (uint32_t *)&r->r[2]);
      case 1:
        return swi_power_control_set_autospindown(r->r[1], r->r[2], (uint32_t *)&r->r[3]);
      case 2:
        return swi_power_control_control_spin(r->r[1], r->r[2] == 0);
      default:
        return MESSAGE_ERRORLOOKUP(true, BadParms, 0);
      }

    //case ADFS_SetIDEController - ADFS_00:  TODO: PATA support

    case ADFS_IDEUserOp - ADFS_00:
      return swi_ide_user_op(r->r[0], (uint8_t *)r->r[2], (uint8_t *)r->r[3], r->r[4], r->r[5], (uint32_t *)&r->r[0], (size_t *)&r->r[4]);

    //case ADFS_ECCSAndRetries - ADFS_00:  not supported; was only used for Acorn's production test of hard drives

    case ADFS_LockIDE - ADFS_00:
      return swi_lock_ide(r->r[0]);

    case ADFS_IDEDeviceInfo - ADFS_00:
      switch (r->r[0])
      {
      case 0:
        return swi_ide_device_info_by_id((r->r[1] & 1) * 8, r->r[1] / 2, (uint32_t *)&r->r[1], (uint32_t *)&r->r[2], (void **)&r->r[3]);
      case 1:
        return swi_ide_device_info_by_id(r->r[1] & 15, r->r[1] / 16, (uint32_t *)&r->r[1], (uint32_t *)&r->r[2], (void **)&r->r[3]);
      case 2:
        return swi_ide_device_info_by_drive(r->r[1], (uint32_t *)&r->r[1], (uint32_t *)&r->r[2], (void **)&r->r[3]);
      default:
        return MESSAGE_ERRORLOOKUP(true, BadParms, 0);
      }

    case ADFS_ATAPIOp - ADFS_00:
      return swi_atapi_op(r->r[0], r->r[1], (uint8_t *)r->r[2], (uint8_t *)r->r[3], r->r[4], r->r[5], (uint32_t *)&r->r[0], (uint8_t **)&r->r[3], (size_t *)&r->r[4]);

    default:
      return MESSAGE_ERRORLOOKUP(false, BadSWI, "ADFS");
  }
  return NULL;
}

_kernel_oserror *module_miscop_handler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);

  dprintf("MiscOp %u\n", r->r[0]);

  switch (r->r[0])
  {
    case MiscOp_Mount:
      return miscop_mount(r->r[1], r->r[2], (uint8_t *) r->r[3], r->r[4], (disc_record_t *) r->r[5]).oserror;

    case MiscOp_PollChanged:
      miscop_poll_changed(r->r[1], (uint32_t *) &r->r[2], (uint32_t *) &r->r[3]);
      return NULL;

    case MiscOp_LockDrive:
      miscop_lock_drive(r->r[1]);
      return NULL;

    case MiscOp_UnlockDrive:
      miscop_unlock_drive(r->r[1]);
      return NULL;

    case MiscOp_PollPeriod:
      miscop_poll_period(r->r[1], (uint32_t *) &r->r[5], (const char **) &r->r[6]);
      return NULL;

    case MiscOp_Eject:
      miscop_eject(r->r[1]);
      return NULL;

    case MiscOp_DriveStatus:
      miscop_drive_status(r->r[1], (uint32_t *) &r->r[2]);
      return NULL;

    case MiscOp_ReadInfo: /* shouldn't be used for low-level MiscOp */
    default:
      return (_kernel_oserror *) BadParmsErr;
  }
}

_kernel_oserror *module_discop_handler(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e;
  uint32_t reason;
  uint32_t flags;
  uint32_t drive = (r->r[2] >> LegacyDiscAddress_DriveNumber_Shift) & LegacyDiscAddress_DriveNumber_Mask;
  uint64_t disc_address;
  uint8_t  log2_sector_size;
  IGNORE(pw);

  dprintf("DiscOp %u, flags %03X, disc address %u/%08X, buffer %08X, length %u\n",
      r->r[1] & DiscOp_Op_Mask,
      r->r[1] &~ DiscOp_Op_Mask,
      drive,
      r->r[2] & LegacyDiscAddress_SectorOffset_Mask,
      r->r[3],
      r->r[4]);

  reason = r->r[1] & DiscOp_Op_Mask;
  switch (reason)
  {
    /* Ops that we support */
    case DiscOp_Verify:
      if (r->r[1] & DiscOp_Op_BackgroundOp_Flag)
        return (_kernel_oserror *) BadParmsErr;
      /* else drop through */
    case DiscOp_ReadSecs:
    case DiscOp_WriteSecs:
      spinrw_read_lock(&g_drive_lock);
      log2_sector_size = g_drive[drive - 4 + NUM_FLOPPIES]->log2_sector_size;
      spinrw_read_unlock(&g_drive_lock);
      flags = r->r[1] & (DiscOp_Op_ScatterList_Flag | DiscOp_Op_IgnoreEscape_Flag |
                         DiscOp_Op_IgnoreTimeout_Flag | DiscOp_Op_BackgroundOp_Flag);
      flags *= ATAOp_Scatter / DiscOp_Op_ScatterList_Flag;
      disc_address = ((uint64_t) r->r[2] & LegacyDiscAddress_SectorOffset_Mask) << log2_sector_size;
      if (disc_address + r->r[4] >= 1ull << (LegacyDiscAddress_DriveNumber_Shift + log2_sector_size))
        /* We won't be able to update the disc address properly on exit, at
         * least in the SectorDiscOp world */
        return (_kernel_oserror *) BadParmsErr;
      e = discop(reason, flags,
                 drive, &disc_address,
                 (block_or_scatter_t *) &r->r[3], (size_t *) &r->r[4]
                 ).oserror;
      r->r[2] = (r->r[2] &~ LegacyDiscAddress_SectorOffset_Mask) | (uint32_t) (disc_address >> log2_sector_size);
      return e;

    /* Ops that we don't support, but lack of support is harmless */
    case DiscOp_Seek:
    case DiscOp_Restore:
    case DiscOp_StepIn:
    case DiscOp_StepOut:
    case DiscOp_Specify:
    case DiscOp_WriteTrk: /* bodge for now to make HForm work */
      return NULL;

    /* Ops that we don't support, but caller would expect to do something */
    case DiscOp_ReadTrk:
    // case DiscOp_WriteTrk: bodge for now to make HForm work
      /* drop through */

    /* Anything else suggests a caller error, including DiscOp_CachedReadSecs which shouldn't get here */
    default:
      return (_kernel_oserror *) BadParmsErr;
  }
}
