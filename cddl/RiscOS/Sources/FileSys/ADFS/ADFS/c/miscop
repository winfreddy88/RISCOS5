/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "Licence").
 * You may not use this file except in compliance with the Licence.
 *
 * You can obtain a copy of the licence at
 * cddl/RiscOS/Sources/FileSys/ADFS/ADFS/LICENCE.
 * See the Licence for the specific language governing permissions
 * and limitations under the Licence.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the Licence file. If applicable, add the
 * following below this CDDL HEADER, with the fields enclosed by
 * brackets "[]" replaced with your own identifying information:
 * Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2015 Ben Avison.  All rights reserved.
 * Use is subject to license terms.
 */

/** \file miscop.c
 * Implementation of low-level miscellaneous functions.
 */

#include "Interface/ATA.h"
#include "Interface/FileCore.h"
#include "Interface/FileCoreErr.h"

#include "discop.h"
#include "miscop.h"

/** Time between polls, in cs. This is the same as old ADFS uses with 82710 floppy controllers. */
#define POLL_PERIOD (100)

low_level_error_t miscop_mount(uint32_t drive, uint32_t byte_address, uint8_t * restrict buffer, size_t length, disc_record_t * restrict disc_record)
{
  low_level_error_t e;
  uint64_t disc_address = (uint64_t) byte_address & LegacyDiscAddress_ByteOffset_Mask;
  IGNORE(disc_record);

  dprintf("Mount - from :%u/%08X to %p, length %u, disc record %p\n",
      drive, byte_address, buffer, length, (void *) disc_record);

  e = discop(DiscOp_ReadSecs, ATAOp_DisableEscape, drive, &disc_address, (block_or_scatter_t *) &buffer, &length);
  /* Unlike DiscOps, we don't update the pointers on exit */

  /* Unlike old ADFS, we no longer use the hardware specific parameters from
   * the disc record, so no need to parse the data that has been read. */
  return e;
}

void miscop_poll_changed(uint32_t drive, uint32_t * restrict sequence_number, uint32_t * restrict result_flags)
{
  /* For now, we only handle the hard disc case */
  IGNORE(drive);
  *sequence_number = 0;
  *result_flags = MiscOp_PollChanged_EmptyWorks_Flag | MiscOp_PollChanged_ChangedWorks_Flag | MiscOp_PollChanged_NotChanged_Flag;

  dprintf("PollChanged(drive %u) - return flags %03X, sequence_number %u\n", drive, *result_flags, *sequence_number);
  return;
}

void miscop_lock_drive(uint32_t drive)
{
  IGNORE(drive);
  /* Could perhaps turn on the LED as the PRM suggests */
}

void miscop_unlock_drive(uint32_t drive)
{
  IGNORE(drive);
  /* Could perhaps turn off the LED as the PRM suggests */
}

void miscop_poll_period(uint32_t drive, uint32_t * restrict poll_period, const char ** restrict media_type_name)
{
  IGNORE(drive);
  *poll_period = POLL_PERIOD;
  *media_type_name = g_media_type_name;
}

void miscop_eject(uint32_t drive)
{
  /* Can't do this */
  IGNORE(drive);
}

void miscop_drive_status(uint32_t drive, uint32_t *status_flags)
{
  /* No need to hide drives unless/until we get hotplug support */
  IGNORE(drive);
  *status_flags = 0;
}
