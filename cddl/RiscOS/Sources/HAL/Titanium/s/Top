;
; CDDL HEADER START
;
; The contents of this file are subject to the terms of the
; Common Development and Distribution License (the "Licence").
; You may not use this file except in compliance with the Licence.
;
; You can obtain a copy of the licence at
; cddl/RiscOS/Sources/HAL/Titanium/LICENCE.
; See the Licence for the specific language governing permissions
; and limitations under the Licence.
;
; When distributing Covered Code, include this CDDL HEADER in each
; file and include the Licence file. If applicable, add the
; following below this CDDL HEADER, with the fields enclosed by
; brackets "[]" replaced with your own identifying information:
; Portions Copyright [yyyy] [name of copyright owner]
;
; CDDL HEADER END
;
;
; Copyright 2014 Elesar Ltd.  All rights reserved.
; Use is subject to license terms.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ImageSize.<ImageSize>
        GET     Hdr:HALSize.<HALSize>
        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.RegMap
        GET     hdr.StaticWS
                
        AREA    |!!!Top|, CODE, READONLY, PIC
        ENTRY

        EXPORT  GPHeader
        IMPORT  EntryDescriptor
        IMPORT  SetupPinMux
        IMPORT  SetupInterruptMux
        IMPORT  SetupDMAMux
        IMPORT  SetupClockMux
        IMPORT  HAL_DebugTXInlineString

BaudDivisor     * ClkPer4/16/115200     ; 115200bps
DDRClockMHz     * 532                   ; MHz
      [ Vayu
DDRRdLatency    * 9                     ; RL=AL+CL
DDRWrLatency    * 6                     ; WL=AL+CWL
      |
DDRRdLatency    * 7                     ; RL=AL+CL
DDRWrLatency    * 6                     ; WL=AL+CWL
      ]
GPBootSizeShift * 11
GPBootSize      * 1:SHL:GPBootSizeShift ; Just need the top off QSPI flash
SFIFastRead     * &0B                   ; 1 command + 3 address + 1 delay
SFIQuadRead     * &6B                   ; 1 command + 3 address + 1 delay
SFIPageProgram  * &02                   ; 1 command + 3 address + 0 delay
SFIBitWidth     * 4                     ; Single or quad reads

                ^ 0
ParamM          # 2                     ; Type A and B table layout
ParamN          # 2
ParamM2         # 2
ParamM3         # 2                     ; Type A only parameters
ParamH1y        # 2 * 4
ParamH2y        # 2 * 4

                ^ 0
ParamConfig     # 4                     ; Memory parameter table layout
ParamConfig2    # 4
ParamByteWidth  # 1
ParamRows       # 1
ParamColumns    # 1
ParamBanks      # 1
ParamTiming1    # 4
ParamRefresh    # 4
ParamTiming2    # 4
ParamTiming3    # 4
ParamTimingZQ   # 4
ParamPhyControl # 4
ParamExtPhyRegs # 25 * 4
ParamEnd        # 4

GPHeader
        ; Needed by the mask ROM loader
        DCD     GPBootSize
        DCD     OCMCRAM1_PhysBase + (GPImage - GPHeader)
GPImage
        B       EarlySetup
        DCB     "(C)2014 SPROW", 0
        
        ASSERT  . - GPHeader < 0x60
        %       0x60 - (. - GPHeader)
ROMSize
        DCD     0                       ; Magic location for the build system
              
ClockParamsPer
        DCW     96, 4                   ; M=96 N=4 => 20x2x96/5 => 768MHz PLL
        DCW     4                       ; M2=4 => 768/4 => 192MHz and 96MHz main output
        DCW     -1                      ; M3 not present
        DCW     3, 4, 12, 4             ; H11 = 768/3 => 256MHz FUNC_256M_CLK
                                        ; H12 = 768/4 => 192MHz DSS_GFCLK
                                        ; H13 = 768/12 => 64MHz QSPI
                                        ; H14 = 768/4 => 192MHz PER_GPU_CLK
        DCW     -1, -1, -1, -1          ; H21/H22/H23/H24 not present

ClockParamsCore
        DCW     266, 4                  ; M=266 N=4 => 20x2x266/5 => 2128MHz PLL
        DCW     8                       ; M2=8 => 2128/8 => 266MHz and 133MHz main output
        DCW     -1                      ; M3 not present
        DCW     -1, 8, 62, 10           ; H12 = 2128/8  => 266MHz CORE_X2_CLK
                                        ; H13 = 2128/62 => 34.3MHz CORE_USB_OTG_SS_LFPS_TX_CLK
                                        ; H14 = 2128/10 => 212.8MHz CORE_GPU_CLK
        DCW     -1, 10, 14, 12          ; H22 = 2128/10 => 212.8MHz CORE_IPU_ISS_BOOST_CLK
                                        ; H23 = 2128/14 => 152MHz CORE_ISS_MAIN_CLK
                                        ; H24 = 2128/12 => 177.3MHz BB2D_GFCLK

ClockParamsMPU
        DCW     50, 0                   ; M=50 N=0 => 20x2x50/1 => 2000MHz PLL
        DCW     1                       ; M2=1 => 2000/1 => (2000MHz and) 1000MHz main output
        DCW     -1                      ; M3 not present
        DCW     -1, -1, -1, -1          ; H11/H12/H13/H14 not present
        DCW     -1, -1, -1, -1          ; H21/H22/H23/H24 not present

ClockParamsDDR
        DCW     266, 4                  ; M=266 N=4 => 20x2x266/5 => 2128MHz PLL
        DCW     2                       ; M2=2 => 2128/2 => (1064MHz and) 532MHz main output
        DCW     -1                      ; M3 not present
        DCW     8, -1, -1, -1           ; H11 = 2128/8 => 266MHz EMIF_DLL_GCLK
                                        ; H12/H13/H14 not present
        DCW     -1, -1, -1, -1          ; H21/H22/H23/H24 not present

ClockParamsABE
        DCW     48, 4                   ; M=48 N=4 => 20x2x48/5 => 384MHz PLL
        DCW     10                      ; M2=10 => 384/10 => 38.4MHz and 19.2MHz main output
        DCW     31                      ; M3 = 384/31 => 12.4MHz CORE_DPLL_HS_CLK
        DCW     -1, -1, -1, -1          ; H11/H21/H23/H24 not present
        DCW     -1, -1, -1, -1          ; H21/H22/H23/H24 not present

ClockParamsGMAC
        DCW     25, 1                   ; M=25 N=1 => 20x2x25/2 => 500MHz PLL
        DCW     1                       ; M2=1 => 500/1 => (500MHz and) 250MHz main output
        DCW     31                      ; M3 = 500/31 => 16.1MHz ICSS_IEP_CLK
        DCW     10                      ; H11 = 500/10 => 50MHz GMAC_RMII_HS_CLK
        DCW     2                       ; H12 = 500/2 => 250MHz GMII_250MHZ_CLK
        DCW     31                      ; H13 = 500/31 => 16.1MHz ICSS_CLK
        DCW     -1                      ; H14 not present
        DCW     -1, -1, -1, -1          ; H21/H22/H23/H24 not present

ClockParamsUSB
        DCW     480, 9                  ; M=48 N=9 => 20x480/10 => 960MHz DCO
        DCW     2                       ; M2=2 => 960/2 => 480MHz output
        ALIGN

ClockParamsPCIe
        DCW     500, 9                  ; M=500 N=9 => 20x500/10 => 1000MHz DCO
        DCW     10                      ; M2=10 => 1000/10 => 100MHz PCIE_REF_CLK
        ALIGN

MemParamsEMIF1
      [ Vayu
        ; EMIF1 = 2 x 128M x 16b = 4Gb = 512MB
        DCD     EMIF_SDRAM_CONFIG_SDRAM_TYPE_DDR3 :OR: EMIF_SDRAM_CONFIG_NARROW_MODE_32B :OR: \
                EMIF_SDRAM_CONFIG_DDR_TERM_RZQ_BY4 :OR: EMIF_SDRAM_CONFIG_DDR2_DDQS :OR: \
                EMIF_SDRAM_CONFIG_SDRAM_DRIVE_RZQ_BY7 :OR: \
                EMIF_SDRAM_CONFIG_CWL_6 :OR: \
                EMIF_SDRAM_CONFIG_CL_9 :OR: \
                EMIF_SDRAM_CONFIG_ROWSIZE_14 :OR: \
                EMIF_SDRAM_CONFIG_IBANK_8 :OR: \
                EMIF_SDRAM_CONFIG_COLSIZE_10
        DCD     EMIF_SDRAM_CONFIG_2_EBANK_POS
        DCB     4, 14, 10, 8            ; Bytes wide, rows, columns, banks, hence size
        DCD     ((1 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RTW_SHIFT) :OR: \
                ((9 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RP_SHIFT) :OR: \
                ((9 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RCD_SHIFT) :OR: \
                ((10 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_WR_SHIFT) :OR: \
                ((24 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RAS_SHIFT) :OR: \
                ((33 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RC_SHIFT) :OR: \
                ((4 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RRD_SHIFT) :OR: \
                ((5 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_WTR_SHIFT)
      |
        ; EMIF1 = 2 x 256M x 16b = 8Gb = 1GB
        DCD     EMIF_SDRAM_CONFIG_SDRAM_TYPE_DDR3 :OR: EMIF_SDRAM_CONFIG_NARROW_MODE_32B :OR: \
                EMIF_SDRAM_CONFIG_DDR_TERM_RZQ_BY4 :OR: EMIF_SDRAM_CONFIG_DDR2_DDQS :OR: \
                EMIF_SDRAM_CONFIG_SDRAM_DRIVE_RZQ_BY7 :OR: \
                EMIF_SDRAM_CONFIG_CWL_6 :OR: \
                EMIF_SDRAM_CONFIG_CL_7 :OR: \
                EMIF_SDRAM_CONFIG_ROWSIZE_15 :OR: \
                EMIF_SDRAM_CONFIG_IBANK_8 :OR: \
                EMIF_SDRAM_CONFIG_COLSIZE_10
        DCD     EMIF_SDRAM_CONFIG_2_EBANK_POS
        DCB     4, 15, 10, 8            ; Bytes wide, rows, columns, banks, hence size
        DCD     ((1 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RTW_SHIFT) :OR: \
                ((9 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RP_SHIFT) :OR: \
                ((9 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RCD_SHIFT) :OR: \
                ((9 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_WR_SHIFT) :OR: \
                ((20 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RAS_SHIFT) :OR: \
                ((27 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RC_SHIFT) :OR: \
                ((5 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RRD_SHIFT) :OR: \
                ((5 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_WTR_SHIFT)
      ]
        DCD     EMIF_SDRAM_REFRESH_PASR_100PCT :OR: \
                ((64000 * DDRClockMHz) / 8192) ; 64000us and 8k refresh in clock ticks
        DCD     ((4 - 1) :SHL: EMIF_SDRAM_TIMING_2_T_XP_SHIFT) :OR: \
                (0 :SHL: EMIF_SDRAM_TIMING_2_T_ODT_SHIFT) :OR: \
                ((&90 - 1) :SHL: EMIF_SDRAM_TIMING_2_T_XSNR_SHIFT) :OR: \
                ((&200 - 1) :SHL: EMIF_SDRAM_TIMING_2_T_XSRD_SHIFT) :OR: \
                ((5 - 1) :SHL: EMIF_SDRAM_TIMING_2_T_RTP_SHIFT) :OR: \
                ((4 - 1) :SHL: EMIF_SDRAM_TIMING_2_T_CKE_SHIFT)
        DCD     (0 :SHL: EMIF_SDRAM_TIMING_3_T_PDLL_UL_SHIFT) :OR: \
                ((5 - 1) :SHL: EMIF_SDRAM_TIMING_3_T_CKESR_SHIFT) :OR: \
                ((64 - 1) :SHL: EMIF_SDRAM_TIMING_3_ZQ_ZQCS_SHIFT) :OR: \
                ((107 - 1) :SHL: EMIF_SDRAM_TIMING_3_T_RFC_SHIFT) :OR: \
                (9 :SHL: EMIF_SDRAM_TIMING_3_T_RAS_MAX_SHIFT)
        DCD     (((256 / 64) - 1) :SHL: EMIF_SDRAM_OUTPUT_IMPEDANCE_CAL_CONFIG_ZQ_ZQCL_MULT_SHIFT) :OR: \
                8192                    ; ZQCL:ZQCS = 256:64, arbitrary 8k refreshes per ZQCS
      [ Vayu
        DCD     ((DDRRdLatency + 2 - 1) :SHL: EMIF_DDR_PHY_READ_LATENCY_SHIFT) :OR: \
                EMIF_DDR_PHY_RDLVL_MASK :OR: \
                EMIF_DDR_PHY_RDLVLGATE_MASK :OR: \
                EMIF_DDR_PHY_WRLVL_MASK :OR: \
                EMIF_DDR_PHY_PHY_HALF_DELAYS :OR: \
                EMIF_DDR_PHY_PHY_INVERT_CLKOUT :OR: \
                (16 :SHL: EMIF_DDR_PHY_PHY_DLL_LOCK_DIFF_SHIFT)
        DCD     0x04040100
        DCD     0x009E009E, 0x009E009E, 0x009E009E, 0x009E009E, 0x009E009E ; FIFO WE[0:3,ECC]
        DCD     0x002E002E, 0x002E002E, 0x002E002E, 0x002E002E, 0x002E002E ; RD DQS[0:3,ECC]
        DCD     0x004D004D, 0x004D004D, 0x004D004D, 0x004D004D, 0x004D004D ; WR DATA[0:31,ECC]
        DCD     0x004D004D, 0x004D004D, 0x004D004D, 0x004D004D, 0x004D004D ; WR DQS[0:3,ECC]
        DCD     0x00000000, 0x00600020, 0x40010080, 0x08102040, -1
      |
        DCD     ((DDRRdLatency + 3 - 1) :SHL: EMIF_DDR_PHY_READ_LATENCY_SHIFT) :OR: \
                EMIF_DDR_PHY_RDLVL_MASK :OR: \
                EMIF_DDR_PHY_RDLVLGATE_MASK :OR: \
                EMIF_DDR_PHY_WRLVL_MASK :OR: \
                EMIF_DDR_PHY_PHY_HALF_DELAYS :OR: \
                EMIF_DDR_PHY_PHY_INVERT_CLKOUT :OR: \
                (16 :SHL: EMIF_DDR_PHY_PHY_DLL_LOCK_DIFF_SHIFT)
        DCD     0x04040100
        DCD     0x009D009D, 0x009D009D, 0x009D009D, 0x009D009D, 0x009D009D ; FIFO WE[0:3,ECC]
        DCD     0x002D002D, 0x002D002D, 0x002D002D, 0x002D002D, 0x002D002D ; RD DQS[0:3,ECC]         
        DCD     0x00570057, 0x00570057, 0x00570057, 0x00570057, 0x00570057 ; WR DATA[0:31,ECC]       
        DCD     0x00570057, 0x00570057, 0x00570057, 0x00570057, 0x00570057 ; WR DQS[0:3,ECC]         
        DCD     0x00000000, 0x00600020, 0x40010080, 0x08102040, -1
      ]
MemParamsEMIF2
      [ Vayu
        ; EMIF2 = 4 x 256M x 8b = 8Gb = 1GB
        DCD     EMIF_SDRAM_CONFIG_SDRAM_TYPE_DDR3 :OR: EMIF_SDRAM_CONFIG_NARROW_MODE_32B :OR: \
                EMIF_SDRAM_CONFIG_DDR_TERM_RZQ_BY4 :OR: EMIF_SDRAM_CONFIG_DDR2_DDQS :OR: \
                EMIF_SDRAM_CONFIG_SDRAM_DRIVE_RZQ_BY7 :OR: \
                EMIF_SDRAM_CONFIG_CWL_6 :OR: \
                EMIF_SDRAM_CONFIG_CL_9 :OR: \
                EMIF_SDRAM_CONFIG_ROWSIZE_15 :OR: \
                EMIF_SDRAM_CONFIG_IBANK_8 :OR: \
                EMIF_SDRAM_CONFIG_COLSIZE_10
        DCD     EMIF_SDRAM_CONFIG_2_EBANK_POS
        DCB     4, 15, 10, 8            ; Bytes wide, rows, columns, banks, hence size
        DCD     ((1 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RTW_SHIFT) :OR: \
                ((9 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RP_SHIFT) :OR: \
                ((9 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RCD_SHIFT) :OR: \
                ((10 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_WR_SHIFT) :OR: \
                ((24 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RAS_SHIFT) :OR: \
                ((33 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RC_SHIFT) :OR: \
                ((4 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RRD_SHIFT) :OR: \
                ((5 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_WTR_SHIFT)
      |
        ; EMIF2 = 2 x 256M x 16b = 8Gb = 1GB
        DCD     EMIF_SDRAM_CONFIG_SDRAM_TYPE_DDR3 :OR: EMIF_SDRAM_CONFIG_NARROW_MODE_32B :OR: \
                EMIF_SDRAM_CONFIG_DDR_TERM_RZQ_BY4 :OR: EMIF_SDRAM_CONFIG_DDR2_DDQS :OR: \
                EMIF_SDRAM_CONFIG_SDRAM_DRIVE_RZQ_BY7 :OR: \
                EMIF_SDRAM_CONFIG_CWL_6 :OR: \
                EMIF_SDRAM_CONFIG_CL_7 :OR: \
                EMIF_SDRAM_CONFIG_ROWSIZE_15 :OR: \
                EMIF_SDRAM_CONFIG_IBANK_8 :OR: \
                EMIF_SDRAM_CONFIG_COLSIZE_10
        DCD     EMIF_SDRAM_CONFIG_2_EBANK_POS
        DCB     4, 15, 10, 8            ; Bytes wide, rows, columns, banks, hence size
        DCD     ((1 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RTW_SHIFT) :OR: \
                ((9 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RP_SHIFT) :OR: \
                ((9 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RCD_SHIFT) :OR: \
                ((9 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_WR_SHIFT) :OR: \
                ((20 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RAS_SHIFT) :OR: \
                ((27 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RC_SHIFT) :OR: \
                ((5 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_RRD_SHIFT) :OR: \
                ((5 - 1) :SHL: EMIF_SDRAM_TIMING_1_T_WTR_SHIFT)
      ]
        DCD     EMIF_SDRAM_REFRESH_PASR_100PCT :OR: \
                ((64000 * DDRClockMHz) / 8192) ; 64000us and 8k refresh in clock ticks
        DCD     ((4 - 1) :SHL: EMIF_SDRAM_TIMING_2_T_XP_SHIFT) :OR: \
                (0 :SHL: EMIF_SDRAM_TIMING_2_T_ODT_SHIFT) :OR: \
                ((&90 - 1) :SHL: EMIF_SDRAM_TIMING_2_T_XSNR_SHIFT) :OR: \
                ((&200 - 1) :SHL: EMIF_SDRAM_TIMING_2_T_XSRD_SHIFT) :OR: \
                ((5 - 1) :SHL: EMIF_SDRAM_TIMING_2_T_RTP_SHIFT) :OR: \
                ((4 - 1) :SHL: EMIF_SDRAM_TIMING_2_T_CKE_SHIFT)
        DCD     (0 :SHL: EMIF_SDRAM_TIMING_3_T_PDLL_UL_SHIFT) :OR: \
                ((5 - 1) :SHL: EMIF_SDRAM_TIMING_3_T_CKESR_SHIFT) :OR: \
                ((64 - 1) :SHL: EMIF_SDRAM_TIMING_3_ZQ_ZQCS_SHIFT) :OR: \
                ((107 - 1) :SHL: EMIF_SDRAM_TIMING_3_T_RFC_SHIFT) :OR: \
                (9 :SHL: EMIF_SDRAM_TIMING_3_T_RAS_MAX_SHIFT)
        DCD     (((256 / 64) - 1) :SHL: EMIF_SDRAM_OUTPUT_IMPEDANCE_CAL_CONFIG_ZQ_ZQCL_MULT_SHIFT) :OR: \
                8192                    ; ZQCL:ZQCS = 256:64, arbitrary 8k refreshes per ZQCS
      [ Vayu
        DCD     ((DDRRdLatency + 2 - 1) :SHL: EMIF_DDR_PHY_READ_LATENCY_SHIFT) :OR: \
                EMIF_DDR_PHY_RDLVL_MASK :OR: \
                EMIF_DDR_PHY_RDLVLGATE_MASK :OR: \
                EMIF_DDR_PHY_WRLVL_MASK :OR: \
                EMIF_DDR_PHY_PHY_HALF_DELAYS :OR: \
                EMIF_DDR_PHY_PHY_INVERT_CLKOUT :OR: \
                (16 :SHL: EMIF_DDR_PHY_PHY_DLL_LOCK_DIFF_SHIFT)
      |
        DCD     ((DDRRdLatency + 3 - 1) :SHL: EMIF_DDR_PHY_READ_LATENCY_SHIFT) :OR: \
                EMIF_DDR_PHY_RDLVL_MASK :OR: \
                EMIF_DDR_PHY_RDLVLGATE_MASK :OR: \
                EMIF_DDR_PHY_WRLVL_MASK :OR: \
                EMIF_DDR_PHY_PHY_HALF_DELAYS :OR: \
                EMIF_DDR_PHY_PHY_INVERT_CLKOUT :OR: \
                (16 :SHL: EMIF_DDR_PHY_PHY_DLL_LOCK_DIFF_SHIFT)
      ]
        DCD     0x04040100
        DCD     0x009D009D, 0x009D009D, 0x009D009D, 0x009D009D, 0x009D009D ; FIFO WE[0:3,ECC]
        DCD     0x002D002D, 0x002D002D, 0x002D002D, 0x002D002D, 0x002D002D ; RD DQS[0:3,ECC]         
        DCD     0x00570057, 0x00570057, 0x00570057, 0x00570057, 0x00570057 ; WR DATA[0:31,ECC]       
        DCD     0x00570057, 0x00570057, 0x00570057, 0x00570057, 0x00570057 ; WR DQS[0:3,ECC]         
        DCD     0x00000000, 0x00600020, 0x40010080, 0x08102040, -1

EarlySetup
        ; Ensure SVC mode and no interrupts
        MSR     CPSR_c, #F32_bit :OR: I32_bit :OR: SVC32_mode

        ; SCTLR
        MRC     p15, 0, a1, c1, c0, 0
        BIC     a1, a1, #2_101          ; D cache & MMU off
        BIC     a1, a1, #1:SHL:12       ; I cache off
        ORR     a1, a1, #1:SHL:10       ; Allow SWP and SWPB
        MCR     p15, 0, a1, c1, c0, 0

        ; ACTLR
        MRC     p15, 0, a1, c1, c0, 1
        LDR     ip, =&107               ; HLOS function to write ACTLR
        ORR     a1, a1, #1:SHL:15       ; Force in order issue in branch execution unit
        ORR     a1, a1, #1:SHL:4        ; Disable indirect predictor
        ORR     a1, a1, #1:SHL:8        ; WFI is NOP
        SMI     1

        ; Contemplate errata 798870
        MRC     p15, 0, a1, c0, c0, 0   ; MIDR
        MRC     p15, 0, a2, c0, c0, 6   ; REVIDR
        BFI     a1, a1, #16, #4
        UBFX    a1, a1, #16, #8         ; Get rNpN
        SUB     a1, a1, #&20
        CMP     a1, #5                  ; Only affects r2p0 to r2p4 inclusive...
        BCS     %FT10

        TST     a2, #1:SHL:2            ; ...and that doesn't have bit 2 of REVIDR set
        BNE     %FT10

        ; L2ACTLR
        MRC     p15, 1, a1, c15, c0, 0
        LDR     ip, =&104               ; HLOS function to write L2ACTLR
        ORR     a1, a1, #1:SHL:7        ; Enable hazard detect timeout
        SMI     1
10
        ; Request UART and QSPI clocks
        ; This also forces a dependency on the PER clock
        LDR     a2, =CMCoreL4PER_PhysBase
        MOV     a1, #CM_CLKCTRL_MODULEMODE_ENABLED
        STR     a1, [a2, #CM_L4PER_UART1_CLKCTRL]
        ORR     a1, a1, #CM_L4PER2_QSPI_CLKCTRL_CLKSEL_DIV_1 :OR: \
                         CM_L4PER2_QSPI_CLKCTRL_CLKSEL_SOURCE_PER
        STR     a1, [a2, #CM_L4PER2_QSPI_CLKCTRL]

        ; Crank up the PLLs
        ADR     a1, ClockParamsPer
        LDR     a2, =CMCoreCkgen_PhysBase + CM_BASE_DPLL_PER
        BL      SetupDPLLTypeA

        ADR     a1, ClockParamsCore
        LDR     a2, =CMCoreAONCkgen_PhysBase + CM_BASE_DPLL_CORE
        BL      SetupDPLLTypeA

        ADR     a1, ClockParamsMPU
        LDR     a2, =CMCoreAONCkgen_PhysBase + CM_BASE_DPLL_MPU
        BL      SetupDPLLTypeA

        ADR     a1, ClockParamsGMAC
        LDR     a2, =CMCoreAONCkgen_PhysBase + CM_BASE_DPLL_GMAC
        BL      SetupDPLLTypeA

        ADR     a1, ClockParamsABE
        LDR     a2, =CMCoreAONCkgen_PhysBase + CM_BASE_DPLL_ABE
        BL      SetupDPLLTypeA

        ; Mind the dog
        BL      SetupWatchdog

        ; Mux IO pins to 4 bit QSPI peripheral on QSPI CS0
        LDR     a2, =ControlCore_PhysBase + ControlCore_PhysAdjust
        LDR     a1, =CTRL_CORE_PAD_MUXMODE_1 :OR: \
                     CTRL_CORE_PAD_INPUTENABLE :OR: \
                     CTRL_CORE_PAD_PULLUDENABLE :OR: CTRL_CORE_PAD_PULLTYPE_UP        
        STR     a1, [a2, #CTRL_CORE_PAD_GPMC_A13]
        STR     a1, [a2, #CTRL_CORE_PAD_GPMC_A14]
        STR     a1, [a2, #CTRL_CORE_PAD_GPMC_A15]
        STR     a1, [a2, #CTRL_CORE_PAD_GPMC_A16]
        STR     a1, [a2, #CTRL_CORE_PAD_GPMC_A17]
        STR     a1, [a2, #CTRL_CORE_PAD_GPMC_A18]
        STR     a1, [a2, #CTRL_CORE_PAD_GPMC_CS2]

        ; Mux IO pins to UART peripheral
        LDR     a2, =ControlCore_PhysBase + ControlCore_PhysAdjust
        LDR     a1, =CTRL_CORE_PAD_MUXMODE_0
        STR     a1, [a2, #CTRL_CORE_PAD_UART1_TXD]
        LDR     a1, =CTRL_CORE_PAD_MUXMODE_0 :OR \
                     CTRL_CORE_PAD_INPUTENABLE :OR: \
                     CTRL_CORE_PAD_PULLUDENABLE :OR: CTRL_CORE_PAD_PULLTYPE_UP
        STR     a1, [a2, #CTRL_CORE_PAD_UART1_RXD]

        ; Set up UART1 to 115200 8N1
        LDR     a2, =UART1_PhysBase
        MOV     a1, #UART_SYSC_SOFTRESET
        STR     a1, [a2, #UART_SYSC]    ; Reset most things to defaults
20
        LDR     a1, [a2, #UART_SYSS]
        TST     a1, #UART_SYSS_RESETDONE
        BEQ     %BT20
        
        MOV     a1, #UART_SYSC_IDLEMODE_NOIDLE
        STR     a1, [a2, #UART_SYSC]    ; Never sleep

        MOV     a1, #0                  ; No interrupts
        STR     a1, [a2, #UART_IER]     
        STR     a1, [a2, #UART_IER2]

        MOV     a1, #UART_LCR_DIV_EN
        STR     a1, [a2, #UART_LCR]     ; Reveal DLL & DLH
        ASSERT  BaudDivisor < 1:SHL:14
        MOV     a1, #(BaudDivisor:SHR:0) :AND: &FF
        STR     a1, [a2, #UART_DLL]
        MOV     a1, #(BaudDivisor:SHR:8) :AND: &3F
        STR     a1, [a2, #UART_DLH]

        MOV     a1, #UART_LCR_PARITY_NONE :OR: UART_LCR_NB_STOP1 :OR: \
                     UART_LCR_CHAR_LENGTH8
        STR     a1, [a2, #UART_LCR]     ; 8N1

        MOV     a1, #UART_MDR1_MODE_SELECT_UART16
        STR     a1, [a2, #UART_MDR1]    ; Go

        Stage   '1'

        ; Small stack in SRAM so we can at least try to follow ATPCS
        LDR     sp, =OCMCRAM1_PhysBase + GPBootSize + &1000

        ; Set up QSPI even if not subsequently used
        BL      SetupQSPI

        ; If we're running from DRAM (softload) leave the DRAM setup alone
        MOV     a1, pc, LSR #GPBootSizeShift
        LDR     a2, =DRAM_PhysBase:SHR:GPBootSizeShift
        ASSERT  DRAM_PhysBase > OCMCRAM1_PhysBase
        ASSERT  DRAM_PhysBase > OCMCRAM2_PhysBase
        CMP     a1, a2
        BCC     %FT30

        ADR     a1, MemParamsEMIF1
        BL      ReportDRAM
        MOV     v1, a1

        ADR     a1, MemParamsEMIF2
        BL      ReportDRAM
        ADD     v1, v1, a1              ; Total DRAM amount (for later)
        B       EarlyKernel
30
        Stage   '2'

        ; Loaded from JTAG or QSPI, initialise the DRAM clock
        ADR     a1, ClockParamsDDR
        LDR     a2, =CMCoreAONCkgen_PhysBase + CM_BASE_DPLL_DDR
        BL      SetupDPLLTypeA

        Stage   '3'

        ; Start the DRAM and present it to the DMM
        ! 0, "TODO! Detect vendor from pullup (when more than 1 vendor)"
        ADR     a1, MemParamsEMIF1
        LDR     a2, =EMIF1_PhysBase
        BL      SetupDRAM
        MOV     v1, a1
        
        ADR     a1, MemParamsEMIF2
        LDR     a2, =EMIF2_PhysBase
        BL      SetupDRAM
        MOV     a2, a1                  ; EMIF2 DRAM amount
        MOV     a1, v1                  ; EMIF1 DRAM amount (from earlier)

        BL      SetupDMM
        MOV     v1, a1                  ; Total DRAM amount (for later)

        Stage   '4'

        ; Load the rest of the ROM image into DRAM
        MOV     a1, pc, LSR #GPBootSizeShift
        LDR     a2, =OCMCRAM1_PhysBase:SHR:GPBootSizeShift
        TEQ     a1, a2
        BNE     EarlyKernel             ; Not a QSPI boot

        LDR     a1, =DRAM_PhysBase
        ADD     a1, a1, v1, LSR #1      ; In the middle is as good as anywhere
        LDR     a2, =QSPIMem_PhysBase
        LDR     a3, ROMSize
        BL      MemCopyQSPI
        MOV     v2, a1

        Stage   '5'

        ; Now jump to the full ROM image just copied into DRAM
        ADRL    a1, EarlyKernel
        ADRL    a2, GPHeader
        SUB     a1, a1, a2              ; How far from start
        ADD     pc, a1, v2              ; Same offset into new image

; SetupQSPI
SetupQSPI ROUT
        LDR     a2, =QSPI_PhysBase
        MOV     a1, #QSPI_SYSCONFIG_IDLEMODE_NOIDLE
        STR     a1, [a2, #QSPI_SYSCONFIG]

        ; Override whatever speed the mask ROM used with clock ÷1
        MOV     a1, #0
        STR     a1, [a2, #QSPI_SPI_CLOCK_CNTRL]
        MOV     a1, #QSPI_SPI_CLOCK_CNTRL_CLKEN :OR: \
                     ((1 - 1) :SHL: QSPI_SPI_CLOCK_CNTRL_DCLK_DIV_SHIFT)
        STR     a1, [a2, #QSPI_SPI_CLOCK_CNTRL]

        ; No interrupts
        MOV     a1, #QSPI_INTR_FRAME_IRQ :OR: QSPI_INTR_WORD_IRQ
        STR     a1, [a2, #QSPI_INTR_ENABLE_CLEAR]

        ; Mode 3, active low CS, no delay
        LDR     a1, [a2, #QSPI_SPI_DC]
        BIC     a1, a1, #QSPI_SPI_DC_DD0_MASK :OR: QSPI_SPI_DC_CSP0_HI :OR: \
                         QSPI_SPI_DC_CKP0 :OR: QSPI_SPI_DC_CKPH0
        ORR     a1, a1, #QSPI_SPI_DC_CKP0 :OR: QSPI_SPI_DC_CKPH0 :OR: \
                         QSPI_SPI_DC_CSP0_LO
        STR     a1, [a2, #QSPI_SPI_DC]  

        ; Hints for the memory mapped serial flash interface
      [ SFIBitWidth = 1
        LDR     a1, =(8 :SHL: QSPI_SPI_SETUP_NUM_D_BITS_SHIFT) :OR: \
                     (0 :SHL: QSPI_SPI_SETUP_NUM_D_BYTES_SHIFT) :OR: \
                     QSPI_SPI_SETUP_NUM_A_BYTES_3 :OR: \
                     QSPI_SPI_SETUP_READ_TYPE_SINGLE :OR: \
                     (SFIFastRead :SHL: QSPI_SPI_SETUP_RCMD_SHIFT) :OR: \
                     (SFIPageProgram :SHL: QSPI_SPI_SETUP_WCMD_SHIFT)
      |
        LDR     a1, =(8 :SHL: QSPI_SPI_SETUP_NUM_D_BITS_SHIFT) :OR: \
                     (0 :SHL: QSPI_SPI_SETUP_NUM_D_BYTES_SHIFT) :OR: \
                     QSPI_SPI_SETUP_NUM_A_BYTES_3 :OR: \
                     QSPI_SPI_SETUP_READ_TYPE_QUAD :OR: \
                     (SFIQuadRead :SHL: QSPI_SPI_SETUP_RCMD_SHIFT) :OR: \
                     (SFIPageProgram :SHL: QSPI_SPI_SETUP_WCMD_SHIFT)
      ]
        STR     a1, [a2, #QSPI_SPI_SETUP0]

        MOV     pc, lr

; MemCopyQSPI
; => a1 = target
;    a2 = source
;    a3 = byte length
; <= a1 = target
MemCopyQSPI ROUT
        Push    "a1, v1-v5, lr"
        LDR     a4, =QSPI_PhysBase
        MOV     ip, #QSPI_SPI_SWITCH_MMPT_S_SFI
        STR     ip, [a4, #QSPI_SPI_SWITCH]

        LDR     a4, =ControlCore_PhysBase + ControlCore_PhysAdjust
        LDR     ip, [a4, #CTRL_CORE_CONTROL_IO_2]
        BIC     ip, ip, #CTRL_CORE_CONTROL_IO_2_QSPI_MEMMAPPED_CS_MASK
        ORR     ip, ip, #CTRL_CORE_CONTROL_IO_2_QSPI_MEMMAPPED_CS_SFI_CS0
        STR     ip, [a4, #CTRL_CORE_CONTROL_IO_2]

        ; Go in 32's (assuming everything's MB aligned)
        ADD     a3, a2, a3
10
        LDMIA   a2!, {a4,v1-v5,ip,lr}
        STMIA   a1!, {a4,v1-v5,ip,lr}
        TEQ     a2, a3
        BNE     %BT10
                          
        Pull    "a1, v1-v5, pc"

; SetupWatchdog
SetupWatchdog ROUT
        LDR     a1, =WDTimer2_PhysBase
        LDR     a2, =WDTIMER2_WSPR_DISABLE_STEP1
        LDR     a3, =WDTIMER2_WSPR_DISABLE_STEP2

        STR     a2, [a1, #WDTIMER2_WSPR]
10
        LDR     ip, [a1, #WDTIMER2_WWPS]
        TST     ip, #WDTIMER2_WWPS_W_PEND_WSPR
        BNE     %BT10

        STR     a3, [a1, #WDTIMER2_WSPR]
20
        LDR     ip, [a1, #WDTIMER2_WWPS]
        TST     ip, #WDTIMER2_WWPS_W_PEND_WSPR
        BNE     %BT20

        MOV     pc, lr
        
      [ Debug
; EarlyStageReport
; => a1 = character to put
EarlyStageReport ROUT
        LDR     ip, =UART1_PhysBase
10
        ; Check FIFO for space
        LDR     a2, [ip, #UART_LSR]
        TST     a2, #UART_LSR_TX_FIFO_E
        BEQ     %BT10

        STR     a1, [ip, #UART_THR]
        MOV     pc, lr
      ]
        
; SetupDRAM
; => a1 = memory parameters
;    a2 = memory controller
; <= a1 = memory size in bytes on that controller
SetupDRAM ROUT

        ; Ensure no override
        LDR     ip, =CMCoreAONCkgen_PhysBase
        MOV     a3, #0
        STR     a3, [ip, #CM_DLL_CTRL]

        ; Configure the DDR PHY specific settings
        LDR     a3, [a1, #ParamPhyControl]
        STR     a3, [a2, #EMIF_DDR_PHY_CONTROL_1_SHADOW]
        STR     a3, [a2, #EMIF_DDR_PHY_CONTROL_1]

        ; Board and speed specific magic numbers (and shadows)
        ADD     a3, a1, #ParamExtPhyRegs
        ADD     a4, a2, #EMIF_EXT_PHY_CONTROL_1
10
        LDR     ip, [a3], #4
        ASSERT  (EMIF_EXT_PHY_CONTROL_26 - EMIF_EXT_PHY_CONTROL_1) = 2 * ?ParamExtPhyRegs
        CMP     ip, #-1
        ASSERT  (EMIF_EXT_PHY_CONTROL_1_SHADOW - EMIF_EXT_PHY_CONTROL_1) = 4
        STRNE   ip, [a4, #4]            ; Shadow
        STRNE   ip, [a4], #8            ; Main & increment
        BNE     %BT10

        LDR     a3, =(5 :SHL: EMIF_DLL_CALIB_CTRL_ACK_WAIT_SHIFT) :OR: \
                     EMIF_DLL_CALIB_CTRL_DLL_CALIB_INTERVAL_OFF
        STR     a3, [a2, #EMIF_DLL_CALIB_CTRL_SHADOW]
        STR     a3, [a2, #EMIF_DLL_CALIB_CTRL]

        ; Define timings and clock parameters
        LDR     a3, [a1, #ParamTiming1]
        STR     a3, [a2, #EMIF_SDRAM_TIMING_1_SHADOW]
        STR     a3, [a2, #EMIF_SDRAM_TIMING_1]
        LDR     a3, [a1, #ParamTiming2]
        STR     a3, [a2, #EMIF_SDRAM_TIMING_2_SHADOW]
        STR     a3, [a2, #EMIF_SDRAM_TIMING_2]
        LDR     a3, [a1, #ParamTiming3]
        STR     a3, [a2, #EMIF_SDRAM_TIMING_3_SHADOW]
        STR     a3, [a2, #EMIF_SDRAM_TIMING_3]
        LDR     a3, [a1, #ParamRefresh]
        STR     a3, [a2, #EMIF_SDRAM_REFRESH_CONTROL_SHADOW]
        STR     a3, [a2, #EMIF_SDRAM_REFRESH_CONTROL]

        ; Configure the SDRAM output impedance calibration parameters
        LDR     a3, [a1, #ParamTimingZQ]
        STR     a3, [a2, #EMIF_SDRAM_OUTPUT_IMPEDANCE_CAL_CONFIG]

        ; Start levelling, using steps of 4
        LDR     a3, =EMIF_READ_WRITE_LEVELING_RAMP_CONTROL_RDWRLVL_EN :OR: \
                     EMIF_READ_WRITE_LEVELING_RAMP_CONTROL_RDWRLVLINC_RMP_PRE_OFF :OR: \
                     EMIF_READ_WRITE_LEVELING_RAMP_CONTROL_RDLVLINC_RMP_INT_OFF :OR: \
                     EMIF_READ_WRITE_LEVELING_RAMP_CONTROL_RDLVLGATEINC_RMP_INT_OFF :OR: \
                     EMIF_READ_WRITE_LEVELING_RAMP_CONTROL_WRLVLINC_RMP_INT_OFF
        STR     a3, [a2, #EMIF_READ_WRITE_LEVELING_RAMP_CONTROL]

        LDR     ip, =EMIF1_PhysBase
        TEQ     ip, a2
        LDR     ip, =ControlWakeUp_PhysBase
        LDR     a3, =CTRL_WKUP_SDRAM_CONFIG_EXT_REG_PHY_NUM_OF_SAMPLES_4 :OR: \
                     CTRL_WKUP_SDRAM_CONFIG_EXT_REG_PHY_SEL_LOGIC_ALGORITHM1 :OR: \
                     CTRL_WKUP_SDRAM_CONFIG_EXT_SDRAM_DISABLE_RESET :OR: \
                     CTRL_WKUP_SDRAM_CONFIG_EXT_PHY_RD_LOCAL_ODT_60R :OR: \
                     CTRL_WKUP_SDRAM_CONFIG_EXT_EN_SLICE_2 :OR: \
                     CTRL_WKUP_SDRAM_CONFIG_EXT_EN_SLICE_1 :OR: \
                     CTRL_WKUP_SDRAM_CONFIG_EXT_EN_SLICE_0
        STREQ   a3, [ip, #CTRL_WKUP_EMIF1_SDRAM_CONFIG_EXT]
        STRNE   a3, [ip, #CTRL_WKUP_EMIF2_SDRAM_CONFIG_EXT]

        LDR     a3, =EMIF_READ_WRITE_LEVELING_CONTROL_RDWRLVLINC_PRE_OFF :OR: \
                     EMIF_READ_WRITE_LEVELING_CONTROL_RDLVLINC_INT_OFF :OR: \
                     EMIF_READ_WRITE_LEVELING_CONTROL_RDLVLGATEINC_INT_OFF :OR: \
                     EMIF_READ_WRITE_LEVELING_CONTROL_WRLVLINC_INT_OFF
        STR     a3, [a2, #EMIF_READ_WRITE_LEVELING_CONTROL]

        ; We're not running from SDRAM so go ahead and trigger the initialisation
        LDR     a3, [a1, #ParamConfig2]
        STR     a3, [a2, #EMIF_SDRAM_CONFIG_2]
        LDR     a3, [a1, #ParamConfig]
        STR     a3, [a2, #EMIF_SDRAM_CONFIG]

        ; Fall through...

ReportDRAM ROUT
        ; Report the byte size
        LDRB    a4, [a1, #ParamByteWidth]
        LDRB    a3, [a1, #ParamRows]
        MOV     a4, a4, LSL a3
        LDRB    a3, [a1, #ParamColumns]
        MOV     a4, a4, LSL a3
        LDRB    a3, [a1, #ParamBanks]
        MUL     a1, a4, a3

        MOV     pc, lr

; SetupDMM
; => a1 = bytes of DRAM on EMIF1
;    a2 = bytes of DRAM on EMIF2
; <= a1 = bytes of contiguous DRAM
SetupDMM ROUT
        Push    "v1-v3, lr"
        LDR     a3, =DynMemMgr_PhysBase
        LDR     a4, =MPUMemAdapter_PhysBase

        LDR     v2, =DRAM_PhysBase

        ; Interleave 2 x MIN(EMIF1,EMIF2) for best performance.
        ; Whatever is left must be non interleaved (this means
        ; there can only ever be one non interleaved region)
        CMP     a1, a2
        MOVCS   v3, a2
        MOVCC   v3, a1
        TEQ     v3, #0
        MOVEQ   v1, #0
        MOVEQ   ip, #0
        BEQ     %FT10                   ; No interleaving, one EMIF is empty

        ; Start the interleaved region at the bottom
        LDR     ip, =DMM_LISA_MAP_INTERLEAVE_128 :OR: \
                     DMM_LIST_MAP_SDRC_MAP_EMIF1_2 :OR: \
                     (0 :SHL: DMM_LISA_MAP_SDRC_ADDRSPC_SHIFT) :OR: \
                     (&00000000 :SHR: (24 - DMM_LISA_MAP_SDRC_ADDR_SHIFT))
        ADD     v1, v3, v3              ; Combined size after interleaving
        ASSERT  DMM_LISA_MAP_SYS_SIZE_16MB = 0
        CLZ     lr, v1
        RSB     lr, lr, #7              ; Calculate SYS_SIZE
        ORR     ip, ip, lr, LSL #DMM_LISA_MAP_SYS_SIZE_SHIFT
        ASSERT  DMM_LISA_MAP_SYS_ADDR_SHIFT = 24
        ORR     ip, ip, v2

        ADD     v2, v2, v1              ; Bottom of next region
        SUB     a1, a1, v3              ; } At least one of these
        SUB     a2, a2, v3              ; } is now zero
10
        STR     ip, [a3, #DMM_LISA_MAP_3]
        STR     ip, [a4, #MPU_MA_LISA_MAP_3]

        ; The single region
        ORRS    lr, a1, a2
        MOVEQ   ip, #0
        BEQ     %FT20                   ; EMIF1 and EMIF2 were equal

        TEQ     a1, #0
        LDREQ   ip, =DMM_LISA_MAP_INTERLEAVE_OFF :OR: \
                     DMM_LIST_MAP_SDRC_MAP_EMIF2 :OR: \
                     (0 :SHL: DMM_LISA_MAP_SDRC_ADDRSPC_SHIFT)
        LDRNE   ip, =DMM_LISA_MAP_INTERLEAVE_OFF :OR: \
                     DMM_LIST_MAP_SDRC_MAP_EMIF1 :OR: \
                     (0 :SHL: DMM_LISA_MAP_SDRC_ADDRSPC_SHIFT)
        ADD     v1, v1, lr              ; Sum the non interleaved bit
        ASSERT  DMM_LISA_MAP_SYS_SIZE_16MB = 0
        CLZ     lr, lr
        RSB     lr, lr, #7              ; Calculate SYS_SIZE
        ORR     ip, ip, lr, LSL #DMM_LISA_MAP_SYS_SIZE_SHIFT
        ASSERT  DMM_LISA_MAP_SYS_ADDR_SHIFT = 24
        ORR     ip, ip, v2
        ASSERT  DMM_LISA_MAP_SDRC_ADDR_SHIFT = 0
        ORR     ip, ip, v3, LSR #24     ; Offset by the interleaved amount
20
        STR     ip, [a3, #DMM_LISA_MAP_2]
        STR     ip, [a4, #MPU_MA_LISA_MAP_2]

        ; Filler in the last 2 slots
        MOV     ip, #0
        STR     ip, [a3, #DMM_LISA_MAP_1]
        STR     ip, [a4, #MPU_MA_LISA_MAP_1]
        STR     ip, [a3, #DMM_LISA_MAP_0]
        STR     ip, [a4, #MPU_MA_LISA_MAP_0]

        ; Enable MFLAG venting
        LDR     ip, =DMM_EMERGENCY_WEIGHT_NOMINAL :OR: DMM_EMERGENCY_ENABLE
        STR     ip, [a3, #DMM_EMERGENCY]

        MOV     a1, v1
        Pull    "v1-v3, pc"

; SetupDPLLTypeA
; => a1 = table of parameters
;    a2 = register base
SetupDPLLTypeA ROUT

        ; Unify all PLL settings
        ; Idle bypass; no spread spectrum; no ramp up; no driftguard
        LDR     a4, =CM_CLKMODE_DPLL_EN_IDLE_B_LOW_POWER :OR: \
                     CM_CLKMODE_DPLL_RAMP_LEVEL_NONE
        STR     a4, [a2, #CM_CLKMODE_DPLL_TYPEA]
        LDRH    a4, [a1, #ParamM]
        LDRH    a3, [a1, #ParamN]
        ASSERT  CM_CLKSEL_DPLL_DIV_SHIFT = 0
        ORR     ip, a3, a4, LSL #CM_CLKSEL_DPLL_MULT_SHIFT
        STR     ip, [a2, #CM_CLKSEL_DPLL_TYPEA]

        LDR     a3, =CM_AUTOIDLE_DPLL_OFF
        STR     a3, [a2, #CM_AUTOIDLE_DPLL_TYPEA]

        ; Main outputs
        LDRSH   a4, [a1, #ParamM2]
        CMP     a4, #-1
        MOVNE   a4, a4, LSL #CM_DIV_Mx_DPLL_DIVHS_SHIFT
        STRNE   a4, [a2, #CM_DIV_M2_DPLL_TYPEA]

        LDRSH   a4, [a1, #ParamM3]
        CMP     a4, #-1
        MOVNE   a4, a4, LSL #CM_DIV_Mx_DPLL_DIVHS_SHIFT
        STRNE   a4, [a2, #CM_DIV_M3_DPLL_TYPEA]

        ; High speed Hxy sub clocks
        MOV     a3, #2 * 3
        ADD     ip, a2, #CM_DIV_H11_DPLL_TYPEA
10
        ADD     a4, a1, #ParamH1y
        LDRSH   a4, [a4, a3]
        CMP     a4, #-1
        MOVNE   a4, a4, LSL #CM_DIV_Hxy_DPLL_DIVHS_SHIFT
        STRNE   a4, [ip, a3, LSL #1]
        SUBS    a3, a3, #2              ; Next param
        BPL     %BT10

        MOV     a3, #2 * 3
        ADD     ip, a2, #CM_DIV_H21_DPLL_TYPEA
10
        ADD     a4, a1, #ParamH2y
        LDRSH   a4, [a4, a3]
        CMP     a4, #-1
        MOVNE   a4, a4, LSL #CM_DIV_Hxy_DPLL_DIVHS_SHIFT
        STRNE   a4, [ip, a3, LSL #1]
        SUBS    a3, a3, #2              ; Next param
        BPL     %BT10

        ; Lock
        LDR     a3, [a2, #CM_CLKMODE_DPLL_TYPEA]
        BIC     a3, a3, #CM_CLKMODE_DPLL_EN_MASK
        ORR     a3, a3, #CM_CLKMODE_DPLL_EN_LOCK
        STR     a3, [a2, #CM_CLKMODE_DPLL_TYPEA]
10
        LDR     a3, [a2, #CM_IDLEST_DPLL_TYPEA]
        TST     a3, #CM_IDLEST_DPLL_LOCK
        BEQ     %BT10
        MOV     pc, lr

        LTORG
        ASSERT  (. - GPHeader) <= GPBootSize

; SetupDPLLTypeB
; => a1 = table of parameters
;    a2 = register base
SetupDPLLTypeB ROUT

        ; Unify all PLL settings
        ; Idle bypass; no spread spectrum; no ramp up; no driftguard; always < 1500MHz output
        LDR     a4, =CM_CLKMODE_DPLL_EN_IDLE_B_LOW_POWER :OR: \
                     CM_CLKMODE_DPLL_RAMP_LEVEL_NONE
        STR     a4, [a2, #CM_CLKMODE_DPLL_TYPEB]
        LDRH    a4, [a1, #ParamM]
        LDRH    a3, [a1, #ParamN]
        ASSERT  CM_CLKSEL_DPLL_DIV_SHIFT = 0
        ORR     ip, a3, a4, LSL #CM_CLKSEL_DPLL_MULT_SHIFT
        ASSERT  CM_CLKSEL_DPLL_SD_DIV_MASK :SHL: CM_CLKSEL_DPLL_SD_DIV_SHIFT <= 1:SHL:8
        MOV     a4, a4, LSL #8          ; u24p8
        ASSERT  (ClkOsc0 / 1000000) * 1000000 = ClkOsc0
        MOV     a3, #ClkOsc0 / 1000000  ; MHz
        MUL     a3, a3, a4
        LDRH    a4, [a1, #ParamN]
        ADD     a4, a4, #1
        UDIV    a3, a3, a4
        MOV     a4, #250
        UDIV    a3, a3, a4              ; SD = (Fref * (M / (N + 1))) / 250
        ADD     a3, a3, #&FF            ; CEIL(SD)
        MOV     a3, a3, LSR #8          ; u32p0
        CMP     a3, #CM_CLKSEL_DPLL_SD_DIV_MIN
        MOVCC   a3, #CM_CLKSEL_DPLL_SD_DIV_MIN
        ORR     ip, ip, a3, LSL #CM_CLKSEL_DPLL_SD_DIV_SHIFT
        STR     ip, [a2, #CM_CLKSEL_DPLL_TYPEB]

        LDR     a3, =CM_AUTOIDLE_DPLL_OFF
        STR     a3, [a2, #CM_AUTOIDLE_DPLL_TYPEB]

        ; Main outputs
        LDRSH   a4, [a1, #ParamM2]
        CMP     a4, #-1
        MOVNE   a4, a4, LSL #CM_DIV_Mx_DPLL_DIVHS_SHIFT
        STRNE   a4, [a2, #CM_DIV_M2_DPLL_TYPEB]

        ; Lock
        LDR     a3, [a2, #CM_CLKMODE_DPLL_TYPEB]
        BIC     a3, a3, #CM_CLKMODE_DPLL_EN_MASK
        ORR     a3, a3, #CM_CLKMODE_DPLL_EN_LOCK
        STR     a3, [a2, #CM_CLKMODE_DPLL_TYPEB]
10
        LDR     a3, [a2, #CM_IDLEST_DPLL_TYPEB]
        TST     a3, #CM_IDLEST_DPLL_LOCK
        BEQ     %BT10
        MOV     pc, lr

; DSPEnableDisable
DSPEnableDisable ROUT
        ; Power cycle each DSP per errata i872 to define their MFLAG
        MOV     ip, #0
10
        ADR     a4, DSPCMBases
        ADR     a3, DSPPRMBases
        LDR     a4, [a4, ip, LSL #2]
        LDR     a3, [a3, ip, LSL #2]

        ; Force wakeup, enable DSP clock, deassert reset
        MOV     a1, #CM_DSP1_CLKSTCTRL_CLKTRCTRL_SW_WKUP
        STR     a1, [a4, #CM_DSP1_CLKSTCTRL]
        MOV     a1, #CM_CLKCTRL_MODULEMODE_AUTO
        STR     a1, [a4, #CM_DSP1_DSP1_CLKCTRL]
        MOV     a1, #RM_DSP1_RSTCTRL_RST_DSP1_LRST
        STR     a1, [a3, #RM_DSP1_RSTCTRL]
20
        LDR     a1, [a4, #CM_DSP1_DSP1_CLKCTRL]
        TST     a1, #CM_CLKCTRL_IDLEST_MASK
        BEQ     %BT20

        ; Then power down and clock off
        MOV     a1, #CM_DSP1_CLKSTCTRL_CLKTRCTRL_HW_AUTO
        STR     a1, [a4, #CM_DSP1_CLKSTCTRL]
        LDR     a1, [a3, #PM_DSP1_PWRSTCTRL]
        BIC     a1, a1, #PM_DSP1_PWRSTCTRL_POWERSTATE_MASK
        ASSERT  PM_DSP1_PWRSTCTRL_POWERSTATE_OFF = 0
        STR     a1, [a3, #PM_DSP1_PWRSTCTRL]
        MOV     a1, #CM_CLKCTRL_MODULEMODE_DISABLE
        STR     a1, [a4, #CM_DSP1_DSP1_CLKCTRL]
        MOV     a1, #RM_DSP1_RSTCTRL_RST_DSP1_LRST :OR: RM_DSP1_RSTCTRL_RST_DSP1
        STR     a1, [a3, #RM_DSP1_RSTCTRL]

        ADD     ip, ip, #1
        TEQ     ip, #DSPCount
        BNE     %BT10

        MOV     pc, lr
DSPCMBases
        DCD     CMCoreAONDSP1_PhysBase
        DCD     CMCoreAONDSP2_PhysBase
DSPPRMBases
        DCD     PRMDSP1_PhysBase
        DCD     PRMDSP2_PhysBase
DSPCount        * (. - DSPPRMBases):SHR:2

EarlyKernel ROUT
        ; Say hello
        DebugTX "TiTwentyTwo"

        ; Crank up the other PLLs
        ADRL    a1, ClockParamsUSB
        LDR     a2, =CMCoreCkgen_PhysBase + CM_BASE_DPLL_USB
        BL      SetupDPLLTypeB

        ADRL    a1, ClockParamsPCIe
        LDR     a2, =CMCoreCkgen_PhysBase + CM_BASE_DPLL_PCIE_REF
        BL      SetupDPLLTypeB

        ; Get address of table of Kernel entries
        ADRL    a1, GPHeader + OSROM_HALSize
        LDR     v8, [a1, #OSHdr_Entries]
        ADD     v8, v8, a1

        MOV     a1, #0
        CallOSPreMMU OS_InitARM
        DebugTX "InitARM done"

        ; Get the multiplexing over and done with before the MMU is on
        BL      SetupClockMux
        BL      SetupInterruptMux
        BL      SetupDMAMux
        BL      SetupPinMux

        ; Put the DSPs into an idle state
        BL      DSPEnableDisable
        
        ; Initial 4k stack must be in 1st registered block
        LDR     sp, =DRAM_PhysBase + &1000
        MOV     a1, #0
        Push    "a1"                    ; NULL RAM ref

        ; Register the bulk SDRAM with RISC OS
        LDR     a2, =DRAM_PhysBase
        ADDS    a3, a2, v1
        SUBCS   a3, a3, #PageSize       ; 1 page attrition when address space limit hit
        MOV     a4, #-1                 ; All bits decoded
        MOV     a1, #0*OSAddRAM_Speed   ; Flags
        CallOSPreMMU OS_AddRAM
        STR     a1, [sp]

        ; Register the SRAM with RISC OS
        LDR     a2, =OCMCRAM1_PhysBase
        ADD     a3, a2, #OCMCRAM1_PhysSize
        MOV     a4, #-1                 ; All bits decoded
        MOV     a1, #1*OSAddRAM_Speed   ; Flags
        CallOSPreMMU OS_AddRAM
        STR     a1, [sp]

        LDR     a2, =OCMCRAM2_PhysBase
        ADD     a3, a2, #OCMCRAM2_PhysSize
        CMP     a2, pc
        CMPCS   pc, a3
        BHI     %FT10                   ; We're loaded via JTAG in that SRAM

        MOV     a4, #-1                 ; All bits decoded
        MOV     a1, #1*OSAddRAM_Speed   ; Flags
        CallOSPreMMU OS_AddRAM
        STR     a1, [sp]
10
        DebugTX "RAM registered"

        ; Read the reset reason and clear flag for next time
        LDR     a2, =MPUPRCMDevice_PhysBase
        LDR     a1, [a2, #MPU_PRCM_RSTST]
        TST     a1, #MPU_PRCM_RSTST_GLOBAL_COLD_RST
        MOV     a1, #MPU_PRCM_RSTST_GLOBAL_COLD_RST :OR: \
                     MPU_PRCM_RSTST_GLOBAL_WARM_RST
        STR     a1, [a2, #MPU_PRCM_RSTST]
        MOVNE   a1, #OSStartFlag_POR
        MOVEQ   a1, #0

        ; Check the CMOS lock
        LDR     a4, =GPIO2_PhysBase
        LDR     a4, [a4, #GPIO_DATAIN]
        TST     a4, #1:SHL:28           ; GPIO2.28 on GPMC_WAIT0
        ORREQ   a1, a1, #OSStartFlag_NoCMOSReset
 
        ADRL    a2, GPHeader + OSROM_HALSize
        ADRL    a3, EntryDescriptor
        Pull    "a4"                    ; Last RAM ref
        CallOSPreMMU OS_Start           ; Start the kernel

        END
