DThreads
========

DThreads is a simple threading library for RISC OS. Each thread is
implemented as a separate Wimp task, timesliced using the TaskWindow.
This keeps the implementation simple, but has the usual drawbacks of
TaskWindow tasks: the application cannot have a GUI other than basic
text editor I/O. However, there are many uses that DThreads can still
be put to within these limitations.

By definition, in a threading system, code, static data and the heap
must be equally accessible to each thread. This is achievd by placing
the code and static data in the RMA and the malloc heap in a dynamic
area; the application slot for each Wimp task is unused and shrunk to
zero size.

This means that the code must be implemented as a module. You must
allocate your own unique name for the module as normal, and certain
definitions are required in your CMHG file:

module-is-runnable:

initialisation-code:            DThreads_ModuleInit

library-enter-code:             DThreads_ModuleStart

finalisation-code:              DThreads_ModuleFinal

library-finalisation-code:      DThreads_ModuleCleanUp

command-keyword-table           DThreads_CommandHandler

The first star command in the list will be used internally by
DThreads, and has exactly 2 arguments. You need to allocate it a
unique name.

DThreads appropriates the main() function for its own uses. You must
supply a function called DThreads_Main() instead, which has the same
syntax and semantics as main() would normally have.

DThreads offers some basic thread control functions DThreads_Create(),
DThreads_Destroy() and DThreads_CurrentThread(), and per-thread
memory management functions DThreads_AllocMem(), DThreads_ReleaseMem()
and DThreads_FindMem(). You can optionally supply any, all or none of
the functions DThreads_Initialising(), DThreads_Finalising() and
DThreads_AdditionalCommands(). All are described in detail in
DThreads.h. You may also optionally add any additional module entry
points which are not used by DThreads.

Some mutex and semaphore structures are provided, however it is also
possible to construct your own using the TaskWindow yield and sleep
primitives available via UpCall 6.

Note that you will need to compile your code with Norcroft compiler
switches -zM -zps0 (or equivalent for other compilers). You will
also need CMHG 5.42 or later.
