/* 
 * CDDL HEADER START
 * 
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "Licence").
 * You may not use this file except in compliance with the Licence.
 * 
 * You can obtain a copy of the licence at
 * RiscOS/Sources/ThirdParty/Endurance/Lib/DThreads/LICENCE.
 * See the Licence for the specific language governing permissions
 * and limitations under the Licence.
 * 
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the Licence file. If applicable, add the
 * following below this CDDL HEADER, with the fields enclosed by
 * brackets "[]" replaced with your own identifying information:
 * Portions Copyright [yyyy] [name of copyright owner]
 * 
 * CDDL HEADER END
 */
/* 
 * Copyright 2007 Endurance Technology Ltd.  All rights reserved.
 * Use is subject to license terms.
 */
/** @file DThreads.h
 *  Dynamic area based threading library.
 *
 *  This library allows the creation of module tasks consisting of multiple
 *  threads, each of which runs in a timesliced manner under the TaskWindow
 *  module.
 *
 *  Sharing of code is achieved by running the application as a module task,
 *  and sharing of static data is achieved by placing the heap in a dynamic
 *  area. This is perhaps not the most elegant way to achieve threading, but
 *  it has few requirements on the rest of the system, and will suffice in
 *  many cases, providing its limitations (no prioritisation, for example)
 *  don't matter to you.
 *
 *  You can to construct your own semaphores, mutexes etc using OS_Upcall 6
 *  as your primitive block/yield mechanism.
 *
 *  Note that ANSI exit(), abort() etc functions will have undesirable effects
 *  if called from a thread, although OS_Exit will cleanly terminate the
 *  current thread. If you chain a new application, you implicitly kill all
 *  the other threads.
 */

#ifndef DTHREADS_DTHREADS_H
#define DTHREADS_DTHREADS_H

#ifdef __cplusplus
extern "C"
{
#endif

#include <stddef.h>
#ifdef __CC_NORCROFT
#include "kernel.h"
#else
#include <kernel.h>
#endif

/** Type of thread handles used by DThreads.
 */
typedef void *DThreads_Thread;

/** Type of per-thread memory handle used by DThreads.
 */
typedef void *DThreads_Mem;

/** Type of mutex handles used by DThreads.
 */
typedef void *DThreads_Mutex;

/** Type of semaphore handles used by DThreads.
 */
typedef void *DThreads_Semaphore;

/** Type of reader-writer mutex handles used by DThreads.
 */
typedef void *DThreads_RWMutex;

/** Module name. Useful for constructing thread names.
 */
extern const char *DThreads_ModuleName;

/** Create new thread.
 *  @param thread_main    Pointer to function for the new thread to enter.
 *  @param thread_arg     Argument to pass to thread entry function.
 *  @param thread_name    Pointer to string to be used as the Wimp task name
 *                        for the new thread.
 *  @param thread_handle  Pointer to return the opaque handle generated by
 *                        DThreads to refer to the new thread. Not valid if
 *                        an error is returned.
 *  @return               A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_Create(_kernel_oserror *(*thread_main)(void *),
                                 void *thread_arg,
                                 const char *thread_name,
                                 DThreads_Thread *thread_handle);

/** Destroy a thread.
 *  If the thread being destroyed is the current one, this function never
 *  returns.
 *  @param thread_handle  Opaque handle that identifies the thread to destroy.
 *  @return               A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_Destroy(DThreads_Thread thread_handle);

/** Find handle of currently-executing thread.
 *  @return  Opaque handle that DThreads is currently executing, or NULL if
 *           current execution context is not recognised.
 */
DThreads_Thread DThreads_CurrentThread(void);

/** Allocate per-thread storage.
 *  @param size  Number of bytes to allocate per thread.
 *  @return      Opaque handle that DThreads associates with this allocation.
 */
DThreads_Mem DThreads_AllocMem(size_t size);

/** Deallocate per-thread storage.
 *  @param mem_handle  Opaque handle for alloation to release.
 */
void DThreads_ReleaseMem(DThreads_Mem mem_handle);

/** Find the address of a per-thread allocation for the current thread.
 *  @param mem_handle  Opaque handle for allocation to look up.
 *  @return            Pointer to memory, or NULL if handle not recognised.
 */
void *DThreads_FindMem(DThreads_Mem mem_handle);

/** Main entry point.
 *  This must be supplied, and is the entry point of the first thread to
 *  execute. The parameters are determined from the command line that launched
 *  the module.
 *  @param argc  Argument count.
 *  @param argv  Array of pointers to arguments.
 *  @return      Exit code.
 */
int DThreads_Main(int argc, char *argv[]);

#ifdef __CC_NORCROFT
___weak
#endif
/** Initialisation hook.
 *  This enables you to specify additional operations to be performed during
 *  initialisation of the thread system. An example would be to call the
 *  static initialisers of a C++ runtime system. If you do not want this,
 *  simply omit the function at the link stage.
 *  @param pw  Pointer to module private word.
 *  @return    A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_Initialising(void *pw);

#ifdef __CC_NORCROFT
___weak
#endif
/** Finalisation hook.
 *  The partner of @c DThreads_Initialising, this enables you to take actions
 *  when the thread system is about to shut down. If you do not want this,
 *  simply omit the function at the link stage.
 *  @param pw  Pointer to module private word.
 */
void DThreads_Finalising(void *pw);

#ifdef __CC_NORCROFT
___weak
#endif
/** Command handler.
 *  DThreads is interfaced directly with CMHG because a star command is
 *  required to start a new thread. However, you can implement additional
 *  star commands if you wish: to do so, link in a function with this
 *  prototype. If you do not want this, simply omit the function at the
 *  link stage.
 *  @param arg_string  Pointer to command tail.
 *  @param argv        Number of arguments.
 *  @param cmd_no      Index into command table. Index 0 is reserved for the
 *                     thread-launching command.
 *  @param pw          Pointer to module private word.
 *  @return            A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_AdditionalCommands(const char *arg_string,
                                             int argc,
                                             int cmd_no,
                                             void *pw);

/** Create new mutex, initially unlocked.
 *  @param flags         Flags word specifying mutex variants.
 *  @param mutex_handle  Pointer to return the opaque handle generated by
 *                       DThreads to refer to the new mutex. Not valid if an
 *                       error is returned.
 *  @return              A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_MutexCreate(uint32_t flags,
                                      DThreads_Mutex *mutex_handle);

/** Detect erroneous unlocks of the mutex by threads other than
 *  the one which locked it, or when the mutex is already unlocked.
 */
#define DTHREADS_MUTEX_FLAG_ERRORCHECK (1u<<0)

/** Destroy a mutex.
 *  Any threads currently blocking on the mutex are unblocked.
 *  @param mutex_handle  Opaque handle that identifies the mutex.
 *  @return              A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_MutexDestroy(DThreads_Mutex mutex_handle);

/** Lock a mutex.
 *  If the mutex is already locked, this will block until it is unlocked.
 *  @param mutex_handle  Opaque handle that identifies the mutex.
 *  @return              A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_MutexLock(DThreads_Mutex mutex_handle);

/** Unlock a mutex.
 *  @param mutex_handle  Opaque handle that identifies the mutex.
 *  @return              A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_MutexUnlock(DThreads_Mutex mutex_handle);

/** Create new semaphore, initially fully signalled.
 *  @param flags       Flags word specifying semaphore variants.
 *  @param max_count   Maximum number of waiting threads that can be
 *                     simultaneously unblocked. Often just 1.
 *  @param sem_handle  Pointer to return the opaque handle generated by
 *                     DThreads to refer to the new semaphore. Not valid if an
 *                     error is returned.
 *  @return            A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_SemaphoreCreate(uint32_t flags,
                                          uint32_t max_count,
                                          DThreads_Semaphore *sem_handle);

/** Destroy a semaphore.
 *  Any threads currently blocking on the semaphore are unblocked.
 *  @param sem_handle  Opaque handle that identifies the semaphore.
 *  @return            A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_SemaphoreDestroy(DThreads_Semaphore sem_handle);

/** Wait on a semaphore.
 *  If necessary, the calling thread will be blocked until its count can be
 *  incremented by @a howmany.
 *  @param sem_handle  Opaque handle that identifies the semaphore.
 *  @param howmany     Amount by which to increment the semaphore's count.
 *  @return            A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_SemaphoreWait(DThreads_Semaphore sem_handle,
                                        uint32_t howmany);
/** Signal a semaphore.
 *  @param sem_handle  Opaque handle that identifies the semaphore.
 *  @param howmany     Amount by which to decrement the semaphore's count.
 *  @return            A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_SemaphoreSignal(DThreads_Semaphore sem_handle,
                                          uint32_t howmany);

/** Create new reader-writer mutex, initially unlocked.
 *  @param flags         Flags word specifying mutex variants.
 *  @param max_readers   Maximum number of concurrent readers allowed.
 *  @param mutex_handle  Pointer to return the opaque handle generated by
 *                       DThreads to refer to the new mutex. Not valid if an
 *                       error is returned.
 *  @return              A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_RWMutex_Create(uint32_t flags,
                                         uint32_t max_readers,
                                         DThreads_RWMutex *mutex_handle);

/** Destroy a reader-writer mutex.
 *  Any threads currently blocking on the mutex are unblocked.
 *  @param mutex_handle  Opaque handle that identifies the mutex.
 *  @return              A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_RWMutex_Destroy(DThreads_RWMutex mutex_handle);

/** Lock a reader-writer mutex as a reader.
 *  If a writer or the maximum number of readers are already locking the
 *  mutex, this will block until it is unlocked.
 *  @param mutex_handle  Opaque handle that identifies the mutex.
 *  @return              A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_RWMutex_LockRead(DThreads_RWMutex mutex_handle);

/** Unlock a reader-writer mutex as a reader.
 *  @param mutex_handle  Opaque handle that identifies the mutex.
 *  @return              A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_RWMutex_UnlockRead(DThreads_RWMutex mutex_handle);

/** Lock a reader-writer mutex as a writer.
 *  If any readers or writers are already locking the mutex, this will block
 *  until it is unlocked.
 *  @param mutex_handle  Opaque handle that identifies the mutex.
 *  @return              A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_RWMutex_LockWrite(DThreads_RWMutex mutex_handle);

/** Unlock a reader-writer mutex as a writer.
 *  @param mutex_handle  Opaque handle that identifies the mutex.
 *  @return              A RISC OS error pointer, or NULL.
 */
_kernel_oserror *DThreads_RWMutex_UnlockWrite(DThreads_RWMutex mutex_handle);

#ifdef __cplusplus
}
#endif

#endif
