/* Copyright 2002 Tematic Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    ekmodule.c                                        */
/*                                                            */
/* Purpose: The EtherK DCI 4 driver for the Intel PRO/1000    */
/*          family of network adapters.                       */
/*                                                            */
/* Author:  J.R.Byrne.                                        */
/*                                                            */
/* Origins: Adapted from the Intel FreeBSD 'em' driver, which */
/*          is why all the other files refer to 'em' rather   */
/*          than 'ek' (the name 'EtherM' was already taken.)  */
/*          The RISC OS driver bits were based on Ether1 and  */
/*          EtherI.                                           */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <locale.h>

#include <kernel.h>
#include <swis.h>
#include <Interface/PCI.h>
#include <AsmUtils/irqs.h>
#include <callx/callx.h>
#include <Global/Services.h>

#include "VersionNum"
#include "EKHdr.h"
#include "em_riscos.h"
#include "if_em.h"
#include "em_device.h"
#include "filter.h"
#include "generic.h"
#include "info.h"
#include "log.h"
#include "mbuf.h"
#include "msgs.h"

/* Local definitions */

#ifndef ErrorNumber_Syntax
#define ErrorNumber_Syntax 0xDC
#endif

/* Checks for valid filter parameters */
#define check_errlevel(x)   ((x) == ERRLVL_NO_ERRORS)
#define check_addrlevel(x)  ((x) >= ADDRLVL_SPECIFIC && (x) <= ADDRLVL_PROMISCUOUS)

/* Local structures */

struct swient
{
    static int (*swi_call)(_kernel_swi_regs *); /* SWI handler */
};

/* SWI handler table */

static int ek_version   (_kernel_swi_regs *);
static int ek_inquire   (_kernel_swi_regs *);
static int ek_getmtu    (_kernel_swi_regs *);
static int ek_setmtu    (_kernel_swi_regs *);
static int ek_transmit  (_kernel_swi_regs *);
static int ek_filter    (_kernel_swi_regs *);
extern int ek_stats     (_kernel_swi_regs *);
static int ek_multicast (_kernel_swi_regs *);

static struct swient ek_ent[] =
{
    ek_version,
    ek_inquire,
    ek_getmtu,
    ek_setmtu,
    ek_transmit,
    ek_filter,
    ek_stats,
    ek_multicast
};

/* Static variables */

static void       * module_wsp;

static int          ekcnt = 0;          /* Number of devices */
static device_t     device_list = NULL; /* List of devices */

static bool         managerstarted = false;
static bool         finalising = false;

static bool         timer_callb_set = false;

static struct stats supported_stats;

/* Hard-coded strings */

static const char   location_unknown[] = "Unknown";
static const char   location_motherboard[] = "Motherboard";
static const char   location_string[] = "PCI Slot %u";
static const char   short_name[] = "ek";
static const char   ether_type[] = "ek0";
static const char   module_name[] = Module_Title;
static const char   link_param_auto[] = "Auto";
static const char   link_param_full[] = "Full";
static const char   link_param_half[] = "Half";
static const char   link_param_1000[] = "1000";
static const char   link_param_100[] = "100";
static const char   link_param_10[] = "10";
static const char   link_param_mdi[] = "MDI";
static const char   link_param_mdix[] = "MDI-X";
static const char   flow_param_none[] = "None";
static const char   flow_param_generate[] = "Generate";
static const char   flow_param_respond[] = "Respond";
static const char   flow_param_full[] = "Full";


/**************************************************************/
/* get_device()                                               */
/*                                                            */
/* Return a pointer to the device structure for the unit with */
/* a given number.                                            */
/*                                                            */
/* Parameters: Unit number.                                   */
/*                                                            */
/* Returns:    Pointer to device structure, or NULL.          */
/**************************************************************/

static device_t get_device(int unit)
{
    int         i;
    device_t    p = device_list;

    for (i = 0; i < unit && p != NULL; i++)
        p = p->next;

    return p;
}


/**************************************************************/
/* Timer routines.                                            */
/**************************************************************/


/**************************************************************/
/* callb_timer()                                              */
/*                                                            */
/* Handler for callback set by timer_handler() every second.  */
/* Execute em_local_timer() for alternately all odd numbered  */
/* units, then all even numbered ones. This means that each   */
/* unit has the routine called every 2 seconds.               */
/*                                                            */
/* Parameters: Register block on callback;                    */
/*                                                            */
/*             Module private word;                           */
/*                                                            */
/*             Handle.                                        */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * callb_timer(_kernel_swi_regs * r, void * pw, void * handle)
{
    static unsigned int which = 0;
    device_t            dev;

    (void)r;
    (void)pw;
    (void)handle;

    for (dev = device_list; dev; dev = dev->next)
    {
        if (dev->localtimerset && (dev->dib.dib_unit & 1) == which)
        {
            dprintf(("Timer", "%s: Calling em_local_timer() for unit %u\n", __func__, dev->dib.dib_unit));
            em_local_timer(&dev->adapter);
        }
    }

    which ^= 1;
    timer_callb_set = false;

    return NULL;
}

/**************************************************************/
/* timer_handler()                                            */
/*                                                            */
/* Handler for callevery timer called once a second.          */
/*                                                            */
/* Parameters: Register block;                                */
/*                                                            */
/*             Module private word;                           */
/*                                                            */
/*             Handle.                                        */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * timer_handler(_kernel_swi_regs * r, void * pw, void * handle)
{
    device_t dev;
    uint32_t now;

    (void)r;
    (void)pw;
    (void)handle;

    _swix(OS_ReadMonotonicTime, _OUT(0), &now);

    /* Do the watchdog check for each unit */
    for (dev = device_list; dev; dev = dev->next)
    {
        if (
            dev->initialised &&
            (dev->adapter.interface_data.ac_if.if_flags & IFF_RUNNING) != 0
           )
        {
            em_ro_watchdog(dev, now);
        }
    }

    /* Schedule a callback to call em_local_timer */
    if (!timer_callb_set)
    {
        if (callx_add_callback(callb_timer, NULL) == NULL)
        {
            timer_callb_set = true;
        }
    }

    return NULL;
}


/**************************************************************/
/* Service call handler support routines.                     */
/**************************************************************/


/**************************************************************/
/* panic()                                                    */
/*                                                            */
/* Log a 'panic' message for all units.                       */
/*                                                            */
/* Parameters: Pointer to the message string.                 */
/**************************************************************/

static void panic(char *s)
{
    device_t dev;

    for (dev = device_list; dev; dev = dev->next)
    {
        log_message(dev, "Panic: %s", s);
    }
}

/**************************************************************/
/* send_driverstatus()                                        */
/*                                                            */
/* Send a DCIDriverStatus Service Call for given dib.         */
/*                                                            */
/* Parameters: Pointer to the dib;                            */
/*                                                            */
/*             The status value to send                       */
/*             (0=starting, 1=terminating.)                   */
/**************************************************************/

static void send_driverstatus(DibRef dib, int status)
{
    dprintf(("Service", "%s: Sending Service_DCIDriverStatus for unit %d, status=%d\n",
        __func__, dib->dib_unit, status));

    _swix(OS_ServiceCall,
          _INR(0,3),

          dib,
          Service_DCIDriverStatus,
          status,
          DCIVERSION);
}

/**************************************************************/
/* callb_send_driverstatus()                                  */
/*                                                            */
/* Handler for callback primed by initialisation routine.     */
/* Sends round DCIDriverStatus Service Calls for all units    */
/* to say they are starting.                                  */
/*                                                            */
/* Parameters: Register block on callback;                    */
/*                                                            */
/*             Module private word;                           */
/*                                                            */
/*             Handle.                                        */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * callb_send_driverstatus(_kernel_swi_regs * r, void * pw, void * handle)
{
    device_t    dev;

    (void)r;
    (void)pw;
    (void)handle;

    for (dev = device_list; dev; dev = dev->next)
    {
        send_driverstatus(&dev->dib, DCIDRIVER_STARTING);
    }

    return NULL;
}

/**************************************************************/
/* handle_managerstatus()                                     */
/*                                                            */
/* Deal with a MbufManagerStatus service call.                */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/**************************************************************/

static void handle_managerstatus(_kernel_swi_regs * r)
{
    switch (r->r[0])
    {
      case MbufManagerStatus_Started:
        dprintf(("Service", "%s: MbufManagerStatus_Started\n", __func__));
        if (!managerstarted)
        {
            /* Mbuf manager has appeared - open session */
            if (mbuf_open_session() == NULL)
            {
                /* Mbuf system initialised, set a callback */
                /* to announce our presence.               */
                managerstarted = true;
                callx_add_callback(callb_send_driverstatus, NULL);
            }
        }

        break;

      case MbufManagerStatus_Stopping:
        dprintf(("Service", "%s: MbufManagerStatus_Stopping\n", __func__));
        /* We should only ever see this message if we are finalising our */
        /* own module, otherwise something has gone terribly wrong (the  */
        /* mbuf manager should only stop when all its clients have       */
        /* closed their sessions.)                                       */
        if (!finalising) panic("Mbuf manager has stopped");
        break;

      case MbufManagerStatus_Scavenge:
        dprintf(("Service", "%s: MbufManagerStatus_Scavenge\n", __func__));
        /* do nothing */
        break;

      default:
        break;
    }
}

/**************************************************************/
/* release_module_filters()                                   */
/*                                                            */
/* Remove all the filters associated with the module with the */
/* specified private word pointer.                            */
/*                                                            */
/* Parameters: Private word pointer.                          */
/**************************************************************/

static void release_module_filters(u_int pwp)
{
    device_t    dev;

    /* Loop over all active units looking for the module */
    for (dev = device_list; dev; dev = dev->next)
    {
        filter_release_module(dev, pwp);
    }
}


/**************************************************************/
/* SWI handler routines.                                      */
/**************************************************************/


/**************************************************************/
/* ek_version()                                               */
/*                                                            */
/* Implement SWI EtherK_Version.                              */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_version(_kernel_swi_regs *r)
{
    if (r->r[0])
        return EINVAL;

    r->r[1] = DCIVERSION;

    return 0;
}

/**************************************************************/
/* ek_inquire()                                               */
/*                                                            */
/* Implement SWI EtherK_Inquire.                              */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_inquire(_kernel_swi_regs *r)
{
    device_t dev = get_device(r->r[1]);

    if (r->r[0])
        return EINVAL;

    if (dev == NULL)
        return ENXIO;

    r->r[2] = dev->dib.dib_inquire;

    return 0;
}

/**************************************************************/
/* ek_getmtu()                                                */
/*                                                            */
/* Implement SWI EtherK_GetNetworkMTU.                        */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_getmtu(_kernel_swi_regs *r)
{
    device_t dev = get_device(r->r[1]);
    int      error = 0;

    if (r->r[0])
    {
        error = EINVAL;
    }
    else if (dev == NULL)
    {
        error = ENXIO;
    }
    else if (!dev->initialised)
    {
        error = ENETDOWN;
    }
    else
    {
        r->r[2] = (int)dev->adapter.interface_data.ac_if.if_mtu;
    }

    return error;
}

/**************************************************************/
/* ek_setmtu()                                                */
/*                                                            */
/* Implement SWI EtherK_SetNetworkMTU.                        */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_setmtu(_kernel_swi_regs *r)
{
    device_t dev = get_device(r->r[1]);
    int      error = 0;

    if (r->r[0])
    {
        error = EINVAL;
    }
    else if (dev == NULL)
    {
        error = ENXIO;
    }
    else if (!dev->initialised)
    {
        error = ENETDOWN;
    }
    else
    {
        if (r->r[2] > ETHERMTU)
        {
            error = EINVAL;
        }
        else
        {
            dev->adapter.interface_data.ac_if.if_mtu = r->r[2];
            dev->adapter.hw.max_frame_size = r->r[2] + ETHER_HDR_LEN + ETHER_CRC_LEN;
            /* Note that the BSD code calls em_init() after changing the */
            /* MTU, but this is only necessary to do the settings for    */
            /* jumbo frames, which we don't currently support.           */
        }
    }

    return error;
}

/**************************************************************/
/* ek_transmit()                                              */
/*                                                            */
/* Implement SWI EtherK_Transmit.                             */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_transmit(_kernel_swi_regs* r)
{
    uint32_t      flags = r->r[0];
    device_t      dev = get_device(r->r[1]);
    struct mbuf * m_head = (struct mbuf *)r->r[3];
    struct mbuf * m;
    uint8_t     * esrc;
    int           num_packets = 0;
    int           error = 0;

    dprintf(("SWI", "%s: unit=%d, flags=&%x, type=&%x, m_head=%p\n", __func__,
             r->r[1], flags, r->r[2], m_head));

    if (flags >= TX_1STRESERVED)
    {
        error = EINVAL;
    }
    else if (dev == NULL)
    {
        error = ENXIO;
    }
    else if (!dev->initialised ||
             (dev->adapter.interface_data.ac_if.if_flags & IFF_RUNNING) == 0)
    {
        error = ENETDOWN;
    }
    else if (!dev->adapter.link_active)
    {
        /* Was initialisation started without waiting for auto-negotiation? */
        if (dev->adapter.hw.wait_autoneg_complete == 0 &&
            dev->adapter.init_start_time != 0)
        {
            uint32_t now;

            /* Wait until the time out period has elapsed or the link comes up */
            dprintf(("TX", "Blocking for link up - "));
            do
            {
                _swix(OS_ReadMonotonicTime, _OUT(0), &now);
            } while (!dev->adapter.link_active && (now - dev->adapter.init_start_time) < (PHY_AUTO_NEG_TIME * 10));
            dprintf(("TX", "finished. Time diff=%u, link=%d\n", now - dev->adapter.init_start_time, dev->adapter.link_active));

            /* Don't do this again until the chip is reinitialised */
            dev->adapter.init_start_time = 0;

            if (!dev->adapter.link_active)
            {
                error = ENETDOWN;
            }
        }
        else
        {
            error = ENETDOWN;
        }
    }

    if (!error)
    {
        /* Count the number of packets to send */
        for (m = m_head; m; m = m->m_list)
            num_packets++;
    }

    if (num_packets > 0)
    {
        if ((flags & TX_FAKESOURCE) != 0 && r->r[5] != 0)
            esrc = (uint8_t *)r->r[5];
        else
            esrc = dev->adapter.hw.mac_addr;

        error = em_ro_transmit(dev, m_head, num_packets, (uint8_t *)r->r[4], esrc, htons(r->r[2]));
    }

    if ((flags & TX_PROTOSDATA) == 0)
    {
        /* We own the mbufs, so free them. It appears that this is the   */
        /* correct thing to do, even if we return an error, although the */
        /* DCI 4 specification is not clear on this.                     */

        while (m_head)
        {
            m = m_head;
            m_head = m_head->m_list;
            m_freem(m);
        }
    }

    return error;
}

/**************************************************************/
/* ek_filter()                                                */
/*                                                            */
/* Implement SWI EtherK_Filter.                               */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_filter(_kernel_swi_regs *r)
{
    device_t dev = get_device(r->r[1]);

    dprintf(("SWI", "%s: flags=&%x, unit=%d, frame type=&%x, address level=&%x, error level=&%x, pwp=&%x, handler=&%x\n",
              __func__,
              r->r[0], r->r[1], r->r[2], r->r[3], r->r[4], r->r[5], r->r[6]));

    /* Range checking */
    if (
        r->r[0] >= FILTER_1STRESERVED ||
        !check_addrlevel(r->r[3])     ||
        !check_errlevel(r->r[4])
       )
    {
        dprintf(("SWI", "%s: Invalid flags\n", __func__));
        return EINVAL;
    }

    if (dev == NULL)
        return ENXIO;

    if (!dev->initialised)
        return ENETDOWN;

    return filter_update(r, dev);
}

/**************************************************************/
/* ek_stats()                                                 */
/*                                                            */
/* Implement SWI EtherK_Stats.                                */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

int ek_stats(_kernel_swi_regs * r)
{
    int error = 0;

    switch (r->r[0])
    {
        case 0:
            memcpy((char *)(r->r[2]), &supported_stats, sizeof(supported_stats));
            break;

        case 1:
        {
            device_t dev = get_device(r->r[1]);

            if (dev != NULL)
            {
                int irqstate;

                /* Get statistics up to date */
                em_ro_update_stats(dev);

                /* Disable interrupts during copy, as some stats may be updated by interrupt */
                irqstate = ensure_irqs_off();
                memcpy((char *)(r->r[2]), &dev->stats, sizeof(dev->stats));
                restore_irqs(irqstate);
            }
            else
            {
                error = ENXIO;
            }
            break;
        }

        default:
            error = EINVAL;
            break;
    }


    return error;
}

/**************************************************************/
/* ek_multicast()                                             */
/*                                                            */
/* Implement SWI EtherK_Multicast.                            */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/*                                                            */
/* Returns:    BSD error number.                              */
/**************************************************************/

static int ek_multicast(_kernel_swi_regs *r)
{
    (void)r;
    
    dprintf(("SWI", "%s: Called\n", __func__));
    /* !!!TODO!!! Not implemented yet */
    return ENOTTY;
}


/**************************************************************/
/* CLI command handler routines.                              */
/**************************************************************/


/**************************************************************/
/* parse_unit_num()                                           */
/*                                                            */
/* Parse unit number from command line parameter, checking    */
/* for validity.                                              */
/*                                                            */
/* Parameters: Pointer to parameter string;                   */
/*                                                            */
/*             Pointer to variable to hold unit number.       */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * parse_unit_num(const char ** arg_string, int * unit)
{
    _kernel_oserror * e;

    if (ekcnt == 0)
        return messages_make_error("Err_NoUnits", ENXIO, NULL);

    e = _swix(
              OS_ReadUnsigned,
              _INR(0,2) | _OUTR(1,2),

              10 | (1u<<29) | (1u<<31),
              *arg_string,
              ekcnt - 1,

              arg_string,
              unit);

    if (e != NULL)
        return messages_make_error("Err_BadUnit", ENXIO, NULL);

    return NULL;
}

/**************************************************************/
/* ek_cli_info()                                              */
/*                                                            */
/* Implement *EKInfo command.                                 */
/*                                                            */
/* Parameters: Pointer to parameter string;                   */
/*                                                            */
/*             Number of parameters.                          */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_info(const char * arg_string, int arg_count)
{
    static const char keywords[] = ",verbose/s";

    _kernel_oserror * e = NULL;
    int               unit = -1;
    bool              verbose = false;

    if (arg_count > 0)
    {
        uint32_t out_buff[5];   /* 2 pointers, 12 bytes for unit number parameter */

        e = _swix(OS_ReadArgs,
                  _INR(0,3),

                  keywords,
                  arg_string,
                  out_buff,
                  sizeof(out_buff));

        if (e != NULL)
            return messages_make_error("SETKINF", ErrorNumber_Syntax, NULL);

        verbose = (out_buff[1] != 0);

        if (out_buff[0] != 0)
        {
            e = parse_unit_num((const char **)out_buff, &unit);
            if (e != NULL)
                return e;
        }
    }

    if (unit == -1)
    {
        info_print(0, "Inf_Head1", 1, Module_FullVersion);
        info_printf(0, "Inf_Head2", "%d.%02d", DCIVERSION / 100, DCIVERSION % 100);

        if (ekcnt == 0)
        {
            info_print(0, "Err_NoUnits", 0);
        }
        else
        {
            info_printf(0, "Inf_Head3", "%d", ekcnt);
            for (int i = 0; i < ekcnt && e == NULL; i++)
            {
                e = info_output(get_device(i), verbose);
            }
        }
    }
    else
    {
        e = info_output(get_device(unit), verbose);
    }

    return e;
}

/**************************************************************/
/* ek_cli_test()                                              */
/*                                                            */
/* Implement *EKTest command.                                 */
/*                                                            */
/* Parameters: Pointer to parameter string.                   */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_test(const char *arg_string)
{
    _kernel_oserror * e;
    int               unit;

    e = parse_unit_num(&arg_string, &unit);
    if (e != NULL)
        return e;

    test_run(get_device(unit));
    return NULL;
}

/**************************************************************/
/* ek_cli_log()                                               */
/*                                                            */
/* Implement *EKLog command.                                  */
/*                                                            */
/* Parameters: Pointer to parameter string;                   */
/*                                                            */
/*             Number of parameters.                          */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_log(const char *arg_string, int arg_count)
{
    _kernel_oserror * e;
    int               unit;

    if (arg_count > 0)
    {
        e = parse_unit_num(&arg_string, &unit);
        if (e == NULL)
            e = log_output(get_device(unit));
    }
    else
    {
        for (unit = 0, e = NULL; unit < ekcnt && e == NULL; unit++)
        {
            if (unit != 0)
               putchar('\n');
            e = log_output(get_device(unit));
        }
    }

    return e;
}

/**************************************************************/
/* ek_cli_link()                                              */
/*                                                            */
/* Implement *Configure EKLink command.                       */
/*                                                            */
/* Parameters: Pointer to parameter string.                   */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_link(const char * arg_string)
{
    _kernel_oserror * e;
    int               unit;
    static const char arg_template[] = "%1\0%2\0%3\0%4";
    char              args[32];
    char            * duplex_arg;
    char            * mdi_arg;
    bool              have_duplex;
    bool              full_duplex = false;
    bool              syntax_error = false;
    ConfigLink        setting = link_auto;
    uint8_t           mdix;

    /* Use OS_SubstituteArgs to separate the arguments using CLI rules. */
    e = _swix(OS_SubstituteArgs,
              _INR(0,4),

              (uint32_t)arg_string,
              args,
              sizeof(args),
              arg_template,
              sizeof(arg_template));

    if (e != NULL)
        return messages_make_error("SETKLNK", ErrorNumber_Syntax, NULL);

    duplex_arg = args + strlen(args) + 1;
    mdi_arg = duplex_arg + strlen(duplex_arg) + 1;

    /* Now args points to the second argument, duplex_arg to the third, */
    /* mdi_arg to the fourth. If there's anything after this, we had    */
    /* too many arguments.                                              */
    if (*(mdi_arg + strlen(mdi_arg) + 1) != 0)
        return configure_TOO_MANY_PARAMS;

    /* Check the unit number */
    e = parse_unit_num(&arg_string, &unit);
    if (e != NULL)
        return e;

    /* Check the third argument to see if it is 'half' or 'full' */
    if (duplex_arg[0] == 0)
    {
        /* There were only two parameters */
        have_duplex = false;
        mdix = 0;
    }
    else
    {
        if (Strcmp_ci(duplex_arg, link_param_full) == 0)
        {
            have_duplex = true;
            full_duplex = true;
        }
        else if (Strcmp_ci(duplex_arg, link_param_half) == 0)
        {
            have_duplex = true;
            full_duplex = false;
        }
        else
        {
            /* Not 'full' or 'half'. As long as there isn't a third */
            /* argument, assume this is actually the MDI parameter. */
            have_duplex = false;
            if (mdi_arg[0] == 0)
            {
                mdi_arg = duplex_arg;
            }
            else
            {
                syntax_error = true;
            }
        }
    }

    /* Check the speed parameter */
    if (Strcmp_ci(args, link_param_auto) == 0)
    {
        setting = link_auto;
        if (have_duplex)
            syntax_error = true;
    }
    else if (Strcmp_ci(args, link_param_100) == 0)
    {
        setting = full_duplex ? link_100_full : link_100_half;
        if (!have_duplex)
            syntax_error = true;
    }
    else if (Strcmp_ci(args, link_param_10) == 0)
    {
        setting = full_duplex ? link_10_full : link_10_half;
        if (!have_duplex)
            syntax_error = true;
    }
    else
    {
        syntax_error = true;
    }

    /* Check the MDI parameter */
    if (mdi_arg[0] == 0)
    {
        /* Default is auto if the speed is auto or MDI if speed is forced */
        mdix = (setting == link_auto) ? 0 : 1;
    }
    else if (Strcmp_ci(mdi_arg, link_param_mdi) == 0)
    {
        mdix = 1;   /* MDI */
    }
    else if (Strcmp_ci(mdi_arg, link_param_mdix) == 0)
    {
        mdix = 2;   /* MDI-X */
    }
    else
    {
        syntax_error = true;
    }

    if (syntax_error)
        return messages_make_error("SETKLNK", ErrorNumber_Syntax, NULL);

    return em_ro_change_link(get_device(unit), setting, mdix);
}

/**************************************************************/
/* ek_cli_link_status()                                       */
/*                                                            */
/* Implement *Status EKLink command.                          */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_link_status(void)
{
    device_t dev;

    for (int i = 0; i < ekcnt; i++)
    {
        const char * p1 = "";
        const char * p2 = NULL;
#if 0
        const char * p3 = NULL;
#endif

        dev = get_device(i);

        switch (dev->link_setting)
        {
            case link_auto:
                p1 = link_param_auto;
                break;

            case link_1000:
                p1 = link_param_1000;
                break;

            case link_100_half:
                p1 = link_param_100;
                p2 = link_param_half;
                break;

            case link_100_full:
                p1 = link_param_100;
                p2 = link_param_full;
                break;

            case link_10_half:
                p1 = link_param_10;
                p2 = link_param_half;
                break;

            case link_10_full:
                p1 = link_param_10;
                p2 = link_param_full;
                break;
        }

        /* MDI/MDI-X option is currently hidden, as the fact that it */
        /* doesn't seem to work when the link speed is forced means  */
        /* that it isn't very useful.                                */
#if 0
        switch (dev->link_mdix)
        {
            case 1:
                p3 = link_param_mdi;
                break;

            case 2:
                p3 = link_param_mdix;
                break;
        }
#endif

        printf("EKLink     %d %s", i, p1);
        if (p2 != NULL)
            printf(" %s", p2);
#if 0
        if (p3 != NULL)
            printf(" %s", p3);
#endif
        putchar('\n');
    }
    return NULL;
}

/**************************************************************/
/* advertise_set_flags()                                      */
/*                                                            */
/* Set bits in a bit mask and return whether they were        */
/* already set or not.                                        */
/*                                                            */
/* Parameters: Bits to be tested and set;                     */
/*                                                            */
/*             Pointer to bit mask.                           */
/*                                                            */
/* Returns:    True if the bits were already set, else false. */
/**************************************************************/

static bool advertise_set_flags(uint8_t bits, uint8_t * mask)
{
    if (((*mask) & bits) != 0)
        return true;

    *mask |= bits;

    return false;
}

/**************************************************************/
/* ek_cli_advertise()                                         */
/*                                                            */
/* Implement *Configure EKAdvertise command.                  */
/*                                                            */
/* Parameters: Pointer to parameter string.                   */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_advertise(const char * arg_string)
{
    _kernel_oserror    * e;
    int                  unit;
    static const char    arg_template[] = "%1\0%2\0%3\0%4\0%5\0%6\0%7\0%8";
    char                 args[40];
    char               * arg_ptr;
    uint8_t              setting;
    uint8_t              speed;
    bool                 had_duplex;
    bool                 syntax_error;

    /* Use OS_SubstituteArgs to separate the arguments using CLI rules. */
    e = _swix(OS_SubstituteArgs,
              _INR(0,4),

              (uint32_t)arg_string,
              args,
              sizeof(args),
              arg_template,
              sizeof(arg_template));

    if (e != NULL)
        return messages_make_error("SETKADV", ErrorNumber_Syntax, NULL);

    /* Check the unit number */
    e = parse_unit_num(&arg_string, &unit);
    if (e != NULL)
        return e;

    /* Run through the arguments, setting the bits in the advertise mask. */
    /* If '10' or '100' is specified without 'half' or 'full' afterwards, */
    /* both duplex settings are made available. The same bit cannot be    */
    /* set twice.                                                         */
    arg_ptr = args;
    setting = 0;
    speed = 0;
    had_duplex = false;
    syntax_error = false;
    while(*arg_ptr != 0 && !syntax_error)
    {
        if (Strcmp_ci(arg_ptr, link_param_1000) == 0)
        {
            syntax_error = advertise_set_flags(ADVERTISE_1000_FULL, &setting);
            speed = 0;
            had_duplex = false;
        }
        else if (Strcmp_ci(arg_ptr, link_param_100) == 0)
        {
            if (speed != 0 && !had_duplex)
                syntax_error = advertise_set_flags(speed | (speed>>1), &setting);
            speed = ADVERTISE_100_FULL;
            had_duplex = false;
        }
        else if (Strcmp_ci(arg_ptr, link_param_10) == 0)
        {
            if (speed != 0 && !had_duplex)
                syntax_error = advertise_set_flags(speed | (speed>>1), &setting);
            speed = ADVERTISE_10_FULL;
            had_duplex = false;
        }
        else if (Strcmp_ci(arg_ptr, link_param_full) == 0)
        {
            if (speed == 0)
                syntax_error = true;
            else
                syntax_error = advertise_set_flags(speed, &setting);
            had_duplex = true;
        }
        else if (Strcmp_ci(arg_ptr, link_param_half) == 0)
        {
            if (speed == 0)
                syntax_error = true;
            else
                syntax_error = advertise_set_flags(speed>>1, &setting);
            had_duplex = true;
        }
        else
        {
            syntax_error = true;
        }

        arg_ptr += strlen(arg_ptr) + 1;
    }

    if (!syntax_error && speed != 0 && !had_duplex)
        syntax_error = advertise_set_flags(speed | (speed>>1), &setting);

    if (syntax_error)
        return messages_make_error("SETKADV", ErrorNumber_Syntax, NULL);

    return em_ro_set_advertise(get_device(unit), setting);
}

/**************************************************************/
/* ek_cli_advertise_status()                                  */
/*                                                            */
/* Implement *Status EKAdvertise command.                     */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_advertise_status(void)
{
    device_t dev;

    for (int i = 0; i < ekcnt; i++)
    {
        uint8_t advertised;

        dev = get_device(i);
        advertised = dev->advertise;
        
        printf("EKAdvertise %d", i);
        if (advertised & (ADVERTISE_10_HALF|ADVERTISE_10_FULL))
            printf(" %s", link_param_10);
        if (advertised & ADVERTISE_10_HALF)
            printf(" %s", link_param_half);
        if (advertised & ADVERTISE_10_FULL)
            printf(" %s", link_param_full);
        if (advertised & (ADVERTISE_100_HALF|ADVERTISE_100_FULL))
            printf(" %s", link_param_100);
        if (advertised & ADVERTISE_100_HALF)
            printf(" %s", link_param_half);
        if (advertised & ADVERTISE_100_FULL)
            printf(" %s", link_param_full);
        if (advertised & ADVERTISE_1000_FULL)
            printf(" %s", link_param_1000);
        putchar('\n');
    }

    return NULL;
}

/**************************************************************/
/* ek_cli_flow()                                              */
/*                                                            */
/* Implement *Configure EKFlowControl command.                */
/*                                                            */
/* Parameters: Pointer to parameter string.                   */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_flow(const char * arg_string)
{
    _kernel_oserror * e;
    int               unit;
    static const char arg_template[] = "%0";
    char              args[32];
    em_fc_type        setting;

    /* Check the unit number */
    e = parse_unit_num(&arg_string, &unit);
    if (e != NULL)
        return e;

    /* Ensure the control terminated parameter is compared as a C string */
    e = _swix(OS_SubstituteArgs,
              _INR(0,4),

              arg_string,
              args,
              sizeof(args),
              arg_template,
              sizeof(arg_template));

    /* Check the parameter */
    if (Strcmp_ci(args, flow_param_none) == 0)
    {
        setting = em_fc_none;
    }
    else if (Strcmp_ci(args, flow_param_respond) == 0)
    {
        setting = em_fc_rx_pause;
    }
    else if (Strcmp_ci(args, flow_param_generate) == 0)
    {
        setting = em_fc_tx_pause;
    }
    else if (Strcmp_ci(args, flow_param_full) == 0)
    {
        setting = em_fc_full;
    }
    else
    {
        return messages_make_error("SETKFLW", ErrorNumber_Syntax, NULL);
    }

    return em_ro_set_flow(get_device(unit), setting);
}

/**************************************************************/
/* ek_cli_flow_status()                                       */
/*                                                            */
/* Implement *Status EKFlowControl command.                   */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

static _kernel_oserror * ek_cli_flow_status(void)
{
    device_t dev;

    for (int i = 0; i < ekcnt; i++)
    {
        const char * p = "";

        dev = get_device(i);

        switch (dev->flow_control)
        {
            case em_fc_none:
                p = flow_param_none;
                break;

            case em_fc_rx_pause:
                p = flow_param_respond;
                break;

            case em_fc_tx_pause:
                p = flow_param_generate;
                break;

            case em_fc_full:
                p = flow_param_full;
                break;
        }

        printf("EKFlowControl %d %s\n", i, p);
    }
    return NULL;
}


/**************************************************************/
/* Module entry points                                        */
/**************************************************************/


/**************************************************************/
/* ek_initialise()                                            */
/*                                                            */
/* Module initialisation code.                                */
/*                                                            */
/* Parameters: Pointer to argument list;                      */
/*                                                            */
/*             Podule base;                                   */
/*                                                            */
/*             Module workspace pointer.                      */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * ek_initialise(const char * cmd_tail, int podule_base, void * pw)
{
    _kernel_oserror *   e;
    uint32_t            num_handles;
    uint32_t            fh;
    device_t            dev = NULL;
    device_t            prev = NULL;
    bool                alloc_failed = false;
    bool                init_failed;
    struct
    {
        uint32_t        devfn;
        uint32_t        bus;
        uint32_t        slot;
        uint32_t        id;
        uint32_t        sub_id;
        uint32_t        device_vector;
    } pci_info;
    const uint32_t      pci_info_bits = PCI_ReadInfo_DevFn + PCI_ReadInfo_Bus +
                                        PCI_ReadInfo_Slot + PCI_ReadInfo_DeviceID +
                                        PCI_ReadInfo_SubsystemID + PCI_ReadInfo_IntDeviceVector;

    (void)cmd_tail;
    (void)podule_base;

    module_wsp = pw;

    /* Initialise DebugLib */
    debug_initialise("EtherK", "null:", NULL);
    debug_set_taskname_prefix(false);
    debug_set_stamp_debug(true);
    debug_set_device(DADEBUG_OUTPUT);
    debug_set_raw_device(NULL_OUTPUT);
    debug_set_trace_device(NULL_OUTPUT);

    /* Initalise callx */
    callx_init(pw);

#ifdef DBG_STATS
    em_ro_init_dbg_stats();
#endif

    /* Initialise messages */
    e = messages_init();
    if (e != NULL)
        return e;

    /* Initialise locale for printing formatted numbers */
    setlocale(LC_ALL, "");

    /* Initialise the supported statistics structure */
    em_ro_init_supported_stats(&supported_stats);

    /* Look for devices we can drive */

    e = _swix(PCI_ReturnNumber,
              _OUT(0),

              &num_handles);

    if (e != NULL)
    {
        dprintf(("", "%s: PCI_ReturnNumber failed: '%s'\n", __func__, e->errmess));
        num_handles = 0;
    }

    dprintf(("Init", "%s: PCI_ReturnNumber reports %d function handles\n", __func__, num_handles));

    for (fh = 1; fh <= num_handles; fh++)
    {
        /* Make sure we have a device structure to fill in */
        if (dev == NULL)
        {
            dev = calloc(1, sizeof(struct device));
            if (dev == NULL)
            {
                alloc_failed = true;
                break;
            }
        }

        dev->module_wsp = pw;
        dev->function_handle = fh;

        /* Read various PCI device information */
        e = _swix(PCI_ReadInfo,
                  _INR(0,3),

                  pci_info_bits,
                  &pci_info,
                  sizeof(pci_info),
                  fh);

        if (e != NULL)
        {
            /* Something went wrong - failed to read the info */
            dprintf(("Init", "%s: PCI_ReadInfo for function handle %u failed: '%s'\n", __func__, fh, e->errmess));
            continue;
        }

        dev->pci_id = pci_info.id;
        dev->pci_sub_id = pci_info.sub_id;
        dev->device_vector = pci_info.device_vector;

        dprintf(("Init", "%s: Function handle %d has vendor ID %04x, device ID %04x, subsystem vendor ID %04x, subsystem ID %04x\n",
             __func__, fh, (dev->pci_id & 0xffff), (dev->pci_id >> 16), (dev->pci_sub_id & 0xffff), (dev->pci_sub_id >> 16)));

        /* Ask the driver whether it recognises this device */
        if (em_probe(dev) == 0)
        {
            bool on_motherboard = ((pci_info.devfn == 0x20) && (pci_info.bus == 0));

            init_failed = false;
            dprintf(("Init", "%s: Function handle %d recognised by em_probe()\n", __func__, fh));
            dprintf(("Init", "%s: Device vector is %d\n", __func__, dev->device_vector));

#ifdef NOMOBO
            if (!on_motherboard) /* Ignore motherboard device */
            {
#endif

            log_message(dev, "Initialising device");

            /* Increment the global count of the number of units */
            ekcnt++;

            /* Initialise the address filter function pointer */
            dev->address_filter = af_reject;

            /* Fill in the Device Information Block */
            dev->dib.dib_swibase = EtherK_00;
            dev->dib.dib_name = (unsigned char *)short_name;
            dev->dib.dib_unit = ekcnt - 1;
            /* dev->dib.dib_address is set after em_attach() */
            dev->dib.dib_module = (unsigned char *)module_name;
            dev->dib.dib_inquire = (INQ_MULTICAST | INQ_PROMISCUOUS |
                                INQ_HWADDRVALID | INQ_SOFTHWADDR |
                                INQ_HASSTATS /*| INQ_HW_MULTICAST*/ );
            /* !!!TODO!!! - get the flags right */

            /* Read the NVRAM configuration settings */
            em_ro_read_configuration(dev);

            if (on_motherboard)
            {
                char    mac[8];

                /* This device is on the motherboard */

                dev->dib.dib_location = (unsigned char *)location_motherboard;

                /* The motherboard controller is a special case. There is */
                /* no EEPROM, so set up the fake EEPROM data now.         */

                dev->no_eeprom = true;

                /* Read the MAC address */
                e = _swix(PCI_ReadInfo,
                          _INR(0,3),

                          PCI_ReadInfo_EthernetAddress,
                          mac,
                          sizeof(mac),
                          fh);

                if (e == NULL)
                {
                    int i;

                    /* Bung the MAC address directly into the driver's */
                    /* hardware structure.                             */
                    for(i = 0; i < NODE_ADDRESS_SIZE; i++)
                        dev->adapter.hw.mac_addr[i] = dev->adapter.hw.perm_mac_addr[i] = mac[5-i];
                }
                else
                {
                    log_message(dev, "Failed to read MAC address for motherboard Ethernet controller (function handle %u, error: '%s')", fh, e->errmess);

                    /* No MAC address, so this device can't be initialised */
                    init_failed = true;
                }
            }
            else
            {
                if (pci_info.slot > 99 || (dev->dib.dib_location = malloc(sizeof(location_string))) == NULL)
                    dev->dib.dib_location = (unsigned char *)location_unknown;
                else
                    sprintf((char *)dev->dib.dib_location, location_string, pci_info.slot);
            }

            dprintf(("Init", "%s: Location of device for function handle %u is '%s'\n", __func__, fh, dev->dib.dib_location));

            dev->dib.dib_slot.sl_slotid = DIB_SLOT_PCI(pci_info.slot);
            dev->dib.dib_slot.sl_minor = 0;
            dev->dib.dib_slot.sl_pcmciaslot = 0;
            dev->dib.dib_slot.sl_mbz = 0;

            /* Initialise the device */
            if (!init_failed)
            {
                if (em_attach(dev) == 0)
                {
                    dev->initialised = true;
                    log_message(dev, "Device initialised successfully");

                    /* We now have the MAC address */
                    dev->dib.dib_address = dev->adapter.interface_data.ac_enaddr;

                    /* Get the bus info - the BSD code doesn't bother */
                    em_get_bus_info(&dev->adapter.hw);
                }
                else
                {
                    log_message(dev, "Device initialisation failed");
                }
            }

            /* Initialise the device statistics */
            em_ro_init_stats(dev);

            /* Add to linked list */
            if (prev == NULL)
            {
                device_list = dev;
            }
            else
            {
                prev->next = dev;
            }
            prev = dev;

            dev = NULL;
#ifdef NOMOBO
            }
#endif
        }
    }

    /* All done - free any leftover device structure */
    free (dev);
    dev = NULL;

    if (alloc_failed)
    {
        e = messages_make_error("NoStore", ENOMEM, NULL);
    }
    else if (ekcnt > 0)
    {
        /* Set Inet$EtherType as the DCI 4 spec says you have to */
        e = _kernel_setenv("Inet$EtherType", ether_type);

        /* Check whether the mbuf manager module is loaded yet */
        if (e == NULL && !managerstarted && mbuf_present())
        {
            /* Mbuf manager is loaded - initialise entry points */
            e = mbuf_open_session();

            if (e == NULL)
            {
                /* OK - set a callback to issue Service_DCIDriverStatus */
                callx_add_callback(callb_send_driverstatus, NULL);

                managerstarted = true;
            }
        }
    }
    else
    {
        /* If we failed to find any devices, ignore errors and exit */
        e = NULL;
    }

    if (e == NULL)
    {
        /* Start watchdog timer to execute every 1s */
        e = callx_add_callevery(100-1, timer_handler, NULL);
    }

    if (e != NULL)
    {
        /* If something went wrong, call the finalisation code to undo */
        /* everything we've done so far.                               */
        ek_quit(1, 0, pw);
    }

    return e;
}

/**************************************************************/
/* ek_quit()                                                  */
/*                                                            */
/* Module finalisation code.                                  */
/*                                                            */
/* Parameters: Finalisation entry R10 value;                  */
/*                                                            */
/*             Finalisation entry R11 value;                  */
/*                                                            */
/*             Module workspace pointer.                      */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * ek_quit(int fatal, int podule, void * pw)
{
    device_t    dev, next;

    (void)fatal;
    (void)podule;
    (void)pw;

    finalising = true;

    /* Remove calleverys and callbacks */
    callx_remove_all_calleverys();
    callx_remove_all_callbacks();
    timer_callb_set = false;

    /* Stop all units and free their data */
    for (dev = device_list; dev; dev = next)
    {
        /* Send the DCI service call to say the driver is dying */
        if (managerstarted) send_driverstatus(&dev->dib, DCIDRIVER_DYING);

        /* Shutdown the device, release interrupt etc. */
        if (dev->initialised) em_detach(dev);

        next = dev->next;

        if (
            dev->dib.dib_location != (unsigned char *)location_unknown &&
            dev->dib.dib_location != (unsigned char *)location_motherboard
           )
        {
            free(dev->dib.dib_location);
        }

        free(dev);
    }

    /* Finish session with mbuf manager, ignore any errors (they don't */
    /* mean much, since the session *may* still be closed, despite any */
    /* errors returned.)                                               */
    if (managerstarted) mbuf_close_session();

    /* Close message file etc. */
    messages_quit();

    return NULL;
}

/**************************************************************/
/* ek_sc_handler()                                            */
/*                                                            */
/* Module Service Call handler.                               */
/*                                                            */
/* Parameters: Service Call number;                           */
/*                                                            */
/*             Pointer to register block;                     */
/*                                                            */
/*             Module workspace pointer.                      */
/**************************************************************/

void ek_sc_handler(int sn, _kernel_swi_regs *r, void *pw)
{
    (void)pw;
    
    switch (sn)
    {
        case Service_MbufManagerStatus:
            handle_managerstatus(r);
            break;

        case Service_PreReset:
            /* Stop/reset all devices. Note that this will also free the PCI */
            /* memory by calling PCI_RAMFree. Is this safe? !!!TODO!!!       */
            /* 20041029: Its safer to reset the hardware on Service_PreReset.*/
            /* failure to do so results in stalled booting in response to a  */
            /* soft reset or OS_Reset                                        */
            for (device_t dev = device_list; dev; dev = dev->next)
            {
                if (dev->initialised) em_stop(&dev->adapter);
            }
            break;

        case Service_EnumerateNetworkDrivers:
            if (managerstarted)
            {
                for (device_t dev = device_list; dev; dev = dev->next)
                {
                    ChDibRef chd;

                    chd = (ChDibRef)malloc(sizeof(*chd));
                    if (chd == NULL)
                    {
                        /* Failed to claim memory - return as much */
                        /* information as possible.                */
                        break;
                    }

                    chd->chd_dib = &dev->dib;
                    chd->chd_next = (ChDibRef)r->r[0];
                    r->r[0] = (int)chd;
                }
            }
            break;

        case Service_DCIProtocolStatus:
            dprintf(("Service", "%s: Protocol '%s' (ver. %u) is %sing\n", __func__,
                (char *)r->r[4], r->r[3], r->r[2] ? "dy" : "start"));
            /* Ignore messages from a protocol module with a different */
            /* major version number.                                   */
            if (managerstarted && (r->r[3] / 100) == (DCIVERSION / 100))
            {
                /* Only interested in termination calls. */
                if (r->r[2] == DCIPROTOCOL_DYING) release_module_filters(r->r[0]);
            }
            break;

        case Service_TerritoryStarted:
            setlocale(LC_ALL, "");
            break;

        default:
            break;
    }
}

/**************************************************************/
/* ek_swi_handler()                                           */
/*                                                            */
/* Module SWI handler.                                        */
/*                                                            */
/* Parameters: SWI number (offset from base);                 */
/*                                                            */
/*             Pointer to register block;                     */
/*                                                            */
/*             Module workspace pointer.                      */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * ek_swi_handler(int swinum, _kernel_swi_regs * r, void * pw)
{
    struct swient * callp;
    int             error;
    int             irqstate;

    (void)pw;

    /* We *assume* that, since service calls are not active until the mbuf */
    /* manager has been started, nobody can find out our SWI base, and     */
    /* therefore cannot raise any SWIs. If this is not true (i.e. someone  */
    /* looks up our particular SWI number, then they deserve all the       */
    /* trouble which they are probably likely to receive.                  */
    if (swinum >= (sizeof(ek_ent) / sizeof(ek_ent[0])))
    {
        return error_BAD_SWI;
    }

    /* Check that a correct unit number has been given for all SWIs other */
    /* than Version.                                                      */
    if (swinum != DCI4Version && r->r[1] >= ekcnt)
    {
        return messages_make_error("Err_BadUnit", ENXIO, NULL);
    }

    dprintf(("SWI", "SWI &%x called\n", swinum));

    callp = &ek_ent[swinum];
    irqstate = ensure_irqs_on();
    error = (*(callp->swi_call))(r);
    restore_irqs(irqstate);

    dprintf(("SWI", "SWI exit, error=%d\n", error));

    return messages_make_error("Err_SWI", error, "%d", error);
}

/**************************************************************/
/* ek_cli_handler()                                           */
/*                                                            */
/* Module command handler.                                    */
/*                                                            */
/* Parameters: Pointer to arguments string;                   */
/*                                                            */
/*             Number of arguments;                           */
/*                                                            */
/*             Command number;                                */
/*                                                            */
/*             Module workspace pointer.                      */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * ek_cli_handler(const char * arg_string, int arg_count,
                                 int cmd_no, void * pw)
{
    _kernel_oserror * e = NULL;

    (void)pw;

    switch (cmd_no)
    {
        case CMD_EKInfo:
            /* *EKInfo */
            e = ek_cli_info(arg_string, arg_count);
            break;

        case CMD_EKTest:
            /* *EKTest */
            e = ek_cli_test(arg_string);
            break;

        case CMD_EKLog:
            /* *EKLog */
            e = ek_cli_log(arg_string, arg_count);
            break;

        case CMD_EKLink:
            /* *Configure EKLink */
            if (arg_string == arg_CONFIGURE_SYNTAX)
            {
                info_print(0, "CETKLNK", 0);
            }
            else if (arg_string == arg_STATUS)
            {
                e = ek_cli_link_status();
            }
            else
            {
                e = ek_cli_link(arg_string);
            }
            break;

        case CMD_EKAdvertise:
            /* *Configure EKAdvertise */
            if (arg_string == arg_CONFIGURE_SYNTAX)
            {
                info_print(0, "CETKADV", 0);
            }
            else if (arg_string == arg_STATUS)
            {
                e = ek_cli_advertise_status();
            }
            else
            {
                e = ek_cli_advertise(arg_string);
            }
            break;

        case CMD_EKFlowControl:
            /* *Configure EKFlowControl */
            if (arg_string == arg_CONFIGURE_SYNTAX)
            {
                info_print(0, "CETKFLW", 0);
            }
            else if (arg_string == arg_STATUS)
            {
                e = ek_cli_flow_status();
            }
            else
            {
                e = ek_cli_flow(arg_string);
            }
            break;
    }

    return e;
}
