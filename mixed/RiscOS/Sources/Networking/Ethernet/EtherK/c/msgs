/* Copyright 2002 Tematic Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Msgs.c                                            */
/*                                                            */
/* Purpose: Message lookup and error handling functions.      */
/*                                                            */
/* Author:  J.R.Byrne.                                        */
/**************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <sys/dcistructs.h>

#include "EKHdr.h"

#include "msgs.h"

/* External declarations */

#ifndef ROM
extern void * messages_file(void);   /* Resource block generated by ResGen */
#endif

/* Local definitions */

#define ERR_BLOCKS                 3
#define MessageTrans_TokenNotFound 0xAC2

/* Static variables */

static uint32_t   messages_fd[4] = {0, 0, 0, 0}; /* Message file descriptor */
static const char messages_default_token[] = "TNF:"Module_Title" message not found in messages file";
static const char messages_path[] = Module_Title "$Path";
static const char messages_path_filename[] = Module_Title ":Messages";
static const char messages_resfs_filename[] = "Resources:$.Resources." Module_Title ".Messages";

/**************************************************************/
/* messages_init()                                            */
/*                                                            */
/* This is called on module initialisation to register the    */
/* module's resources (if necessary) and open the messages    */
/* file, using the global messages block                      */
/*                                                            */
/* Returns: Error pointer.                                    */
/**************************************************************/

_kernel_oserror * messages_init(void)
{
    _kernel_oserror * e;
    bool              have_path;

#ifndef ROM
    /* Register resources */
    e = _swix(
              ResourceFS_RegisterFiles,
              _IN(0),

              messages_file());

    if (e != NULL)
        return e;
#endif

    /* Open messages file */
    have_path = (getenv(messages_path) != NULL);
    e = _swix(
              MessageTrans_OpenFile,
              _INR(0,2),

              messages_fd,
              have_path ? messages_path_filename : messages_resfs_filename,
              0);

#ifndef ROM
    if (e != NULL)
    {
        _swix(
              ResourceFS_DeregisterFiles,
              _IN(0),

              messages_file());
    }
#endif

  return e;
}

/**************************************************************/
/* messages_quit()                                            */
/*                                                            */
/* This is called on module finalisation to close the         */
/* messages file using the global messages block, and         */
/* deregister the module's resources (if necessary).          */
/**************************************************************/

void messages_quit(void)
{
    /* Close messages file */
    _swix(
          MessageTrans_CloseFile,
          _IN(0),

          messages_fd);

#ifndef ROM
    /* Deregister resources */
    _swix(
          ResourceFS_DeregisterFiles,
          _IN(0),

          messages_file());
#endif
}

/**************************************************************/
/* messages_return_message()                                  */
/*                                                            */
/* Lookup a message through MessageTrans and return a pointer */
/* to the message. If the token is not found a pointer to a   */
/* default message is returned instead. Messages looked up in */
/* this way must include a null terminator in the messages    */
/* file, and must not be tokenised.                           */
/*                                                            */
/* Parameters: Pointer to the message token.                  */
/*                                                            */
/* Returns:    Pointer to the message.                        */
/*                                                            */
/* Assumes:    Messages include a null terminator in the      */
/*             messages file, and are not tokenised.          */
/**************************************************************/

const char * messages_return_message(const char * token)
{
    _kernel_oserror * e;
    char            * ptr;

    /* Look up token */
    e = _swix(MessageTrans_Lookup,
              _INR(0,7) | _OUT(2),
    
              messages_fd,
              token,
              0,
              0,
              0,
              0,
              0,
              0,

              &ptr);

    /* If the token isn't found, replace with our not found message */
    if (e != NULL)
    {
        if (e->errnum == MessageTrans_TokenNotFound)
        {
            e = _swix(MessageTrans_Lookup,
                      _INR(0,7) | _OUT(2),
            
                      messages_fd,
                      messages_default_token,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,

                      &ptr);
        }

        /* Last resort - MessageTrans went wrong, so use its error message */
        if (e != NULL)
        {
            ptr = e->errmess;
        }
    }

    return ptr;
}

/**************************************************************/
/* messages_lookup_subst()                                    */
/*                                                            */
/* Look up a message token and perform parameter              */
/* substitution. If the token is not found it is replaced     */
/* with a default message. An error is only returned if       */
/* the lookup of the default message also fails, and in       */
/* this case the error message is copied to the output        */
/* buffer too.                                                */
/*                                                            */
/* Parameters: Pointer to a buffer to write the output to;    */
/*                                                            */
/*             The size of the buffer;                        */
/*                                                            */
/*             Pointer to the message token;                  */
/*                                                            */
/*             Pointer to an array containing four pointers   */
/*             to the strings to be substituted for the %0    */
/*             to %3 parameters. Any of these can be NULL     */
/*             if the parameter is not required.              */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * messages_lookup_subst(char * buffer, size_t length,
    const char * token, const char * params[static 4])
{
    _kernel_oserror * e;

    /* Look up token */
    e = _swix(MessageTrans_Lookup,
              _INR(0,7),
    
              messages_fd,
              token,
              buffer,
              length,
              params[0],
              params[1],
              params[2],
              params[3]);

    /* If the token isn't found, replace with our own not found message */
    if (e != NULL)
    {
        if (e->errnum == MessageTrans_TokenNotFound)
        {
            e = _swix(MessageTrans_Lookup,
                      _INR(0,7),
            
                      messages_fd,
                      messages_default_token,
                      buffer,
                      length,
                      0,
                      0,
                      0,
                      0);
        }

        /* Last resort - MessageTrans went wrong, so use its error message */
        if (e != NULL)
        {
            strncpy(buffer, e->errmess, length);
            buffer[length-1] = 0;
        }
    }

    return e;
}

/**************************************************************/
/* messages_vlookup()                                         */
/*                                                            */
/* Look up a message token and perform parameter              */
/* substitution. If the token is not found it is replaced     */
/* with a default message. An error is only returned if       */
/* the lookup of the default message also fails, and in       */
/* this case the error message is copied to the output        */
/* buffer too.                                                */
/*                                                            */
/* Parameters: Pointer to a buffer to write the output to;    */
/*                                                            */
/*             The size of the buffer;                        */
/*                                                            */
/*             Pointer to the message token;                  */
/*                                                            */
/*             The number of parameters (0-4);                */
/*                                                            */
/*             Variable argument list pointer that has been   */
/*             initialised by the va_start macro. The         */
/*             arguments, if any, are pointers to the strings */
/*             to be substituted for the %0 to %3 parameters. */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * messages_vlookup(char * buffer, size_t length,
    const char * token, int nparams, va_list ap)
{
    const char * p[4] = {NULL, NULL, NULL, NULL};

    /* Determine parameter pointers */
    if (nparams > 4)
        nparams = 4;

    for (int i = 0; i < nparams; i++)
    {
        p[i] = va_arg(ap, const char *);
    }

    return messages_lookup_subst(buffer, length, token, p);
}

/**************************************************************/
/* messages_lookup()                                          */
/*                                                            */
/* Look up a message token and perform parameter              */
/* substitution. If the token is not found it is replaced     */
/* with a default message. An error is only returned if       */
/* the lookup of the default message also fails, and in       */
/* this case the error message is copied to the output        */
/* buffer too.                                                */
/*                                                            */
/* Parameters: Pointer to a buffer to write the output to;    */
/*                                                            */
/*             The size of the buffer;                        */
/*                                                            */
/*             Pointer to the message token;                  */
/*                                                            */
/*             The number of parameters (0-4);                */
/*                                                            */
/*             Variable argument list of up to four pointers  */
/*             to the strings to be substituted for the %0    */
/*             to %3 parameters.                              */
/*                                                            */
/* Returns:    Error pointer.                                 */
/**************************************************************/

_kernel_oserror * messages_lookup(char * buffer, size_t length,
    const char * token, int nparams, ...)
{
    _kernel_oserror * e;
    va_list           ap;

    va_start(ap, nparams);
    e = messages_vlookup(buffer, length, token, nparams, ap);
    va_end(ap);

    return e;
}

/**************************************************************/
/* messages_vlookupf()                                        */
/*                                                            */
/* Look up a message token using MessageTrans, substituting   */
/* parameters with elements from a printf() style formatted   */
/* string. The format string and its parameters are processed */
/* by sprintf() first, then the resulting string is split at  */
/* any line feed characters within it. Each of the resulting  */
/* strings becomes one parameter for the MessageTrans         */
/* parameter substitution.                                    */
/*                                                            */
/* For example, if the message string for the token was       */
/* "First %0, then %1", the format string was "a=%d\nb=%d"    */
/* and the parameters were '1' and '2' then the result would  */
/* be "First a=1, then b=2".                                  */
/*                                                            */
/* If the token is not found it is replaced with a default    */
/* message.                                                   */
/*                                                            */
/* Parameters: Pointer to a buffer to write the output to;    */
/*                                                            */
/*             The size of the buffer;                        */
/*                                                            */
/*             Pointer to the message token;                  */
/*                                                            */
/*             Pointer to the format string;                  */
/*                                                            */
/*             Variable argument list pointer that has been   */
/*             initialised by the va_start macro.             */
/*                                                            */
/* Returns:    Error pointer.                                 */
/*                                                            */
/* Assumes:    The expanded string will be no more than 80    */
/*             characters in length. Longer strings will be   */
/*             truncated.                                     */
/**************************************************************/

_kernel_oserror * messages_vlookupf(char * buffer, size_t length,
    const char * token, const char * format, va_list ap)
{
    char         params[80];
    const char * pp[4] = {NULL, NULL, NULL, NULL};

    if (format != NULL)
    {
        vsnprintf(params, sizeof(params), format, ap);
    
        char * p = params;
        for (int i = 0; *p && i < 4; i++)
        {
            pp[i] = p;
            while (*p)
            {
                if (*p++ == '\n')
                {
                    *(p-1) = 0;
                    break;
                }
            }
        }
    }

    return messages_lookup_subst(buffer, length, token, pp);
}

/**************************************************************/
/* messages_lookupf()                                         */
/*                                                            */
/* Look up a message token using MessageTrans, substituting   */
/* parameters with elements from a printf() style formatted   */
/* string. The format string and its parameters are processed */
/* by sprintf() first, then the resulting string is split at  */
/* any line feed characters within it. Each of the resulting  */
/* strings becomes one parameter for the MessageTrans         */
/* parameter substitution.                                    */
/*                                                            */
/* For example, if the message string for the token was       */
/* "First %0, then %1", the format string was "a=%d\nb=%d"    */
/* and the parameters were '1' and '2' then the result would  */
/* be "First a=1, then b=2".                                  */
/*                                                            */
/* If the token is not found it is replaced with a default    */
/* message.                                                   */
/*                                                            */
/* Parameters: Pointer to a buffer to write the output to;    */
/*                                                            */
/*             The size of the buffer;                        */
/*                                                            */
/*             Pointer to the message token;                  */
/*                                                            */
/*             Pointer to the format string;                  */
/*                                                            */
/*             Variable argument list of parameters.          */
/*                                                            */
/* Returns:    Error pointer.                                 */
/*                                                            */
/* Assumes:    The expanded string will be no more than 80    */
/*             characters in length. Longer strings will be   */
/*             truncated.                                     */
/**************************************************************/

_kernel_oserror * messages_lookupf(char * buffer, size_t length,
    const char * token, const char * format, ...)
{
    _kernel_oserror * e;
    va_list           ap;

    va_start(ap, format);
    e = messages_vlookupf(buffer, length, token, format, ap);
    va_end(ap);

    return e;
}

/**************************************************************/
/* find_error()                                               */
/*                                                            */
/* Get a pointer to one of ERR_BLOCKS locally stored error    */
/* blocks, in which error messages can be stored for future   */
/* reference. Each request increments the internal counter    */
/* until it wraps around back to the first error block held.  */
/*                                                            */
/* Returns: Pointer to an error block.                        */
/**************************************************************/

static _kernel_oserror * find_error(void)
{
    static _kernel_oserror global_error_block[ERR_BLOCKS];
    static int             errblock = 0;

    errblock = (errblock+1) % ERR_BLOCKS;
    return &global_error_block[errblock];
}

/**************************************************************/
/* messages_make_error()                                      */
/*                                                            */
/* Builds an error block from a message file token.           */
/* Parameters in the message are substituted by using a       */
/* format string and argument list. See messages_lookupf()    */
/* for a description of how this works.                       */
/*                                                            */
/* Parameters: Pointer to the message token;                  */
/*                                                            */
/*             Error number;                                  */
/*                                                            */
/*             Pointer to the format string;                  */
/*                                                            */
/*             Variable argument list of parameters.          */
/*                                                            */
/* Returns:    Pointer to an error block.                     */
/**************************************************************/

_kernel_oserror * messages_make_error(const char * token, int errno,
    const char * format, ...)
{
    _kernel_oserror * e;

    if (errno == 0)
    {
        e = NULL;
    }
    else
    {
        e = find_error();
    
        /* Put error number in static error block */
        if (errno >= 0x80)
            e->errnum = errno;
        else
            REALLYSETDCI4ERRNO(e->errnum, errno);
    
        va_list ap;
        va_start(ap, format);
        messages_vlookupf(e->errmess, sizeof(e->errmess), token, format, ap);
        va_end(ap);
    }

    return e;
}
