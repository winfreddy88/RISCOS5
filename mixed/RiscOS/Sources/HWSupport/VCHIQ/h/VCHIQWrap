/*
 * Copyright (c) 2012, RISC OS Open Ltd
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef INTERFACE_VCHIQWRAP_H
#define INTERFACE_VCHIQWRAP_H

#include <stdint.h>
#include <stdbool.h>

/* Datatypes and wrappers around SWIs to provide an API similar to that which would be available via a VCHIQ C library */

typedef uint32_t VCHI_INSTANCE_T;
typedef uint32_t VCHI_SERVICE_HANDLE_T;
typedef uint32_t VCHI_FLAGS_T;
typedef uint32_t VCHI_CONNECTION_T;

struct vchi_version {
  uint32_t version;
  uint32_t version_min;
};
#define VCHI_VERSION(v_) { v_, v_ }
#define VCHI_VERSION_EX(v_, m_) { v_, m_ }

typedef struct vchi_msg_vector
{
  const void *vec_base; /* Address of message data */
  int32_t vec_len; /* Length of message data */
  /* Note: Negative length can be used to link to another vector list (pointed
     to by vec_base), containing -vec_len entries */
} VCHI_MSG_VECTOR_T;

typedef struct
{
  struct vchi_version version;
  uint32_t service_id; /* fourcc, big endian. E.g. 'AUDS' = 0x41554453 */
  uint32_t reserved_0; /* Reserved, must be 0 */
  uint32_t rx_fifo_size;
  uint32_t tx_fifo_size;
  void (*callback)(void); /* Assuming this is will be set to call a CMHG veneer
                             Veneer function will be called with:
                             r0 = callback_param
                             r1 = reason (VCHI_CALLBACK_...)
                             r2 = handle
                             r12 = private_word (from vchi_initialise) */
  void *callback_param;
  uint32_t want_unaligned_bulk_rx; /* 0/1 */
  uint32_t want_unaligned_bulk_tx; /* 0/1 */
  uint32_t want_crc; /* 0/1 */
} SERVICE_CREATION_T;

#define vchi_error_is_retry(e) (e && (e->errnum == ErrorNumber_VCHIQ_Retry))

/* Note addition of private_word, this gets passed to service callbacks in r12 (see above) */
static inline _kernel_oserror *vchi_initialise(VCHI_INSTANCE_T *instance,
                                               void *private_word)
{
  return _swix(VCHIQ_Initialise,_IN(0)|_OUT(0),private_word,instance);
}

static inline _kernel_oserror *vchi_connect(VCHI_CONNECTION_T **connections,
                                            uint32_t num_connections,
                                            VCHI_INSTANCE_T instance_handle)
{
  return _swix(VCHIQ_Connect,_INR(0,2),connections,num_connections,instance_handle);
}

static inline _kernel_oserror *vchi_disconnect(VCHI_INSTANCE_T instance)
{
  return _swix(VCHIQ_Disconnect,_IN(0),instance);
}

static inline _kernel_oserror *vchi_bulk_queue_transmit(VCHI_SERVICE_HANDLE_T handle,
                                                        const void *data_src,
                                                        uint32_t data_size,
                                                        VCHI_FLAGS_T flags,
                                                        void *bulk_handle)
{
  return _swix(VCHIQ_BulkQueueTransmit,_INR(0,4),handle,data_src,data_size,flags,bulk_handle);
}

static inline _kernel_oserror *vchi_bulk_queue_receive(VCHI_SERVICE_HANDLE_T handle,
                                                        const void *data_dst,
                                                        uint32_t data_size,
                                                        VCHI_FLAGS_T flags,
                                                        void *bulk_handle)
{
  return _swix(VCHIQ_BulkQueueReceive,_INR(0,4),handle,data_dst,data_size,flags,bulk_handle);
}

static inline _kernel_oserror *vchi_msg_dequeue(VCHI_SERVICE_HANDLE_T handle,
                                                void *data,
                                                uint32_t max_data_size_to_read,
                                                uint32_t *actual_msg_size,
                                                VCHI_FLAGS_T flags)
{
  return _swix(VCHIQ_MsgDequeue,_INR(0,3)|_OUT(2),handle,data,max_data_size_to_read,flags,actual_msg_size);
}

static inline _kernel_oserror *vchi_msg_queue(VCHI_SERVICE_HANDLE_T handle,
                                              void *data,
                                              uint32_t data_size,
                                              VCHI_FLAGS_T flags,
                                              void *msg_handle)
{
  return _swix(VCHIQ_MsgQueue,_INR(0,4),handle,data,data_size,flags,msg_handle);
}

static inline _kernel_oserror *vchi_msg_queuev(VCHI_SERVICE_HANDLE_T handle,
                                               VCHI_MSG_VECTOR_T *vector,
                                               uint32_t count,
                                               VCHI_FLAGS_T flags,
                                               void *msg_handle)
{
  return _swix(VCHIQ_MsgQueueV,_INR(0,4),handle,vector,count,flags,msg_handle);
}

static inline _kernel_oserror *vchi_msg_peek(VCHI_SERVICE_HANDLE_T handle,
                                             void **data,
                                             uint32_t *msg_size,
                                             VCHI_FLAGS_T flags)
{
  return _swix(VCHIQ_MsgPeek,_INR(0,1)|_OUTR(0,1),handle,flags,data,msg_size);
}

static inline _kernel_oserror *vchi_msg_remove(VCHI_SERVICE_HANDLE_T handle)
{
  return _swix(VCHIQ_MsgRemove,_IN(0),handle);
}

static inline _kernel_oserror *vchi_service_close(VCHI_SERVICE_HANDLE_T handle)
{
  return _swix(VCHIQ_ServiceClose,_IN(0),handle);
}

static inline _kernel_oserror *vchi_service_open(VCHI_INSTANCE_T instance,
                                                 SERVICE_CREATION_T *setup,
                                                 VCHI_SERVICE_HANDLE_T *handle)
{
  return _swix(VCHIQ_ServiceOpen,_INR(0,1)|_OUT(0),instance,setup,handle);
}

static inline _kernel_oserror *vchi_service_create(VCHI_INSTANCE_T instance,
                                                   SERVICE_CREATION_T *setup,
                                                   VCHI_SERVICE_HANDLE_T *handle)
{
  return _swix(VCHIQ_ServiceCreate,_INR(0,1)|_OUT(0),instance,setup,handle);
}

static inline _kernel_oserror *vchi_service_destroy(VCHI_SERVICE_HANDLE_T handle)
{
  return _swix(VCHIQ_ServiceDestroy,_IN(0),handle);
}

static inline _kernel_oserror *vchi_service_use(VCHI_SERVICE_HANDLE_T handle)
{
  return _swix(VCHIQ_ServiceUse,_IN(0),handle);
}

static inline _kernel_oserror *vchi_service_release(VCHI_SERVICE_HANDLE_T handle)
{
  return _swix(VCHIQ_ServiceRelease,_IN(0),handle);
}

#endif
