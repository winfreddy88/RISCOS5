; Copyright 2001 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
; 		Copyright 1996 Acorn Network Computing
;
;  This material is the confidential trade secret and proprietary
;  information of Acorn Network Computing. It may not be reproduced,
;  used, sold, or transferred to any third party without the prior
;  written consent of Acorn Network Computing. All rights reserved.
;
;

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; DeviceFS declarations
host_name     = "PHCI", 0
                ALIGN

host_block      & host_name  - host_block
                & DeviceFlag_BufferedDevice + DeviceFlag_DefinePathVariable
                & 8                             ; default RX buffer flags
                & 1024                          ; default RX buffer size
                & 8                             ; default TX buffer flags
                & 4096                          ; default TX buffer size
                & 0                             ; reserved field (must be zero)

                & 0                             ; end of table

                ALIGN



; endpoint structure
                    ^ 0, r2
ep_next             # 4 ; \ link the structures together
ep_prev             # 4 ; /
ep_devicefs         # 4
ep_fileswitch       # 4
ep_buffer           # 4
ep_buffer_priv      # 4
ep_buffer_size      # 4
ep_usb_endpoint     # 1 ; \ a USB descriptor
ep_usb_attributes   # 1 ;    for the endpoint
ep_usb_maxpacket    # 2 ;
ep_usb_interval     # 1 ; /
ep_interval_count   # 1
ep_errorcount       # 2 ; 1 bytes to space it out.
ep_scratch          # 4 ; used by control transfers to store setup
ep_scratch2         # 4
ep_ptd_header0      # 1 ; Actual bytes [7:0]
ep_ptd_header1      # 1 ; Completion code [3:0], Active, Toggle, Actual bytes [8:9]
ep_ptd_header2      # 1 ; Max packet size [7:0]
ep_ptd_header3      # 1 ; Endpoint number [3:0], Last, Speed, Max packet size [9:8]
ep_ptd_header4      # 1 ; Total bytes [7:0]
ep_ptd_header5      # 1 ; reserved [4 bits], Direction PID [1:0] (SETUP,OUT,IN), Total bytes [9:8]
ep_ptd_header6      # 1 ; Format, Function address [6:0]
ep_ptd_header7      # 1 ; reserved
ep_ptd_chain        # 4 ; link contents of payload together so we know what to scan when parsing.
ep_state            # 4 ; used by control transfers to store state
ep_pollword         # 4 ; used by control transfers to signify end of transfer (inverse completion code)
ep_workspace        * :INDEX:@

ep_state_setup      * 1
ep_state_data       * 2
ep_state_ack        * 3


; Macros for manipulating fields from payload descriptors

; Read the actual bytes field (lower word)
                MACRO
$label          LDRActualBytes $rd, $rn
$label          MOV     $rd, $rn, LSL#22
                MOV     $rd, $rd, LSR#22
                MEND

; Read max packet size (lower word)
                MACRO
$label          LDRMaxPacket    $rd, $rn
$label          MOV     $rd, $rn, LSL#6
                MOV     $rd, $rd, LSR#22
                MEND

; Write total bytes (upper word), assumes less than 1024
                MACRO
$label          STRTotalBytes   $rd, $rn
$label          MOV     $rn, $rn, LSR#10
                MOV     $rn, $rn, LSL#10
                ORR     $rn, $rn , $rd
                MEND

; Read total bytes (upper word), assumes less than 1024
                MACRO
$label          LDRTotalBytes   $rd, $rn
$label          MOV     $rd, $rn, LSL#22
                MOV     $rd, $rd, LSR#22
                MEND

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; register device
;
; in  : r11 port workspace pointer
;
register_device Entry "r0-r7"
		CMP	r11, #0                         ; clears V
		EXIT	EQ

; have we already been registered
		LDR	r0, Flags
		TST	r0, #flag_Registered
		EXIT	NE

                MOV     r0, #ParentFlag_FullDuplex :OR: ParentFlag_MonitorTransfers :OR: ParentFlag_DeviceUpcalls
		ADR	r1, host_block
                ADDR    r2, handle_host_call    	; -> handler
                MOV     r3, r11				; passed in as r8
                MOV     r4, wp                         	; -> workspace
                ADRL    r5, device_validation           ; validation
                MOV     r6, #127			; max RX stream
                MOV     r7, #127                        ; max TX stream
                SWI     XDeviceFS_Register
                STRVS   r0, [sp]
                EXIT    VS
		STR	r0, DeviceHandle

; show we are registered
		LDR	r0, Flags
		ORR	r0, r0, #flag_Registered
		STR	r0, Flags

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; deregister device
;
; in  : r11 port workspace pointer
;
deregister_device Entry "r0"
		CMP	r11, #0                         ; clears V
		EXIT	EQ

; have we been registered
		LDR	r0, Flags
		TST	r0, #flag_Registered
		EXIT	EQ

                LDR     r0, DeviceHandle
                CMP     r0, #0
                EXIT	EQ
                SWI     XDeviceFS_Deregister
                SUBS    r0, r0, r0                      ; R0=0, V cleared
                STR     r0, DeviceHandle

; show we are unregistered
		LDR	r0, Flags
		BIC	r0, r0, #flag_Registered
		STR	r0, Flags

		EXIT
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: handle_host_call
;

;
; DeviceFS will have ensured that V is clear on entry - so we don't need to
; do that.   The return address is now stacked, and the CPSR too for the
; duration of the call.
;

handle_host_call ROUT

                Push    lr
                SavePSR lr
                Push    lr
                JumpAddress lr, host_call_exit, forward       ; load return address
		MOV	r11, r8			; sort out port workspace

                Debug   devicecall, "device call: ", r0, r2

                CMP     r0, #(%20-%10)/4	; validate reason code
                ADDCC   pc, pc, r0, LSL #2 	; despatch
		B	%20
10
                B       initialise              ; 0  initialise
                B       finalise                ; 1  finalise
                B       wakeup_tx               ; 2  wake up for TX
                B       wakeup_rx               ; 3  wake up for RX
                B       sleep_rx                ; 4  sleep rx
                MOV     pc, lr                  ; 5  enumerate directory
                B       create_tx_buffer        ; 6  create buffer for TX
                B       create_rx_buffer        ; 7  create buffer for RX
                B       threshold_halt          ; 8  halt - below threshold
                B       threshold_resume	; 9  resume - above threshold
                MOV     pc, lr                  ; 10 end of data
                B       stream_created		; 11 stream created
                B       monitor_tx              ; 12 monitor tx
                B       monitor_rx              ; 13 monitor rx
                MOV     pc, lr                  ; 14 IOCtl
20
                TEQ     r0, #&80000000          ; usb request
                BEQ     usb_request
                Pull    lr
                ORR     lr, lr, #V_bit
                RestPSR lr,,cf
;                ADDR    r0, ErrorBlock_Serial_BadDeviceReasonCode
                Pull    lr
                B	make_error

;		MakeErrorBlock Serial_BadDeviceReasonCode

host_call_exit
                Pull    lr
                ORRVS   lr, lr, #V_bit
                RestPSR lr,,cf
                NOP
                Pull    pc

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: decode_validation
;
; in:   r3 = flags for opening the stream : bit 0 - 0 opened for RX, 1 opened
;            for TX
;       r5 = pointer to destination for decoded USB descriptor endpoint
;       r6 = pointer to a special field control block
;
; out: r0 = usb address
;      r1 = speed (0 = full, 1 = low)
;
;      V set and r0 = error block if an error.
;
; This routine will decode the special field as given into a USB descriptor
; endpoint see 9.6.6, Table 9-13

device_validation = "address/Nendpoint/Ncontrol,isochronous,bulk,interrupt/Snosync,async,adaptive,synch/Sdata,feedback,implicit/Smaxpacket/Ninterval/Nfull,low/S",0

                    ^ 0, r6
valid_address       # 4
valid_endpoint      # 4
valid_type          # 4
valid_synch         # 4
valid_usage         # 4
valid_maxpacket     # 4
valid_interval      # 4
valid_speed         # 4

                    ^ 0, r5
usb_ep_address      # 1     ; bit 7 is direction, 0=out, 1=in
usb_ep_attributes   # 1     ; [5..4] usage (data, feedback, implicit),
                            ; [3..2] synch (none, async, adaptive, synch)
                            ; [1..0] type (control, isochronous, bulk, interrupt)
usb_ep_maxpacketlsb # 1     ; [10..0] maxpacket size
usb_ep_maxpacketmsb # 1     ; [12..11] additional transactions per µframe
usb_ep_interval     # 1

decode_validation   Entry "r2"

                Debug   devicecall, "Device validation"
                LDR     r2, =&deaddead
                ; If a value is &deaddead then make it zero
                MACRO
$label          LDValid $reg, $valid
$label          LDR     $reg, valid_$valid
                TEQ     $reg, r2
                MOVEQ   $reg, #0
                MEND

                ; Set usb endpoint address
                LDValid r0, endpoint
                TST     r3, #1
                ORREQ   r0, r0, #&80
                STRB    r0, usb_ep_address
                Debug   devicecall, "endpoint     : ", r0

                ; Set usb endpoint attributes
                LDValid r0, type
                LDValid r1, synch
                ORR     r0, r0, r1, LSL#2
                LDValid r1, usage
                ORR     r0, r0, r1, LSL#4
                STRB    r0, usb_ep_attributes
                Debug   devicecall, "atributes    : ", r0

                ; Set maxpacket (8 by default)
                LDValid r0, maxpacket
                TEQ     r0, #0
                MOVEQ   r0, #8
                STRB    r0, usb_ep_maxpacketlsb
                Debug   devicecall, "maxpacketlsb : ", r0
                MOV     r0, r0, LSR#8
                STRB    r0, usb_ep_maxpacketmsb
                Debug   devicecall, "maxpacketmsb : ", r0

                ; Set interval
                LDValid r0, interval
                STRB    r0, usb_ep_interval
                Debug   devicecall, "interval     : ", r0

                ; return address and speed
                LDValid r0, address
                Debug   devicecall, "address is   : ", r0
                LDValid r1, speed
                Debug   devicecall, "speed is     : ", r1

                EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: construct_ptd
;
; in:   r0 = usb address
;       r1 = speed (0 = full, 1 = low)
;       r2 = stream pointer
;       r5 = pointer to endpoint descriptor
;
; This routine takes a usb address, endpoint descriptor and speed,
; and constructs a philips payload descriptor.
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

construct_ptd   Entry "r0,r1,r3"

                LDRB    r1, ep_usb_attributes
                AND     r1, r1, #3
                TEQ     r1, #1                  ; if it's isochronous, set the top bit
                ORREQ   r0, r0, #&80
                STRB    r0, ep_ptd_header6
                Debug   devicecall, "Constructing PTD with address ", r0

                ; start in setup state if we're a control endpoint
                TEQ     r1, #0
                MOVEQ   r0, #1
                STREQ   r0, ep_state

                LDRB    r0, usb_ep_maxpacketlsb
                STRB    r0, ep_ptd_header2
                Debug   devicecall, "maxpacket ", r0

                LDRB    r0, usb_ep_maxpacketmsb
                LDRB    r3, usb_ep_address
                ORR     r0, r0, r3, LSL#4
                LDR     r1, [sp, #Proc_RegOffset + 1*4]
                ORR     r0, r0, r1, LSL#2
                STRB    r0, ep_ptd_header3
                Debug   devicecall, "endpoint + other bits ", r0

                MOV     r3, r3, LSR#7
                ADD     r3, r3, #1
                MOV     r3, r3, LSL#2
                STRB    r3, ep_ptd_header5

 [ debug
                LDR     r0, ep_ptd_header0
                LDR     r1, ep_ptd_header4
                Debug   devicecall, "ptd header is: ", r0, r1
 ]

                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: initialise
;
; in:   r0 = reason code
;       r2 = DeviceFS stream handle
;       r3 = flags for opening the stream : bit 0 - 0 opened for RX, 1 opened
;            for TX
;	r4 = file switch file handle
;       r6 = pointer to special field control block
;	r11 = port workspace
; out:  r2 = internal stream handle
;
; This routine is called as a stream is being opened onto the device by
; DeviceFS. It must store the relevant handles and setup the device.
;
; The special field control block will consist of a number of words each
; corresponding to the field in the device open string in the following order :
;

; If the field is not present, it will be &deaddead

initialise      Entry "r0-r5"

                ; Create new endpoint structure and zero it
                MOV     r3, #ep_workspace
                MOV     r0, #ModHandReason_Claim
                SWI     XOS_Module
                EXIT    VS

                MOV     r0, #0
10
                SUBS    r3, r3, #1
                STRNEB  r0, [r2, r3]
                BNE     %b10

                ; record handles
                LDR     r0, [sp, #Proc_RegOffset + 2*4]
                STR     r0, ep_devicefs
                STR     r4, ep_fileswitch
                Debug   devicecall, "devicefs, fileswitch: ", r0, r4

                ; set up descriptors
                LDR     r3, [sp, #Proc_RegOffset + 3*4]
                ADR     r5, ep_usb_endpoint
                BL      decode_validation
                BL      construct_ptd

                ; if this is the address of the root hub, maybe set interrupt handle
                LDR     r1, RHAddress
                LDRB    r3, ep_usb_endpoint
                TEQ     r0, r1
                TEQEQ   r3, #&81
                STREQ   r2, RHInterrupt
                DebugIf EQ, devicecall, "Root hub endpoint set to ", r2


                ; Link into chain
                ASSERT  :INDEX:EPHead              = :INDEX:EPHeadControl
                ASSERT  :INDEX:EPHeadIsochronous   = :INDEX:EPHeadControl + 4
                ASSERT  :INDEX:EPHeadBulk          = :INDEX:EPHeadIsochronous + 4
                ASSERT  :INDEX:EPHeadInterrupt     = :INDEX:EPHeadBulk + 4

                LDRB    r3, ep_usb_attributes
                AND     r3, r3, #3
                ADR     r0, EPHead
                LDR     r0, [r0, r3, LSL#2] ; load appropriate head

                BL      validate_new_endpoint
                BVC     %f20
                STR     r0, [sp, #Proc_RegOffset]
                MOV     r0, #ModHandReason_Free
                SWI     XOS_Module
                SETV
                EXIT
20
                ; link up the chain
                STR     r0, ep_next
                TEQ     r0, #0
                STRNE   r2, [r0, #:INDEX:ep_prev]
                MOV     r0, #0
                STR     r0, ep_prev
                ADR     r0, EPHead
                STR     r2, [r0, r3, LSL#2]
                STR     r2, [sp, #Proc_RegOffset + 2*4]     ; pass stream handle back to DeviceFS

		Debug	devicecall, "initialising stream: ", R2

                EXIT

; check that the current head (the new endpoint) isn't a duplicate.
; E: R2 = the head endpoint
; X: VS if it's a duplicate
validate_new_endpoint
                Entry   "R2"


                EXIT

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: finalise
;
; in:   r0 = reason code
;       r2 = device driver stream handle, or 0 for all streams
;
; out:  -
;
; This routine is called when a stream is being closed by DeviceFS. When
; received then we should halt the relevant transmission type until the stream
; is re-opened.

finalise        Entry	"r0-r5, r11"

		Debug	devicecall, "finalising stream: ", R2

                LDR     r11, BaseAddress

                TEQ     r2, #0
                BEQ     %f10

                ; If these are root hub streams, zero their handles
                LDR     r0, RHInterrupt
                TEQ     r0, r2
                BNE     %f05

                ; Turn off root hub interrupts, and zero RH int stream
                MOV     R0, #HcInterruptDisable
                MOV     R1, #OHCI_RHSC
                HCSTR   R1, R0

                MOV     r0, #0
                STR     r0, RHInterrupt
05
                ; If this is the RH control in, zero the stream
                LDR     r0, RHControlIn
                TEQ     r0, r2
                MOVEQ   r0, #0
                STREQ   r0, RHControlIn

                ; If this is the RH control out, zero the stream
                LDR     r0, RHControlOut
                TEQ     r0, r2
                MOVEQ   r0, #0
                STREQ   r0, RHControlOut

                ; Relink the chain
                LDR     r0, ep_next
                LDR     r1, ep_prev
                Debug   devicecall, "next, prev: ", r0, r1
                TEQ     r0, #0
                STRNE   r1, [r0, #:INDEX:ep_prev]
                TEQ     r1, #0
                STRNE   r0, [r1, #:INDEX:ep_next]

                ; If we were the head of a chain, reset it.
                ; Here we loop through the 4 heads, looking for a match.
                ADR     r0, EPHead
                MOV     r1, #0
07
                LDR     r3, [r0, r1, LSL#2]
                TEQ     r2, r3
                LDREQ   r3, ep_next
                STREQ   r3, [r0, r1, LSL#2]
                DebugIf EQ, devicecall, "removing head no. with ", r1, r3
                TEQNE   r1, #3
                ADDNE   r1, r1, #1
                BNE     %b07

                ; Remove the structure
                MOV     r0, #ModHandReason_Free
                SWI     XOS_Module

                EXIT

                ; Here we're removing all streams
10
                ; Turn off root hub interrupts
                MOV     R0, #HcInterruptDisable
                MOV     R1, #OHCI_RHSC
                HCSTR   R1, R0

                ; Clear root hub endpoint streams
                MOV     r0, #0
                STR     r0, RHInterrupt
                STR     r0, RHControlIn
                STR     r0, RHControlOut

                ; Free all stream structures
                ASSERT  :INDEX:EPHead              = :INDEX:EPHeadControl
                ASSERT  :INDEX:EPHeadIsochronous   = :INDEX:EPHeadControl + 4
                ASSERT  :INDEX:EPHeadBulk          = :INDEX:EPHeadIsochronous + 4
                ASSERT  :INDEX:EPHeadInterrupt     = :INDEX:EPHeadBulk + 4

                MOV     r0, #ModHandReason_Free
                ADR     r4, EPHead
                MOV     r5, #0
15
                CMP     r5, #4
                CLRV    HS
                EXIT    HS
                LDR     r2, [r4, r5, LSL#2]
20
                TEQ     r2, #0
                ADDEQ   r5, r5, #1
                BEQ     %b15
                LDR     r3, ep_next
                SWI     XOS_Module
                MOV     r2, r3
                B       %b20

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: wakeup_tx
;
; in:   r0 = reason code
;	r2 = device driver stream handle
;
; out:  r0  = 0 if driver wishes to remain dormant, else preserved
;
; This routine is called when data is ready to be transmitted. Data should
; start being passed to the device

; Must not corrupt Z

wakeup_tx       Entry	"r0"

                ; mark the endpoint as active
                PHPSEI  lr
                LDRB    r0, ep_ptd_header1
                ORR     r0, r0, #1:SHL:3
                STRB    r0, ep_ptd_header1
                PLP

                ; set the ATL pending flag
                LDR     r0, Flags
                ORR     r0, r0, #flag_ATLBufferPending
                STR     r0, Flags

 		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: wakeup_rx
;
; in:   r0 = reason code
;	r2 = device driver stream handle
;
; out:  r0  = 0 if driver wishes to remain dormant, else preserved
;
; This routine is called when data is to be received. Data should
; start read from the device

; Must not corrupt Z

wakeup_rx       Entry   "r0, r1"

10
                ; mark the endpoint as active
                PHPSEI  lr
                LDRB    r0, ep_ptd_header1
                ORR     r0, r0, #1:SHL:3
                STRB    r0, ep_ptd_header1
                PLP

                ; set the ATL pending flag
                LDR     r0, Flags
                ORR     r0, r0, #flag_ATLBufferPending
                STR     r0, Flags

                EXIT

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: sleep_rx
;
; in:   r0 = reason code
;	r2 = device driver stream handle
;
; This routine is called when data has been received. Data should
; stop being read from the device

; Must not corrupt Z

sleep_rx        Entry   "r0, r1"

                ; mark the endpoint as in active
                PHPSEI  lr
                LDRB    r0, ep_ptd_header1
                BIC     r0, r0, #1:SHL:3
                STRB    r0, ep_ptd_header1
                PLP

 		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: create_tx_buffer
;
; in:   r0  = reason code
;       r2  = device driver stream handle
;       r3  = suggested flags for buffer
;       r4  = suggested size of buffer
;       r5  = suggested handle for buffer
;       r6  = suggested threshold value
;
; out:  r3  = modified flags
;       r4  = modified buffer size
;       r5  = suggested buffer handle
;       r6  = if -1 on exit then no threshold, else set to specified value
;
; This routine is called before the buffer is actually created, it allows the
; device to change the values (ie. buffer size) and then return.  r5 should
; contain a unique buffer handle.

create_tx_buffer Entry "r0"
                MOV     r6, #256
 		EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: create_rx_buffer
;
; in:   r0  = reason code
;       r2  = device driver stream handle
;       r3  = suggested flags for buffer
;       r4  = suggested size of buffer
;       r5  = suggested handle for buffer
;       r6  = suggested threshold value
;
; out:  r3  = modified flags
;       r4  = modified buffer size
;       r5  = suggested buffer handle
;       r6  = if -1 on exit then no threshold, else set to specified value
;
; This routine is called before the buffer is actually create, it allows the
; device to change the values (ie. buffer size) and then return.  r5 should
; contain a unique buffer handle.
;
create_rx_buffer Entry
 		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: threshold_halt
;
; in:   r0 = reason code
;       r2 = device driver stream handle
;
; out:  -
;
; This routine is called when the free space in the buffer has dropped below
; the specified threshold.
;
; We have registered for halt/resume information on both streams but only
; require information here for the input buffer so check stream handles.

threshold_halt  Entry "r0-r1"
                Debug   devicecall, "below threshold"

                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: threshold_resume
;
; in:   r0 = reason code
;       r2 = device driver stream handle
;
; out:  -
;
; This routine is called when the free space in the buffer has risen above the
; specified threshold.

threshold_resume Entry	"r0-r1"
                Debug   devicecall, "above threshold"

                LDR     r0, Flags
                ORR     r0, r0, #flag_ATLBufferPending
                STR     r0, Flags

                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: stream_created
;
; in:   r0 = reason code
;       r2 = device driver stream handle
;       r3 = buffer handle
;
; out:  -
;
; This routine is called after the stream has been created, it gives me a chance
; to setup the device correctly and start transmission etc, etc...
;

stream_created  Entry	"r0-r4, r11"
		Debug	devicecall, "stream handle, buffer handle : ", r2, r3
                LDR     r11, BaseAddress

                STR     r3, ep_buffer
		MOV	r4, r2			; save stream handle
		MOV	r0, r3			; need buffer handle
		SWI	XBuffer_InternalInfo
                STRVS  	r0, [sp]
		EXIT	VS
		STR	r1, BuffManService
		STR	r2, BuffManWkSpace
                MOV     r2, r4
                STR     r0, ep_buffer_priv
                Debug   devicecall, "private handle : ", r0

                ; if the endpoint has the root hub address,
                LDRB    r0, ep_ptd_header6
                LDRB    r1, RHAddress
                TEQ     r0, r1
                BNE     %f10

                ; and is endpoint 1 (the interrupt endpoint),
                LDRB    r0, ep_ptd_header3
                MOV     r0, r0, LSR#4
                TEQ     r0, #1
                BNE     %f10

                ; turn on the root hub interrupts
                PHPSEI  lr
                HCSTRH  r1, r0
                MOV     r0, #HcInterruptEnable
                LDR     r1, =OHCI_MIE :OR: OHCI_RHSC
                HCSTR   r1, r0
                PLP     lr
10
                EXIT

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: monitor_tx/monitor_rx
;
; in:	r2 = device driver stream handle
;
; out:  return possible error

monitor_tx
monitor_rx      Entry "r0-r2"

                ; if the pollword is zero of &f there is no error
                LDR     r0, ep_pollword
                Debug   devicecall, "monitor transfer, pollword = ", r0

                RSBS    r0, r0, #&f
                TEQNE   r0, #&f
                EXIT    EQ

                SUB     sp, sp, #16
                MOV     r1, sp
                MOV     r2, #16
                SWI     XOS_ConvertCardinal1
                MOV     r1, r0
                ADRL    r0, ErrorBlock_PHCI_TransactionError
                BL      make_error1
                ADD     sp, sp, #16
                STR     r0, [sp, #Proc_RegOffset]
                EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: usb_request
;
; in:   r0 = devicefs reason code
;       r1 = driver handle, or pointer to path
;	r2 = device driver stream handle
;       r3 = request and value
;       r4 = index and length
;       r5 = pointer to data block
;
usb_request
                Entry   ,8
                Debug   devicecall, "USB request, stream ", r2

                ; Find endpoint
                MOV     r1, r2
                LDR     r2, EPHeadControl
10
                Debug   devicecall, "Looking at handle ", r2
                TEQ     r2, #0
                BNE     %f15
                ADRL    r0, ErrorBlock_PHCI_NoSuchEndpoint
                BL      make_error
                EXIT
15
                LDR     r0, ep_fileswitch
                Debug   devicecall, "fileswitch handle ", r0
                TEQ     r0, r1
                BEQ     %f20
                LDR     r2, ep_next
                B       %b10
20
                Debug   devicecall, "Internal handle ", r2
                MOV     r0, #0
                STR     r0, ep_pollword

                Debug   devicecall, "About to send request", r3, r4
                ; Insert setup into buffer
                STMIA   sp, {r3, r4}
                Push    "r2, r3"
                MOV     r0, #BufferReason_InsertBlock
                LDR     r1, ep_buffer_priv
                ADD     r2, sp, #8
                MOV     r3, #8
                CallBuffMan
                Pull    "r2, r3"

                ; If an out request, insert data into buffer
                TST     r3, #&80
                BEQ     %f30

25
                MOV     r0, #6
                ADR     r1, ep_pollword
                SWI     XOS_UpCall
                EXIT    VS
                LDR     r0, ep_pollword
                TEQ     r0, #0
                BEQ     %b25

                RSB     r0, r0, #&f
                Debug   devicecall, "Control read sequence finished, return code ", r0
                TEQ     r0, #0
                BNE     %50

                Debug   devicecall, "About to read data"
                ; Remove data from buffer
                MOV     r0, #BufferReason_RemoveBlock
                LDR     r1, ep_buffer_priv
                MOV     r2, r5
                MOV     r4, r4, LSR#16
                CallBuffMan
                EXIT
30
                Debug   devicecall, "About to send data"
                ; Insert data into buffer (if there is any)
                MOVS    r4, r4, LSR#16
                BEQ     %f35
                Push    "r2"
                MOV     r0, #BufferReason_InsertBlock
                LDR     r1, ep_buffer_priv
                MOV     r2, r5
                CallBuffMan
                Pull    "r2"
35
                LDR     r0, ep_pollword
                TEQ     r0, #0
                BNE     %f40
                MOV     r0, #6
                ADR     r1, ep_pollword
                SWI     XOS_UpCall
                EXIT    VS
                ALIGN
                B       %b35
40
                RSB     r0, r0, #&f
                Debug   devicecall, "Control write sequence finished, return code ", r0
                TEQ     r0, #0

                EXIT    EQ
50
                SUB     sp, sp, #16
                MOV     r1, sp
                MOV     r2, #16
                SWI     XOS_ConvertCardinal1
                MOV     r1, r0
                ADRL    r0, ErrorBlock_PHCI_TransactionError
                BL      make_error1
                ADD     sp, sp, #16
                EXIT


		MakeErrorBlock PHCI_NoSuchEndpoint
		MakeErrorBlock PHCI_TransactionError

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: build_atl_buffer
;
; in:   -
; out:  r0 = number of bytes written to soft atl buffer
;
; This call constructs a payload in the soft atl buffer from the current endpoint state.

build_atl_buffer

                ; macro to store the ptd header
                MACRO
                STRPTDHeader

                ; round up to nearest 4
                ANDS    r0, r6, #3
                RSBNE   r0, r0, #4
                ADD     r6, r0, r6

                Debug   atlbuffer, "Recording header at", r6
                MOV     r8, r6              ; mark current point as last packet for later
                BIC     r3, r3, #1:SHL:27   ; clear last packet bit
                MOV     r3, r3, LSR#10      ; clear actual bytes
                MOV     r3, r3, LSL#10
                ORR     r3, r3, #&f000      ; set completion code to unsent
                STMIA   r6!, {r3-r4}        ; store header into buffer
                MEND

                Entry   "r1-r8"

                ADR     r6, SoftATLBuffer
                MOV     r8, #0              ; ptd pointer for setting last bit

                Debug   atlbuffer, "Building ATL buffer at ", r6

                ; Start with no PTDs
                MOV     r0, #0
                ADR     r7, EPATLHead
                STR     r0, [r7]

                ; do interrupt queue
                LDR     r2, EPHeadInterrupt
00
                TEQ     r2, #0
                BEQ     %f99

                Debug   atlbuffer, "Examining interrupt endpoint", R2

                ; Ignore root hub endpoints
                LDRB    r0, ep_ptd_header6
                LDRB    r1, RHAddress
                TEQ     r0, r1
                BEQ     %f50

                ; Load the endpoint
                ADR     r0, ep_ptd_header0
                LDMIA   r0, {r3-r4}

                ; if there are any active interrupt endpoints then we must flag as pending
                LDR     r0, Flags
                ORR     r0, r0, #flag_ATLBufferPending
                STR     r0, Flags

                ; Take account of interval handling
                ; we must count even if there is no data ready (5.7.4)
                LDRB    r0, ep_interval_count
                SUBS    r0, r0, #1
                STRGEB  r0, ep_interval_count
                Debug   atlbuffer, "Interval now: ", r0
                BGE     %f50
                LDRB    r0, ep_usb_interval
                STRB    r0, ep_interval_count
                Debug   interrupt, "reset to ", r0

                Debug   interrupt, "Endpoint ready... ptd:", r3, r4
                ; Ignore non-active endpoints
                TST     r3, #1:SHL:11
                DebugIf EQ, interrupt, "... but not active"
                BEQ     %f50

                ; We transfer up to one maxpacket size
                LDRMaxPacket    r5, r3
                Debug   interrupt, "max packet is ", r5

                Push    "r2"
                TST     r4, #1:SHL:11                   ; test direction bit
                MOVNE   r0, #BufferReason_FreeSpace     ; If there's less free space
                MOVEQ   r0, #BufferReason_UsedSpace
                LDR     r1, ep_buffer_priv              ; than maxpacket size
                CallBuffMan

                CMP     r2, r5                          ; then use free space
                MOVLT   r5, r2
                Pull    "r2"

                TEQ     r5, #0
                DebugIf EQ, interrupt, "no data to transfer"
                BEQ     %f50

                ; Store the total bytes, and bump the pointer
                STRTotalBytes   r5, r4
                STRPTDHeader

                TST     r4, #1:SHL:11                   ; test direction bit
                ADDNE   r6, r6, r5
                BNE     %f40

                Push    "r2"
                MOV     r0, #BufferReason_ExamineBlock
                MOV     r2, r6
                MOV     r3, r5
                CallBuffMan
                MOV     r6, r2
                Pull    "r2"
40
                ; Link into PTD chain
                STR     r2, [r7]
                ADR     r7, ep_ptd_chain
                MOV     r0, #0
                STR     r0, [r7]
50
                LDR     r2, ep_next
                B       %b00
99
                ; do control queue
                LDR     r2, EPHeadControl
100
                TEQ     r2, #0
                BEQ     %f199

                Debug   atlbuffer, "Examining control endpoint", R2

                ; Load the endpoint
                ADR     r0, ep_ptd_header0
                LDMIA   r0, {r3-r4}

                ; Ignore non-active endpoints
                TST     r3, #1:SHL:11
                BEQ     %f150

                ; Depending on what phase we're in, either send the setup, the data or the ack.
                LDRB    r0, ep_state
                Debug   atlbuffer, "Control endpoint state ", r0
                ADD     pc, pc, r0, LSL#2
                B       %f150               ; never get here
                B       %f150               ; zero - shouldn't be in this state
                B       %f120               ; 1 setup
                B       %f130               ; 2 data

110             ; 3 ack - direction is opposite to initial transfer, data toggle ins 1
                Debug   atlbuffer, "Acknowledge"
                STRTotalBytes   #0, r4
                LDR     r0, ep_scratch
                TST     r0, #&80
                BIC     r4, r4, #3:SHL:10
                ORREQ   r4, r4, #2:SHL:10
                ORRNE   r4, r4, #1:SHL:10
                ORR     r3, r3, #1:SHL:10
                STRPTDHeader
                B       %f140

120             ; setup
                Debug   atlbuffer, "Setup"
                Push    "r2"
                MOV     r0, #BufferReason_UsedSpace     ; If there's less free space
                LDR     r1, ep_buffer_priv              ; than maxpacket size
                CallBuffMan
                MOV     r0, r2
                Pull    "r2"
                CMP     r0, #8
                Debug   atlbuffer, "bytes in setup: ", r0
                BLT     %f150

                ; If it's for the root hub, then handle it immediately
                LDRB    r0, ep_ptd_header6
                Debug   atlbuffer, "Sending to address", r0
                LDRB    r1, RHAddress
                TEQ     r0, r1
                BNE     %f125
                Debug   atlbuffer, "Root hub request"
                BL      root_hub_out
                MOV     r0, #&0f
                STRB    r0, ep_pollword

                LDRB    r0, ep_ptd_header1
                BIC     r0, r0, #1:SHL:3
                STRB    r0, ep_ptd_header1

;                MOV     r0, #1
;                STR     r0, ep_state
                B       %f150

125
                BIC     r4, r4, #3:SHL:10
                STRTotalBytes   #8, r4
                STRPTDHeader

                Push    "r2"
                MOV     r0, #BufferReason_ExamineBlock
                LDR     r1, ep_buffer_priv
                MOV     r2, r6
                MOV     r3, #8
                CallBuffMan
                MOV     r6, r2
                Pull    "r2"
                Debug   atlbuffer, "buffer pointer now at: ", r6

                SUBS    r6, r6, #8
                LDMIA   r6!, {r3-r4}                     ; Store set up request
                ADR     r0, ep_scratch
                STMIA   r0, {r3-r4}
                Debug   atlbuffer, "Storing request, from: ", r3, r4, r6
                B       %f140

130             ; data
                Debug   atlbuffer, "Data"
                LDR     r0, ep_scratch
                TST     r0, #&80
                BIC     r4, r4, #3:SHL:10
                ORRNE   r4, r4, #2:SHL:10
                ORREQ   r4, r4, #1:SHL:10
                Debug   atlbuffer, "request byte, ptd top word: ", r0, r4

                LDR     r5, ep_scratch2                 ; get length
                MOVS    r5, r5, LSR#16
                MOVEQ   r0, #3
                STREQ   r0, ep_state
                BEQ     %b110                           ; if zero length, just ackowledge

                Push    "r2"
                TST     r4, #1:SHL:11                   ; test direction bit
                MOVNE   r0, #BufferReason_FreeSpace     ; If there's less space
                MOVEQ   r0, #BufferReason_UsedSpace     ;
                LDR     r1, ep_buffer_priv              ; than request size
                CallBuffMan

                CMP     r2, r5                          ; then use space
                MOVLT   r5, r2
                Pull    "r2"

                ; Store the total bytes, and bump the pointer
                Debug   atlbuffer, "no. of bytes to transfer: ", r5
                STRTotalBytes   r5, r4
                STRPTDHeader

                TST     r4, #1:SHL:11                   ; test direction bit
                ADDNE   r6, r6, r5
                BNE     %f140

                Push    "r2"
                MOV     r0, #BufferReason_ExamineBlock
                MOV     r2, r6
                MOV     r3, r5
                CallBuffMan
                MOV     r6, r2
                Pull    "r2"

                B       %f140
140
                ; Link into PTD chain
                STR     r2, [r7]
                ADR     r7, ep_ptd_chain
                MOV     r0, #0
                STR     r0, [r7]
150
                LDR     r2, ep_next
                B       %b100

199
                ; do bulk queue
                LDR     r2, EPHeadBulk
200
                TEQ     r2, #0
                BEQ     %f299

                Debug   atlbuffer, "Examining bulk endpoint", R2

                ; Load the endpoint
                ADR     r0, ep_ptd_header0
                LDMIA   r0, {r3-r4}

                ; Ignore non-active endpoints
                TST     r3, #1:SHL:11
                BEQ     %f250

                ; We transfer up to four times maxpacket size
                LDRMaxPacket    r5, r3
                MOV     r5, r5, LSL#2

                Push    "r2"
                TST     r4, #1:SHL:11                   ; test direction bit
                MOVNE   r0, #BufferReason_FreeSpace     ; If there's less free space
                MOVEQ   r0, #BufferReason_UsedSpace
                LDR     r1, ep_buffer_priv              ; than maxpacket size
                CallBuffMan

                CMP     r2, r5                          ; then use free space
                MOVLT   r5, r2
                Pull    "r2"

                TEQ     r5, #0
                BEQ     %f250

                Debug   atlbuffer, "Transfer size", r5

                ; Store the total bytes, and bump the pointer
                STRTotalBytes   r5, r4
                STRPTDHeader

                TST     r4, #1:SHL:11                   ; test direction bit
 [ debug
                BNE     %f1
                Debug   atlbuffer, "OUT transfer"
                B       %f2
1
                Debug   atlbuffer, "IN transfer"
2
 ]
                ADDNE   r6, r6, r5
                BNE     %f240

                Push    "r2"
                MOV     r0, #BufferReason_ExamineBlock
                MOV     r2, r6
                MOV     r3, r5
                CallBuffMan
                MOV     r6, r2
                Pull    "r2"

240
                ; Link into PTD chain
                STR     r2, [r7]
                ADR     r7, ep_ptd_chain
                MOV     r0, #0
                STR     r0, [r7]
250
                LDR     r2, ep_next
                B     %b200

299
                MOVS    r0, r8
                EXIT    EQ


                ; round up to nearest 4
                ANDS    r0, r6, #3
                RSBNE   r0, r0, #4
                ADD     r6, r0, r6

 [ DummyLastPTD
                LDR     r0, =&08000000
                STR     r0, [r6], #4
                MOV     r0, #0
                STR     r0, [r6], #4
 |
                ; Set last bit
                LDR     r0, [r8]
                ORR     r0, r0, #1:SHL:27
                STR     r0, [r8]
 ]

                ; Compute size of transfer
                ADR     r0, SoftATLBuffer
                SUB     r0, r6, r0

                Debug   atlbuffer, "number of bytes inserted into buffer: ", r0
                Debug   interrupt, "number of bytes inserted into buffer: ", r0

                EXIT

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: parse_atl_buffer
;
; in:   -
; out:  -
;
; This call reads a completed atl buffer and updates the endpoint states
parse_atl_buffer
                Entry   "r0-r6"
                ADR     r6, SoftATLBuffer
                LDR     r2, EPATLHead
                Debug   atlbuffer, "Parsing atl buffer, starting with endpoint ", r2
10
                TEQ     r2, #0
                EXIT    EQ

                Debug   atlbuffer, "Parsing endpoint ", r2

                LDMIA   r6!, {r3, r4}
                Debug   atlbuffer, "ptd is now: ", r3, r4

                LDRActualBytes  r1, r3
                Debug   control, "bytes transferred: ", r1, r3, r4

                ; If it was a control data transfer, reduce count
                LDR     r0, ep_state
                TEQ     r0, #2
                BNE     %f12
                LDR     r0, ep_scratch2
                MOV     r0, r0, LSR#16
                SUBS    r0, r0, r1
                MOVLT   r0, #0
                MOV     r0, r0, LSL#16
                LDR     lr, ep_scratch2
                MOV     lr, lr, LSL#16
                ORR     r0, r0, lr, LSR#16
                STR     r0, ep_scratch2
                Debug   control, "number of bytes now ", r0
12
                ANDS    r0, r3, #&f000                  ; if we completed OK,
                TEQNE   r0, #&f000                      ; or are still in unset state (i.e. we NAKed)
                MOVEQ   r0, #0
                STREQB  r0, ep_errorcount               ; reset error count if completed OK.
                ORR     r3, r3, #1:SHL:11               ; then mark as still active
                BNE     %f15                            ; if there was an error, cancel ourstanding control seq.

                Debug   atlbuffer, "Completed OK"
                LDRTotalBytes   r0, r4
                TEQ     r1, r0
                BNE     %f20                             ; we didn't transfer all our load, so don't advance state
                LDR     r0, ep_state
                Debug   control, "Control state ", r0
                TEQ     r0, #0
;                BICEQ   r3, r3, #1:SHL:11               ; mark as not active if we're not a control point
                BEQ     %f20                            ; we're not a control endpoint
                ADD     r0, r0, #1
                TEQ     r0, #ep_state_ack + 1
                STRNE   r0, ep_state
                BNE     %f20                            ; we haven't finished a control seq yet
15
                MOV     r0, r3, LSL#16
                MOVS    r0, r0, LSR#28
                Debug   module, "Completed with code ", r0
                Debug   control, "Completed with code ", r0

                BEQ     %f18

                Debug   interrupt, "Interrupt transfer finished with code ", r0
 [ debug
                Push    "r0"
                LDRActualBytes  r0, r3
                Debug   interrupt, "bytes read, ptd ", r0, r3, r4
                Pull    "r0"
 ]

                ; due to a bug in the ISP1161, there is no way to distinguish between inerrupt and bulk
                ; endpoints, so an interrupt request will be repeated all throughout the frame in which
                ; is scheduled if the endpoint NAKs.  This causes some devices to break and return
                ; broken responses specifically no response and PID check failure.  We take account of
                ; this here and don't mark the endpoint as non-active
;                TEQ     r0, #0
;                BNE     %f16
;                TST     r3, #1:SHL:11
;                EOREQ   r3, r3, #1:SHL:10               ; toggle if not active
;                DebugIf EQ, module, "Toggling bit"
;                B       %f20
;
;16
;                TEQ     r0, #5                          ; these actually mean NAK
;                TEQNE   r0, #6
;                LDREQ   r3, ep_ptd_header0              ; reset ptd
;                BICEQ   r3, r3, #&ff
;                BEQ     %f20

                LDR     r1, ErrorCount
                ADD     r1, r1, #1
                STR     r1, ErrorCount

                LDRB    r1, ep_errorcount
                ADD     r1, r1, #1
                CMP     r1, #PTD_MaxErrorCount
                BGT     %f18
                STRB    r1, ep_errorcount
                EOR     r3, r3, #1:SHL:10               ; toggle
                ADR     r1, ep_ptd_header0
                B       %f20                            ; record any data transferred

18
                LDR     r1, ep_state                    ; skip next bit of not a control ep
                TEQ     r1, #0
                BEQ     %f19

                MOV     r1, #1                          ; move to setup, and flush buffer
                STR     r1, ep_state

                TEQ     r0, #0
                BEQ     %f19
                Push    "r0"
                MOV     r0, #BufferReason_PurgeBuffer
                LDR     r1, ep_buffer_priv
                CallBuffMan
                Pull    "r0"
                Debug   control, "purging control buffer - error overrun"
19
                RSB     r0, r0, #&0f
                STR     r0, ep_pollword

                BIC     r3, r3, #1:SHL:11               ; Mark as non active
20
;                TST     r3, #1:SHL:11
;                EOREQ   r3, r3, #1:SHL:10               ; toggle if not active
 [ debug
                TST     r3, #1:SHL:11
                DebugIf EQ, interrupt, "toggle 0"
                DebugIf NE, interrupt, "toggle 1"
 ]
                Debug   interrupt, "transfer finished , ptd, ", r3, r4
                LDR     r1, ep_ptd_header0
;                TST     r1, #1:SHL:11
;                BICEQ   r3, r3, #1:SHL:11               ; mark as not active if marked as such in endpoint structure

                ADR     r0, ep_ptd_header0
                STMIA   r0, {r3, r4}

                Push    "r2, r3"
                TST     r4, #1:SHL:11                   ; test direction bit
                MOVNE   r0, #BufferReason_InsertBlock
                MOVEQ   r0, #BufferReason_NextBlock
                LDR     r1, ep_buffer_priv
                MOV     r2, r6
                LDRActualBytes  r3, r3
                TEQ     r3, #0
                Debug   atlbuffer, "bytes read: ", r3
                BEQ     %f30
                CallBuffMan
30
                Pull    "r2, r3"

200
                MOV     r5, r4, LSL#22                  ; bump r6 by total bytes
                MOV     r5, r5, LSR#22
                TST     r5, #3
                BIC     r5, r5, #3
                ADDNE   r5, r5, #4
                ADD     r6, r6, r5

                LDR     r2, ep_ptd_chain
                B       %b10


		END

