; Copyright 2001 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; Philips 1161 controller

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; module workspace
                        ^ 0, wp
Flags			# 4
BaseAddress             # 4
BuffManWkSpace          # 4	; buffer manager workspace
BuffManService          # 4     ; address of buffer manager routine
MessagesWorkspace       # 16    ; needed for messages routines
DeviceFSBlock		# 4	; address of devicefs registration block
DeviceHandle		# 4	; handle returned from DeviceFS_Register
RHInterrupt             # 4     ; root hub interrupt stream
RHControlIn             # 4     ; root hub control in  stream
RHControlOut            # 4     ; root hub control out stream
RHAddress               # 1     ; address of root hub
RHConfig                # 1     ; root hub config value
                        # 2     ; alignhash 4
EPHead                  # 0
EPHeadControl           # 4     ; head endpoint structure
EPHeadIsochronous       # 4     ; head endpoint structure
EPHeadBulk              # 4     ; head endpoint structure
EPHeadInterrupt         # 4     ; head endpoint structure
EPATLHead               # 4     ; head endpoint from last fill of ATL buffer
 [ USBDevice
DevEPHead               # 4     ; head of device endpoint structures
 ]
ClkReadyCount           # 4     ; |
HCSuspendedCount        # 4     ; |
OPR_RegCount            # 4     ; |--- counts for each type of IRQ
AllEOTIntCount          # 4     ; |
ATLIntCount             # 4     ; |
SOFITLIntCount          # 4     ; |
ErrorCount              # 4     ; |
ATLSize                 # 4     ; size of ATL buffer
ATLUsed                 # 4     ; amount of ATL buffer currently used
ITLSize                 # 4     ; size of ITL buffers
ITL0Used                # 4     ; amount of ITL buffer 0 used
ITL1Used                # 4     ; amount of ITL buffer 1 used
ATLBufferSize           # 4     ; amount of data written to ATL buffer
SoftATLBuffer           # &1000 ; soft copy of ATL buffer
workspace               * :INDEX: @

;
; bit definitions for Flags
;
flag_OwnIRQ             * 1:SHL:2  ; set => IRQ owned for device
flag_HaveMessages	* 1:SHL:3  ; set => opened messages file
flag_Registered         * 1:SHL:4  ; set => registered device
flag_ATLBufferFilled    * 1:SHL:5  ; set => there is data in the ATL buffer
flag_ATLBufferPending   * 1:SHL:6  ; set => an endpoint requires the ATL buffer
flag_Testing            * 1:SHL:7  ; set => in test mode - don't process ATL buffer in interrupts

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; standard module declarations
                AREA  |PHCI$$Code|, CODE, READONLY, PIC

                ENTRY   ; for debug aif
Module_BaseAddr
module          & 0
                & init    -module               ; => initalise routine
                & final   -module               ; => finalise routine
                & service -module               ; => service trap

                & title -module                 ; => title string
                & help  -module                 ; => help string
                & command_table-module		; => command table

                & &80000
;                & swi_handler-module
                & 0
                & swi_table-module
 [ :LNOT: No32bitCode
                & 0
                & 0
                & moduleflags - module          ; => module flags
 ]

swi_table
title           = "PHCIDriver", 0
                = "Request", 0, 0

help            = "PHCIDriver", 9, 9, "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
                = " $Module_MinorVersion"
 ]
 [ debug
                = " (Debug on)", 0
 ]
                = 0

                ALIGN
command_table
 [ test
                Command PHCIRegs,       0, 0, 0
                Command PHCIWrite,      2, 2, 0
                Command PHCIRead,       1, 1, 0
                Command PHCITest,       2, 0, 0
                Command PHCIReadATL,    1, 0, 0
                Command PDCIWrite,      2, 2, 0
                Command PDCIRead,       1, 1, 0
                Command PHCIDevDesc,    1, 0, 0
                Command PHCIReset,      0, 0, 0
                Command PHCITestBuild,  0, 0, 0
                Command PHCIList,       0, 0, 0
 ]
                DCB 0

		ALIGN

 [ :LNOT: No32bitCode
moduleflags     DCD ModuleFlag_32bit
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Globals

resource_file = "Resources:$.Resources.PHCI.Messages", 0

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Error declarations

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This code handles the startup of the module, the routine must claim the
; required workspace and then initialise the driver.
;
init            Entry	"r7-r11"

                Debug   module, "Initialising PHCIDriver"

                MOV     r0, #ModHandReason_Claim
                LDR     r3, =workspace          ; r3  = amount of workspace

                SWI     XOS_Module
                EXIT    VS                      ; return if didn't work

                STR     r2, [wp]		; wp = r2
                MOV     wp, r2                  ; wp -> workspace

; zero the workspace
                MOV     r0, #0
10
                STR     r0, [r2], #4
                SUBS    r3, r3, #4
                BGT     %b10

 [ standalonemessages
                ADRL    r0, resource_file_block
                SWI     XResourceFS_RegisterFiles
                EXIT    VS
 ]

30
; claim the device vector
		BL 	hardware_claim
                BLVC    register_device
                EXIT    VC
; free workspace up before exit
40
;		BL	hardware_release
 [ standalonemessages
                MOV     r6, r0
                ADRL    r0, resource_file_block
                SWI     XResourceFS_DeregisterFiles
                MOV     r0, r6
 ]
                SETV
                EXIT

bad_hardware
        ADR     r0, ErrorBlock_BadHard
        MOV     r1, #0                          ;only use global message file
        MOV     r2, #0                          ;use MessageTrans buffer
        MOV     r4, #0                          ;don't substitute anything
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        B       %BT40

        MakeErrorBlock  BadHard

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		LTORG
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle module close down.
;

final           Entry	"r0-r1,r11"

                LDR     wp, [r12]               ; wp -> workspace
		BL	hardware_release
                BL      deregister_device

 [ standalonemessages
                ADRL    R0, resource_file_block
                SWI     XResourceFS_DeregisterFiles
 ]
                CLRV
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle service calls received by the module.
;
; Quickly test to see if they are of interest to use and pass on.

                ASSERT  Service_ResourceFSStarting < Service_DeviceFSStarting
                ASSERT  Service_DeviceFSStarting < Service_DeviceFSDying
servicetable    DCD     0
                DCD     serviceentry -module
 [ standalonemessages
                DCD     Service_ResourceFSStarting      ; &60
 ]
                DCD     Service_DeviceFSStarting        ; &70
                DCD     Service_DeviceFSDying           ; &71
                DCD     0

                DCD     servicetable -module
service         ROUT
                MOV     r0, r0
                TEQ     r1, #Service_DeviceFSStarting
                TEQNE   r1, #Service_DeviceFSDying
 [ standalonemessages
                TEQNE   r1, #Service_ResourceFSStarting
 ]
                MOVNE   pc, lr

serviceentry    LDR     wp, [r12]

20
 [ standalonemessages
                TEQ     r1, #Service_ResourceFSStarting
                BNE     %FT30					; no so continue
                Push    "r0-r3,lr"
                ADRL    r0, resource_file_block
                MOV     lr, pc
                MOV     pc, r2
                Pull    "r0-r3,pc"				; and exit
30
 ]
                TEQ     r1, #Service_DeviceFSDying
                BNE     %f40
                LDR     r0, Flags
		BIC	r0, r0, #flag_Registered
		STR	r0, Flags

                MOV     pc, lr

40
                TEQ     r1, #Service_DeviceFSStarting
                BNE     %f50
                B       register_device
50
99
                MOV  	pc, lr

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ test
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; handle the command *PHCIRegs
;
;
hc_32bit_registers
                DCD     HcRevision
                = "HcRevision           : ", 0
                DCD     HcControl
                = "HcControl            : ", 0
                DCD     HcCommandStatus
                = "HcCommandStatus      : ", 0
                DCD     HcInterruptStatus
                = "HcInterruptStatus    : ", 0
                DCD     HcInterruptEnable
                = "HcInterruptEnable    : ", 0
                DCD     HcInterruptDisable
                = "HcInterruptDisable   : ", 0
                DCD     HcFmInterval
                = "HcFmInterval         : ", 0
                DCD     HcFmRemaining
                = "HcFmRemaining        : ", 0
                DCD     HcFmNumber
                = "HcFmNumber           : ", 0
                DCD     HcLSThreshold
                = "HcLSThreshold        : ", 0
                DCD     HcRhDescriptorA
                = "HcRhDescriptorA      : ", 0
                DCD     HcRhDescriptorB
                = "HcRhDescriptorB      : ", 0
                DCD     HcRhStatus
                = "HcRhStatus           : ", 0
                DCD     HcRhPortStatus1
                = "HcRhPortStatus1      : ", 0
                DCD     HcRhPortStatus2
                = "HcRhPortStatus2      : ", 0

hc_16bit_registers
                DCD     HcHardwareConfiguration
                = "HcHardwareConfig     : ", 0
                DCD     HcDMAConfiguration
                = "HcDMAConfig          : ", 0
                DCD     HcTransferCounter
                = "HcTransferCounter    : ", 0
                DCD     HcuPInterrupt
                = "HcuPInterrupt        : ", 0
                DCD     HcuPInterruptEnable
                = "HcuPInterruptEnable  : ", 0
                DCD     HcChipID
                = "HcChipID             : ", 0
                DCD     HcScratch
                = "HcScratch            : ", 0
                DCD     HcITLBufferLength
                = "HcITLBufferLength    : ", 0
                DCD     HcATLBufferLength
                = "HcATLBufferLength    : ", 0
                DCD     HcBufferStatus
                = "HcBufferStatus       : ", 0
hc_reg_end

PHCIRegs_Help   = "*PHCIRegs reads the ISP1161s registers", 0
PHCIRegs_Syntax = "Syntax: *PHCIRegs", 0
                ALIGN
PHCIRegs_Code Entry "r1-r5"

                LDR     r12, [r12]
                LDR     r11, BaseAddress

                ADRL    r4, hc_32bit_registers
                ADRL    r3, hc_16bit_registers
                PHPSEI  r5
10
                LDR     r0, [r4], #4
                BL      show_hex2
                MOV     r1, r0
                MOV     R0, #' '
                SWI     XOS_WriteC
                MOV     r0, r4
                SWI     XOS_Write0
                MOV     r4, r0
                MOV     r0, r1
                HCLDR   r0, r0, r2
                Debug   module, "", r0
                BL      show_hex8
                SWI     XOS_NewLine
                CMP     r4, r3
                BLO     %BT10

                ADRL    r3, hc_reg_end
20
                LDR     r0, [r4], #4
                BL      show_hex2
                MOV     r1, r0
                MOV     R0, #' '
                SWI     XOS_WriteC
                MOV     r0, r4
                SWI     XOS_Write0
                MOV     r4, r0
                MOV     r0, r1
                HCLDRH  r0, r0
                BL      show_hex4
                SWI     XOS_NewLine
                CMP     r4, r3
                BLO     %BT20

                PLP     r5

                MACRO
                WRTIRQ  $irq
                SWI     XOS_WriteS
                =       "$irq : ",0
                LDR     R0, $irq.Count
                BL      show_integer
                SWI     XOS_NewLine
                MEND

                WRTIRQ  ClkReady
                WRTIRQ  HCSuspended
                WRTIRQ  OPR_Reg
                WRTIRQ  AllEOTInt
                WRTIRQ  ATLInt
                WRTIRQ  SOFITLInt
                WRTIRQ  Error

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCIWrite
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCIWrite_Help      = "Write to a register in the ISP1161 host", 13
PHCIWrite_Syntax    = "Syntax: *PHCIWrite <register> <value>", 0
                ALIGN
PHCIWrite_Code Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
                MOV     r3, r2
10
                LDRB    r0, [r1, #1]!
                TEQ     r0, #" "
                BEQ     %BT10

                MOV     r0, #&10
                SWI     XOS_ReadUnsigned
                EXIT    VS

                CMP     r3, #&20                ; use the call appropriate to the register
                BLHS    %FT20
                HCSTR   r2, r3
                EXIT
20
                HCSTRH  r2, r3
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCIRead
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCIRead_Help      = "Read a register from the ISP1161 host", 13
PHCIRead_Syntax    = "Syntax: *PHCIRead <register>", 0
                ALIGN
PHCIRead_Code Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
10
                CMP     r2, #&20                ; use the call appropriate to the register
                BLHS    %FT20
                HCLDR   r0, r2
                BL      show_hex8
                SWI     XOS_NewLine
                EXIT
20
                HCLDRH  r0, r2
                BL      show_hex4
                SWI     XOS_NewLine
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PDCIWrite
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PDCIWrite_Help      = "Write to a register in the ISP1161 device", 13
PDCIWrite_Syntax    = "Syntax: *PDCIWrite <register> <value>", 0
                ALIGN
PDCIWrite_Code Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
                MOV     r3, r2
10
                LDRB    r0, [r1, #1]!
                TEQ     r0, #" "
                BEQ     %BT10

                MOV     r0, #&10
                SWI     XOS_ReadUnsigned
                EXIT    VS

                DCSTRH  r2, r3
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PDCIRead
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PDCIRead_Help      = "Read a register in from the ISP1161 device", 13
PDCIRead_Syntax    = "Syntax: *PDCIRead <register>", 0
                ALIGN
PDCIRead_Code Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
                MOV     r3, r2

20
                HCLDRH  r0, r3
                BL      show_hex4
                SWI     XOS_NewLine

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCITest
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCITest_Help       = "Send some test data on the bus from memory, by default the internal buffer", 13
PHCITest_Syntax     = "Syntax: *PHCITest [<memory> <size>]", 0
                ALIGN
PHCITest_Code   Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress

                BL      claim_test_semaphore
                EXIT    VS

                ; Clear the EOT and ATL interrupt bit
                MOV     r3, #HcuPInterrupt
                MOV     r4, #AllEOTInt
                HCSTRH  r4, r3

                ; Allocate all RAM to the ATL buffer
                MOV     r3, #HcATLBufferLength
                MOV     r4, #&1000
                HCSTRH  r4, r3

                ; If there are no parameters, then read the internal ones
                TEQ     r1, #0
                LDREQ   r2, ATLBufferSize
                ADREQ   r3, SoftATLBuffer
                BEQ     %f15

                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                BVS     %f99
                MOV     r3, r2
10
                LDRB    r0, [r1, #1]!
                TEQ     r0, #" "
                BEQ     %BT10

                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                BVS     %f99

                ; Allocate RAM to the ATL buffer
;                MOV     r0, #HcATLBufferLength
;                HCSTRH  r2, r0
15
                Debug   module, "about to write bytes (nbytes, from): ", r2, r3
                LDR     r5, ATLIntCount

                ; Setup the transfer length
                MOV     r0, #HcTransferCounter
                HCSTRH  r2, r0

                ; Start the transfer
                MOV     r0, #HcATLBufferPort:OR:&80
                STR     r0, HCCommand

                ; Write all the data
                Push    "r2, r3"
20
                LDR     r0, [r3], #2
                STR     r0, HCData
                SUBS    r2, r2, #2
                BHI     %BT20

                ; Are interrupts enabled?
                MOV     r0, #HcuPInterruptEnable
                HCLDRH  r1, r0
                TEQ     r1, #0
                BNE     %f25

                ; If not then poll status bit after ackowledging any outstanding interrupts
                MOV     r3, #HcuPInterrupt
                MOV     r0, #&ff
                HCSTRH  r0, r3
                SWI     XOS_ReadMonotonicTime
                ADD     r2, r0, #100
                MOV     r1, #0                  ; taskwindow yield
23
                HCLDRH  r0, r3
                TST     r0, #ATLInt
                BNE     %f40
                MOV     r1, #0
                MOV     r0, #6
                SWI     XOS_UpCall
                SWI     XOS_ReadMonotonicTime
                CMP     r0, r2
                BLT     %b23
                B       %f35
25
                ; Wait for the next interrupt
                MOV     r3, r5                  ; restore saved IRQ value
                SWI     XOS_ReadMonotonicTime
                ADD     R2, R0, #100
                MOV     R1, #0                  ; taskwindow yield
30
                LDR     R4, ATLIntCount
                TEQ     R3, R4
                BNE     %f40
                MOV     R0, #6
                SWI     XOS_UpCall
                SWI     XOS_ReadMonotonicTime
                CMP     R0, R2
                BLT     %b30
35
;                Pull    "r2, r3"
                SWI     OS_WriteS
                =       "Timeout waiting for device reply",10,13,0
                ALIGN
;                BL      release_test_semaphore
;                EXIT
40
                ; Read back the data
                Pull    "r2, r3"

                ; Setup the transfer length
                MOV     r0, #HcTransferCounter
                HCSTRH  r2, r0

                ; Start the transfer
                MOV     r0, #HcATLBufferPort
                STR     r0, HCCommand
50
                LDR     r0, HCData
                STRB    r0, [r3], #1
                MOV     r0, r0, LSR#8
                STRB    r0, [r3], #1
                SUBS    r2, r2, #2
                BHI     %BT50
99
                BL      release_test_semaphore
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCIDevDesc
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCIDevDesc_Help       = "Read the device descriptor of the connected device to the memory location specified", 13
PHCIDevDesc_Syntax     = "Syntax: *PHCIDevDesc <memory>", 0
                ALIGN
PHCIDevDesc_Code   Entry "r0-r1", &14
                LDR     r12, [r12]
                LDR     r11, BaseAddress

                ; Go into test mode
                BL      claim_test_semaphore
                STRVS   r0, [sp, #Proc_RegOffset]
                EXIT    VS

                ; Ramp up FSLargest packet so that we can read low speed devices !?!?!
                MOV     r3, #HcFmInterval
                HCLDR   r4, r3
                MOV     r4, r4, LSL#16
                MOV     r4, r4, LSR#16
                ORR     r4, r4, #&20000000
                HCSTR   r4, r3

                ; Clear the EOT and ATL interrupt bit
                MOV     r3, #HcuPInterrupt
                MOV     r4, #AllEOTInt
                HCSTRH  r4, r3

                ; Turn power on
                MOV     r3, #HcRhStatus
                MOV     r4, #OHCI_LPSC
                HCSTRH  r4, r3

                ; Allocate all RAM to the ATL buffer
                MOV     r3, #HcATLBufferLength
                MOV     r4, #&1000
                HCSTRH  r4, r3

                ; If there are no arguments, then print to the screen
                TEQ     r1, #0
                BNE     %f5
                MOV     r8, sp
                B       %f7
5
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                BVS     %f99
                MOV     r8, r2                  ; save for later
7
                Debug   module, "Writing to address ", r8

                ; Wait for the next interrupt
                ADR     R1, SOFITLIntCount
                MOV     r0, #10
                BL      wait_for_interrupt
                BVS     %f99

                ; fill buffer
                ADR     r0, GetDevDesc
                MOV     r1, #16
                BL      write_atl_buffer

                ; Wait for the next interrupt
                ADR     R1, ATLIntCount
                MOV     r0, #10
                BL      wait_for_interrupt
                BVS     %f99
10
                ; fill buffer
                ADR     r0, read18
                MOV     r1, #26
                BL      write_atl_buffer

                ; Wait for interrupt
                ADR     R1, ATLIntCount
                MOV     r0, #10
                BL      wait_for_interrupt
                BVS     %f99

                ; Read header
                MOV     r0, #HcTransferCounter
                MOV     r2, #2
                HCSTRH  r2, r0

                ; Start the transfer
                PHPSEI  r6
                MOV     r0, #HcATLBufferPort
                STR     r0, HCCommand
                LDR     r0, HCData
                PLP     r6
                TST     r0, #1:SHL:11
                BNE     %b10

                ; Read back the data
                PHPSEI  r6

                ; Setup the transfer length
                MOV     r0, #HcTransferCounter
                MOV     r2, #26
                HCSTRH  r2, r0

                ; Start the transfer
                MOV     r0, #HcATLBufferPort
                STR     r0, HCCommand

                ; Read out header
                LDR     r0, HCData
                LDR     r0, HCData
                LDR     r0, HCData
                LDR     r0, HCData

                ; Read back data
                MOV     r3, r8
                MOV     r2, #18
10
                LDR     r0, HCData
                STRB    r0, [r3], #1
                MOV     r0, r0, LSR#8
                STRB    r0, [r3], #1
                SUBS    r2, r2, #2
                BHI     %BT10
                PLP     r6

                ; Acknowledge
                ADRL    r0, acknowledge
                MOV     r1, #8
                BL      write_atl_buffer

                ; Wait for interrupt
                ADRL    R1, ATLIntCount
                MOV     r0, #10
                BL      wait_for_interrupt

99
                BL      release_test_semaphore
                DebugIf VS, module, "exit with error"

                ; If there was no memory specified, write to screen
                LDR     r1, [sp, #Proc_RegOffset + 4]
                TEQ     r1, #0
                EXIT    NE

                SWI     XOS_WriteS
                =       "Contents of device descriptor:",10,13,10,13

                MOV     r4, sp

                SWI     XOS_WriteS
                =       "USB release     : ", 0
                LDR     r0, [r4], #4
                MOV     r0, r0, LSR#16
                BL      show_hex4
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Device class    : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Device subclass : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Device protocol : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Max packet size : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Vendor          : ", 0
                LDR     r0, [r4], #2
                MOV     r0, r0, LSL#16
                MOV     r0, r0, LSR#16
                BL      show_hex4
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Product         : ", 0
                LDR     r0, [r4], #2
                MOV     r0, r0, LSL#16
                MOV     r0, r0, LSR#16
                BL      show_hex4
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Release         : ", 0
                LDR     r0, [r4], #2
                MOV     r0, r0, LSL#16
                MOV     r0, r0, LSR#16
                BL      show_hex4
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Manufacturer    : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Product         : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "Serial number   : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                SWI     XOS_WriteS
                =       "No. of configs  : ", 0
                LDRB    r0, [r4], #1
                BL      show_hex2
                SWI     OS_NewLine

                EXIT

GetDevDesc  = &00, &08, &08, &0C, &08, &00, &00, &00, &80, &06, &00, &01, &00, &00, &12, &00
read18      = &00, &0C, &08, &0C, &12, &08, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00
acknowledge = &00, &0C, &08, &0C, &00, &04, &00, &00

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCIReadATL
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCIReadATL_Help       = "Dump the contents of the ATL buffer", 13
PHCIReadATL_Syntax     = "Syntax: *PHCIReadATL [<nbytes>]", 0
                ALIGN
PHCIReadATL_Code
                Entry "r0-r7", 16 ; workspace for ConvertHex
                LDR     r12, [r12]
                LDR     r11, BaseAddress


                Debug   module, "n arguments ", r1
                Debug   module, "r0 => ", r0

                TEQ     r1, #0
                BEQ     %f10

                ; Read command line
                MOV     r1, sp
                MOV     r2, #16
                SWI     XOS_EvaluateExpression
                DebugIf VS, module, "Error evaluating"
                BVS     %f10
                TEQ     r1, #0
                Debug   module, "r1 = ", r1
                BNE     %f10

                MOV     r4, r2
                B       %f15
10
                ; Read ATL buffer size
                LDR     r4, ATLBufferSize
15
                MOV     r0, r4
                BL      show_integer
                SWI     XOS_NewLine

                PHPSEI  r6

                ; Setup the transfer length
                MOV     r0, #HcTransferCounter
                HCSTRH  r4, r0
                MOV     r5, r4

                ; Start the transfer
                MOV     r0, #HcATLBufferPort
                STR     r0, HCCommand

                ADR     R2, SoftATLBuffer
17
                LDR     R0, HCData
                STRB    R0, [R2], #1
                MOV     R0, R0, LSR#8
                STRB    R0, [R2], #1
                SUBS    R4, R4, #2
                BHI     %b17

                PLP     r6

                ; Read all the data, writing it to screen
                MOV     r4, r5
                ADR     r5, SoftATLBuffer
20
;                LDR     r0, [R5], #2
;                MOV     r0, r0, LSL#16
;                MOV     r0, r0, LSR#16
;                MOV     r1, r13
;                MOV     r2, #16
;                SWI     XOS_ConvertHex4
                LDR     r0, [R5], #4
                MOV     r1, r13
                MOV     r2, #16
                SWI     XOS_ConvertHex8
                SWIVC   XOS_Write0

                ; Put a space between each read, and a newline every 8
                SUBS    r4, r4, #4
                BLE     %FT30

                TST     r4, #&1f
                SWIEQ   XOS_NewLine
                BEQ     %BT20

                MOV     r0, #' '
                SWI     XOS_WriteC
                B       %BT20
30
                SWI     XOS_NewLine

                PLP     r6

                BL      parse_atl_buffer

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Return status info
;

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handles the PHCIReset command
;
PHCIReset_Help      = "Reset the ISP1161 safely", 13
PHCIReset_Syntax    = "Syntax: PHCIReset", 0
                ALIGN
PHCIReset_Code
                Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                PHPSEI  r4
                MOV     r0, #HcSoftwareReset:OR:&80
                STR     r0, HCCommand

                MOV     r0, #HcHardwareConfiguration
                LDR     r1, =HcHardConfReserved:OR:EOTInputPolarity:OR:DataBusWidth:OR:InterruptOutputPolarity:OR:InterruptPinEnable
                HCSTRH  r1, r0

                MOV     r0, #HcFmInterval   ; set fs largest packet - needed for low speed as well
                LDR     r1, =&20002edf
                HCSTR   r1, r0

                ; Turn on power
                MOV     r0, #HcRhStatus
                MOV     r1, #&10000
                HCSTR   r1, r0

                ; Turn HC interrupts on
                MOV     R0, #HcuPInterruptEnable
                MOV     R1, #HCAllInts
                HCSTRH  R1, R0

                PLP     r4

                ; Start the controller
                MOV     R3, #HcControl
                SWI     OS_ReadMonotonicTime
                ADD     R2, R0, #100
20
                MOV     R1, #&80
                HCSTR   R1, R3
                SWI     OS_ReadMonotonicTime
                CMP     R0, R2
                BGT     %f30
                HCLDR   R1, R3
                TEQ     R1, #&80
                BNE     %b20
30
                EXIT

                LTORG
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handles the PHCITestBuild command
;
PHCITestBuild_Help      = "Test run of an ATL buffer fill", 13
PHCITestBuild_Syntax    = "Syntax: PHCITestBuild", 0
                ALIGN
PHCITestBuild_Code
                Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress

                BL      build_atl_buffer
                STR     r0, ATLBufferSize
                TEQ     r0, #0
                BNE     %f10
                SWI     XOS_WriteS
                =       "No data to write", 10, 13, 0
                EXIT
10
                MOV     r4, r0
                SWI     XOS_WriteS
                =       "Bytes Read: ", 0
                BL      show_integer
                SWI     XOS_NewLine

                ; Read all the data, writing it to screen
                SUB     sp, sp, #8
                ADR     r6, SoftATLBuffer
20
                LDR     r0, [r6], #2
                MOV     r1, r13
                MOV     r2, #8
                SWI     XOS_ConvertHex4
                SWIVC   XOS_Write0

                ; Put a space between each read, and a newline every 8
                SUBS    r4, r4, #2
                BEQ     %FT30

                TST     r4, #&1f
                SWIEQ   XOS_NewLine
                BEQ     %BT20

                MOV     r0, #' '
                SWI     XOS_WriteC
                B       %BT20
30
                ADD     sp, sp, #8
                SWI     XOS_NewLine

                EXIT
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handles *PHCIList
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
PHCIList_Help      = "List the current set of endpoints", 13
PHCIList_Syntax    = "Syntax: PHCIList", 0
                ALIGN
PHCIList_Code   Entry
                LDR     r12, [r12]

                MACRO
                LISTEP
10
                TEQ     r2, #0
                BEQ     %FT20
                Push    "r2"
                LDR     r0, ep_fileswitch
                BL      show_hex2
                SWI     XOS_WriteI+32
                LDR     r0, ep_ptd_header0
                BL      show_hex8
                SWI     XOS_WriteI+32
                LDR     r0, ep_ptd_header4
                BL      show_hex8
                SWI     XOS_NewLine
                Pull    "r2"
                LDR     r2, ep_next
                B       %BT10
20
                MEND

                SWI     XOS_WriteS
                =       "Control:",13,10,0
                ALIGN
                LDR     r2, EPHeadControl
                LISTEP
                SWI     XOS_WriteS
                =       "Bulk:",13,10,0
                ALIGN
                LDR     r2, EPHeadBulk
                LISTEP
                SWI     XOS_WriteS
                =       "Interrupt:",13,10,0
                ALIGN
                LDR     r2, EPHeadInterrupt
                LISTEP
                LDR     r0, [sp]
                BL      show_hex8
                SWI     XOS_NewLine
;                Debug   module, "return address: ", r0

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Wait for an ATL interrupt
;
; in: -
; out:
;    V set if couldn't claim
claim_test_semaphore
                Entry   "r0,r1"
                Debuga  module, "Claiming test semaphore... "
                LDR     r0, Flags
                TST     r0, #flag_Testing
                BNE     %f10
                ORR     r0, r0, #flag_Testing
                STR     r0, Flags
                Debug   module, "OK"
                CLRV
                EXIT
10
                Debug   module, "Already claimed"
                ADR     R0, ErrorBlock_PHCI_TestSem
                BL      make_error
                STR     r0, [sp, #Proc_RegOffset]
                EXIT

                MakeErrorBlock  PHCI_TestSem

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Wait for an ATL interrupt
;
; in:  -
; out:
;    V set if already cleared

release_test_semaphore
                Entry   "r0"
                LDR     r0, Flags
                BIC     r0, r0, #flag_Testing
                STR     r0, Flags
                Debug   module, "semaphore released"
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Wait for an ATL interrupt
;
; in:
;    r0 - timeout
;    r1 - pollword (interrupt counter)
; out:
;    V set if timed out, and r0 points to error

wait_for_interrupt
                Entry   "R2,R3"
                MOV     R2, R0
                ; Wait for the next interrupt
                SWI     XOS_ReadMonotonicTime
                ADD     R2, R2, R0
                MOV     R0, #0
                STR     R0, [R1]
10
                LDR     R3, [R1]
                TEQ     R3, #0
                EXIT    NE
;                MOV     R0, #6
;                SWI     XOS_UpCall
                SWI     XOS_ReadEscapeState
                BCS     %f20
                SWI     XOS_ReadMonotonicTime
                CMP     R0, R2
                BLT     %b10

                Debug   module, "IRQ timeout"
                ADR     R0, ErrorBlock_PHCI_Timeout
                BL      make_error
                EXIT
20
                MOV     R0, #126
                SWI     XOS_Byte
                Debug   module, "IRQ Escape"
                ADR     R0, ErrorBlock_PHCI_Escape
                BL      make_error
                EXIT


                MakeErrorBlock  PHCI_Timeout
                MakeErrorBlock  PHCI_Escape

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Write a buffer to the ATL FIFO
;
; in:
;    r0 - pointer to buffer
;    r1 - number of bytes
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
write_atl_buffer
                Entry   "r0-r3"
                ; Setup the transfer length
                MOV     r2, #HcTransferCounter
                HCSTRH  r1, r2

                PHPSEI  r3

                ; Start the transfer
                MOV     r2, #HcATLBufferPort:OR:&80
                STR     r2, HCCommand
10
                LDR     r2, [r0], #2
                STR     r2, HCData
                SUBS    r1, r1, #2
                BHI     %b10

                PLP     r3

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Writes an integer to the screen.
;
; in:
;    r0 - value to be displayed
show_integer	Entry "r1-r2"
        	SUB     r13, r13, #16
        	MOV     r1, r13
        	MOV     r2, #16
        	SWI     XOS_ConvertInteger4
        	SWIVC	OS_Write0
        	ADD     r13, r13, #16
        	EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 ] ; end if debug commands

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Routine to write a hex number to the screen
; in:
;    r0 - value to be displayed
        MACRO
$label  SHOW_HEX    $n
$label  Entry   "r0-r2", 16
        MOV     r1, r13
        MOV     r2, #16
        SWI     XOS_ConvertHex$n
        SWIVC	OS_Write0
        EXIT
        MEND

show_hex8 SHOW_HEX  8
show_hex4 SHOW_HEX  4
show_hex2 SHOW_HEX  2

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generalised internationalisation routines, these ensure that messages files
; are correctly opened and then return the relevant data.
;
; Attempt to open the messages file.

open_messages   Entry   "r0-r3"
                LDRB    r3, Flags
                TST     r3, #flag_HaveMessages
                EXIT    NE

                ADR     r0, MessagesWorkspace
                ADRL    r1, resource_file     ; -> path to be opened
                MOV     r2, #0                ; allocate some wacky space in RMA
                SWI     XMessageTrans_OpenFile
                LDRVCB  r3, Flags
                ORRVC   r3, r3, #flag_HaveMessages
                STRVCB  r3, Flags
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Attempt to close the messages file.

close_messages  Entry   "r0"
                LDRB    r0, Flags
                TST     r0, #flag_HaveMessages
                EXIT    EQ

                ADR     r0, MessagesWorkspace
                SWI     XMessageTrans_CloseFile
                LDRVCB  r0, Flags
                BICVC   r0, r0, #flag_HaveMessages
                STRVCB  r0, Flags
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generate an error based on the error token given.  Does not assume that
; the messages file is open.  Will attempt to open it, then look it up.
; if make_error_with_name is called, the module name is substituted in r4

make_error_with_name Entry "r1-r7"
		ADRL	r4, title
		B	make_error_entry

make_error      ALTENTRY
                MOV     r4, #0
make_error_entry
                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BLEQ    open_messages

                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BEQ     make_error_exit

                ADR     r1, MessagesWorkspace
                MOV     r2, #0
                MOV     r3, #0
                MOV     r5, #0
                MOV     r6, #0
                MOV     r7, #0
                SWI     XMessageTrans_ErrorLookup
                BL      close_messages

make_error_exit
                SETV
                EXIT                           ; return, r0 -> block, V set

make_error1     Entry   "r2-r7"
                MOV     r4, R1
                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BLEQ    open_messages

                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BEQ     make_error_exit1

                ADR     r1, MessagesWorkspace
                MOV     r2, #0
                MOV     r3, #0
                MOV     r5, #0
                MOV     r6, #0
                MOV     r7, #0
                SWI     XMessageTrans_ErrorLookup
                BL      close_messages

make_error_exit1
                SETV
                EXIT                           ; return, r0 -> block, V set

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This bit of apparently harmless code will bind a messages file into the code
; in the case of a standalone module. The macro ResourceFile will create the
; stuff and the label resource_file is used to point to the block required by
; ResourceFS

 [ standalonemessages
resource_file_block
	ResourceFile $MergedMsgs, Resources.PHCI.Messages
 [ :DEF:HardwareTest
        ! 0, "Incorporating hardware test"
        ResourceFile Test.HardwareTest, !Boot.!Run
 ]
	DCD     0
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		END
