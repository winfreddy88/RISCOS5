/*
 * Copyright (c) 2009 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jeffrey Lee (me@phlamethrower.co.uk)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef MUSBDRIVER_MUSB_H
#define MUSBDRIVER_MUSB_H

#include <stdbool.h>
#include "tps.h"

typedef unsigned char u8;
typedef signed char s8;
typedef unsigned short u16;
typedef signed short s16;
typedef unsigned int u32;
typedef signed int s32;

/*

			HARDWARE REGISTERS

*/

typedef struct {
	u8 faddr;
	u8 power;
	u16 intrtx; /* ep 0-16 transmit interrupt status */
	u16 intrrx; /* ep 0-16 receive interrupt status */
	u16 intrtxe; /* ep 0-16 transmit interrupt enable */
	u16 intrrxe; /* ep 0-16 receive interrupt enable */
	u8 intrusb; /* todo - may have to use intmsksetr/intmskclrr instead? */
	u8 intrusbe;
	u16 frame;
	u8 index; /* ep select register */
	u8 testmode;
} musb_reg_common;

#define FADDR_FUNCADDR 0x7F /* mask */
#define POWER_ENSUSPM 1
#define POWER_SUSPENDM 2
#define POWER_RESUME 4
#define POWER_RESET 8
#define POWER_HSMODE 16
#define POWER_HSEN 32
#define POWER_SOFTCONN 64
#define POWER_ISOUPDATE 128
#define INTRUSB_SUSPEND 1
#define INTRUSB_RESUME 2
#define INTRUSB_RESET_BABBLE 4
#define INTRUSB_SOF 8
#define INTRUSB_CONN 16
#define INTRUSB_DISCON 32
#define INTRUSB_SESSREQ 64
#define INTRUSB_VBUSERR 128
#define FRAME_FRAMENUMBER 0x7FF /* mask */
#define INDEX_EPSEL 0xF /* mask */
#define TESTMODE_SE0_NAK 1
#define TESTMODE_TEST_J 2
#define TESTMODE_TEST_K 4
#define TESTMODE_TEST_PACKET 8
#define TESTMODE_FORCE_HS 16
#define TESTMODE_FORCE_FS 32
#define TESTMODE_FIFO_ACCESS 64
#define TESTMODE_FORCE_HOST 128

typedef struct {
	u16 _pad1;
	u16 peri_csr0;
	u16 _pad2;
	u16 _pad3;
	u16 count0;
	u8 _pad4;
	u8 _pad5;
	u8 _pad6;
	u8 _pad7;
	u8 _pad8;
	u8 configdata;
} musb_reg_peri_ep0;

typedef struct {
	u16 _pad1;
	u16 host_csr0;
	u16 _pad2;
	u16 _pad3;
	u16 count0;
	u8 host_type0;
	u8 host_naklimit0;
	u8 _pad4;
	u8 _pad5;
	u8 _pad6;
	u8 configdata;
} musb_reg_host_ep0;

typedef struct {
	u16 txmaxp;
	u16 peri_txcsr;
	u16 rxmaxp;
	u16 peri_rxcsr;
	u16 rxcount;
	u8 _pad1;
	u8 _pad2;
	u8 _pad3;
	u8 _pad4;
	u8 _pad5;
	u8 _pad6;
} musb_reg_peri_ep1;

typedef struct {
	u16 txmaxp;
	u16 host_txcsr;
	u16 rxmaxp;
	u16 host_rxcsr;
	u16 rxcount;
	u8 host_txtype;
	u8 host_txinterval;
	u8 host_rxtype;
	u8 host_rxinterval;
	u8 _pad1;
	u8 _pad2;
} musb_reg_host_ep1;

#define TXMAXP_M 0xF800 /* mask */
#define TXMAXP_MAXPAYLOAD 0x7FF /* mask */
#define PERI_CSR0_RXPKTRDY 1
#define PERI_CSR0_TXPKTRDY 2
#define PERI_CSR0_SENTSTALL 4
#define PERI_CSR0_DATAEND 8
#define PERI_CSR0_SETUPEND 16
#define PERI_CSR0_SENDSTALL 32
#define PERI_CSR0_SERV_RXPKTRDY 64
#define PERI_CSR0_SERV_SETUPEND 128
#define PERI_CSR0_FLUSHFIFO 256
#define HOST_CSR0_RXPKTRDY 1
#define HOST_CSR0_TXPKTRDY 2
#define HOST_CSR0_RXSTALL 4
#define HOST_CSR0_SETUPPKT 8
#define HOST_CSR0_ERROR 16
#define HOST_CSR0_REQPKT 32
#define HOST_CSR0_STATUSPKT 64
#define HOST_CSR0_NAK_TIMEOUT 128
#define HOST_CSR0_FLUSHFIFO 256
#define HOST_CSR0_DATATOG 512
#define HOST_CSR0_DATATOGWREN 1024
#define PERI_TXCSR_TXPKTRDY 1
#define PERI_TXCSR_FIFONOTEMPTY 2
#define PERI_TXCSR_UNDERRUN 4
#define PERI_TXCSR_FLUSHFIFO 8
#define PERI_TXCSR_SENDSTALL 16
#define PERI_TXCSR_SENTSTALL 32
#define PERI_TXCSR_CLRDATATOG 64
#define PERI_TXCSR_DMAMODE 1024
#define PERI_TXCSR_FRCDATATOG 2048
#define PERI_TXCSR_DMAEN 4096
#define PERI_TXCSR_MODE 8192
#define PERI_TXCSR_ISO 16384
#define PERI_TXCSR_AUTOSET 32768
#define HOST_TXCSR_TXPKTRDY 1
#define HOST_TXCSR_FIFONOTEMPTY 2
#define HOST_TXCSR_ERROR 4
#define HOST_TXCSR_FLUSHFIFO 8
#define HOST_TXCSR_SETUPPKT 16
#define HOST_TXCSR_RXSTALL 32
#define HOST_TXCSR_CLRDATATOG 64
#define HOST_TXCSR_NAK_TIMEOUT 128
#define HOST_TXCSR_DATATOG 256
#define HOST_TXCSR_DATATOGWREN 512
#define HOST_TXCSR_DMAMODE 1024
#define HOST_TXCSR_FRCDATATOG 2048
#define HOST_TXCSR_DMAEN 4096
#define HOST_TXCSR_MODE 8192
#define HOST_TXCSR_AUTOSET 32768
#define RXMAXP_M 0xF800 /* mask */
#define RXMAXP_MAXPAYLOAD 0x7FF /* mask */
#define PERI_RXCSR_RXPKTRDY 1
#define PERI_RXCSR_FIFOFULL 2
#define PERI_RXCSR_OVERRUN 4
#define PERI_RXCSR_DATAERROR 8
#define PERI_RXCSR_FLUSHFIFO 16
#define PERI_RXCSR_SENDSTALL 32
#define PERI_RXCSR_SENTSTALL 64
#define PERI_RXCSR_CLRDATATOG 128
#define PERI_RXCSR_DMAMODE 2048
#define PERI_RXCSR_DISNYET 4096
#define PERI_RXCSR_DMAEN 8096
#define PERI_RXCSR_ISO 16384
#define PERI_RXCSR_AUTOCLEAR 32768
#define HOST_RXCSR_RXPKTRDY 1
#define HOST_RXCSR_FIFOFULL 2
#define HOST_RXCSR_ERROR 4
#define HOST_RXCSR_DATAERR_NAKTIMEOUT 8
#define HOST_RXCSR_FLUSHFIFO 16
#define HOST_RXCSR_REQPKT 32
#define HOST_RXCSR_RXSTALL 64
#define HOST_RXCSR_CLRDATATOG 128
#define HOST_RXCSR_DATATOG 512
#define HOST_RXCSR_DATATOGWREN 1024
#define HOST_RXCSR_DMAMODE 2048
#define HOST_RXCSR_DSINYET 4096 /* Doesn't exist in spruf98c? PIDERROR replaces it, which is read-only */
#define HOST_RXCSR_PIDERROR 4096 /* Doesn't exist in spruf98b? */
#define HOST_RXCSR_DMAEN 8192
#define HOST_RXCSR_AUTOCLEAR 32768
#define COUNT0_EP0RXCOUNT 0x7F /* mask */
#define RXCOUNT_EPRXCOUNT 0x1FFF /* mask */
#define HOST_TYPE0_SPEED 0xC0 /* mask */
#define HOST_TYPE0_SPEED_ILLEGAL 0x00
#define HOST_TYPE0_SPEED_HIGH 0x40
#define HOST_TYPE0_SPEED_FULL 0x80
#define HOST_TYPE0_SPEED_LOW 0xC0
#define HOST_TXTYPE_TENDPN 0x0F /* mask */
#define HOST_TXTYPE_PROT 0x30 /* mask */
#define HOST_TXTYPE_PROT_CONTROL 0x00
#define HOST_TXTYPE_PROT_ISO 0x10
#define HOST_TXTYPE_PROT_BULK 0x20
#define HOST_TXTYPE_PROT_INTERRUPT 0x30
#define HOST_TXTYPE_SPEED 0xC0 /* mask */
#define HOST_TXTYPE_SPEED_ILLEGAL 0x00
#define HOST_TXTYPE_SPEED_HIGH 0x40
#define HOST_TXTYPE_SPEED_FULL 0x80
#define HOST_TXTYPE_SPEED_LOW 0xC0
#define HOST_NAKLIMIT0_EP0NAKLIMIT 0x1F /* mask */
#define HOST_TXINTERVAL_POLINTVL_NAKLIMIT 0xFF /* mask */
#define HOST_RXTYPE_RENDPN 0x0F /* mask */
#define HOST_RXTYPE_PROT 0x30 /* mask */
#define HOST_RXTYPE_PROT_CONTROL 0x00
#define HOST_RXTYPE_PROT_ISO 0x10
#define HOST_RXTYPE_PROT_BULK 0x20
#define HOST_RXTYPE_PROT_INTERRUPT 0x30
#define HOST_RXTYPE_SPEED 0xC0 /* mask */
#define HOST_RXTYPE_SPEED_ILLEGAL 0x00
#define HOST_RXTYPE_SPEED_HIGH 0x40
#define HOST_RXTYPE_SPEED_FULL 0x80
#define HOST_RXTYPE_SPEED_LOW 0xC0
#define HOST_RXINTERVAL_POLINTVL_NAKLIMIT 0xFF /* mask */
#define CONFIGDATA_UTIMIDATAWIDTH 1
#define CONFIGDATA_SOFTCONE 2
#define CONFIGDATA_DYNFIFO 4
#define CONFIGDATA_HBTXE 8
#define CONFIGDATA_HBRXE 16
#define CONFIGDATA_BIGENDIAN 32
#define CONFIGDATA_MPTXE 64
#define CONFIGDATA_MPRXE 128

typedef union {
	u8 _u8;
	u16 _u16;
	u32 _u32;
} musb_fifo;

typedef struct {
	u8 txfuncaddr;
	u8 _pad1;
	u8 txhubaddr;
	u8 txhubport;
	u8 rxfuncaddr;
	u8 _pad2;
	u8 rxhubaddr;
	u8 rxhubport;
} musb_reg_target_ep_host;

#define TXFUNCADDR_FUNCADDR 0x7F /* mask */
#define TXHUBADDR_HUBADDR 0x7F /* mask */
#define TXHUBADDR_MULT_TRANS 128
#define TXHUBPORT_HUBPORT 0x7F /* mask */
#define RXFUNCADDR_FUNCADDR 0x7F /* mask */
#define RXHUBADDR_HUBADDR 0x7F /* mask */
#define RXHUBADDR_MULT_TRANS 128
#define RXHUBPORT_HUBPORT 0x7F /* mask */

typedef struct {
	u32 cntl;
	u32 addr;
	u32 count;
	u32 _pad;
} musb_reg_dma;

#define CNT_CHn_DMA_ENAB 1
#define CNT_CHn_DMA_DIR 2
#define CNT_CHn_DMAMODE 4
#define CNT_CHn_DMAIE 8
#define CNT_CHn_DMAEP 0xF0 /* mask */
#define CNT_CHn_DMAEP_SHIFT 4
#define CNT_CHn_DMA_ERR 256
#define CNT_CHn_DMA_BRSTM 0x0600 /* mask */
#define CNT_CHn_DMA_BRSTM_UNS 0x0000
#define CNT_CHn_DMA_BRSTM_INCR4 0x0200
#define CNT_CHn_DMA_BRSTM_INCR8 0x0400
#define CNT_CHn_DMA_BRSTM_INCR16 0x0600

typedef struct {
	/* Common regs */
	musb_reg_common common;
	/* Indexed regs */
	union {
	musb_reg_peri_ep0 peri_ep0;
	musb_reg_host_ep0 host_ep0;
	musb_reg_peri_ep1 peri_ep1;
	musb_reg_host_ep1 host_ep1;
	} indexed;
	/* FIFO regs */
	musb_fifo fifo[16];
	/* OTG */
	u8 devctl;
	u8 _pad1;
	/* Dynamic FIFO control (ep1+) */
	u8 txfifosz;
	u8 rxfifosz;
	u16 txfifoaddr;
	u16 rxfifoaddr;
	/* Padding bytes */
	u8 _pad3[0x70-0x68];
	/* ULPI */
	u8 ulpivbuscontrol;
	u8 ulpiutmicontrol;
	u8 ulpiintmask;
	u8 ulpiintsrc;
	u8 ulpiregdata;
	u8 ulpiregaddr;
	u8 ulpiregcontrol;
	u8 ulpirawdata;
	/* Padding bytes */
	u8 _pad4[0x80-0x78];
	/* Host mode target endpoints */
	musb_reg_target_ep_host ep_host[5];
	/* Padding bytes */
	u8 _pad5[0x100-0xa8];
	/* Endpoint control & status registers */
	union { /* Union for simpler indexing of ep0? */
	musb_reg_peri_ep0 peri_ep0;
	musb_reg_host_ep0 host_ep0;
	musb_reg_peri_ep1 peri_ep[16];
	musb_reg_host_ep1 host_ep[16];
	} csr;
	/* DMA controller registers */
	u32 dma_intr;
	musb_reg_dma dma_ch[8];
	/* Padding */
	u8 _pad6[0x300-0x284];
	/* Request packet count registers (host mode) */
	u32 rqpktcount[16]; //ep0 invalid
	/* Padding */
	u8 _pad7[0x400-0x340];
	/* OTG high-speed regs */
	u32 otg_revision;
	u32 otg_sysconfig;
	u32 otg_sysstatus;
	u32 otg_interfsel;
	u32 otg_forcestdby;
} musb_regs;

#define DEVCTL_SESSION 1
#define DEVCTL_HOSTREQ 2
#define DEVCTL_HOSTMODE 4
#define DEVCTL_VBUS 0x18 /* mask */
#define DEVCTL_VBUS_BELOW_SE 0x00
#define DEVCTL_VBUS_ABOVE_SE_BELOW_AVALID 0x08
#define DEVCTL_VBUS_ABOVE_AVALID_BELOW_VBUSVALID 0x10
#define DEVCTL_VBUS_ABOVE_VBUSVALID 0x18
#define DEVCTL_LSDEV 32
#define DEVCTL_FSDEV 64
#define DEVCTL_BDEVICE 128
#define TXFIFOSZ_SZ 0xF /* mask */
#define TXFIFOSZ_DPB 0x10
#define RXFIFOSZ_SZ 0xF /* mask */
#define RXFIFOSZ_DPB 0x10
#define TXFIFOADDR_ADDR 0x1FFF /* mask */
#define RXFIFOADDR_ADDR 0x1FFF /* mask */
#define ULPIVBUSCONTROL_USEEXTVBUS 1
#define ULPIVBUSCONTROL_USEEXTVBUSIND 2
#define ULPIUTMICONTROL_DISABLEUTMI 1
#define ULPIINTMASK_REGINTEN 1
#define ULPIREGCONTROL_ULPIREGREQ 1
#define ULPIREGCONTROL_ULPIREGCMPLT 2
#define ULPIREGCONTROL_ULPIRDNWR 4
#define OTG_REVISION 0xFF /* mask */
#define OTG_SYSCONFIG_AUTOIDLE 1
#define OTG_SYSCONFIG_SOFTRESET 2
#define OTG_SYSCONFIG_ENABLEWAKEUP 4
#define OTG_SYSCONFIG_SIDLEMODE 0x18 /* mask */
#define OTG_SYSCONFIG_SIDLEMODE_FORCE 0x00
#define OTG_SYSCONFIG_SIDLEMODE_NOIDLE 0x08
#define OTG_SYSCONFIG_SIDLEMODE_SMART 0x10
#define OTG_SYSCONFIG_MIDLEMODE 0x3000 /* mask */
#define OTG_SYSCONFIG_MIDLEMODE_FORCE 0x0000
#define OTG_SYSCONFIG_MIDLEMODE_NOSTANDBY 0x1000
#define OTG_SYSCONFIG_MIDLEMODE_SMART 0x2000
#define OTG_SYSSTATUS_RESETDONE 1
#define OTG_INTERFSEL_PHYSEL 1
#define OTG_FORCESTDBY_ENABLEFORCE 1

/*

			PERIPHERAL MODE

*/

/* EP0 state enum */
typedef enum {
	PERI_EP0_STATE_IDLE,
	PERI_EP0_STATE_TX,
	PERI_EP0_STATE_RX,
	PERI_EP0_STATE_STATUS,
	PERI_EP0_STATE_ERROR,
} PERI_EP0_STATE;

#define PERI_EP0_MAXP 64 /* Endpoint 0 max packet size (fixed in HW) */


/*

			HOST MODE

*/

/* EP0 state enum */
typedef enum {
	HOST_EP0_STATE_IDLE,
	HOST_EP0_STATE_SETUP,
	HOST_EP0_STATE_IN_DATA,
	HOST_EP0_STATE_OUT_DATA,
	HOST_EP0_STATE_IN_STATUS,
	HOST_EP0_STATE_OUT_STATUS,
} HOST_EP0_STATE;

#define HOST_EP0_MAXP 64 /* Endpoint 0 max packet size (fixed in HW) */

struct musb_xfer {
	struct usbd_xfer xfer; /* Base USBDriver struct */
};

struct musb_multiplexer;

struct musb_pipe {
	struct usbd_pipe pipe; /* Base USBDriver struct */

	/* Multiplexer vars */
	struct musb_multiplexer *multiplexer;		/* Multiplexer we belong to. Always valid, except for root hub xfers. */
	SIMPLEQ_ENTRY(musb_pipe) multiq;	/* Queue waiting for allocation by multiplexer */

	/* Pipe state */
	bool running;				/* True if this pipe is running (may not be allocated though) */
	s8 ep;					/* allocated endpoint, or -1 for none (i.e. not running or awaiting allocation) */
	bool toggle;				/* Toggle state to use for next packet */

	/* Head xfer state */
	bool null_packet;			/* True if null packet needs sending at end of head xfer */
	int remain;				/* Number of bytes remaining in xfer at head of pipe's queue */
	u8 *buf;				/* Current position in buffer. */
	int last_write;				/* How many bytes are sat in the TX FIFO (not used for control setup packets) */
};

struct musb_multiplexer {
	bool tx;				/* True for TX, false for RX */
	u16 idle_mask;				/* Mask of which endpoints are idle */
	SIMPLEQ_HEAD(, musb_pipe) waitq;	/* Queue of pipes awaiting allocation */
	u32 interval;				/* Rescheduling interval in (micro)frames. 0 for none. */
};

/*

			BUS STRUCT

*/

typedef struct musb_softc {
	struct usbd_bus sc_bus;			/* Base USBDriver struct */

	/* Hardware regs */
	volatile musb_regs *musb_base;

	/* Root hub vars */
	usbd_xfer_handle sc_intrxfer;		/* Interrupt xfer for root hub; used to notify of port status changes */
	u32 port_status;			/* Lower 16 bits: wPortStatus. Upper 16 bits: wPortChange. */
	u_int8_t sc_addr;			/* root hub device address */
	u_int8_t sc_conf;			/* root hub device configuration */
	char sc_vendor[16];		/* vendor string for root hub (doesn't get set anywhere?) */
	int sc_id_vendor;		/* vendor ID for root hub (doesn't get set anywhere?) */

	SIMPLEQ_HEAD(, usbd_xfer) sc_free_xfers; /* free xfers */

	/* peripheral mode vars */
	PERI_EP0_STATE peri_ep0_state;
	usb_device_request_t peri_ep0_req;
	/* Buffer for receiving data */
	u8 peri_ep0_rxbuf[256];
	int peri_ep0_rxbufpos;
	/* Buffer for sending data */
	u8 *peri_ep0_txbuf;
	int peri_ep0_txremain;
	int peri_addr;				/* Current address in peripheral mode */
	int peri_conf;				/* Current config in peripheral mode */
	char peri_vendor[16];			/* Vendor string in peripheral mode */
	int peri_addr_pending;			/* Nonzero when address change is pending */

	/* host mode vars */
	HOST_EP0_STATE host_ep0_state;
	/* Active pipes, null if ep inactive. */
	struct musb_pipe *host_tx[16];
	struct musb_pipe *host_rx[16];
	/* Multiplexers */
	struct musb_multiplexer mp_ep0;
	struct musb_multiplexer mp_bulktx;
	struct musb_multiplexer mp_bulkrx;
	struct musb_multiplexer mp_iitx;
	struct musb_multiplexer mp_iirx;

	/* TPS state vars */
	tps_state tps;

	/* IRQ number */
	int devno;
} musb_softc_t;


/*

			DEBUG & MISC

*/

#ifdef MUSB_DEBUG
#define DPRINTF(X) if(musbdebug) logprintf X
#define DPRINTFN(A,X) if(musbdebug>(A)) logprintf X
#define DASSERT(X) if(!(X)) musb_assert_fail(__FILE__,__LINE__,#X)
#else
#define DPRINTF(X)
#define DPRINTFN(A,X)
#define DASSERT(X)
#endif

#define WAITON(x) \
{\
	int timeout=128*1024;\
	while(x)\
	{\
		if(!(timeout--))\
		{\
			DPRINTF(("WAITON timeout! File %s Line %d Event %s (%08x)\n",__FILE__,__LINE__,#x,x));\
			break;\
		}\
	}\
}

extern int hz;
#define MS_TO_TICKS(ms) ((ms) * hz / 1000)

#define MUSB_INTR_ENDPT 1

#ifdef MUSB_DEBUG
extern int musbdebug;
extern char *musb_dump_regs(char *buf);
extern char *musb_dump_pipe(char *buf,struct musb_pipe *epipe);
extern char *musb_dump_mp(char *buf,const char *name,struct musb_multiplexer *mp);
extern char *musb_dump_state(char *buf);
extern void musb_assert_fail(const char *file,int line,const char *reason);
#endif

/* There seem to be serious problems with the USB controller (or at least the version used in the BB rev C2) when it comes to handling NAK timeouts. Specifically the method described in the manual for clearing the timeout condition doesn't work, and the methods which do work aren't particularly convenient or reliable. So for now disable all code which attempts to use NAK timeouts. */
//#define MUSB_USE_NAKTIMEOUT

#endif
