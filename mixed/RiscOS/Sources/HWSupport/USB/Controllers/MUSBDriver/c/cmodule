/* Copyright 2009 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "modhead.h"
#include "swis.h"
#include <stdlib.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <stddef.h>
#include <machine/bus.h>

#include <sys/queue.h>
#include <sys/types.h>
#include <sys/systm.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>

#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Global/HALEntries.h"
#include "Interface/USBDriver.h"
#include "callx/callx.h"
#include "cmodule.h"
#include "tboxlibint/messages.h"

/* Have to avoid including stdio as there's a clash with the BSD stuff */
#define __stdio_h

#include "DebugLib/DebugLib.h"
#include "USB/USBDevFS.h"

#include "musb.h"
#include "tps.h"
#include "musb_usb.h"

/*****************************************************************************
* Function prototypes - Private to this file
*****************************************************************************/

/* this function is generated by resgen from the resource files */
extern void* resource_files (void);

/*****************************************************************************
* Module management
*****************************************************************************/

static int* magic = NULL;
static int hal_device = -1;
static int instance = 0;
static int device_number;

void* private_word;

extern musb_softc_t musb_soft; /* Keep compiler happy (extern only used by debug code for simplicity) */
musb_softc_t musb_soft;
static struct device * usb_soft=NULL;
static volatile musb_regs *musb_base;
static bool driver_init=false;
static bool registering=false; /* True/false for whether we're in the middle of registering. Avoids nested registration attempt during ROM init. */

extern int * init_veneer (void);

static _kernel_oserror* register_bus(void *in,struct device **out)
{
    *out = NULL;
    /* Check USBDriver is new enough */
    int version;
    _kernel_oserror *e = _swix(USBDriver_Version,_OUT(0),&version);
    if(e)
        return e;
    if(version < RISCOS_USBDRIVER_API_VERSION)
    {
        return make_error (ErrorNumber_MUSB_USBTooOld, 0);
    }

    /* Now attempt to register */
    registering = true;
    e = _swix(USBDriver_RegisterBus, _INR(0,1)|_OUT(0),in,RISCOS_USBDRIVER_API_VERSION,out);
    if(e) *out = NULL;
    registering = false;
    return e;
}

void build_veneer (int* vn, int* st, size_t sz)
{
    int i;
    dprintf (("", "writing veneer from %p at %p\n", st, vn));
    int* entry_table = vn + sz / sizeof (void*);
    for (i = 0; i < sz / sizeof (void*); ++i) {
        int* entry = entry_table + 2 * i;

        /* if the method isn't implemented, don't veneer it */
        if (st[i] == NULL) continue;

        /* copy function pointer into veneer */
        vn[i] = st[i];

        /* copy new pointer into structure */
        st[i] = (int) entry;

        /* LDR ip, function[i] */
        entry[0] = 0xe51fC000       /* LDR ip, [pc, #-0] */
                  + 8               /* go back to current instruction */
                  + i * 8           /* go back to beginning of veneers */
                  + sz              /* go back to beginning of struct */
                  - i * 4;          /* go to func pointer */

        /* B common */
        entry[1] = 0xea000000       /* B here + 8 */
                  | ((magic - entry - 1) & 0x00ffffff);
                                    /* branch to diff */
    }
    _swix(OS_SynchroniseCodeAreas, _INR(0,2), 1,
                                   entry_table,
                                   entry_table + 2 * (sz / sizeof (void*)) - 1);
}

static _kernel_oserror* new_instance (_kernel_swi_regs* r, void* pw, void* h)
{
    _kernel_oserror * e;

    (void) r;
    (void) pw;
    (void) h;



    /* register with the usbdriver module if it's already resident */
    dprintf (("", "Registering with USB driver\n"));
    e = register_bus(&musb_soft, &usb_soft);
    if (e)
    {
        dprintf (("", "Failed to register: %s\n", e->errmess));
    }
    else
    {
        dprintf (("", "Registering with USB driver-done\n"));
    }


    // allow enough space for name, % and number, then space, and
    // another number
    char name[sizeof Module_Title + 1 + 12 + 1 + 12];
    sprintf (name, Module_Title"%%%d %d", instance + 1, hal_device+1);
    dprintf (("", "Trying to start %s\n", name));
    e = _swix (OS_Module, _INR(0,1), 14, name);

    if (e)
    {
        dprintf (("", "Failed to start %s: %s\n", name, e->errmess));
    }

    return NULL;
}

static void init_driver(void)
{
    if(driver_init)
        return;

    memset (&musb_soft, 0, sizeof musb_soft);
    sprintf (musb_soft.sc_bus.bdev.dv_xname, "MUSB%d", instance);
    musb_soft.musb_base = musb_base;
    musb_soft.devno = device_number;

    /* todo - HAL should tell us the device that controls the PHY */
    tps_init(&musb_soft.tps,&musb_soft);

    musb_init (&musb_soft);

    _swix (OS_ClaimDeviceVector, _INR(0,4),
        device_number| (1u<<31), usb_irq_entry, private_word, 0, 0);
    _swix (OS_Hardware, _IN(0) | _INR(8,9),
        device_number, 0, EntryNo_HAL_IRQEnable);

    driver_init = true;
}

static void shutdown_driver(void)
{
    if(!driver_init)
        return;

    /* don't disable the interrupt since it is shared, the OS will disable it
       when noone is left responding */
//    _swix (OS_Hardware, _IN(0) | _INR(8,9),
//        device_number, 0, EntryNo_HAL_IRQDisable);
    callx_remove_all_callbacks ();
    callx_remove_all_callafters ();
    callx_remove_all_calleverys ();
    _swix (OS_ReleaseDeviceVector, _INR(0,4),
        device_number | (1u<<31), usb_irq_entry, private_word, 0, 0);

    tps_shutdown(&musb_soft.tps);

    /* Reset controller */
    musb_soft.musb_base->otg_sysconfig = OTG_SYSCONFIG_SOFTRESET;

    driver_init = false;
}

_kernel_oserror* module_init (const char *cmd_tail, int podule_base, void *pw)
{
    _kernel_oserror* e = NULL;

    callx_init (pw);

    /* set up debugging */
    debug_initialise (Module_Title, "", "");
    debug_set_device(DADEBUG_OUTPUT);
//    debug_set_device(PRINTF_OUTPUT);
    debug_set_unbuffered_files (TRUE);

#ifdef MUSB_DEBUG
    const char *c = getenv("musbdebug");
    musbdebug = (c?atoi(c):0);
//    musbdebug = 11;
#endif


    private_word = pw;
    instance = podule_base;


    /* if we're the first instance, then start searching from device # 0,
       otherwise the device to start searching from was passed as a string
       in the command tail */

    if (podule_base != 0)
    {
        char* endptr;
        hal_device = (int) strtol (cmd_tail, &endptr, 0);
        if (endptr == cmd_tail)
        {
            struct
            {
                int errnum;
                char errtok[8];
            } err_noreinit = { ErrorNumber_MUSB_NoReinit, "NumParm" };

            return _swix (MessageTrans_ErrorLookup, _INR(0,2),
                          &err_noreinit, 0 /* Global messages */, 0 /* Internal buffer */);
        }
    }
    else
    {
#ifndef ROM
        /* Only first instance registers the messages in ResourceFS */
        e = _swix (ResourceFS_RegisterFiles, _IN (0), resource_files ());
        if (e != NULL) return e;
#endif
    }

    e = messages_file_open (Module_MessagesFile);
    if (e) goto error_dereg;
    
    /* find the next possible controller */
    do {
        struct
        {
            int type;
            int flags;
            void *hw;
            int devno;
        } usbinfo;
        size_t usbinfolen;

        hal_device++;

        e = _swix(OS_Hardware, _INR(0,2)|_INR(8,9)|_OUT(0),
                               hal_device, &usbinfo, sizeof usbinfo,
                               0, EntryNo_HAL_USBControllerInfo,
                               &usbinfolen);
        if (!e && (usbinfolen == sizeof(usbinfo)) && (usbinfo.type == HALUSBControllerType_MUSBMHDRC))
        {
            device_number = usbinfo.devno;
            musb_base = usbinfo.hw;
            break;
        }
        if(e || !usbinfolen)
        {
            /* Reached end of list */
            e = make_error (ErrorNumber_MUSB_NoMUSB, 0);
            goto error;
        }
    } while (1);

    dprintf (("", "Found MUSB controller on device %d\n", hal_device));

    if ((magic = init_veneer ()) == NULL)
    {
        e = make_error (ErrorNumber_MUSB_ClaimVeneer, 0);
        goto error;
    }
    dprintf (("", "magic at %p", magic));

    init_driver();

    dprintf (("", "Finished module initialisation\n"));

    /* try and start a new instance to catch any more controllers on the bus */

    callx_add_callback (new_instance, 0);

    return NULL;

error:
    dprintf (("", "Failed initialisation: %s\n", e->errmess));
    messages_file_close ();
error_dereg:
#ifndef ROM
    if (podule_base == 0) _swix (ResourceFS_DeregisterFiles, _IN(0), resource_files ());
#endif
    return e;    
}

_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
    NOTUSED(podule);
    NOTUSED(fatal);
    NOTUSED(pw);
    
    if (usb_soft != NULL)
    {
        _swix (USBDriver_DeregisterBus, _IN(0), usb_soft);
        usb_soft=NULL;
    }

    shutdown_driver();

    if (magic) _swix (OS_Module, _IN(0)|_IN(2), 7, magic);

    messages_file_close ();

#ifndef ROM
    /* only remove files for last instantiation */
    if (podule == 0)
    {
        _swix (ResourceFS_DeregisterFiles, _IN(0), resource_files ());
    }
#endif
    return NULL;
}

void module_services(int service_number, _kernel_swi_regs *r, void *pw)
{
    dprintf (("", "svce %x reason %x\n",service_number,r->r[0]));
    NOTUSED(pw);
    switch (service_number)
    {
      case Service_USB:
        switch (r->r[0])
        {
           case Service_USB_USBDriverStarting:
             if ((usb_soft == NULL) && !registering)
             {
                 init_driver();
                 dprintf (("", "Registering with USB driver from svcecall\n"));
                 _kernel_oserror *e = register_bus(&musb_soft,&usb_soft);
                 if(e)
                 {
                     dprintf (("", "Failed to register: %s\n", e->errmess));
                 }
                 else
                 {
                     dprintf (("", "Registering with USB driver from svcecall-done\n"));
                 }
             }
             break;
           case Service_USB_USBDriverDying:
             dprintf (("", "Deregistering with USB driver\n"));
             /* USBDriver will do the deregistering at this point, since
                it's SWIs are not active anymore */
//             ehci_detach(&ehci_soft,0);
//             ehci_shutdown(&ehci_soft);
             usb_soft = NULL;
             shutdown_driver(); /* TODO - Would be nice if this didn't kill peripheral mode support */
             break;
           default:break;
         }
        break;
      case Service_PreReset:
        dprintf (("", "Svce prereset %x %x\n",Service_PreReset,service_number));
        shutdown_driver(); /* Should be safe to do this without deregistering the bus */
        break;
#ifndef ROM
      case Service_ResourceFSStarting:
        /* Re-register the messages */
        (*(void (*)(void *, void *, void *, void *))r->r[2]) (resource_files (), 0, 0, (void *)r->r[3]);
        break;
#endif
    }
}

#ifdef MUSB_DEBUG
_kernel_oserror *module_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
    switch (cmd_no) {
    case CMD_MUSBRegs:
        {
        /* Disable interrupts and dump everything to a buffer */
        char* buf = malloc(4096);
        int s = _kernel_irqs_disabled();
        _kernel_irqs_off();
        musb_dump_regs(buf);
        if(s==0)
        	_kernel_irqs_on();
        printf("%s",buf);
        free(buf);
        break;
        }
    case CMD_MUSBDebug:
        {
        char* ptr;
        musbdebug = (int) strtoul (arg_string, &ptr, 0);
        }
        break;
    case CMD_MUSBWrite:
        {
        int a, b;
        char* ptr;
        a = (int) strtoul (arg_string, &ptr, 16);
        b = (int) strtoul (ptr, 0, 16);
        printf ("writing %x to %x\n", b, a);
        ((char *)musb_soft.musb_base)[a] = b;
        }
        break;
    case CMD_MUSBState:
        {
        /* Disable interrupts and dump everything to a buffer */
        char* buf = malloc(32768);
        int s = _kernel_irqs_disabled();
        _kernel_irqs_off();
        musb_dump_state(buf);
        if(s==0)
        	_kernel_irqs_on();
        printf("%s",buf);
        free(buf);
        }        
    }

    return 0;

    NOTUSED(pw);
    NOTUSED(argc);
}
#endif


int usb_irq_handler(_kernel_swi_regs *r, void *pw)
{
    int ret;

    /* Prevent recursion by masking the IRQ while we handle the interrupt */
    _swix(OS_Hardware, _IN(0)|_INR(8,9), device_number, 0, EntryNo_HAL_IRQDisable);

    ret = musb_intr(&musb_soft);

    _swix(OS_Hardware, _IN(0)|_INR(8,9), device_number, 0, EntryNo_HAL_IRQEnable);

    NOTUSED(r);
    NOTUSED(pw);

    return ret;
}

/*---------------------------------------------------------------------------*/
/* RISC OS specific leaf functions                                           */
/*---------------------------------------------------------------------------*/
void riscos_irqclear(int devno)
{
    _swix(OS_Hardware, _IN(0)|_INR(8,9), devno, 0, EntryNo_HAL_IRQClear);
}

static _kernel_oserror*_riscos_abort_pipe (_kernel_swi_regs * r, void* pw, void* v)
{
    NOTUSED(r);
    NOTUSED(pw);
    musb_abort_xfer (v, USBD_TIMEOUT);
    return NULL;
}

void
riscos_abort_pipe (void* v)
{
    callx_add_callback_irqsoff (_riscos_abort_pipe, v);
}

void
riscos_cancel_abort_pipe (void* v)
{
    callx_remove_callback (_riscos_abort_pipe, v);
}

int do_iicop(iic_transfer *tran,int count)
{
    return (_swix(OS_IICOp,_INR(0,1),tran,count) == 0);
}
