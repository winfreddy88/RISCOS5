/* Copyright 2012 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "modhead.h"
#include "swis.h"
#include <stdlib.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <stddef.h>
#include <machine/bus.h>

#include <sys/queue.h>
#include <sys/types.h>
#include <sys/systm.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>

#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Global/HALEntries.h"
#include "Interface/USBDriver.h"
#include "callx/callx.h"
#include "cmodule.h"
#include "tboxlibint/messages.h"

/* Have to avoid including stdio as there's a clash with the BSD stuff */
#define __stdio_h

#include "DebugLib/DebugLib.h"
#include "USB/USBDevFS.h"

#include "dwc_common_riscos.h"
#include "dwc_os.h"
#include "dwc_otg_riscos.h"

#include "dwc/driver/dwc_otg_hcd_if.h"
#include "dwc/driver/dwc_otg_regs.h"
#include "dwc/driver/dwc_otg_fiq_fsm.h"

/*****************************************************************************
* Function prototypes - Private to this file
*****************************************************************************/

/* this function is generated by resgen from the resource files */
extern void* resource_files (void);

/*****************************************************************************
* Module management
*****************************************************************************/

void* private_word; /* Module private word ptr */
static int instance = 0; /* Module instance no. */

static int* veneer_code = NULL; /* Pointer to USBDriver call veneer code */

static int hal_device = -1; /* Index of USB device in HAL */
static int usb_device_number; /* USB IRQ number */
static void *dwc_base=NULL; /* HW registers */
static void *mphi_base=NULL; /* MPHI registers */
static int mphi_device_number; /* MPHI IRQ number */
int dma_offset; /* ARM phys addr -> DMA addr offset */

static dwc_softc_t dwc_soft; /* Bus device we register with USBDriver */
static struct device * usb_soft=NULL; /* Device handle from USBDriver */
static bool driver_init=false; /* True/false for whether DWC layer is initialised */
static bool registering=false; /* True/false for whether we're in the middle of registering. Avoids nested registration attempt during ROM init. */

#ifdef DWCDRIVER_DEBUG
int dwcdebug; /* Debug level */
#endif

bool microframe_schedule = true;

extern int * init_veneer (void);

static _kernel_oserror* register_bus(void *in,struct device **out)
{
    *out = NULL;
    /* Check USBDriver is new enough */
    int version;
    _kernel_oserror *e = _swix(USBDriver_Version,_OUT(0),&version);
    if(e)
        return e;
    if(version < RISCOS_USBDRIVER_API_VERSION)
    {
        return make_error(ErrorNumber_DWC_USBTooOld, 0);
    }

    /* Now attempt to register */
    registering = true;
    e = _swix(USBDriver_RegisterBus, _INR(0,1)|_OUT(0),in,RISCOS_USBDRIVER_API_VERSION,out);
    if(e) *out = NULL;
    registering = false;
    return e;
}

void build_veneer (int* vn, int* st, size_t sz)
{
    int i;
    dprintf (("", "writing veneer from %p at %p\n", st, vn));
    int* entry_table = vn + sz / sizeof (void*);
    for (i = 0; i < sz / sizeof (void*); ++i) {
        int* entry = entry_table + 2 * i;

        /* if the method isn't implemented, don't veneer it */
        if (st[i] == NULL) continue;

        /* copy function pointer into veneer */
        vn[i] = st[i];

        /* copy new pointer into structure */
        st[i] = (int) entry;

        /* LDR ip, function[i] */
        entry[0] = 0xe51fC000       /* LDR ip, [pc, #-0] */
                  + 8               /* go back to current instruction */
                  + i * 8           /* go back to beginning of veneers */
                  + sz              /* go back to beginning of struct */
                  - i * 4;          /* go to func pointer */

        /* B common */
        entry[1] = 0xea000000       /* B here + 8 */
                  | ((veneer_code - entry - 1) & 0x00ffffff);
                                    /* branch to diff */
    }
    _swix(OS_SynchroniseCodeAreas, _INR(0,2), 1,
                                   entry_table,
                                   entry_table + 2 * (sz / sizeof (void*)) - 1);
}

static _kernel_oserror* new_instance (_kernel_swi_regs* r, void* pw, void* h)
{
    _kernel_oserror * e;

    (void) r;
    (void) pw;
    (void) h;


    /* register with the usbdriver module if it's already resident */
    dprintf (("", "Registering with USB driver\n"));
    e = register_bus(&dwc_soft, &usb_soft);
    if (e)
    {
        dprintf (("", "Failed to register: %s\n", e->errmess));
    }
    else
    {
        dprintf (("", "Registering with USB driver-done\n"));
    }

    // allow enough space for name, % and number, then space, and
    // another number
    char name[sizeof Module_Title + 1 + 12 + 1 + 12];
    sprintf (name, Module_Title"%%%d %d", instance + 1, hal_device+1);
    dprintf (("", "Trying to start %s\n", name));
    e = _swix (OS_Module, _INR(0,1), 14, name);

    if (e)
    {
        dprintf (("", "Failed to start %s: %s\n", name, e->errmess));
    }

    return NULL;
}

static _kernel_oserror *init_driver(void)
{
    if(driver_init)
        return NULL;

    dprintf (("", "Initialising dwc_common\n"));
    _kernel_oserror *e = dwc_common_riscos_init();
    if(e)
        return e;

    e = dwc_otg_riscos_init((const uint32_t *) dwc_base, (const uint8_t *) mphi_base, usb_device_number, mphi_device_number, &dwc_soft);
    if(e)
    {
        dwc_common_riscos_shutdown();
        return e;
    }    

    driver_init = true;

    return NULL;
}

static void shutdown_driver(void)
{
    if(!driver_init)
        return;

    dwc_otg_riscos_shutdown(&dwc_soft);

    dwc_common_riscos_shutdown();

    callx_remove_all_callbacks ();
    callx_remove_all_callafters ();
    callx_remove_all_calleverys ();

    driver_init = false;
}

_kernel_oserror* module_init (const char *cmd_tail, int podule_base, void *pw)
{
    _kernel_oserror* e = 0;

    callx_init (pw);

    /* set up debugging */
    debug_initialise (Module_Title, "", "");
    debug_set_device(DADEBUG_OUTPUT);
    debug_set_unbuffered_files (TRUE);

#ifdef DWCDRIVER_DEBUG
    const char *c = getenv("dwcdebug");
    dwcdebug = (c?atoi(c):0);
#endif


    private_word = pw;
    instance = podule_base;


    /* if we're the first instance, then start searching from device # 0,
       otherwise the device to start searching from was passed as a string
       in the command tail */

    if (podule_base != 0)
    {
        char* endptr;
        hal_device = (int) strtol (cmd_tail, &endptr, 0);
        if (endptr == cmd_tail)
        {
            struct
            {
                int errnum;
                char errtok[8];
            } err_noreinit = { ErrorNumber_DWC_NoReinit, "NumParm" };

            return _swix (MessageTrans_ErrorLookup, _INR(0,2),
                          &err_noreinit, 0 /* Global messages */, 0 /* Internal buffer */);
        }
    }
    else
    {
#ifndef ROM
        /* Only first instance registers the messages in ResourceFS */
        e = _swix (ResourceFS_RegisterFiles, _IN (0), resource_files ());
        if (e != NULL) return e;
#endif
    }

    e = messages_file_open (Module_MessagesFile);
    if (e) goto error_dereg;

    /* find the next possible controller */
    do {
        struct
        {
            int type;
            int flags;
            void *hw;
            int devno;
            int dmaoffset;
            void *hw_mphi;
            int devno_mphi;
        } usbinfo;
        size_t usbinfolen;

        hal_device++;

        e = _swix(OS_Hardware, _INR(0,2)|_INR(8,9)|_OUT(0),
                               hal_device, &usbinfo, sizeof usbinfo,
                               0, EntryNo_HAL_USBControllerInfo,
                               &usbinfolen);
        if (!e && (usbinfolen == sizeof(usbinfo)) && usbinfo.type == HALUSBControllerType_SynopsysDWC)
        {
            usb_device_number = usbinfo.devno;
            dwc_base = usbinfo.hw;
            dma_offset = usbinfo.dmaoffset;
            mphi_base = usbinfo.hw_mphi;
            mphi_device_number = usbinfo.devno_mphi;
            break;
        }
        if(e || !usbinfolen)
        {
            /* Reached end of list */
            e = make_error (ErrorNumber_DWC_NoDWC, 0);
            goto error;
        }
    } while (1);

    dprintf (("", "Found DWC controller at %08x IRQ %d on device %d\n", dwc_base, usb_device_number, hal_device));

    if ((veneer_code = init_veneer ()) == NULL)
    {
        e = make_error (ErrorNumber_DWC_ClaimVeneer, 0);
        goto error;
    }
    dprintf (("", "veneer_code at %p\n", veneer_code));

    e = init_driver();

    if(e)
    {
        dprintf (("", "Failed to initialise driver: %s\n", e->errmess));
        return e;
    }

    dprintf (("", "Finished module initialisation\n"));

    /* try and start a new instance to catch any more controllers on the bus */

    callx_add_callback (new_instance, 0);

    return NULL;

error:
    dprintf (("", "Failed initialisation: %s\n", e->errmess));
    messages_file_close ();
error_dereg:
#ifndef ROM
    if (podule_base == 0) _swix (ResourceFS_DeregisterFiles, _IN(0), resource_files ());
#endif
    return e;    
}

_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
    NOTUSED(podule);
    NOTUSED(fatal);
    NOTUSED(pw);
    
    if (usb_soft != NULL)
    {
        _swix (USBDriver_DeregisterBus, _IN(0), usb_soft);
        usb_soft=NULL;
    }

    shutdown_driver();

    if (veneer_code) _swix (OS_Module, _IN(0)|_IN(2), 7, veneer_code);

    messages_file_close ();

#ifndef ROM
    /* only remove files for last instantiation */
    if (podule == 0)
    {
        _swix (ResourceFS_DeregisterFiles, _IN(0), resource_files ());
    }
#endif
    return NULL;
}

void module_services(int service_number, _kernel_swi_regs *r, void *pw)
{
    dprintf (("", "svce %x reason %x\n",service_number,r->r[0]));
    NOTUSED(pw);
    switch (service_number)
    {
      case Service_USB:
        switch (r->r[0])
        {
           case Service_USB_USBDriverStarting:
             if ((usb_soft == NULL) && !registering)
             {
                 _kernel_oserror *e = init_driver();
                 if(e)
                 {
                   dprintf (("", "Failed to init driver: %s\n", e->errmess));
                   return;
                 }
                 dprintf (("", "Registering with USB driver from svcecall\n"));
                 e = register_bus(&dwc_soft,&usb_soft);
                 if(e)
                 {
                     dprintf (("", "Failed to register: %s\n", e->errmess));
                 }
                 else
                 {
                     dprintf (("", "Registering with USB driver from svcecall-done\n"));
                 }
             }
             break;
           case Service_USB_USBDriverDead:
             dprintf (("", "USB driver is dead, shutting down\n"));
             usb_soft = NULL;
             shutdown_driver();
             break;
           default:
             break;
         }
        break;
      case Service_PreReset:
        dprintf (("", "Svce prereset %x %x\n",Service_PreReset,service_number));
        if (usb_soft != NULL)
        {
            _swix (USBDriver_DeregisterBus, _IN(0), usb_soft);
            usb_soft=NULL;
        }
        shutdown_driver();
        break;
      case Service_ClaimFIQ:
        if(own_fiq_vector)
        {
          /* Someone is kicking us off the FIQ vector. How rude. */
          dprintf(("","Service_ClaimFIQ\n"));
          dwc_otg_riscos_release_fiq(&dwc_soft);
          r->r[1] = Service_Serviced;
        }
        break;
      case Service_ReleaseFIQ:
        if(reclaim_fiq_vector)
        {
          dprintf(("","Service_ReleaseFIQ\n"));
          dwc_otg_riscos_try_use_fiqs(&dwc_soft,false);
          if(own_fiq_vector)
          {
            r->r[1] = Service_Serviced;
          }
        }
        break;
#ifndef ROM
      case Service_ResourceFSStarting:
        /* Re-register the messages */
        (*(void (*)(void *, void *, void *, void *))r->r[2]) (resource_files (), 0, 0, (void *)r->r[3]);
        break;
#endif
    }
}

#ifdef DWCDRIVER_DEBUG
_kernel_oserror *module_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
    switch (cmd_no) {
    case CMD_DWCDebug:
        {
        char* ptr;
        dwcdebug = (int) strtoul (arg_string, &ptr, 0);
extern uint32_t g_dbg_lvl;
        g_dbg_lvl = (int) strtoul (ptr, &ptr, 16);
        }
        break;
    }

    return 0;

    NOTUSED(pw);
    NOTUSED(argc);
}
#endif


int usb_irq_handler(_kernel_swi_regs *r, void *pw)
{
    int ret;

#ifdef RISCOS_FIQ_DOWNGRADE
    if(fiq_enable)
    {
      /* Flag to the FIQ routine that we want the IRQ to be off */
      fiq_downgrade.irq_masked = true;
    }
#endif

    /* Prevent recursion by masking the IRQ while we handle the interrupt */
    _swix(OS_Hardware, _IN(0)|_INR(8,9), dwc_soft.device_number, 0, EntryNo_HAL_IRQDisable);

    ret = dwc_otg_riscos_irq(&dwc_soft);

#ifdef RISCOS_FIQ_DOWNGRADE
    if(fiq_enable)
    {
      /* Flag to the FIQ routine that it can enable the IRQ again */
      fiq_downgrade.irq_masked = false;
      /* Re-enable the IRQ if we still have more work to do */
      if(!fiq_downgrade.fiq_trigger)
      {
        return 0;        
      }
      ret = 0;
    }
#endif

    if(!ret)
    {
      _swix(OS_Hardware, _IN(0)|_INR(8,9), dwc_soft.device_number, 0, EntryNo_HAL_IRQClear);
      _swix(OS_Hardware, _IN(0)|_INR(8,9), dwc_soft.device_number, 0, EntryNo_HAL_IRQEnable);
    }
    else
    {
      dprintf(("","******** Panic! unhandled IRQ ********\n"));
    }

    NOTUSED(r);
    NOTUSED(pw);

    return ret;
}

/*****************************************************************************/

usbd_status usb_insert_transfer(usbd_xfer_handle xfer)
{
    usbd_status status = USBD_CANCELLED; /* Should _swix() error */
    _swix (USBDriver_InsertTransfer, _IN (0) | _OUT (0), xfer, &status);
    return status;
}

void usb_transfer_complete(usbd_xfer_handle xfer)
{
    _swix (USBDriver_TransferComplete, _IN (0), xfer);
}

static _kernel_oserror*_riscos_abort_pipe (_kernel_swi_regs * r, void* pw, void* v)
{
    NOTUSED(r);
    NOTUSED(pw);
    softc_abort_xfer (v, USBD_TIMEOUT);
    return NULL;
}

void
riscos_abort_pipe (void* v)
{
    callx_add_callback_irqsoff (_riscos_abort_pipe, v);
}

void
riscos_cancel_abort_pipe (void* v)
{
    callx_remove_callback (_riscos_abort_pipe, v);
}

_kernel_oserror *endpoint_disable_cb(_kernel_swi_regs *r,void *pw,void *handle)
{
    DPRINTFN(15,("endpoint_disable_cb: %08x\n",handle));
    dwc_otg_hcd_endpoint_disable(dwc_soft.dwc_dev.hcd,handle,250);
    return NULL;
}

#ifdef DEBUGLIB
int address_valid(void *addr,int align)
{
    if(!addr || (((int)addr) & align))
        return 0;
    if(_swi(OS_ValidateAddress,_INR(0,1)|_RETURN(_FLAGS),addr,((int)addr)+1) & _C)
        return 0;
    return 1;
}
#endif
