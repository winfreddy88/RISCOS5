Various upgrades to the libpng version herein have occurred over time.
A full set of diffs is below. The upgrade to libpng release 1.0.0
occurs at around revision 1.7; diffs from that point up to HEAD show
only configuration changes for the RISC OS build.

Index: !MkClean,fd7
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/!MkClean,fd7,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
19a20,21
> Echo Stripping Makefile dependencies...
> StripDepnd Makefile
Index: CHANGES
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/CHANGES,v
retrieving revision 1.1
retrieving revision 1.4
diff -r1.1 -r1.4
1c1
< pngchange.txt - changes for libpng
---
> CHANGES - changes for libpng
246a247,273
> version 0.99f [March 5, 1998]
>    Corrected a bug in pngpread() introduced in version 99c (Kevin Bracey)
>    Moved makefiles into a "scripts" directory, and added INSTALL instruction file
>    Added makefile.os2 and pngos2.def (A. Zabolotny) and makefile.s2x (W. Sebok)
>    Added pointers to "note on libpng versions" in makefile.lnx and README
>    Added row callback feature when reading and writing nonprogressive rows
>       and added a test of this feature in pngtest.c
>    Added user transform callbacks, with test of the feature in pngtest.c
> version 0.99g [March 6, 1998, morning]
>    Minor changes to pngtest.c to suppress compiler warnings.
>    Removed "beta" language from documentation.
> version 0.99h [March 6, 1998, evening]
>    Minor changes to previous minor changes to pngtest.c 
>    Changed PNG_READ_NOT_FULLY_SUPPORTED to PNG_READ_TRANSFORMS_NOT_SUPPORTED
>    and added PNG_PROGRESSIVE_READ_NOT_SUPPORTED macro
> version 1.00 [March 7, 1998]
>    Changed several typedefs in pngrutil.c
>    Added makefile.wat (Pawel Mrochen), updated makefile.tc3 (Willem van Schaik)
>    replaced "while(1)" with "for(;;)"
>    added PNGARG() to prototypes in pngtest.c and removed some prototypes
>    updated some of the makefiles (Tom Lane)
>    changed some typedefs (s_start, etc.) in pngrutil.c
>    fixed dimensions of "short_months" array in pngwrite.c
>    Replaced ansi2knr.c with the one from jpeg-v6
> version 1.0.0 [March 8, 1998]
>    Changed name from 1.00 to 1.0.0 (Adam Costello)
>    Added smakefile.ppc (with SCOPTIONS.ppc) for Amiga PPC (Andreas Kleinert)
Index: Makefile
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/Makefile,v
retrieving revision 1.1
retrieving revision 1.8
diff -r1.1 -r1.8
25a26
> # 2001-06-13 ADH          Wipes o and z directories as well as contents.
45c46
< WIPE    = wipe
---
> WIPE    = x wipe
47c48
< CCFLAGS = -c -depend !Depend -ffah -throwback ${INCLUDES} ${DFLAGS}
---
> CCFLAGS = -c -depend !Depend -ffa -throwback ${INCLUDES} ${DFLAGS}
66,67c67,91
< INCLUDES  = -IC:,^.ZLib
< DFLAGS    = -DRISCOS
---
> INCLUDES  = -IC:,C:zlib
> 
> #
> # Symbols to predefine. Everything after the first
> # line simply strips down pnglib to the bare
> # minimum required for ImageLib. Pngtest won't
> # work with these defined...
> #
> DFLAGS    = -DRISCOS -DPNG_DEBUG=0 -DPNG_NO_STDIO\
>  -DPNG_READ_TRANSFORMS_NOT_SUPPORTED\
>  -DPNG_READ_EXPAND_SUPPORTED\
>  -DPNG_READ_PACK_SUPPORTED\
>  -DPNG_READ_PACKSWAP_SUPPORTED\
>  -DPNG_READ_16_TO_8_SUPPORTED\
>  -DPNG_READ_FILLER_SUPPORTED\
>  -DPNG_READ_GAMMA_SUPPORTED\
>  -DPNG_READ_USER_TRANSFORM_SUPPORTED\
>  -DPNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED\
>  -DPNG_READ_bKGD_SUPPORTED\
>  -DPNG_READ_gAMA_SUPPORTED\
>  -DPNG_READ_sBIT_SUPPORTED\
>  -DPNG_READ_sRGB_SUPPORTED\
>  -DPNG_READ_tRNS_SUPPORTED\
>  -DPNG_WRITE_TRANSFORMS_NOT_SUPPORTED\
>  -DPNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED
72,73c96,97
< COMPONENT  = libpng-lib
< COMPONENTZ = libpng-lzm
---
> COMPONENT  = o.libpng-lib
> COMPONENTZ = o.libpng-lzm
126c150
< all:	${COMPONENT} ${COMPONENTZ}
---
> all install:	${COMPONENT} ${COMPONENTZ}
132,133c156,157
<         ${WIPE} o.* ${WFLAGS}
<         ${WIPE} z.* ${WFLAGS}
---
>         ${WIPE} o ${WFLAGS}
>         ${WIPE} z ${WFLAGS}
144c168
<         ${LB} ${LBFLAGS} -o o.${COMPONENT} ${OBJS}
---
>         ${LB} ${LBFLAGS} -o ${COMPONENT} ${OBJS}
147c171,175
< 	${LB} ${LBFLAGS} -o o.${COMPONENTZ} ${OBJSZ}
---
> 	${LB} ${LBFLAGS} -o ${COMPONENTZ} ${OBJSZ}
> 
> pngtest: o.pngtest ${TARGET} ${CLIB} C:zlib.o.zlib
>         ${LD} -o pngtest o.pngtest ${TARGET} ${CLIB} C:zlib.o.zlib
> 
150,299d177
< o.png:	c.png
< o.png:	h.png
< o.png:	h.zlib
< o.png:	h.zconf
< o.png:	h.pngconf
< o.pngerror:	c.pngerror
< o.pngerror:	h.png
< o.pngerror:	h.zlib
< o.pngerror:	h.zconf
< o.pngerror:	h.pngconf
< o.pngget:	c.pngget
< o.pngget:	h.png
< o.pngget:	h.zlib
< o.pngget:	h.zconf
< o.pngget:	h.pngconf
< o.pngmem:	c.pngmem
< o.pngmem:	h.png
< o.pngmem:	h.zlib
< o.pngmem:	h.zconf
< o.pngmem:	h.pngconf
< o.pngpread:	c.pngpread
< o.pngpread:	h.png
< o.pngpread:	h.zlib
< o.pngpread:	h.zconf
< o.pngpread:	h.pngconf
< o.pngread:	c.pngread
< o.pngread:	h.png
< o.pngread:	h.zlib
< o.pngread:	h.zconf
< o.pngread:	h.pngconf
< o.pngrio:	c.pngrio
< o.pngrio:	h.png
< o.pngrio:	h.zlib
< o.pngrio:	h.zconf
< o.pngrio:	h.pngconf
< o.pngrtran:	c.pngrtran
< o.pngrtran:	h.png
< o.pngrtran:	h.zlib
< o.pngrtran:	h.zconf
< o.pngrtran:	h.pngconf
< o.pngrutil:	c.pngrutil
< o.pngrutil:	h.png
< o.pngrutil:	h.zlib
< o.pngrutil:	h.zconf
< o.pngrutil:	h.pngconf
< o.pngset:	c.pngset
< o.pngset:	h.png
< o.pngset:	h.zlib
< o.pngset:	h.zconf
< o.pngset:	h.pngconf
< o.pngtrans:	c.pngtrans
< o.pngtrans:	h.png
< o.pngtrans:	h.zlib
< o.pngtrans:	h.zconf
< o.pngtrans:	h.pngconf
< o.pngwio:	c.pngwio
< o.pngwio:	h.png
< o.pngwio:	h.zlib
< o.pngwio:	h.zconf
< o.pngwio:	h.pngconf
< o.pngwrite:	c.pngwrite
< o.pngwrite:	h.png
< o.pngwrite:	h.zlib
< o.pngwrite:	h.zconf
< o.pngwrite:	h.pngconf
< o.pngwtran:	c.pngwtran
< o.pngwtran:	h.png
< o.pngwtran:	h.zlib
< o.pngwtran:	h.zconf
< o.pngwtran:	h.pngconf
< o.pngwutil:	c.pngwutil
< o.pngwutil:	h.png
< o.pngwutil:	h.zlib
< o.pngwutil:	h.zconf
< o.pngwutil:	h.pngconf
< z.png:	c.png
< z.png:	h.png
< z.png:	h.zlib
< z.png:	h.zconf
< z.png:	h.pngconf
< z.pngerror:	c.pngerror
< z.pngerror:	h.png
< z.pngerror:	h.zlib
< z.pngerror:	h.zconf
< z.pngerror:	h.pngconf
< z.pngget:	c.pngget
< z.pngget:	h.png
< z.pngget:	h.zlib
< z.pngget:	h.zconf
< z.pngget:	h.pngconf
< z.pngmem:	c.pngmem
< z.pngmem:	h.png
< z.pngmem:	h.zlib
< z.pngmem:	h.zconf
< z.pngmem:	h.pngconf
< z.pngpread:	c.pngpread
< z.pngpread:	h.png
< z.pngpread:	h.zlib
< z.pngpread:	h.zconf
< z.pngpread:	h.pngconf
< z.pngread:	c.pngread
< z.pngread:	h.png
< z.pngread:	h.zlib
< z.pngread:	h.zconf
< z.pngread:	h.pngconf
< z.pngrio:	c.pngrio
< z.pngrio:	h.png
< z.pngrio:	h.zlib
< z.pngrio:	h.zconf
< z.pngrio:	h.pngconf
< z.pngrtran:	c.pngrtran
< z.pngrtran:	h.png
< z.pngrtran:	h.zlib
< z.pngrtran:	h.zconf
< z.pngrtran:	h.pngconf
< z.pngrutil:	c.pngrutil
< z.pngrutil:	h.png
< z.pngrutil:	h.zlib
< z.pngrutil:	h.zconf
< z.pngrutil:	h.pngconf
< z.pngset:	c.pngset
< z.pngset:	h.png
< z.pngset:	h.zlib
< z.pngset:	h.zconf
< z.pngset:	h.pngconf
< z.pngtrans:	c.pngtrans
< z.pngtrans:	h.png
< z.pngtrans:	h.zlib
< z.pngtrans:	h.zconf
< z.pngtrans:	h.pngconf
< z.pngwio:	c.pngwio
< z.pngwio:	h.png
< z.pngwio:	h.zlib
< z.pngwio:	h.zconf
< z.pngwio:	h.pngconf
< z.pngwrite:	c.pngwrite
< z.pngwrite:	h.png
< z.pngwrite:	h.zlib
< z.pngwrite:	h.zconf
< z.pngwrite:	h.pngconf
< z.pngwtran:	c.pngwtran
< z.pngwtran:	h.png
< z.pngwtran:	h.zlib
< z.pngwtran:	h.zconf
< z.pngwtran:	h.pngconf
< z.pngwutil:	c.pngwutil
< z.pngwutil:	h.png
< z.pngwutil:	h.zlib
< z.pngwutil:	h.zconf
< z.pngwutil:	h.pngconf
Index: README
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/README,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
1c1,2
< README for libpng 0.95
---
> README for libpng 1.0.0 (shared library 2.1)
> See the note about version numbers near the top of png.h
3,6c4,11
< This is the fifth (and hopefully last) beta release of libpng 1.0.
< The changes from libpng-0.90 include bug fixes, a C++ wrapper for
< png.h, some additions to the API, as well as internal changes to
< the library.  See "CHANGES" for a detailed list of differences.
---
> See INSTALL for instructions on how to install libpng.
> 
> This is the first official release of libpng.  Don't let the fact that
> it's the first release fool you.  The libpng library has been in
> extensive use and testing for about two and a half years.  However, it's
> finally gotten to the stage where there haven't been significant
> changes to the API in some time, and people have a bad feeling about
> libraries with versions < 1.0.
13c18
< png_uint_32, which will affect shared-library applications which use
---
> png_uint_32, which will affect shared-library applications that use
19c24,32
< png_get_<chunk> functions.
---
> png_get_<chunk> functions.  These functions should be used when
> accessing/storing the info_struct data, rather than manipulating it
> directly, to avoid such problems in the future.
> 
> It is important to note that the APIs do not make current programs
> that access the info struct directly incompatible with the new
> library.  However, it is strongly suggested that new programs use
> the new APIs (as shown in example.c), and older programs be converted
> to the new format, to facilitate upgrades in the future.
66c79
< as an Internet Draft, and RFC, and a W3C Recommendation.  Failing
---
> as an RFC and a W3C Recommendation.  Failing
86c99
< based in a large way on Guy's earlier work), and the PNG group.
---
> based in a large way on Guy's and Andreas' earlier work), and the PNG group.
88c101
< adilger@enel.ucalgary.ca
---
> randeg@alumni.rpi.edu
91,94c104,106
< You can reach Guy, the original libpng author, at (internet preferred):
< 
< internet: schalnat@group42.com
< CompuServe: 75501,1625
---
> You can't reach Guy, the original libpng author, at the addresses
> given in previous versions of this document.  He and Andreas will read mail
> addressed to the png-implement list, however.
97,98c109,111
< the address in the specification.  At the same time, please do
< not send libpng questions to that address, send them to me.  I'll
---
> the address in the specification (png-group@w3.org).  At the same
> time, please do not send libpng questions to that address, send them to me
> or to png-implement@dworkin.wustl.edu.  I'll
106c119
< been discussing PNG for a couple years now, and it is official and
---
> been discussing PNG for three years now, and it is official and
115a129
>       ansi2knr.1    =>  Manual page for ansi2knr
119a134
>       libpng.3      =>  manual page for libpng
121,133c136,137
<       makefile      =>  Default Unixish makefile
<       makefile.aco  =>  ACORN makefile
<       makefile.ama  =>  Amiga makefile
<       makefile.atr  =>  Atari makefile
<       makefile.bor  =>  Borland makefile
<       makefile.dj2  =>  DJGPP 2 makefile
<       makefile.elf  =>  Unix ELF makefile
<       makefile.knr  =>  Makefile which calls ansi2knr to convert files
<       makefile.mip  =>  MIPS makefile
<       makefile.msc  =>  Microsoft C makefile
<       makefile.std  =>  Standard Unix makefile
<       makefile.tc   =>  Turbo C makefile
<       makevms.com   =>  VMS make program
---
>       libpngpf.3    =>  manual page for libpng's private functions
>       png.5         =>  manual page for the PNG format
137a142
>       pngget.c      =>  Functions for retrieving info from struct
151a157,180
>       scripts       =>  Directory containing scripts for building libpng:
>         descrip.mms   =>  VMS makefile for MMS or MMK
>         makefile.std  =>  Generic UNIX makefile
>         makefile.knr  =>  Archaic UNIX Makefile that converts files with ansi2knr
>         makefile.dec  =>  DEC Alpha UNIX makefile
>         makefile.sgi  =>  Silicon Graphics IRIX makefile
>         makefile.sun  =>  Sun makefile
>         makefile.s2x  =>  Solaris 2.X makefile (gcc, creates libpng.so.2.1.0)
>         makefile.lnx  =>  Linux/ELF makefile (gcc, creates libpng.so.2.1.0)
>         makefile.mip  =>  MIPS makefile
>         makefile.aco  =>  Acorn makefile
>         makefile.ama  =>  Amiga makefile
>         smakefile.ppc =>  AMIGA smakefile for SAS C V6.58/7.00 PPC compiler
>                           (Requires SCOPTIONS, copied from scripts/SCOPTIONS.ppc)
>         makefile.atr  =>  Atari makefile
>         makefile.bor  =>  Borland makefile
>         build.bat     =>  MS-DOS batch file for Borland compiler
>         makefile.dj2  =>  DJGPP 2 makefile
>         makefile.msc  =>  Microsoft C makefile
>         makefile.tc3  =>  Turbo C 3.0 makefile
>         makefile.os2  =>  OS/2 Makefile (gcc and emx, requires pngos2.def)
>         makefile.wat  =>  Watcom 10a+ Makefile, 32-bit flat memory model
>         pngos2.def    =>  OS/2 module definition file used by makefile.os2
>         makevms.com   =>  VMS build script
154a184,187
> -Glenn Randers-Pehrson
>  Internet: randeg@alumni.rpi.edu
>  Web: http://www.rpi.edu/~randeg/index.html
> 
160,164c193,194
<  Group 42, Inc.
<  Internet: schalnat@group42.com
<  CompuServe: 75501,1625
<  Web: http://www.group42.com/
< 
---
>  (formerly of Group 42, Inc)
>  Internet: gschal@infinet.com
Index: TODO
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/TODO,v
retrieving revision 1.1
retrieving revision 1.4
diff -r1.1 -r1.4
1c1
< pngtodo.txt - list of things to do for libpng
---
> TODO - list of things to do for libpng
2a3,4
> fix problem with C++ and EXTERN "C"
> add "grayscale->palette" transformation and "palette->grayscale" detection
4a7
> sPLT chunk handling
6,7c9,11
< sRGB chunk handling
< man pages for function calls and info_struct
---
> complete sRGB transformation (presently it simply uses gamma=0.45)
> man pages for function calls
> high-level API for reading images
18,20d21
< other languages (pascal?)
< pull writer (is this really needed?)
< comments of > 64K for DOS?
Index: libpng.txt
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/libpng.txt,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
1c1
< libpng.txt - a description on how to use and modify libpng
---
> libpng.txt - A description on how to use and modify libpng
3,16c3,23
<    libpng 1.0 beta 5 - version 0.95
<    Updated and distributed by Andreas Dilger <adilger@enel.ucalgary.ca>,
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 15, 1997
<       based on:
< 
<    libpng 1.0 beta 2 - version 0.88
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    January 26, 1996
< 
<    Updated/rewritten per request in the libpng FAQ
<    Copyright (c) 1995 Frank J. T. Wojcik
<    December 18, 1995 && January 20, 1996
---
>  libpng version 1.0.0 March 8, 1998
>  Updated and distributed by Glenn Randers-Pehrson
>  <randeg@alumni.rpi.edu>
>  Copyright (c) 1998, Glenn Randers-Pehrson
>  For conditions of distribution and use, see copyright
>  notice in png.h.
> 
>  based on:
> 
>  libpng 1.0 beta 6  version 0.96 May 28, 1997
>  Updated and distributed by Andreas Dilger 
>  Copyright (c) 1996, 1997 Andreas Dilger
> 
>  libpng 1.0 beta 2 - version 0.88  January 26, 1996
>  For conditions of distribution and use, see copyright
>  notice in png.h. Copyright (c) 1995, 1996 Guy Eric
>  Schalnat, Group 42, Inc.
> 
>  Updated/rewritten per request in the libpng FAQ
>  Copyright (c) 1995 Frank J. T. Wojcik
>  December 18, 1995 && January 20, 1996
18c25
< I. Introduction
---
> Introduction
26c33,34
< will need.
---
> will need.  We assume that libpng is already installed; see the
> INSTALL file for instructions on how to install libpng.
29,34c37,49
< to reduce the amount of time and effort it takes to support the PNG
< file format in application programs.  Most users will not have to
< modify the library significantly; advanced users may want to modify it
< more.  All attempts were made to make it as complete as possible,
< while keeping the code easy to understand.  Currently, this library
< only supports C.  Support for other languages is being considered.
---
> of reducing the amount of time and effort it takes to support the PNG
> file format in application programs.  The PNG specification is available
> as RFC 2083 <ftp://ftp.uu.net/graphics/png/documents/> and as a
> W3C Recommendation <http://www.w3.org/TR/REC.png.html>. Some
> additional chunks are described in the special-purpose public chunks
> documents at <ftp://ftp.uu.net/graphics/png/documents/>.  Other information
> about PNG can be found at the PNG home page, <http://www.cdrom.com/pub/png/>.
> 
> Most users will not have to modify the library significantly; advanced
> users may want to modify it more.  All attempts were made to make it as
> complete as possible, while keeping the code easy to understand.
> Currently, this library only supports C.  Support for other languages
> is being considered.
42c57
< majority of the needs of it's users.
---
> majority of the needs of its users.
47a63,64
> You can usually find the source files for the zlib utility wherever you
> find the libpng source files.
56d72
< 
68c84
< a set of interface functions for png_info were delevoped.  The fields
---
> a set of interface functions for png_info was developed.  The fields
77,78d92
< 
< 
107a122
> 
120,126d134
< Next, png_struct and png_info need to be allocated and initialized.
< In order to ensure that the size of these structures is correct even
< with a dynamically linked libpng, there are functions to initialize
< and allocate the structures.  We also pass the library version, and
< optionally pointers to error handling functions (these can be NULL
< if the default error handlers are to be used).  See the section on
< Changes to Libpng below regarding the old initialization functions.
128,129c136,147
<     png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,
<        (void *)user_error_ptr, user_error_fn, user_warning_fn);
---
> Next, png_struct and png_info need to be allocated and initialized.  In
> order to ensure that the size of these structures is correct even with a
> dynamically linked libpng, there are functions to initialize and
> allocate the structures.  We also pass the library version, optional
> pointers to error handling functions, and a pointer to a data struct for
> use by the error functions, if necessary (the pointer and functions can
> be NULL if the default error handlers are to be used).  See the section
> on Changes to Libpng below regarding the old initialization functions.
> 
>     png_structp png_ptr = png_create_read_struct
>        (PNG_LIBPNG_VER_STRING, (void *)user_error_ptr,
>         user_error_fn, user_warning_fn);
136c154,155
<         png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
---
>         png_destroy_read_struct(&png_ptr,
>            (png_infopp)NULL, (png_infopp)NULL);
143c162,163
<         png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
---
>         png_destroy_read_struct(&png_ptr, &info_ptr,
>           (png_infopp)NULL);
146a167
> 
156d176
< information on setjmp/longjmp.  See the discussion on libpng error
164c184,185
<         png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
---
>         png_destroy_read_struct(&png_ptr, &info_ptr,
>            &end_info);
172,174c193,196
< opened in binary mode.  Again, if you wish to handle reading data in
< another way, see the discussion on libpng I/O handling in the Customizing
< Libpng section below.
---
> opened in binary mode.  If you wish to handle reading data in another
> way, you need not call the png_init_io() function, but you must then
> implement the libpng I/O methods discussed in the Customizing Libpng
> section below.
183a206,249
> At this point, you can set up a callback function that will be
> called after each row has been read, which you can use to control
> a progress meter or the like.  It's demonstrated in pngtest.c.
> You must supply a function
> 
>     void read_row_callback(png_ptr, png_uint_32 row, int pass);
>     {
>       /* put your code here */
>     }
> 
> (You can give it another name that you like instead of "read_row_callback")
> 
> To inform libpng about your function, use
> 
>     png_set_read_status_fn(png_ptr, read_row_callback);
> 
> In PNG files, the alpha channel in an image is the level of opacity.
> If you need the alpha channel in an image to be the level of transparency
> instead of opacity, you can invert the alpha channel (or the tRNS chunk
> data) after it's read, so that 0 is fully opaque and 255 (in 8-bit or
> paletted images) or 65535 (in 16-bit images) is fully transparent, with
> 
>     png_set_invert_alpha(png_ptr);
> 
> This has to appear here rather than later with the other transformations
> because the tRNS chunk data must be modified in the case of paletted images.
> If your image is not a paletted image, the tRNS data (which in such cases
> represents a single color to be rendered as transparent) won't be changed.
> 
> Finally, you can write your own transformation function if none of
> the existing ones meets your needs.  This is done by setting a callback
> with
> 
>     png_set_read_user_transform_fn(png_ptr,
>        read_transform_fn);
> 
> You must supply the function
> 
>     void read_transform_fn(png_ptr ptr, row_info_ptr
>        row_info, png_bytep data) 
> 
> See pngtest.c for a working example.  Your function will be called
> after all of the other transformations have been processed.
> 
191,204c257,281
<     png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,
<        &interlace_type, &compression_type, &filter_type);
< 
<     width          - holds the width of the image in pixels (up to 2^31).
<     height         - holds the height of the image in pixels (up to 2^31).
<     bit_depth      - holds the bit depth of one of the image channels.
<                      (valid values are 1, 2, 4, 8, 16 and depend also on the
<                       color_type.  See also significant bits (sBIT) below).
<     color_type     - describes which color/alpha channels are present.
<                      PNG_COLOR_TYPE_GRAY        (bit depths 1, 2, 4, 8, 16)
<                      PNG_COLOR_TYPE_GRAY_ALPHA  (bit depths 8, 16)
<                      PNG_COLOR_TYPE_PALETTE     (bit depths 1, 2, 4, 8)
<                      PNG_COLOR_TYPE_RGB         (bit_depths 8, 16)
<                      PNG_COLOR_TYPE_RGB_ALPHA   (bit_depths 8, 16)
---
>     png_get_IHDR(png_ptr, info_ptr, &width, &height,
>        &bit_depth, &color_type, &interlace_type,
>        &compression_type, &filter_type);
> 
>     width          - holds the width of the image
>                      in pixels (up to 2^31).
>     height         - holds the height of the image
>                      in pixels (up to 2^31).
>     bit_depth      - holds the bit depth of one of the
>                      image channels.  (valid values are
>                      1, 2, 4, 8, 16 and depend also on
>                      the color_type.  See also
>                      significant bits (sBIT) below).
>     color_type     - describes which color/alpha channels
>                          are present.
>                      PNG_COLOR_TYPE_GRAY
>                         (bit depths 1, 2, 4, 8, 16)
>                      PNG_COLOR_TYPE_GRAY_ALPHA  
>                         (bit depths 8, 16)
>                      PNG_COLOR_TYPE_PALETTE
>                         (bit depths 1, 2, 4, 8)
>                      PNG_COLOR_TYPE_RGB
>                         (bit_depths 8, 16)
>                      PNG_COLOR_TYPE_RGB_ALPHA
>                         (bit_depths 8, 16)
210,212c287,295
<     interlace_type - PNG_INTERLACE_TYPE_NONE or PNG_INTER_LACE_TYPE_ADAM7
<     compression_type - (must be PNG_COMPRESSION_TYPE_DEFAULT for PNG 1.0)
<     filter_type    - (must be PNG_FILTER_TYPE_DEFAULT for PNG 1.0)
---
>     filter_type    - (must be PNG_FILTER_TYPE_BASE
>                      for PNG 1.0)
>     compression_type - (must be PNG_COMPRESSION_TYPE_BASE
>                      for PNG 1.0)
>     interlace_type - (PNG_INTERLACE_NONE or
>                      PNG_INTERLACE_ADAM7)
>     Any or all of interlace_type, compression_type, of
>                      filter_type can be
>     NULL if you are not interested in their values.
215,217c298,301
<     channels       - number of channels of info for the color type
<                      (valid values are 1 (GRAY, PALETTE), 2 (GRAY_ALPHA),
<                       3 (RGB), 4 (RGB_ALPHA or RGB + filler byte))
---
>     channels       - number of channels of info for the
>                      color type (valid values are 1 (GRAY,
>                      PALETTE), 2 (GRAY_ALPHA), 3 (RGB),
>                      4 (RGB_ALPHA or RGB + filler byte))
222,227c306,331
<     signature      - holds the signature read from the file (if any).  The
<                      data is kept in the same offset it would be if the
<                      whole signature were read (ie if an application had
<                      already read in 4 bytes of signature before staring
<                      libpng, the remaining 4 bytes would be in signature[4]
<                      through signature[7] (see png_set_sig_bytes())).
---
>     signature      - holds the signature read from the
>                      file (if any).  The data is kept in
>                      the same offset it would be if the
>                      whole signature were read (i.e. if an
>                      application had already read in 4
>                      bytes of signature before starting
>                      libpng, the remaining 4 bytes would
>                      be in signature[4] through signature[7]
>                      (see png_set_sig_bytes())).
> 
> 
>     width            = png_get_image_width(png_ptr,
>                          info_ptr);
>     height           = png_get_image_height(png_ptr,
>                          info_ptr);
>     bit_depth        = png_get_bit_depth(png_ptr,
>                          info_ptr);
>     color_type       = png_get_color_type(png_ptr,
>                          info_ptr);
>     filter_type      = png_get_filter_type(png_ptr,
>                          info_ptr);
>     compression_type = png_get_compression_type(png_ptr,
>                          info_ptr);
>     interlace_type   = png_get_interlace_type(png_ptr,
>                          info_ptr);
> 
236,237c340,343
<     png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);
<     palette        - the palette for the file (array of png_color)
---
>     png_get_PLTE(png_ptr, info_ptr, &palette,
>                      &num_palette);
>     palette        - the palette for the file
>                      (array of png_color)
241c347,348
<     gamma          - the gamma the file is written at (PNG_INFO_gAMA)
---
>     gamma          - the gamma the file is written
>                      at (PNG_INFO_gAMA)
243,251c350,356
<     png_get_sBIT(png_ptr, info_ptr, &sig_bit);
<     sig_bit        - the number of significant bits for (PNG_INFO_sBIT)
<                      the gray, red, green, and blue channels, whichever
<                      are appropriate for the given color type (png_color_16)
< 
<     png_get_tRNS(png_ptr, info_ptr, &trans, &num_trans, &trans_values);
<     trans          - array of transparent entries for palette (PNG_INFO_tRNS)
<     trans_values   - transparent pixel for non-paletted images (PNG_INFO_tRNS)
<     num_trans      - number of transparent entries (PNG_INFO_tRNS)
---
>     png_get_sRGB(png_ptr, info_ptr, &srgb_intent);
>     srgb_intent    - the rendering intent (PNG_INFO_sRGB)
>                      The presence of the sRGB chunk
>                      means that the pixel data is in the
>                      sRGB color space.  This chunk also
>                      implies specific values of gAMA and
>                      cHRM.
253,254c358,377
<     png_get_hIST(png_ptr, info_ptr, &hist);        (PNG_INFO_hIST)
<     hist           - histogram of palette (array of png_color_16)
---
>     png_get_sBIT(png_ptr, info_ptr, &sig_bit);
>     sig_bit        - the number of significant bits for
>                      (PNG_INFO_sBIT) each of the gray,
>                      red, green, and blue channels,
>                      whichever are appropriate for the
>                      given color type (png_color_16)
> 
>     png_get_tRNS(png_ptr, info_ptr, &trans, &num_trans,
>                      &trans_values);
>     trans          - array of transparent entries for
>                      palette (PNG_INFO_tRNS)
>     trans_values   - transparent pixel for non-paletted
>                      images (PNG_INFO_tRNS)
>     num_trans      - number of transparent entries
>                      (PNG_INFO_tRNS)
> 
>     png_get_hIST(png_ptr, info_ptr, &hist);
>                      (PNG_INFO_hIST)
>     hist           - histogram of palette (array of
>                      png_color_16)
257c380,381
<     mod_time       - time image was last modified (PNG_VALID_tIME)
---
>     mod_time       - time image was last modified
>                     (PNG_VALID_tIME)
263,268c387,394
<     text_ptr       - array of png_text holding image comments
<     text_ptr[i]->key         - keyword for comment.
<     text_ptr[i]->text        - text comments for current keyword.
<     text_ptr[i]->compression - type of compression used on "text"
<                                PNG_TEXT_COMPRESSION_NONE or
<                                PNG_TEXT_COMPRESSION_zTXt
---
>     text_ptr       - array of png_text holding image
>                      comments
>     text_ptr[i]->key   - keyword for comment.
>     text_ptr[i]->text  - text comments for current
>                          keyword.
>     text_ptr[i]->compression - type of compression used
>                      on "text" PNG_TEXT_COMPRESSION_NONE
>                      or PNG_TEXT_COMPRESSION_zTXt
271,273c397,402
<     png_get_oFFs(png_ptr, info_ptr, &offset_x, &offset_y, &unit_type);
<     offset_x       - positive offset from the left edge of the screen
<     offset_y       - positive offset from the top edge of the screen
---
>     png_get_oFFs(png_ptr, info_ptr, &offset_x, &offset_y,
>                      &unit_type);
>     offset_x       - positive offset from the left edge
>                      of the screen
>     offset_y       - positive offset from the top edge
>                      of the screen
276,279c405,428
<     png_get_pHYs(png_ptr, info_ptr, &res_x, &res_y, &unit_type);
<     res_x          - pixels/unit physical resolution in x direction
<     res_y          - pixels/unit physical resolution in x direction
<     unit_type      - PNG_RESOLUTION_UNKOWN, PNG_RESOLUTION_METER
---
>     png_get_pHYs(png_ptr, info_ptr, &res_x, &res_y,
>                      &unit_type);
>     res_x          - pixels/unit physical resolution in
>                      x direction
>     res_y          - pixels/unit physical resolution in
>                      x direction
>     unit_type      - PNG_RESOLUTION_UNKNOWN,
>                      PNG_RESOLUTION_METER
> 
> The data from the pHYs chunk can be retrieved in several convenient
> forms:
> 
>     res_x = png_get_x_pixels_per_meter(png_ptr,
>                   info_ptr)
>     res_y = png_get_y_pixels_per_meter(png_ptr,
>                   info_ptr)
>     res_x_and_y = png_get_pixels_per_meter(png_ptr,
>                   info_ptr)
>     aspect_ratio = png_get_pixel_aspect_ratio(png_ptr,
>                   info_ptr)
> 
>    (Each of these returns 0 [signifying "unknown"] if
>        the data is not present or if res_x is 0;
>        res_x_and_y is 0 if res_x != res_y)
285c434
< See png_update_info(), below.
---
> See png_read_update_info(), below.
292,294c441,443
< to humans (that's the point), so don't use abbreviations or non-printing
< symbols.  See the PNG specification for more details.  There is also
< no requirement to have text after the keyword.
---
> to humans (that's the point), so don't use abbreviations.  Non-printing
> symbols are not allowed.  See the PNG specification for more details.
> There is also no requirement to have text after the keyword.
314c463
< checks to see if it has data that it can do somthing with, you should
---
> checks to see if it has data that it can do something with, you should
323c472
< calls the png_update_info() routine (see below).
---
> calls the png_read_update_info() routine (see below).
342,343c491,492
<    if (color_type == PNG_COLOR_TYPE_PALETTE && bit_depth < 8)
<         png_set_expand(png_ptr);
---
>     if (color_type == PNG_COLOR_TYPE_PALETTE &&
>         bit_depth <= 8) png_set_expand(png_ptr);
345,346c494,495
<     if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
<       png_set_expand(png_ptr);
---
>     if (color_type == PNG_COLOR_TYPE_GRAY &&
>         bit_depth < 8) png_set_expand(png_ptr);
348,349c497,498
<    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
<       png_set_expand(png_ptr);
---
>     if (png_get_valid(png_ptr, info_ptr,
>         PNG_INFO_tRNS)) png_set_expand(png_ptr);
354,355c503,515
<    if (bit_depth == 16)
<       png_set_strip_16(png_ptr);
---
>     if (bit_depth == 16)
>         png_set_strip_16(png_ptr);
> 
> The png_set_background() function tells libpng to composite images
> with alpha or simple transparency against the supplied background
> color.  If the PNG file contains a bKGD chunk (PNG_INFO_bKGD valid),
> you may use this color, or supply another color more suitable for
> the current display (e.g., the background color from a web page).  You
> need to tell libpng whether the color is in the gamma space of the
> display (PNG_BACKGROUND_GAMMA_SCREEN for colors you supply), the file
> (PNG_BACKGROUND_GAMMA_FILE for colors from the bKGD chunk), or one
> that is neither of these gammas (PNG_BACKGROUND_GAMMA_UNIQUE - I don't
> know why anyone would use this, but it's here).
358c518,520
< and you want to remove it rather than combining it with the background:
---
> and you want to remove it rather than combining it with the background
> (but the image author certainly had in mind that you *would* combine
> it with the background, so that's what you should probably do):
360,361c522,523
<    if (color_type & PNG_COLOR_MASK_ALPHA)
<       png_set_strip_alpha(png_ptr);
---
>     if (color_type & PNG_COLOR_MASK_ALPHA)
>         png_set_strip_alpha(png_ptr);
372,373c534,535
< stored in a PNG image whave been "scaled" or "shifted" up to the next
< higher possible bit depth (eg from 5 bits/sample in the range [0,31] to
---
> stored in a PNG image have been "scaled" or "shifted" up to the next
> higher possible bit depth (e.g. from 5 bits/sample in the range [0,31] to
383c545
< PNG files store 3 color pixels in red, green, blue order.  This code
---
> PNG files store 3-color pixels in red, green, blue order.  This code
393,394c555,557
<    if (bit_depth == 8 && color_type == PNG_COLOR_TYPE_RGB)
<       png_set_filler(png_ptr, filler, PNG_FILLER_BEFORE);
---
>     if (bit_depth == 8 && color_type ==
>         PNG_COLOR_TYPE_RGB) png_set_filler(png_ptr,
>         filler, PNG_FILLER_BEFORE);
404,405c567,568
<    if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)
<       png_set_swap_alpha(png_ptr);
---
>     if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)
>         png_set_swap_alpha(png_ptr);
407c570
< For some uses, you may want a gray-scale image to be represented as
---
> For some uses, you may want a grayscale image to be represented as
410,423c573,575
<    if (color_type == PNG_COLOR_TYPE_GRAY ||
<        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
<          png_set_gray_to_rgb(png_ptr);
< 
< The png_set_background() function tells libpng to composite images
< with alpha or simple transparency against the supplied background
< color.  If the PNG file contains a bKGD chunk (PNG_INFO_bKGD valid),
< you may use this color, or supply another color more suitable for
< the current display (eg the background color from a web page).  You
< need to tell libpng whether the color is in the gamma space of the
< dispay (PNG_BACKGROUND_GAMMA_SCREEN for colors you supply), the file
< (PNG_BACKGROUND_GAMMA_FILE for colors from the bKGD chunk), or one
< that is neither of these gammas (PNG_BACKGROUND_GAMMA_UNIQUE - I don't
< know why anyone would use this, but it's here).
---
>     if (color_type == PNG_COLOR_TYPE_GRAY ||
>         color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
>           png_set_gray_to_rgb(png_ptr);
434,435c586,587
<    png_color_16 my_background;
<    png_color_16p image_background;
---
>     png_color_16 my_background;
>     png_color_16p image_background;
437,442c589,595
<    if (png_get_bKGD(png_ptr, info_ptr, &image_background))
<       png_set_background(png_ptr, image_background),
<             PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
<    else
<       png_set_background(png_ptr, &my_background,
<          PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);
---
>     if (png_get_bKGD(png_ptr, info_ptr,
>         &image_background))
>         png_set_background(png_ptr, image_background),
>         PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
>     else
>         png_set_background(png_ptr, &my_background,
>           PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);
448c601,610
< DISPLAY_GAMMA environment variable, which will hopefully be correctly set.
---
> DISPLAY_GAMMA and VIEWING_GAMMA environment variables or for a SCREEN_GAMMA
> environment variable, which will hopefully be correctly set.
> 
> Note that display_gamma is the gamma of your display, while screen_gamma is
> the overall gamma correction required to produce pleasing results,
> which depends on the lighting conditions in the surrounding environment.
> Screen_gamma is display_gamma/viewing_gamma, where viewing_gamma is
> the amount of additional gamma correction needed to compensate for
> a (viewing_gamma=1.25) environment.  In a dim or brightly lit room, no
> compensation other than the display_gamma is needed (viewing_gamma=1.0).
450c612,613
<    if (/* We have a user-defined screen gamma value */)
---
>    if (/* We have a user-defined screen
>        gamma value */)
454,455c617,620
<    /* One way that applications can share the same screen gamma value */
<    else if ((gamma_str = getenv("DISPLAY_GAMMA")) != NULL)
---
>    /* One way that applications can share the same
>       screen gamma value */
>    else if ((gamma_str = getenv("SCREEN_GAMMA"))
>       != NULL)
462,463c627,632
<       screen_gamma = 2.2;  /* A good guess for PC monitors */
<       screen_gamma = 1.7 or 1.0;  /* A good guess for Mac systems */
---
>       screen_gamma = 2.2; /* A good guess for a
>            PC monitor in a bright office or a dim room */
>       screen_gamma = 2.0; /* A good guess for a
>            PC monitor in a dark room */
>       screen_gamma = 1.7 or 1.0;  /* A good
>            guess for Mac systems */
469c638
< it is (usually 0.45 is a good guess for GIF images on PCs).  Note
---
> it is (usually 0.50 is a good guess for GIF images on PCs).  Note
478c647
<       png_set_gamma(png_ptr, screen_gamma, 0.45);
---
>       png_set_gamma(png_ptr, screen_gamma, 0.50);
493c662,663
<       if (png_get_valid(png_ptr, info_ptr, PNG_INFO_PLTE))
---
>       if (png_get_valid(png_ptr, info_ptr,
>          PNG_INFO_PLTE))
497,499c667,670
<          png_get_hIST(png_ptr, info_ptr, &histogram);
<          png_set_dither(png_ptr, palette, num_palette, max_screen_colors,
<             histogram, 1);
---
>          png_get_hIST(png_ptr, info_ptr,
>             &histogram);
>          png_set_dither(png_ptr, palette, num_palette,
>             max_screen_colors, histogram, 1);
506,507c677,679
<          png_set_dither(png_ptr, std_color_cube, MAX_SCREEN_COLORS,
<             MAX_SCREEN_COLORS, NULL,0);
---
>          png_set_dither(png_ptr, std_color_cube,
>             MAX_SCREEN_COLORS, MAX_SCREEN_COLORS,
>             NULL,0);
519,520c691,692
< ie. most significant bits first).  This code chages the storage to the
< other way (little-endian, ie. least significant bits first, eg. the
---
> ie. most significant bits first).  This code changes the storage to the
> other way (little-endian, i.e. least significant bits first, the
533c705,706
< but you must call the function here.
---
> but you must call the function here if you want libpng to handle expansion
> of the interlaced image.
535c708
<     number_passes = png_set_interlace_handling(png_ptr);
---
>     number_of_passes = png_set_interlace_handling(png_ptr);
539,541c712,714
< call.  This is most useful to update the info structures rowbytes
< field, so you can use it to allocate your image memory.  This function
< will also update your palette with the correct display gamma and
---
> call.  This is most useful to update the info structure's rowbytes
> field so you can use it to allocate your image memory.  This function
> will also update your palette with the correct screen_gamma and
573c746
< If you don't want to read int the whole image at once, you can
---
> If you don't want to read in the whole image at once, you can
575c748
< interlace_type == PNG_INTERLACE_TYPE_NONE), this is simple:
---
> interlace_type == PNG_INTERLACE_NONE), this is simple:
577c750,751
<     png_read_rows(png_ptr, row_pointers, NULL, number_of_rows);
---
>     png_read_rows(png_ptr, row_pointers, NULL,
>        number_of_rows);
589,590c763,764
< interlacing type for PNG is (interlace_type == PNG_INTERLACE_TYPE_ADAM7)
< is a someewhat complicated 2D interlace scheme, known as Adam7, that
---
> interlacing type for PNG is (interlace_type == PNG_INTERLACE_ADAM7)
> is a somewhat complicated 2D interlace scheme, known as Adam7, that
597,603c771,777
< those pixels that have not been read yet.  This results in a blocky
< image for the first pass, which gradually smoothes out as more pixels
< are read.  The other method is the "sparkle" method, where pixels are
< draw only in their final locations, with the rest of the image remaining
< whatever colors they were initialized to before the start of the read.
< The first method usually looks better, but tends to be slower, as there
< are more pixels to put in the rows.
---
> those pixels that have not been read yet (the "rectangle" method).
> This results in a blocky image for the first pass, which gradually
> smooths out as more pixels are read.  The other method is the "sparkle"
> method, where pixels are drawn only in their final locations, with the
> rest of the image remaining whatever colors they were initialized to
> before the start of the read.  The first method usually looks better,
> but tends to be slower, as there are more pixels to put in the rows.
607c781
< images are valid images by themselves, or they can be combined on an
---
> images is a valid image by itself, or they can all be combined on an
615c789
< third pass will be 1/4 as wide (every 4th pixel starting in row 0) and
---
> third pass will be 1/4 as wide (every 4th pixel starting in column 0) and
628,629c802,804
<     if (interlace_type == PNG_INTERLACE_TYPE_ADAM7)
<         number_passes = png_set_interlace_handling(png_ptr);
---
>     if (interlace_type == PNG_INTERLACE_ADAM7)
>         number_of_passes
>            = png_set_interlace_handling(png_ptr);
640c815
< after each pass, the rectangle effect is generally considered the
---
> after each pass, the "rectangle" effect is generally considered the
645c820
< the image number_passes times, and you don't change the data in the
---
> the image number_of_passes times, and you don't change the data in the
650c825,826
<     png_read_rows(png_ptr, row_pointers, NULL, number_of_rows);
---
>     png_read_rows(png_ptr, row_pointers, NULL,
>        number_of_rows);
656c832,833
<     png_read_rows(png_ptr, NULL, row_pointers, number_of_rows);
---
>     png_read_rows(png_ptr, NULL, row_pointers,
>        number_of_rows);
661d837
< info_ptr pointer from the png_read_info() call, or you can pass a
670c846,847
<    png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
---
>    png_destroy_read_struct(&png_ptr, &info_ptr,
>        &end_info);
691,697c868,876
< /*  An example code fragment of how you would initialize the progressive
<     reader in your application. */
< int
< initialize_png_reader()
< {
<     png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,
<         (void *)user_error_ptr, user_error_fn, user_warning_fn);
---
>  /*  An example code fragment of how you would
>      initialize the progressive reader in your
>      application. */
>  int
>  initialize_png_reader()
>  {
>     png_ptr = png_create_read_struct
>         (PNG_LIBPNG_VER_STRING, (void *)user_error_ptr,
>          user_error_fn, user_warning_fn);
703c882,883
<         png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
---
>         png_destroy_read_struct(&png_ptr, (png_infopp)NULL,
>            (png_infopp)NULL);
709c889,890
<         png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
---
>         png_destroy_read_struct(&png_ptr, &info_ptr,
>            (png_infopp)NULL);
713,721c894,906
<     /* This one's new.  You can provide functions to be called
<        when the header info is valid, when each row is completed,
<        and when the image is finished.  If you aren't using all
<        functions, you can specify a NULL parameter.  You can use
<        any struct as the user_ptr (cast to a void pointer for the
<        function call), and retrieve the pointer from inside the
<        callbacks using the function png_get_progressive_ptr(png_ptr);        
<        which will return a void pointer, which you have to cast
<        appropriately.
---
>     /* This one's new.  You can provide functions
>        to be called when the header info is valid,
>        when each row is completed, and when the image
>        is finished.  If you aren't using all functions,
>        you can specify a NULL parameter.  You can use
>        any struct as the user_ptr (cast to a void pointer
>        for the function call), and retrieve the pointer
>        from inside the callbacks using the function
> 
>           png_get_progressive_ptr(png_ptr);
> 
>        which will return a void pointer, which you have
>        to cast appropriately.
727c912
< }
---
>  }
729,732c914,918
< /* A code fragment that you call as you recieve blocks of data */
< int
< process_data(png_bytep buffer, png_uint_32 length)
< {
---
>  /* A code fragment that you call as you receive blocks
>    of data */
>  int
>  process_data(png_bytep buffer, png_uint_32 length)
>  {
735c921,922
<         png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
---
>         png_destroy_read_struct(&png_ptr, &info_ptr,
>            (png_infopp)NULL);
739,747c926,937
<     /* This one's new also.  Simply give it a chunk of data
<        from the file stream (in order, of course).  On machines
<        with segmented memory models machines, don't give it any 
<        more than 64K.  The library seems to run fine with sizes 
<        of 4K. Although you can give it much less if necessary 
<        (I assume you can give it chunks of 1 byte, I haven't
<        tried less then 256 bytes yet).  When this function returns,
<        you may want to display any rows that were generated in the
<        row callback if you don't already do so there. 
---
>     /* This one's new also.  Simply give it a chunk
>        of data from the file stream (in order, of
>        course).  On machines with segmented memory
>        models machines, don't give it any more than
>        64K.  The library seems to run fine with sizes 
>        of 4K. Although you can give it much less if
>        necessary (I assume you can give it chunks of
>        1 byte, I haven't tried less then 256 bytes
>        yet).  When this function returns, you may
>        want to display any rows that were generated
>        in the row callback if you don't already do
>        so there. 
751c941
< }
---
>  }
753,754c943,946
< /* This function is called (as set by png_set_progressive_fn() above)
<    when enough data has been supplied so all of the header has been read.
---
>  /* This function is called (as set by
>     png_set_progressive_fn() above) when enough data
>     has been supplied so all of the header has been
>     read.
756,764c948,959
< void
< info_callback(png_structp png_ptr, png_infop info)
< {
<     /* Do any setup here, including setting any of the transformations
<        mentioned in the Reading PNG files section.  For now, you _must_
<        call either png_start_read_image() or png_read_update_info()
<        after all the transformations are set (even if you don't set
<        any).  You may start getting rows before png_process_data()
<        returns, so this is your last chance to prepare for that.
---
>  void
>  info_callback(png_structp png_ptr, png_infop info)
>  {
>     /* Do any setup here, including setting any of
>        the transformations mentioned in the Reading
>        PNG files section.  For now, you _must_ call
>        either png_start_read_image() or
>        png_read_update_info() after all the
>        transformations are set (even if you don't set
>        any).  You may start getting rows before
>        png_process_data() returns, so this is your
>        last chance to prepare for that.
766c961
< }
---
>  }
768,770c963,966
< /* This function is called when each row of image data is complete */
< void
< row_callback(png_structp png_ptr, png_bytep new_row,
---
>  /* This function is called when each row of image
>     data is complete */
>  void
>  row_callback(png_structp png_ptr, png_bytep new_row,
772,786c968,987
< {
<     /* If the image is interlaced, and you turned on the interlace
<        handler, this function will be called for every row in every pass.
<        Some of these rows will not be changed from the previous pass.
<        When the row is not changed, the new_row variable will be NULL.
<        The rows and passes are called in order, so you don't really
<        need the row_num and pass, but I'm supplying them because it
<        may make your life easier.
< 
<        For the non-NULL rows of interlaced images, you must call
<        png_progressive_combine_row() passing in the row and the
<        old row.  You can call this function for NULL rows (it will
<        just return) and for non-interlaced images (it just does the
<        memcpy for you) if it will make the code easier.  Thus, you
<        can just do this for all cases:
---
>  {
>     /* If the image is interlaced, and you turned
>        on the interlace handler, this function will
>        be called for every row in every pass.  Some
>        of these rows will not be changed from the
>        previous pass.  When the row is not changed,
>        the new_row variable will be NULL.  The rows
>        and passes are called in order, so you don't
>        really need the row_num and pass, but I'm
>        supplying them because it may make your life
>        easier.
> 
>        For the non-NULL rows of interlaced images,
>        you must call png_progressive_combine_row()
>        passing in the row and the old row.  You can
>        call this function for NULL rows (it will just
>        return) and for non-interlaced images (it just
>        does the memcpy for you) if it will make the
>        code easier.  Thus, you can just do this for
>        all cases:
789c990,991
<         png_progressive_combine_row(png_ptr, old_row, new_row);
---
>         png_progressive_combine_row(png_ptr, old_row,
>           new_row);
791,796c993,1000
<     /* where old_row is what was displayed for previous rows.  Note
<        that the first pass (pass == 0, really) will completely cover
<        the old row, so the rows do not have to be initialized.  After
<        the first pass (and only for interlaced images), you will have
<        to pass the current row, and the function will combine the
<        old row and the new row.
---
>     /* where old_row is what was displayed for
>        previous rows.  Note that the first pass
>        (pass == 0, really) will completely cover
>        the old row, so the rows do not have to be
>        initialized.  After the first pass (and only
>        for interlaced images), you will have to pass
>        the current row, and the function will combine
>        the old row and the new row.
798c1002
< }
---
>  }
800,807c1004,1012
< void
< end_callback(png_structp png_ptr, png_infop info)
< {
<     /* This function is called after the whole image has been read,
<        including any chunks after the image (up to and including
<        the IEND).  You will usually have the same info chunk as you
<        had in the header, although some data may have been added
<        to the comments and time fields.
---
>  void
>  end_callback(png_structp png_ptr, png_infop info)
>  {
>     /* This function is called after the whole image
>        has been read, including any chunks after the
>        image (up to and including the IEND).  You
>        will usually have the same info chunk as you
>        had in the header, although some data may have
>        been added to the comments and time fields.
809,810c1014,1015
<        Most people won't do much here, perhaps setting a flag that
<        marks the image as finished.
---
>        Most people won't do much here, perhaps setting
>        a flag that marks the image as finished.
812c1017
< }
---
>  }
836,839c1041,1048
< will want to check if they return NULL.
< 
<     png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,
<        (void *)user_error_ptr, user_error_fn, user_warning_fn);
---
> will want to check if they return NULL.  If you are also reading,
> you won't want to name your read structure and your write structure
> both "png_ptr"; you can call them anything you like, such as
> "read_ptr" and "write_ptr".  Look at pngtest.c, for example.
> 
>     png_structp png_ptr = png_create_write_struct
>        (PNG_LIBPNG_VER_STRING, (void *)user_error_ptr,
>         user_error_fn, user_warning_fn);
846c1055,1056
<        png_destroy_write_struct(&png_ptr, (png_infopp)NULL);
---
>        png_destroy_write_struct(&png_ptr,
>          (png_infopp)NULL);
868c1078
< Now you need to set up the input code.  The default for libpng is to
---
> Now you need to set up the output code.  The default for libpng is to
876a1087,1102
> At this point, you can set up a callback function that will be
> called after each row has been written, which you can use to control
> a progress meter or the like.  It's demonstrated in pngtest.c.
> You must supply a function
> 
>     void write_row_callback(png_ptr, png_uint_32 row, int pass);
>     {
>       /* put your code here */
>     }
> 
> (You can give it another name that you like instead of "write_row_callback")
> 
> To inform libpng about your function, use
> 
>     png_set_write_status_fn(png_ptr, write_row_callback);
> 
886c1112,1113
< 06/96 PNG specification.  The third parameter is a flag that indicates
---
> October 1996 PNG specification, version 1.0).  The third parameter is a
> flag that indicates
891c1118,1119
<     /* turn on or off filtering, and/or choose specific filters */
---
>     /* turn on or off filtering, and/or choose
>        specific filters */
893c1121,1122
<        PNG_FILTER_NONE | PNG_FILTER_SUB | PNG_FILTER_PAETH);
---
>        PNG_FILTER_NONE | PNG_FILTER_SUB |
>        PNG_FILTER_PAETH);
902c1131,1132
<     png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);
---
>     png_set_compression_level(png_ptr,
>         Z_BEST_COMPRESSION);
906c1136,1137
<     png_set_compression_strategy(png_ptr, Z_DEFAULT_STRATEGY);
---
>     png_set_compression_strategy(png_ptr,
>         Z_DEFAULT_STRATEGY);
923,935c1154,1178
<     png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth, color_type,
<        interlace_type,
<     width          - holds the width of the image in pixels (up to 2^31).
<     height         - holds the height of the image in pixels (up to 2^31).
<     bit_depth      - holds the bit depth of one of the image channels.
<                      (valid values are 1, 2, 4, 8, 16 and depend also on the
<                       color_type.  See also significant bits (sBIT) below).
<     color_type     - describes which color/alpha channels are present.
<                      PNG_COLOR_TYPE_GRAY        (bit depths 1, 2, 4, 8, 16)
<                      PNG_COLOR_TYPE_GRAY_ALPHA  (bit depths 8, 16)
<                      PNG_COLOR_TYPE_PALETTE     (bit depths 1, 2, 4, 8)
<                      PNG_COLOR_TYPE_RGB         (bit_depths 8, 16)
<                      PNG_COLOR_TYPE_RGB_ALPHA   (bit_depths 8, 16)
---
>     png_set_IHDR(png_ptr, info_ptr, width, height,
>        bit_depth, color_type, interlace_type,
>        compression_type, filter_type)
>     width          - holds the width of the image
>                      in pixels (up to 2^31).
>     height         - holds the height of the image
>                      in pixels (up to 2^31).
>     bit_depth      - holds the bit depth of one of the
>                      image channels.
>                      (valid values are 1, 2, 4, 8, 16
>                      and depend also on the
>                      color_type.  See also significant
>                      bits (sBIT) below).
>     color_type     - describes which color/alpha
>                      channels are present.
>                      PNG_COLOR_TYPE_GRAY
>                         (bit depths 1, 2, 4, 8, 16)
>                      PNG_COLOR_TYPE_GRAY_ALPHA
>                         (bit depths 8, 16)
>                      PNG_COLOR_TYPE_PALETTE
>                         (bit depths 1, 2, 4, 8)
>                      PNG_COLOR_TYPE_RGB
>                         (bit_depths 8, 16)
>                      PNG_COLOR_TYPE_RGB_ALPHA
>                         (bit_depths 8, 16)
941,948c1184,1193
<     interlace_type - PNG_INTERLACE_TYPE_NONE or PNG_INTER_LACE_TYPE_ADAM7
<     compression_type - (must be PNG_COMPRESSION_TYPE_DEFAULT for PNG 1.0)
<     filter_type    - (must be PNG_FILTER_TYPE_DEFAULT for PNG 1.0)
<     Any or all of interlace_type, compression_type, of filter_type can be
<     NULL if you are not interested in their values.
< 
<     png_set_PLTE(png_ptr, info_ptr, palette, num_palette);
<     palette        - the palette for the file (array of png_color)
---
>     interlace_type - PNG_INTERLACE_NONE or
>                      PNG_INTERLACE_ADAM7
>     compression_type - (must be
>                      PNG_COMPRESSION_TYPE_DEFAULT)
>     filter_type    - (must be PNG_FILTER_TYPE_DEFAULT)
> 
>     png_set_PLTE(png_ptr, info_ptr, palette,
>        num_palette);
>     palette        - the palette for the file
>                      (array of png_color)
952c1197,1198
<     gamma          - the gamma the image was created at (PNG_INFO_gAMA)
---
>     gamma          - the gamma the image was created
>                      at (PNG_INFO_gAMA)
954,962c1200,1227
<     png_set_sBIT(png_ptr, info_ptr, sig_bit);
<     sig_bit        - the number of significant bits for (PNG_INFO_sBIT)
<                      the gray, red, green, and blue channels, whichever
<                      are appropriate for the given color type (png_color_16)
< 
<     png_set_tRNS(png_ptr, info_ptr, trans, num_trans, trans_values);
<     trans          - array of transparent entries for palette (PNG_INFO_tRNS)
<     trans_values   - transparent pixel for non-paletted images (PNG_INFO_tRNS)
<     num_trans      - number of transparent entries (PNG_INFO_tRNS)
---
>     png_set_sRGB(png_ptr, info_ptr, srgb_intent);
>     srgb_intent    - the rendering intent
>                      (PNG_INFO_sRGB) The presence of
>                      the sRGB chunk means that the pixel
>                      data is in the sRGB color space.
>                      This chunk also implies specific
>                      values of gAMA and cHRM.  Rendering
>                      intent is the CSS-1 property that
>                      has been defined by the International
>                      Color Consortium
>                      (http://www.color.org).
>                      It can be one of
>                      PNG_SRGB_INTENT_SATURATION,
>                      PNG_SRGB_INTENT_PERCEPTUAL,
>                      PNG_SRGB_INTENT_ABSOLUTE, or
>                      PNG_SRGB_INTENT_RELATIVE.
>                         
> 
>     png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr,
>        srgb_intent);
>     srgb_intent    - the rendering intent
>                      (PNG_INFO_sRGB) The presence of the
>                      sRGB chunk means that the pixel
>                      data is in the sRGB color space.
>                      This function also causes gAMA and
>                      cHRM chunks with the specific values
>                      that are consistent with sRGB to be
>                      written.
964,965c1229,1248
<     png_set_hIST(png_ptr, info_ptr, hist);        (PNG_INFO_hIST)
<     hist           - histogram of palette (array of png_color_16)
---
>     png_set_sBIT(png_ptr, info_ptr, sig_bit);
>     sig_bit        - the number of significant bits for
>                      (PNG_INFO_sBIT) each of the gray, red,
>                      green, and blue channels, whichever are
>                      appropriate for the given color type
>                      (png_color_16)
> 
>     png_set_tRNS(png_ptr, info_ptr, trans, num_trans,
>        trans_values);
>     trans          - array of transparent entries for
>                      palette (PNG_INFO_tRNS)
>     trans_values   - transparent pixel for non-paletted
>                      images (PNG_INFO_tRNS)
>     num_trans      - number of transparent entries
>                      (PNG_INFO_tRNS)
> 
>     png_set_hIST(png_ptr, info_ptr, hist);
>                     (PNG_INFO_hIST)
>     hist           - histogram of palette (array of
>                      png_color_16)
968c1251,1252
<     mod_time       - time image was last modified (PNG_VALID_tIME)
---
>     mod_time       - time image was last modified
>                      (PNG_VALID_tIME)
974,990c1258,1297
<     text_ptr       - array of png_text holding image comments
<     text_ptr[i]->key         - keyword for comment.
<     text_ptr[i]->text        - text comments for current keyword.
<     text_ptr[i]->compression - type of compression used on "text"
<                                PNG_TEXT_COMPRESSION_NONE or
<                                PNG_TEXT_COMPRESSION_zTXt
<     num_text       - number of comments in text_ptr
< 
<     png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);
<     offset_x       - positive offset from the left edge of the screen
<     offset_y       - positive offset from the top edge of the screen
<     unit_type      - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER
< 
<     png_get_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);
<     res_x          - pixels/unit physical resolution in x direction
<     res_y          - pixels/unit physical resolution in x direction
<     unit_type      - PNG_RESOLUTION_UNKOWN, PNG_RESOLUTION_METER
---
>     text_ptr       - array of png_text holding image
>                      comments
>     text_ptr[i]->key   - keyword for comment.
>     text_ptr[i]->text  - text comments for current
>                          keyword.
>     text_ptr[i]->compression - type of compression used
>          on "text" PNG_TEXT_COMPRESSION_NONE or
>          PNG_TEXT_COMPRESSION_zTXt
>     num_text    - number of comments in text_ptr
> 
>     png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y,
>         unit_type);
>     offset_x  - positive offset from the left
>                      edge of the screen
>     offset_y  - positive offset from the top
>                      edge of the screen
>     unit_type - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER
> 
>     png_set_pHYs(png_ptr, info_ptr, res_x, res_y,
>         unit_type);
>     res_x       - pixels/unit physical resolution
>                   in x direction
>     res_y       - pixels/unit physical resolution
>                   in y direction
>     unit_type   - PNG_RESOLUTION_UNKNOWN,
>                   PNG_RESOLUTION_METER
> 
> In PNG files, the alpha channel in an image is the level of opacity.
> If your data is supplied as a level of transparency, you can invert the
> alpha channel before you write it, so that 0 is fully transparent and 255
> (in 8-bit or paletted images) or 65535 (in 16-bit images) is fully opaque,
> with
> 
>     png_set_invert_alpha(png_ptr);
> 
> This must appear here instead of later with the other transformations
> because in the case of paletted images the tRNS chunk data has to
> be inverted before the tRNS chunk is written.  If your image is not a
> paletted image, the tRNS data (which in such cases represents a single
> color to be rendered as transparent) won't be changed.
1010,1020c1317,1329
<             Title            Short (one line) title or caption for image
<             Author           Name of image's creator
<             Description      Description of image (possibly long)
<             Copyright        Copyright notice
<             Creation Time    Time of original image creation
<             Software         Software used to create the image
<             Disclaimer       Legal disclaimer
<             Warning          Warning of nature of content
<             Source           Device used to create the image
<             Comment          Miscellaneous comment; conversion from other
<                              image format
---
>     Title            Short (one line) title or
>                      caption for image
>     Author           Name of image's creator
>     Description      Description of image (possibly long)
>     Copyright        Copyright notice
>     Creation Time    Time of original image creation
>                      (usually RFC 1123 format, see below)
>     Software         Software used to create the image
>     Disclaimer       Legal disclaimer
>     Warning          Warning of nature of content
>     Source           Device used to create the image
>     Comment          Miscellaneous comment; conversion
>                      from other image format
1024c1333
< keywords are found in the PNG specification, as is some recomendations
---
> keywords are found in the PNG specification, as is some recommendations
1048c1357
< year (ie 1996, rather than 96 - PNG is year 2000 compliant!), and
---
> year (e.g. 1998, rather than 98 - PNG is year 2000 compliant!), and
1050a1360,1373
> If you want to store the time of the original image creation, you should
> use a plain tEXt chunk with the "Creation Time" keyword.  This is
> necessary because the "creation time" of a PNG image is somewhat vague,
> depending on whether you mean the PNG file, the time the image was
> created in a non-PNG format, a still photo from which the image was
> scanned, or possibly the subject matter itself.  In order to facilitate
> machine-readable dates, it is recommended that the "Creation Time"
> tEXt chunk use RFC 1123 format dates (e.g. 22 May 1997 18:07:10 GMT"),
> although this isn't a requirement.  Unlike the tIME chunk, the
> "Creation Time" tEXt chunk is not expected to be automatically changed
> by the software.  To facilitate the use of RFC 1123 dates, a function
> png_convert_to_rfc1123(png_timep) is provided to convert from PNG
> time to an RFC 1123 format string.
> 
1062c1385
< checks to see if it has data that it can do somthing with, you should
---
> checks to see if it has data that it can do something with, you should
1105c1428
< one supported by PNG (ie 3 bit data in the range 0-7 for a 4-bit PNG),
---
> one supported by PNG (e.g. 3 bit data in the range 0-7 for a 4-bit PNG),
1113,1114c1436,1437
< supplied the other way (little-endian, ie. least significant bits
< first, eg. the way PCs store them):
---
> supplied the other way (little-endian, i.e. least significant bits
> first, the way PCs store them):
1134c1457,1472
<     png_set_invert(png_ptr);
---
>     png_set_invert_mono(png_ptr);
> 
> Finally, you can write your own transformation function if none of
> the existing ones meets your needs.  This is done by setting a callback
> with
> 
>     png_set_write_user_transform_fn(png_ptr,
>        write_transform_fn);
> 
> You must supply the function
> 
>     void write_transform_fn(png_ptr ptr, row_info_ptr
>        row_info, png_bytep data) 
> 
> See pngtest.c for a working example.  Your function will be called
> before any of the other transformations have been processed.
1151c1489
< png_write_flush()ls is called before 25 more lines have been written.
---
> png_write_flush() is called before 25 more lines have been written.
1153c1491
< RGB image) the image compression may decrease noticably (although this
---
> RGB image) the image compression may decrease noticeably (although this
1178c1516,1517
<     png_write_rows(png_ptr, row_pointers, number_of_rows);
---
>     png_write_rows(png_ptr, row_pointers,
>        number_of_rows);
1190,1192c1529,1531
< complicated.  The only currently (as of 6/96 -- PNG Specification
< version 1.0) defined interlacing scheme for PNG files is a
< compilcated interlace scheme, known as Adam7, that breaks down an
---
> complicated.  The only currently (as of February 1998 -- PNG Specification
> version 1.0, dated October 1996) defined interlacing scheme for PNG files
> is the "Adam7" interlace scheme, that breaks down an
1205c1544,1545
<     number_passes = png_set_interlace_handling(png_ptr);
---
>     number_of_passes =
>        png_set_interlace_handling(png_ptr);
1210c1550
< Then write the complete image number_passes times.
---
> Then write the complete image number_of_passes times.
1212c1552,1553
<     png_write_rows(png_ptr, row_pointers, number_of_rows);
---
>     png_write_rows(png_ptr, row_pointers,
>        number_of_rows);
1220,1221c1561,1562
< pass the an appropriately filled png_info pointer.  If you
< are not interested, you can pass NULL.
---
> pass an appropriately filled png_info pointer.  If you are not interested,
> you can pass NULL.
1242,1245c1583,1586
< All of the memory allocation, input/output, and error handling in
< libpng goes through callbacks which are user setable.  The default
< routines are in pngmem.c, pngrio.c, pngwio.c, and pngerror.c respectively.
< To change these functions, call the approprate png_set_???_fn() function.
---
> All of the memory allocation, input/output, and error handling in libpng
> goes through callbacks which are user settable.  The default routines are
> in pngmem.c, pngrio.c, pngwio.c, and pngerror.c respectively.  To change
> these functions, call the appropriate png_set_???_fn() function.
1251,1261c1592,1603
< your pointers can't access more then 64K at a time, you will want to
< set MAXSEG_64K in zlib.h.  Since it is unlikely that the method of
< handling memory allocation on a platform will change between applications,
< these functions must be modified in the library at compile time.
< 
< Input/Output in libpng is done throught png_read() and png_write(), which
< currently just call fread() and fwrite().  The FILE * is stored in
< png_struct, and is initialized via png_init_io().  If you wish to change
< the method of I/O, the library supplies callbacks that you can set through
< the function png_set_read_fn() and png_set_write_fn() at run time.  These
< functions also provide a void pointer that can be retrieved via the function
---
> your pointers can't access more then 64K at a time, you will want to set
> MAXSEG_64K in zlib.h.  Since it is unlikely that the method of handling
> memory allocation on a platform will change between applications, these
> functions must be modified in the library at compile time.
> 
> Input/Output in libpng is done through png_read() and png_write(),
> which currently just call fread() and fwrite().  The FILE * is stored in
> png_struct and is initialized via png_init_io().  If you wish to change
> the method of I/O, the library supplies callbacks that you can set
> through the function png_set_read_fn() and png_set_write_fn() at run
> time, instead of calling the png_init_io() function.  These functions
> also provide a void pointer that can be retrieved via the function
1264,1265c1606,1607
<     png_set_read_fn(png_structp png_ptr, voidp io_ptr,
<         png_rw_ptr read_data_fn)
---
>     png_set_read_fn(png_structp png_ptr,
>         voidp io_ptr, png_rw_ptr read_data_fn)
1267,1268c1609,1611
<     png_set_write_fn(png_structp png_ptr, voidp io_ptr,
<         png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn);
---
>     png_set_write_fn(png_structp png_ptr,
>         voidp io_ptr, png_rw_ptr write_data_fn,
>         png_flush_ptr output_flush_fn);
1274,1277c1617,1620
<     void user_read_data(png_structp png_ptr, png_bytep data,
<         png_uint_32 length);
<     void user_write_data(png_structp png_ptr, png_bytep data,
<         png_uint_32 length);
---
>     void user_read_data(png_structp png_ptr,
>         png_bytep data, png_uint_32 length);
>     void user_write_data(png_structp png_ptr,
>         png_bytep data, png_uint_32 length);
1286c1629
< should never return to it's caller.  Currently, this is handled via
---
> should never return to its caller.  Currently, this is handled via
1297,1298c1640,1642
<     png_set_error_fn(png_structp png_ptr, png_voidp error_ptr,
<         png_error_ptr error_fn, png_error_ptr warning_fn);
---
>     png_set_error_fn(png_structp png_ptr,
>         png_voidp error_ptr, png_error_ptr error_fn,
>         png_error_ptr warning_fn);
1307,1308c1651,1654
<     void user_error_fn(png_struct png_ptr, png_const_charp error_msg);
<     void user_warning_fn(png_struct png_ptr, png_const_charp warning_msg);
---
>     void user_error_fn(png_structp png_ptr,
>         png_const_charp error_msg);
>     void user_warning_fn(png_structp png_ptr,
>         png_const_charp warning_msg);
1315c1661
< setjmp returns non zero besides returning itself.  Consult your compiler
---
> setjmp returns non-zero besides returning itself.  Consult your compiler
1338c1684
< routines in pngmem.c, as these are requred to allocate 64K, although
---
> routines in pngmem.c, as these are required to allocate 64K, although
1342c1688
< won't be accessable.  So limit zlib and libpng to 64K by defining MAXSEG_64K.
---
> won't be accessible.  So limit zlib and libpng to 64K by defining MAXSEG_64K.
1353c1699
< complers.  Make sure MAXSEG_64K gets defined, USE_FAR_KEYWORD gets
---
> compilers.  Make sure MAXSEG_64K gets defined, USE_FAR_KEYWORD gets
1367c1713
< They can be changed later via png_set_error_fn().  On some compliers,
---
> They can be changed later via png_set_error_fn().  On some compilers,
1385,1386c1731,1732
< the range 3-6 compress as well as higher levels, and do so much faster.
< For online applications it may be desirable to have maximum speed
---
> the range 3-6 compress nearly as well as higher levels, and do so much
> faster.  For online applications it may be desirable to have maximum speed
1404,1405c1750,1753
<     png_set_compression_strategy(png_ptr, strategy);
<     png_set_compression_window_bits(png_ptr, window_bits);
---
>     png_set_compression_strategy(png_ptr,
>         strategy);
>     png_set_compression_window_bits(png_ptr,
>         window_bits);
1412,1419c1760,1772
< can call one of these functions.  Filtering is enabled by default for
< RGB and grayscale images (with and without alpha), and for 8-bit
< paletted images, but not for paletted images with bit depths less
< than 8 bits/pixel.  The 'method' parameter sets the main filtering
< method, which is currently only '0' in the PNG 1.0 specification.
< The 'filters' parameter sets which filter(s), if any, should be
< used for each scanline.  Possible values are PNG_ALL_FILTERS and
< PNG_NO_FILTERS to turn filtering on and off, respectively.
---
> can call one of these functions.  The selection and configuration
> of row filters can have a significant impact on the size and
> encoding speed and a somewhat lesser impact on the decoding speed
> of an image.  Filtering is enabled by default for RGB and grayscale
> images (with and without alpha), and for 8-bit paletted images, but
> not for paletted images with bit depths less than 8 bits/pixel.
> 
> The 'method' parameter sets the main filtering method, which is
> currently only '0' in the PNG 1.0 specification.  The 'filters'
> parameter sets which filter(s), if any, should be used for each
> scanline.  Possible values are PNG_ALL_FILTERS and PNG_NO_FILTERS
> to turn filtering on and off, respectively.
> 
1429,1430c1782,1785
<     filters = PNG_FILTER_NONE | PNG_FILTER_SUB | PNG_FILTER_UP;
<     png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, filters);
---
>     filters = PNG_FILTER_NONE | PNG_FILTER_SUB
>        | PNG_FILTER_UP;
>     png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE,
>        filters);
1438c1793,1794
<            costs[PNG_FILTER_VALUE_LAST] = {1.0, 1.3, 1.3, 1.5, 1.7};
---
>        costs[PNG_FILTER_VALUE_LAST] =
>        {1.0, 1.3, 1.3, 1.5, 1.7};
1440,1441c1796,1798
<     png_set_filter_selection(png_ptr, PNG_FILTER_SELECTION_WEIGHTED,
<        3, weights, costs);
---
>     png_set_filter_selection(png_ptr,
>        PNG_FILTER_SELECTION_WEIGHTED, 3,
>        weights, costs);
1458c1815
< the various filters, since this would unduely influence the final image
---
> the various filters, since this would unduly influence the final image
1470,1471c1827,1841
< before recompiling libpng and save yourself code and data space.  All
< the reading and writing specific code are in seperate files, so the
---
> before recompiling libpng and save yourself code and data space.
> You can also turn a number of them off en masse with a compiler directive
> that defines PNG_READ[or WRITE]_TRANSFORMS_NOT_SUPPORTED, or
> PNG_READ[or WRITE]_ANCILLARY_CHUNKS_NOT_SUPPORTED, or all four,
> along with directives to turn on any of the capabilities that you do
> want.  The PNG_READ[or WRITE]_TRANSFORMS_NOT_SUPPORTED directives disable
> the extra transformations but still leave the library fully capable of reading
> and writing PNG files with all known public chunks [except for sPLT].
> Use of the PNG_READ[or WRITE]_ANCILLARY_CHUNKS_NOT_SUPPORTED directive
> produces a library that is incapable of reading or writing ancillary chunks.
> If you are not using the progressive reading capability, you can
> turn that off with PNG_PROGRESSIVE_READ_NOT_SUPPORTED (don't confuse
> this with the INTERLACING capability, which you'll still have).
> 
> All the reading and writing specific code are in separate files, so the
1489,1492c1859,1864
< It should be noted that versions of libpng later than 0.88 are not
< distributed by the original libpng author, Guy Schalnat, but rather
< another member of the original PNG Group, Andreas Dilger.  Guy is still
< alive and well, but has just moved on to other things.
---
> It should be noted that versions of libpng later than 0.96 are not
> distributed by the original libpng author, Guy Schalnat, nor by
> Andreas Dilger, who had taken over from Guy during 1996 and 1997, and
> distributed versions 0.89 through 0.96, but rather by another member
> of the original PNG Group, Glenn Randers-Pehrson.  Guy and Andreas are
> still alive and well, but they have moved on to other things.
Index: pngtest.pn,b60
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/pngtest.pn,b60,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
Binary files /tmp/cvsRo3no9 and /tmp/cvsn9xDep differ
Index: c/ansi2knr
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/ansi2knr,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
1,2d0
< /* Copyright (C) 1989, 1991, 1993 Aladdin Enterprises. All rights reserved. */
< 
4c2
< /* Convert ANSI function declarations to K&R syntax */
---
> /* Convert ANSI C function definitions to K&R ("traditional C") syntax */
7,19c5,25
< ansi2knr is distributed in the hope that it will be useful, but
< WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility
< to anyone for the consequences of using it or for whether it serves any
< particular purpose or works at all, unless he says so in writing.  Refer
< to the GNU General Public License for full details.
< 
< Everyone is granted permission to copy, modify and redistribute
< ansi2knr, but only under the conditions described in the GNU
< General Public License.  A copy of this license is supposed to have been
< given to you along with ansi2knr so you can know your rights and
< responsibilities.  It should be in a file named COPYING.  Among other
< things, the copyright notice and this notice must be preserved on all
< copies.
---
> ansi2knr is distributed in the hope that it will be useful, but WITHOUT ANY
> WARRANTY.  No author or distributor accepts responsibility to anyone for the
> consequences of using it or for whether it serves any particular purpose or
> works at all, unless he says so in writing.  Refer to the GNU General Public
> License (the "GPL") for full details.
> 
> Everyone is granted permission to copy, modify and redistribute ansi2knr,
> but only under the conditions described in the GPL.  A copy of this license
> is supposed to have been given to you along with ansi2knr so you can know
> your rights and responsibilities.  It should be in a file named COPYLEFT.
> [In the IJG distribution, the GPL appears below, not in a separate file.]
> Among other things, the copyright notice and this notice must be preserved
> on all copies.
> 
> We explicitly state here what we believe is already implied by the GPL: if
> the ansi2knr program is distributed as a separate set of sources and a
> separate executable file which are aggregated on a storage medium together
> with another program, this in itself does not bring the other program under
> the GPL, nor does the mere fact that such a program or the procedures for
> constructing it invoke the ansi2knr executable bring any other part of the
> program under the GPL.
23c29
< ---------- Here is the GNU GPL file COPYING, referred to above ----------
---
> ---------- Here is the GNU GPL file COPYLEFT, referred to above ----------
169c175
< -------------------- End of file COPYING ------------------------------
---
> -------------------- End of file COPYLEFT ------------------------------
171a178,234
> /*
>  * Usage:
> 	ansi2knr input_file [output_file]
>  * If no output_file is supplied, output goes to stdout.
>  * There are no error messages.
>  *
>  * ansi2knr recognizes function definitions by seeing a non-keyword
>  * identifier at the left margin, followed by a left parenthesis,
>  * with a right parenthesis as the last character on the line,
>  * and with a left brace as the first token on the following line
>  * (ignoring possible intervening comments).
>  * It will recognize a multi-line header provided that no intervening
>  * line ends with a left or right brace or a semicolon.
>  * These algorithms ignore whitespace and comments, except that
>  * the function name must be the first thing on the line.
>  * The following constructs will confuse it:
>  *	- Any other construct that starts at the left margin and
>  *	    follows the above syntax (such as a macro or function call).
>  *	- Some macros that tinker with the syntax of the function header.
>  */
> 
> /*
>  * The original and principal author of ansi2knr is L. Peter Deutsch
>  * <ghost@aladdin.com>.  Other authors are noted in the change history
>  * that follows (in reverse chronological order):
> 	lpd 96-01-21 added code to cope with not HAVE_CONFIG_H and with
> 		compilers that don't understand void, as suggested by
> 		Tom Lane
> 	lpd 96-01-15 changed to require that the first non-comment token
> 		on the line following a function header be a left brace,
> 		to reduce sensitivity to macros, as suggested by Tom Lane
> 		<tgl@sss.pgh.pa.us>
> 	lpd 95-06-22 removed #ifndefs whose sole purpose was to define
> 		undefined preprocessor symbols as 0; changed all #ifdefs
> 		for configuration symbols to #ifs
> 	lpd 95-04-05 changed copyright notice to make it clear that
> 		including ansi2knr in a program does not bring the entire
> 		program under the GPL
> 	lpd 94-12-18 added conditionals for systems where ctype macros
> 		don't handle 8-bit characters properly, suggested by
> 		Francois Pinard <pinard@iro.umontreal.ca>;
> 		removed --varargs switch (this is now the default)
> 	lpd 94-10-10 removed CONFIG_BROKETS conditional
> 	lpd 94-07-16 added some conditionals to help GNU `configure',
> 		suggested by Francois Pinard <pinard@iro.umontreal.ca>;
> 		properly erase prototype args in function parameters,
> 		contributed by Jim Avera <jima@netcom.com>;
> 		correct error in writeblanks (it shouldn't erase EOLs)
> 	lpd 89-xx-xx original version
>  */
> 
> /* Most of the conditionals here are to make ansi2knr work with */
> /* or without the GNU configure machinery. */
> 
> #if HAVE_CONFIG_H
> # include <config.h>
> #endif
176,184c239
< #ifdef BSD
< #include <strings.h>
< #else
< #ifdef VMS
< 	extern int strlen(), strncmp();
< #else
< #include <string.h>
< #endif
< #endif
---
> #if HAVE_CONFIG_H
186,189c241,269
< /* malloc and free should be declared in stdlib.h, */
< /* but if you've got a K&R compiler, they probably aren't. */
< #ifdef MSDOS
< #include <malloc.h>
---
> /*
>    For properly autoconfiguring ansi2knr, use AC_CONFIG_HEADER(config.h).
>    This will define HAVE_CONFIG_H and so, activate the following lines.
>  */
> 
> # if STDC_HEADERS || HAVE_STRING_H
> #  include <string.h>
> # else
> #  include <strings.h>
> # endif
> 
> #else /* not HAVE_CONFIG_H */
> 
> /* Otherwise do it the hard way */
> 
> # ifdef BSD
> #  include <strings.h>
> # else
> #  ifdef VMS
>     extern int strlen(), strncmp();
> #  else
> #   include <string.h>
> #  endif
> # endif
> 
> #endif /* not HAVE_CONFIG_H */
> 
> #if STDC_HEADERS
> # include <stdlib.h>
191c271,278
< #ifdef VMS
---
> /*
>    malloc and free should be declared in stdlib.h,
>    but if you've got a K&R compiler, they probably aren't.
>  */
> # ifdef MSDOS
> #  include <malloc.h>
> # else
> #  ifdef VMS
194c281
< #else
---
> #  else
197c284,286
< #endif
---
> #  endif
> # endif
> 
200,216c289,291
< /* Usage:
< 	ansi2knr input_file [output_file]
<  * If no output_file is supplied, output goes to stdout.
<  * There are no error messages.
<  *
<  * ansi2knr recognizes functions by seeing a non-keyword identifier
<  * at the left margin, followed by a left parenthesis,
<  * with a right parenthesis as the last character on the line.
<  * It will recognize a multi-line header provided that the last character
<  * of the last line of the header is a right parenthesis,
<  * and no intervening line ends with a left brace or a semicolon.
<  * These algorithms ignore whitespace and comments, except that
<  * the function name must be the first thing on the line.
<  * The following constructs will confuse it:
<  *	- Any other construct that starts at the left margin and
<  *	    follows the above syntax (such as a macro or function call).
<  *	- Macros that tinker with the syntax of the function header.
---
> /*
>  * The ctype macros don't always handle 8-bit characters correctly.
>  * Compensate for this here.
217a293,306
> #ifdef isascii
> #  undef HAVE_ISASCII		/* just in case */
> #  define HAVE_ISASCII 1
> #else
> #endif
> #if STDC_HEADERS || !HAVE_ISASCII
> #  define is_ascii(c) 1
> #else
> #  define is_ascii(c) isascii(c)
> #endif
> 
> #define is_space(c) (is_ascii(c) && isspace(c))
> #define is_alpha(c) (is_ascii(c) && isalpha(c))
> #define is_alnum(c) (is_ascii(c) && isalnum(c))
220,221c309,310
< #define isidchar(ch) (isalnum(ch) || (ch) == '_')
< #define isidfirstchar(ch) (isalpha(ch) || (ch) == '_')
---
> #define isidchar(ch) (is_alnum(ch) || (ch) == '_')
> #define isidfirstchar(ch) (is_alpha(ch) || (ch) == '_')
229a319
> int
236a327,348
> 	char *more;
> 	/*
> 	 * In previous versions, ansi2knr recognized a --varargs switch.
> 	 * If this switch was supplied, ansi2knr would attempt to convert
> 	 * a ... argument to va_alist and va_dcl; if this switch was not
> 	 * supplied, ansi2knr would simply drop any such arguments.
> 	 * Now, ansi2knr always does this conversion, and we only
> 	 * check for this switch for backward compatibility.
> 	 */
> 	int convert_varargs = 1;
> 
> 	if ( argc > 1 && argv[1][0] == '-' )
> 	  {	if ( !strcmp(argv[1], "--varargs") )
> 		  {	convert_varargs = 1;
> 			argc--;
> 			argv++;
> 		  }
> 		else
> 		  {	fprintf(stderr, "Unrecognized switch: %s\n", argv[1]);
> 			exit(1);
> 		  }
> 	  }
243c355,356
< 		out = stdout; break;
---
> 		out = stdout;
> 		break;
247c360
< 		   {	fprintf(stderr, "Cannot open %s\n", argv[2]);
---
> 		   {	fprintf(stderr, "Cannot open output file %s\n", argv[2]);
253c366
< 	   {	fprintf(stderr, "Cannot open %s\n", argv[1]);
---
> 	   {	fprintf(stderr, "Cannot open input file %s\n", argv[1]);
260c373,375
< 	   {	switch ( test1(buf) )
---
> 	   {
> test:		line += strlen(line);
> 		switch ( test1(buf) )
261a377,379
> 		case 2:			/* a function header */
> 			convert1(buf, out, 1, convert_varargs);
> 			break;
263c381,406
< 			convert1(buf, out);
---
> 			/* Check for a { at the start of the next line. */
> 			more = ++line;
> f:			if ( line >= buf + (bufsize - 1) ) /* overflow check */
> 			  goto wl;
> 			if ( fgets(line, (unsigned)(buf + bufsize - line), in) == NULL )
> 			  goto wl;
> 			switch ( *skipspace(more, 1) )
> 			  {
> 			  case '{':
> 			    /* Definitely a function header. */
> 			    convert1(buf, out, 0, convert_varargs);
> 			    fputs(more, out);
> 			    break;
> 			  case 0:
> 			    /* The next line was blank or a comment: */
> 			    /* keep scanning for a non-comment. */
> 			    line += strlen(line);
> 			    goto f;
> 			  default:
> 			    /* buf isn't a function header, but */
> 			    /* more might be. */
> 			    fputs(buf, out);
> 			    strcpy(buf, more);
> 			    line = buf;
> 			    goto test;
> 			  }
266d408
< 			line = buf + strlen(buf);
268c410
< 				continue;
---
> 			  continue;
271c413
< 			fputs(buf, out);
---
> wl:			fputs(buf, out);
276c418,419
< 	if ( line != buf ) fputs(buf, out);
---
> 	if ( line != buf )
> 	  fputs(buf, out);
289,290c432,435
< 	   {	while ( isspace(*p) ) p += dir;
< 		if ( !(*p == '/' && p[dir] == '*') ) break;
---
> 	   {	while ( is_space(*p) )
> 		  p += dir;
> 		if ( !(*p == '/' && p[dir] == '*') )
> 		  break;
293c438,439
< 		   {	if ( *p == 0 ) return p;	/* multi-line comment?? */
---
> 		   {	if ( *p == 0 )
> 			  return p;	/* multi-line comment?? */
302a449
>  * Don't overwrite end-of-line characters.
309c456,458
< 	for ( p = start; p < end; p++ ) *p = ' ';
---
> 	for ( p = start; p < end; p++ )
> 	  if ( *p != '\r' && *p != '\n' )
> 	    *p = ' ';
318a468
>  *	2 - definitely a function prototype (NOT USED);
320a471,473
>  * The reason we don't attempt to convert function prototypes is that
>  * Ghostscript's declaration-generating macros look too much like
>  * prototypes, and confuse the algorithms.
328a482
> 
330c484
< 		return 0;		/* no name at left margin */
---
> 	  return 0;		/* no name at left margin */
334,337c488,492
< 	case ')': contin = 1; break;
< 	case '{':
< 	case ';': return 0;		/* not a function */
< 	default: contin = -1;
---
> 	   case ';': contin = 0 /*2*/; break;
> 	   case ')': contin = 1; break;
> 	   case '{': return 0;		/* not a function */
> 	   case '}': return 0;		/* not a function */
> 	   default: contin = -1;
339c494,495
< 	while ( isidchar(*p) ) p++;
---
> 	while ( isidchar(*p) )
> 	  p++;
343c499
< 		return 0;		/* not a function */
---
> 	  return 0;		/* not a function */
346c502
< 		return 0;		/* no parameters */
---
> 	  return 0;		/* no parameters */
359a516
> 
362c519
< 				return 0;	/* name is a keyword */
---
> 			  return 0;	/* name is a keyword */
368a526
> /* Convert a recognized function definition or header to K&R syntax. */
370c528
< convert1(buf, out)
---
> convert1(buf, out, header, convert_varargs)
372a531,532
>     int header;			/* Boolean */
>     int convert_varargs;	/* Boolean */
379a540,541
> 	char *vararg = 0;
> 
382c544,545
< 	for ( endfn = buf; *(endfn++) != '('; ) ;
---
> 	for ( endfn = buf; *(endfn++) != '('; )
> 	  ;
395a559,560
> 		char *lp = NULL;
> 		char *rp;
396a562
> 
409,413c575,590
< 			case ',': if ( !level ) end = p; break;
< 			case '(': level++; break;
< 			case ')': if ( --level < 0 ) end = p; break;
< 			case '/': p = skipspace(p, 1) - 1; break;
< 			default: ;
---
> 			   case ',':
> 				if ( !level ) end = p;
> 				break;
> 			   case '(':
> 				if ( !level ) lp = p;
> 				level++;
> 				break;
> 			   case ')':
> 				if ( --level < 0 ) end = p;
> 				else rp = p;
> 				break;
> 			   case '/':
> 				p = skipspace(p, 1) - 1;
> 				break;
> 			   default:
> 				;
415a593,595
> 		/* Erase any embedded prototype parameters. */
> 		if ( lp )
> 		  writeblanks(lp + 1, rp);
424,425c604,605
< 			case ']':	/* skip array dimension(s) */
< 			case ')':	/* skip procedure args OR name */
---
> 			   case ']':	/* skip array dimension(s) */
> 			   case ')':	/* skip procedure args OR name */
430,433c610,613
< 				case ']': case ')': level++; break;
< 				case '[': case '(': level--; break;
< 				case '/': p = skipspace(p, -1) + 1; break;
< 				default: ;
---
> 				   case ']': case ')': level++; break;
> 				   case '[': case '(': level--; break;
> 				   case '/': p = skipspace(p, -1) + 1; break;
> 				   default: ;
439c619
< 						p = skipspace(p, 1) + 1;
---
> 					  p = skipspace(p, 1) + 1;
443c623,624
< 			default: goto found;
---
> 			   default:
> 				goto found;
447,449c628,631
< 		   {	p++;
< 			if ( bp == breaks + 1 )	/* sole argument */
< 				writeblanks(breaks[0], p);
---
> 		  {	if ( convert_varargs )
> 			  {	*bp++ = "va_alist";
> 				vararg = p-2;
> 			  }
451,452c633,639
< 				writeblanks(bp[-1] - 1, p);
< 			bp--;
---
> 			  {	p++;
> 				if ( bp == breaks + 1 )	/* sole argument */
> 				  writeblanks(breaks[0], p);
> 				else
> 				  writeblanks(bp[-1] - 1, p);
> 				bp--;
> 			  }
473c660
< 	/* Put out the function name */
---
> 	/* Put out the function name and left parenthesis. */
476,485c663,690
< 	/* Put out the declaration */
< 	for ( ap = breaks+1; ap < bp; ap += 2 )
< 	   {	p = *ap;
< 		while ( isidchar(*p) ) putc(*p, out), p++;
< 		if ( ap < bp - 1 ) fputs(", ", out);
< 	   }
< 	fputs(")  ", out);
< 	/* Put out the argument declarations */
< 	for ( ap = breaks+2; ap <= bp; ap += 2 ) (*ap)[-1] = ';';
< 	fputs(breaks[0], out);
---
> 	/* Put out the declaration. */
> 	if ( header )
> 	  {	fputs(");", out);
> 		for ( p = breaks[0]; *p; p++ )
> 		  if ( *p == '\r' || *p == '\n' )
> 		    putc(*p, out);
> 	  }
> 	else
> 	  {	for ( ap = breaks+1; ap < bp; ap += 2 )
> 		  {	p = *ap;
> 			while ( isidchar(*p) )
> 			  putc(*p, out), p++;
> 			if ( ap < bp - 1 )
> 			  fputs(", ", out);
> 		  }
> 		fputs(")  ", out);
> 		/* Put out the argument declarations */
> 		for ( ap = breaks+2; ap <= bp; ap += 2 )
> 		  (*ap)[-1] = ';';
> 		if ( vararg != 0 )
> 		  {	*vararg = 0;
> 			fputs(breaks[0], out);		/* any prior args */
> 			fputs("va_dcl", out);		/* the final arg */
> 			fputs(bp[0], out);
> 		  }
> 		else
> 		  fputs(breaks[0], out);
> 	  }
Index: c/example
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/example,v
retrieving revision 1.1
retrieving revision 1.4
diff -r1.1 -r1.4
0a1
> 
4,33c5,34
<    The file libpng.txt is much more verbose then this.  If you have not
<    read it, do so first.  This was designed to be a starting point of an
<    implementation.  This is not officially part of libpng, and therefore
<    does not require a copyright notice.
< 
<    This file does not currently compile, because it is missing certain
<    parts, like allocating memory to hold an image.  You will have to
<    supply these parts to get it to compile.  For an example of a minimal
<    working PNG reader/writer, see pngtest.c, included in this distribution.
< */
< 
< #include <png.h>
< 
< /* Check to see if a file is a PNG file using png_check_sig().  Returns
<    non-zero if the image is a PNG, and 0 if it isn't a PNG.
< 
<    If this call is successful, and you are going to keep the file open,
<    you should call png_set_sig_bytes(png_ptr, PNG_BYTES_TO_CHECK); once
<    you have created the png_ptr, so that libpng knows your application
<    has read that many bytes from the start of the file.  Make sure you
<    don't call png_set_sig_bytes() with more than 8 bytes read or give it
<    an incorrect number of bytes read, or you will either have read too
<    many bytes (your fault), or you are telling libpng to read the wrong
<    number of magic bytes (also your fault).
< 
<    Many applications already read the first 2 or 4 bytes from the start
<    of the image to determine the file type, so it would be easiest just
<    to pass the bytes to png_check_sig() or even skip that if you know
<    you have a PNG file, and call png_set_sig_bytes().
< */
---
>  * The file libpng.txt is much more verbose then this.  If you have not
>  * read it, do so first.  This was designed to be a starting point of an
>  * implementation.  This is not officially part of libpng, and therefore
>  * does not require a copyright notice.
>  *
>  * This file does not currently compile, because it is missing certain
>  * parts, like allocating memory to hold an image.  You will have to
>  * supply these parts to get it to compile.  For an example of a minimal
>  * working PNG reader/writer, see pngtest.c, included in this distribution.
>  */
> 
> #include "png.h"
> 
> /* Check to see if a file is a PNG file using png_sig_cmp().  Returns
>  * non-zero if the image is a PNG, and 0 if it isn't a PNG.
>  *
>  * If this call is successful, and you are going to keep the file open,
>  * you should call png_set_sig_bytes(png_ptr, PNG_BYTES_TO_CHECK); once
>  * you have created the png_ptr, so that libpng knows your application
>  * has read that many bytes from the start of the file.  Make sure you
>  * don't call png_set_sig_bytes() with more than 8 bytes read or give it
>  * an incorrect number of bytes read, or you will either have read too
>  * many bytes (your fault), or you are telling libpng to read the wrong
>  * number of magic bytes (also your fault).
>  *
>  * Many applications already read the first 2 or 4 bytes from the start
>  * of the image to determine the file type, so it would be easiest just
>  * to pass the bytes to png_sig_cmp() or even skip that if you know
>  * you have a PNG file, and call png_set_sig_bytes().
>  */
48c49
<    return(png_check_sig(buf, PNG_BYTES_TO_CHECK));
---
>    return(png_sig_cmp(buf, (png_size_t)0, PNG_BYTES_TO_CHECK));
52,56c53,58
<    fails (depending upon the failure).  There are two "prototypes" given
<    here - one where we are given the filename, and we need to open the
<    file, and the other where we are given an open file (possibly with
<    some or all of the magic bytes read - see comments above). */
< **** prototype 1 ****
---
>  * fails (depending upon the failure).  There are two "prototypes" given
>  * here - one where we are given the filename, and we need to open the
>  * file, and the other where we are given an open file (possibly with
>  * some or all of the magic bytes read - see comments above).
>  */
> #ifdef open_file /* prototype 1 */
68c70
< **** prototype 2 ****
---
> #else no_open_file /* prototype 2 */
75c77
< **** only use one prototype! ****
---
> #endif no_open_file /* only use one prototype! */
93c95
<    info_ptr = png_create_info_struct();
---
>    info_ptr = png_create_info_struct(png_ptr);
115c117
< **** PNG file I/O method 1 ****
---
> #ifdef streams /* PNG file I/O method 1 */
119c121
< **** PNG file I/O method 2 ****
---
> #else no_streams /* PNG file I/O method 2 */
121c123,124
<     * png_init_io() here you would call */
---
>     * png_init_io() here you would call:
>     */
124c127
< **** Use only one I/O method! ****
---
> #endif no_streams /* Use only one I/O method! */
127c130
<    png_set_sig_bytes_read(png_ptr, sig_read);
---
>    png_set_sig_bytes(png_ptr, sig_read);
146,147c149,151
<    /* strip alpha bytes from the input data without combining with th
<     * background (not recommended) */
---
>    /* Strip alpha bytes from the input data without combining with th
>     * background (not recommended).
>     */
150c154
<    /* extract multiple pixels with bit depths of 1, 2, and 4 from a single
---
>    /* Extract multiple pixels with bit depths of 1, 2, and 4 from a single
155c159
<    /* change the order of packed pixels to least significant bit first
---
>    /* Change the order of packed pixels to least significant bit first
159c163
<    /* expand paletted colors into true RGB triplets */
---
>    /* Expand paletted colors into true RGB triplets */
163c167
<    /* expand grayscale images to the full 8 bits from 1, 2, or 4 bits/pixel */
---
>    /* Expand grayscale images to the full 8 bits from 1, 2, or 4 bits/pixel */
167,168c171,173
<    /* expand paletted or RGB images with transparency to full alpha channels
<     * so the data will be available as RGBA quartets */
---
>    /* Expand paletted or RGB images with transparency to full alpha channels
>     * so the data will be available as RGBA quartets.
>     */
179c184
<    png_color_16 my_background, *image_background);
---
>    png_color_16 my_background, *image_background;
181,182c186,187
<    if (png_get_bKGD(png_ptr, info_ptr, &image_background);
<       png_set_background(png_ptr, image_background),
---
>    if (png_get_bKGD(png_ptr, info_ptr, &image_background))
>       png_set_background(png_ptr, image_background,
188a194,195
> 
>    /* Note that screen gamma is (display_gamma/viewing_gamma) */
194c201
<    else if ((gamma_str = getenv("DISPLAY_GAMMA")) != NULL)
---
>    else if ((gamma_str = getenv("SCREEN_GAMMA")) != NULL)
201c208,209
<       screen_gamma = 2.2;  /* A good guess for PC monitors */
---
>       screen_gamma = 2.2;  /* A good guess for a PC monitors in a dimly
>                               lit room */
210,213c218,227
<    if (png_get_gAMA(png_ptr, info_ptr, &image_gamma);
<       png_set_gamma(png_ptr, screen_gamma, image_gamma);
<    else
<       png_set_gamma(png_ptr, screen_gamma, 0.45);
---
> 
>    int intent;
> 
>    if (png_get_sRGB(png_ptr, info_ptr, &intent))
>       png_set_sRGB(png_ptr, intent, 0);
>    else 
>       if (png_get_gAMA(png_ptr, info_ptr, &image_gamma))
>          png_set_gamma(png_ptr, screen_gamma, image_gamma);
>       else
>          png_set_gamma(png_ptr, screen_gamma, 0.50);
216c230,231
<       to the number of colors available on your screen */
---
>     * to the number of colors available on your screen.
>     */
223c238
<       if (we have our own palette)
---
>       if (/* we have our own palette */)
232c247
<       else if (png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette)))
---
>       else if (png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette))
244c259
<    png_set_invert(png_ptr);
---
>    png_set_invert_mono(png_ptr);
272c287
<     * see the png_read_row() method below.
---
>     * see the png_read_row() method below:
276c291
<    /* optional call to gamma correct and add the background to the palette
---
>    /* Optional call to gamma correct and add the background to the palette
282c297
<    /* allocate the memory to hold the image using the fields of info_ptr. */
---
>    /* Allocate the memory to hold the image using the fields of info_ptr. */
284c299
<    /* the easiest way to read the image */
---
>    /* The easiest way to read the image: */
293c308
< **** Read the entire image in one go ****
---
> #ifdef entire /* Read the entire image in one go */
296,297c311,312
< **** Read the image one or more scanlines at a time ****
<    /* the other way to read images - deal with interlacing */
---
> #else no_entire /* Read the image one or more scanlines at a time */
>    /* The other way to read images - deal with interlacing: */
301c316
< [[[[[[[ Read the image a single row at a time ]]]]]]]
---
> #ifdef single /* Read the image a single row at a time */
308c323
< [[[[[[[ Read the image several rows at a time ]]]]]]]
---
> #else no_single /* Read the image several rows at a time */
311c326
< <<<<<<<<<< Read the image using the "sparkle" effect. >>>>>>>>>>
---
> #ifdef sparkle /* Read the image using the "sparkle" effect. */
314c329
< <<<<<<<<<< Read the image using the "rectangle" effect >>>>>>>>>>
---
> #else no_sparkle /* Read the image using the "rectangle" effect */
316c331
< <<<<<<<<<< use only one of these two methods >>>>>>>>>>
---
> #endif no_sparkle /* use only one of these two methods */
321c336
< [[[[[[[ use only one of these two methods ]]]]]]]
---
> #endif no_single /* use only one of these two methods */
323c338
< **** use only one of these two methods ****
---
> #endif no_entire /* use only one of these two methods */
468c483
< void write_png(char *file_name, ... other image information ...)
---
> void write_png(char *file_name /* , ... other image information ... */)
515c530
< **** I/O initialization method 1 ****
---
> #ifdef streams /* I/O initialization method 1 */
518c533
< **** I/O initialization method 2 ****
---
> #else no_streams /* I/O initialization method 2 */
524c539
< **** only use 1 initialization method ****
---
> #endif no_streams /* only use one initialization method */
538,539c553,554
<    palette = png_malloc(png_ptr, 256 * sizeof (png_color));
<    ... set palette colors ...
---
>    palette = (png_colorp)png_malloc(png_ptr, 256 * sizeof (png_color));
>    /* ... set palette colors ... */
555c570,571
<     * as to the correct gamma of the image. */
---
>     * as to the correct gamma of the image.
>     */
570a587,588
>    /* note that if sRGB is present the cHRM chunk must be ignored
>     * on read and must be written in accordance with the sRGB profile */
582c600,601
<     * all optional.  Only call them if you want them. */
---
>     * all optional.  Only call them if you want them.
>     */
585c604
<    png_set_invert(png_ptr);
---
>    png_set_invert_mono(png_ptr);
588c607,608
<     * as appropriate to correctly scale the image */
---
>     * as appropriate to correctly scale the image.
>     */
598c618,619
<     * RGB (4 channels -> 3 channels). The second parameter is not used. */
---
>     * RGB (4 channels -> 3 channels). The second parameter is not used.
>     */
623c644
< **** write out the entire image data in one call ***
---
> #ifdef entire /* write out the entire image data in one call */
628c649
< **** write out the image data by one or more scanlines ****
---
> #else no_entire /* write out the image data by one or more scanlines */
644c665
< **** use only one output method ****
---
> #endif no_entire /* use only one output method */
Index: c/png
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/png,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
2,9c2,10
< /* png.c - location for general purpose png functions
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
> /* png.c - location for general purpose libpng functions
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  */
16,17c17,19
<    string defined in png.h */
< char png_libpng_ver[] = "0.95";
---
>  * string defined in png.h.
>  */
> char png_libpng_ver[6] = "1.0.0";
19c21
< /* Place to hold the signiture string for a PNG file. */
---
> /* Place to hold the signature string for a PNG file. */
22,24c24,27
< /* constant strings for known chunk types.  If you need to add a chunk,
<    add a string holding the name here.  If you want to make the code
<    portable to EBCDIC machines, use ASCII numbers, not characters. */
---
> /* Constant strings for known chunk types.  If you need to add a chunk,
>  * add a string holding the name here.  If you want to make the code
>  * portable to EBCDIC machines, use ASCII numbers, not characters.
>  */
36a40
> png_byte FARDATA png_sRGB[5] = {115,  82,  71,  66, '\0'};
56,58c60,61
< /* width of interlace block */
< /* this is not currently used - if you need it, uncomment it here and
<    in png.h
---
> /* Width of interlace block.  This is not currently used - if you need
>  * it, uncomment it here and in png.h
62,64c65,66
< /* height of interlace block */
< /* this is not currently used - if you need it, uncomment it here and
<    in png.h
---
> /* Height of interlace block.  This is not currently used - if you need
>  * it, uncomment it here and in png.h
68c70
< /* mask to determine which pixels are valid in a pass */
---
> /* Mask to determine which pixels are valid in a pass */
71c73
< /* mask to determine which pixels to overwrite while displaying */
---
> /* Mask to determine which pixels to overwrite while displaying */
104c106
<       return 0;
---
>       return (0);
107c109
<       return 0;
---
>       return (0);
112c114
<    return (png_memcmp(&sig[start], &png_sig[start], num_to_check));
---
>    return ((int)(png_memcmp(&sig[start], &png_sig[start], num_to_check)));
116,117c118,120
<    to check a partial signature.  This function will be removed in the
<    future - use png_sig_cmp(). */
---
>  * to check a partial signature.  This function will be removed in the
>  * future - use png_sig_cmp().
>  */
121c124
<   return !png_sig_cmp(sig, (png_size_t)0, (png_size_t)num);
---
>   return ((int)!png_sig_cmp(sig, (png_size_t)0, (png_size_t)num));
132c135
<    ptr = png_malloc((png_structp)png_ptr, num_bytes);
---
>    ptr = (png_voidp)png_malloc((png_structp)png_ptr, num_bytes);
143c146
<    return (voidpf)(ptr);
---
>    return ((voidpf)ptr);
154c157,158
<    in case CRC is > 32 bits to leave the top bits 0. */
---
>  * in case CRC is > 32 bits to leave the top bits 0.
>  */
158,161d161
<    /* set CRC to all 1's */
< #ifdef PNG_USE_OWN_CRC
<    png_ptr->crc = 0xffffffffL;
< #else
163,218d162
< #endif
< }
< 
< #ifdef PNG_USE_OWN_CRC
< /* Table of CRCs of all 8-bit messages.  By default, we use the tables made
<    by zlib, to save some memory.  If you wish to png_malloc() this
<    table, turn this into a pointer, and png_malloc() it in make_crc_table().
<    You may then want to hook it into png_struct and free it with the
<    destroy functions.  Another alternative is to pre-fill the table.  */
< static png_uint_32 crc_table[256];
< 
< /* Flag: has the table been computed? Initially false. */
< static int crc_table_computed = 0;
< 
< /* make the table for a fast crc */
< static void
< make_crc_table(void)
< {
<   png_uint_32 c;
<   int n, k;
< 
<   for (n = 0; n < 256; n++)
<   {
<    c = (png_uint_32)n;
<    for (k = 0; k < 8; k++)
<      c = c & 1 ? 0xedb88320L ^ (c >> 1) : c >> 1;
<    crc_table[n] = c;
<   }
<   crc_table_computed = 1;
< }
< 
< /* Update a running CRC with the bytes buf[0..len-1] - the CRC should be
<    initialized to all 1's, and the transmitted value is the 1's complement
<    of the final running CRC. */
< static png_uint_32
< update_crc(png_uint_32 crc, png_bytep buf, png_size_t len)
< {
<   png_uint_32 c;
<   png_bytep p;
<   png_uint_32 n;
< 
<   c = crc;
<   p = buf;
<   n = len;
< 
<   if (!crc_table_computed)
<   {
<    make_crc_table();
<   }
< 
<   if (n > 0) do
<   {
<    c = crc_table[(png_byte)((c ^ (*p++)) & 0xff)] ^ (c >> 8);
<   } while (--n);
< 
<   return c;
220d163
< #endif /* PNG_USE_OWN_CRC */
223,225c166,169
<    much data to this routine as the largest single buffer size.  We
<    also check that this data will actually be used before going to the
<    trouble of calculating it. */
---
>  * much data to this routine as the largest single buffer size.  We
>  * also check that this data will actually be used before going to the
>  * trouble of calculating it.
>  */
244,248c188
< #ifdef PNG_USE_OWN_CRC
<       png_ptr->crc = update_crc(png_ptr->crc, ptr, length);
< #else
<       png_ptr->crc = crc32(png_ptr->crc, ptr, length);
< #endif
---
>       png_ptr->crc = crc32(png_ptr->crc, ptr, (uInt)length);
252,255c192,196
<    really need the png_ptr, but it could potentially be useful in the
<    future.  This should be used in favour of malloc(sizeof(png_info))
<    and png_info_init() so that applications that want to use a shared
<    libpng don't have to be recompiled if png_info changes size. */
---
>  * really need the png_ptr, but it could potentially be useful in the
>  * future.  This should be used in favour of malloc(sizeof(png_info))
>  * and png_info_init() so that applications that want to use a shared
>  * libpng don't have to be recompiled if png_info changes size.
>  */
261a203
>    if(png_ptr == NULL) return (NULL);
267c209
<    return info_ptr;
---
>    return (info_ptr);
271,273c213,216
<    Normally, one would use either png_destroy_read_struct() or
<    png_destroy_write_struct() to free an info struct, but this may be
<    useful for some applications. */
---
>  * Normally, one would use either png_destroy_read_struct() or
>  * png_destroy_write_struct() to free an info struct, but this may be
>  * useful for some applications.
>  */
293,294c236,238
<    and applications using it are urged to use png_create_info_struct()
<    instead. */
---
>  * and applications using it are urged to use png_create_info_struct()
>  * instead.
>  */
328c272
<       for (i = 0; i < info_ptr->pcal_nparams; i++)
---
>       for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
340,341c284,286
<    functions.  The application should free any memory associated with this
<    pointer before png_write_destroy() or png_read_destroy() are called. */
---
>  * functions.  The application should free any memory associated with this
>  * pointer before png_write_destroy() or png_read_destroy() are called.
>  */
345c290
<    return png_ptr->io_ptr;
---
>    return (png_ptr->io_ptr);
350,351c295,297
<    use your own read or write routines, you can call either png_set_read_fn()
<    or png_set_write_fn() instead of png_init_io(). */
---
>  * use your own read or write routines, you can call either png_set_read_fn()
>  * or png_set_write_fn() instead of png_init_io().
>  */
359,363d304
< 
< void png_init(void)
< {
<     zlib_init();
< }
Index: c/pngerror
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngerror,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,13c3,15
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
< 
<    This file provides a location for all error handling.  Users which
<    need special error handling are expected to write replacement functions
<    and use png_set_error_fn() to use those functions.  See the instructions
<    at each function. */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  *
>  * This file provides a location for all error handling.  Users which
>  * need special error handling are expected to write replacement functions
>  * and use png_set_error_fn() to use those functions.  See the instructions
>  * at each function.
>  */
24,26c26,29
<    should not be changed.  If there is a need to handle errors differently,
<    you should supply a replacement error function and use png_set_error_fn()
<    to replace the error function at run-time. */
---
>  * should not be changed.  If there is a need to handle errors differently,
>  * you should supply a replacement error function and use png_set_error_fn()
>  * to replace the error function at run-time.
>  */
39,41c42,45
<    should not be changed.  If there is a need to handle warnings differently,
<    you should supply a replacement warning function and use
<    png_set_error_fn() to replace the warning function at run-time. */
---
>  * should not be changed.  If there is a need to handle warnings differently,
>  * you should supply a replacement warning function and use
>  * png_set_error_fn() to replace the warning function at run-time.
>  */
50a55,108
> /* These utilities are used internally to build an error message which relates
>  * to the current chunk.  The chunk name comes from png_ptr->chunk_name,
>  * this is used to prefix the message.  The message is limited in length
>  * to 63 bytes, the name characters are output as hex digits wrapped in []
>  * if the character is invalid.
>  */
> #define isnonalpha(c) ((c) < 41 || (c) > 122 || ((c) > 90 && (c) < 97))
> static PNG_CONST char png_digit[16] = {
>    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
> };
> 
> static void
> png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp message)
> {
>    int iout = 0, iin = 0;
> 
>    while (iin < 4) {
>       int c = png_ptr->chunk_name[iin++];
>       if (isnonalpha(c)) {
>          buffer[iout++] = '[';
>          buffer[iout++] = png_digit[(c & 0xf0) >> 4];
>          buffer[iout++] = png_digit[c & 0xf];
>          buffer[iout++] = ']';
>       } else {
>          buffer[iout++] = c;
>       }
>    }
> 
>    if (message == NULL)
>       buffer[iout] = 0;
>    else {
>       buffer[iout++] = ':';
>       buffer[iout++] = ' ';
>       png_memcpy(buffer+iout, message, 64);
>       buffer[iout+63] = 0;
>    }
> }
> 
> void
> png_chunk_error(png_structp png_ptr, png_const_charp message)
> {
>    char msg[16+64];
>    png_format_buffer(png_ptr, msg, message);
>    png_error(png_ptr, msg);
> }
> 
> void
> png_chunk_warning(png_structp png_ptr, png_const_charp message)
> {
>    char msg[16+64];
>    png_format_buffer(png_ptr, msg, message);
>    png_warning(png_ptr, msg);
> }
> 
52,54c110,113
<    this function MUST NOT RETURN, or the program will likely crash.  This
<    function is used by default, or if the program supplies NULL for the
<    error function pointer in png_set_error_fn(). */
---
>  * this function MUST NOT RETURN, or the program will likely crash.  This
>  * function is used by default, or if the program supplies NULL for the
>  * error function pointer in png_set_error_fn().
>  */
74,76c133,136
<    it can continue anyway.  Replacement functions don't have to do anything
<    here if you don't want to.  In the default configuration, png_ptr is
<    not used, but it is passed in case it may be useful. */
---
>  * it can continue anyway.  Replacement functions don't have to do anything
>  * here if you don't want to.  In the default configuration, png_ptr is
>  * not used, but it is passed in case it may be useful.
>  */
89,91c149,152
<    of handling errors and warnings.  Note that the error function MUST NOT
<    return to the calling routine or serious problems will occur.  The return
<    method used in the default routine calls longjmp(png_ptr->jmpbuf, 1) */
---
>  * of handling errors and warnings.  Note that the error function MUST NOT
>  * return to the calling routine or serious problems will occur.  The return
>  * method used in the default routine calls longjmp(png_ptr->jmpbuf, 1)
>  */
103,104c164,166
<    functions.  The application should free any memory associated with this
<    pointer before png_write_destroy and png_read_destroy are called. */
---
>  * functions.  The application should free any memory associated with this
>  * pointer before png_write_destroy and png_read_destroy are called.
>  */
108c170
<    return png_ptr->error_ptr;
---
>    return ((png_voidp)png_ptr->error_ptr);
Index: c/pngget
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngget,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,8c3,10
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  */
16c18
<    if (info_ptr != NULL)
---
>    if (png_ptr != NULL && info_ptr != NULL)
25c27
<    if (info_ptr != NULL)
---
>    if (png_ptr != NULL && info_ptr != NULL)
30a33,311
> #ifdef PNG_EASY_ACCESS_SUPPORTED
> /* easy access to info, added in libpng-0.99 */
> png_uint_32
> png_get_image_width(png_structp png_ptr, png_infop info_ptr)
> {
>    if (png_ptr != NULL && info_ptr != NULL)
>    {
>       return info_ptr->width;
>    }
>    return (0);
> }
> 
> png_uint_32
> png_get_image_height(png_structp png_ptr, png_infop info_ptr)
> {
>    if (png_ptr != NULL && info_ptr != NULL)
>    {
>       return info_ptr->height;
>    }
>    return (0);
> }
> 
> png_byte
> png_get_bit_depth(png_structp png_ptr, png_infop info_ptr)
> {
>    if (png_ptr != NULL && info_ptr != NULL)
>    {
>       return info_ptr->bit_depth;
>    }
>    return (0);
> }
> 
> png_byte
> png_get_color_type(png_structp png_ptr, png_infop info_ptr)
> {
>    if (png_ptr != NULL && info_ptr != NULL)
>    {
>       return info_ptr->color_type;
>    }
>    return (0);
> }
> 
> png_byte
> png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
> {
>    if (png_ptr != NULL && info_ptr != NULL)
>    {
>       return info_ptr->filter_type;
>    }
>    return (0);
> }
> 
> png_byte
> png_get_interlace_type(png_structp png_ptr, png_infop info_ptr)
> {
>    if (png_ptr != NULL && info_ptr != NULL)
>    {
>       return info_ptr->interlace_type;
>    }
>    return (0);
> }
> 
> png_byte
> png_get_compression_type(png_structp png_ptr, png_infop info_ptr)
> {
>    if (png_ptr != NULL && info_ptr != NULL)
>    {
>       return info_ptr->compression_type;
>    }
>    return (0);
> }
> 
> png_uint_32
> png_get_x_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
> {
> #if defined(PNG_READ_pHYs_SUPPORTED) || defined(PNG_WRITE_pHYs_SUPPORTED)
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
>    {
>       png_debug1(1, "in %s retrieval function\n", "png_get_x_pixels_per_meter");
>       if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
>           return (0);
>       else return (info_ptr->x_pixels_per_unit);
>    }
>    else
> #endif
>    return (0);
> }
> 
> png_uint_32
> png_get_y_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
> {
> #if defined(PNG_READ_pHYs_SUPPORTED) || defined(PNG_WRITE_pHYs_SUPPORTED)
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
>    {
>       png_debug1(1, "in %s retrieval function\n", "png_get_y_pixels_per_meter");
>       if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
>           return (0);
>       else return (info_ptr->y_pixels_per_unit);
>    }
>    else
> #endif
>    return (0);
> }
> 
> png_uint_32
> png_get_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
> {
> #if defined(PNG_READ_pHYs_SUPPORTED) || defined(PNG_WRITE_pHYs_SUPPORTED)
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
>    {
>       png_debug1(1, "in %s retrieval function\n", "png_get_pixels_per_meter");
>       if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER ||
>          info_ptr->x_pixels_per_unit != info_ptr->y_pixels_per_unit)
>           return (0);
>       else return (info_ptr->x_pixels_per_unit);
>    }
>    else
> #endif
>    return (0);
> }
> 
> float
> png_get_pixel_aspect_ratio(png_structp png_ptr, png_infop info_ptr)
>    {
> #if defined(PNG_READ_pHYs_SUPPORTED) || defined(PNG_WRITE_pHYs_SUPPORTED)
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
>    {
>       png_debug1(1, "in %s retrieval function\n", "png_get_aspect_ratio");
>       if (info_ptr->x_pixels_per_unit == 0)
>          return ((float)0.0);
>       else
>          return ((float)info_ptr->y_pixels_per_unit
>             /(float)info_ptr->x_pixels_per_unit);
>    }
>    else
> #endif
>       return ((float)0.0);
> }
> 
> png_uint_32
> png_get_x_offset_microns(png_structp png_ptr, png_infop info_ptr)
> {
> #if defined(PNG_READ_oFFs_SUPPORTED) || defined(PNG_WRITE_oFFs_SUPPORTED)
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
>    {
>       png_debug1(1, "in %s retrieval function\n", "png_get_x_offset_microns");
>       if(info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
>           return (0);
>       else return (info_ptr->x_offset);
>    }
>    else
> #endif
>    return (0);
> }
> 
> png_uint_32
> png_get_y_offset_microns(png_structp png_ptr, png_infop info_ptr)
> {
> #if defined(PNG_READ_oFFs_SUPPORTED) || defined(PNG_WRITE_oFFs_SUPPORTED)
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
>    {
>       png_debug1(1, "in %s retrieval function\n", "png_get_y_offset_microns");
>       if(info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
>           return (0);
>       else return (info_ptr->y_offset);
>    }
>    else
> #endif
>    return (0);
> }
> 
> png_uint_32
> png_get_x_offset_pixels(png_structp png_ptr, png_infop info_ptr)
> {
> #if defined(PNG_READ_oFFs_SUPPORTED) || defined(PNG_WRITE_oFFs_SUPPORTED)
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
>    {
>       png_debug1(1, "in %s retrieval function\n", "png_get_x_offset_microns");
>       if(info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
>           return (0);
>       else return (info_ptr->x_offset);
>    }
>    else
> #endif
>    return (0);
> }
> 
> png_uint_32
> png_get_y_offset_pixels(png_structp png_ptr, png_infop info_ptr)
> {
> #if defined(PNG_READ_oFFs_SUPPORTED) || defined(PNG_WRITE_oFFs_SUPPORTED)
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
>    {
>       png_debug1(1, "in %s retrieval function\n", "png_get_y_offset_microns");
>       if(info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
>           return (0);
>       else return (info_ptr->y_offset);
>    }
>    else
> #endif
>    return (0);
> }
> 
> #ifdef PNG_INCH_CONVERSIONS
> png_uint_32
> png_get_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
> {
>    return ((png_uint_32)((float)png_get_pixels_per_meter(png_ptr, info_ptr)
>      *.03937 +.5)
> }
> 
> png_uint_32
> png_get_x_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
> {
>    return ((png_uint_32)((float)png_get_x_pixels_per_meter(png_ptr, info_ptr)
>      *.03937 +.5)
> }
> 
> png_uint_32
> png_get_y_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
> {
>    return ((png_uint_32)((float)png_get_y_pixels_per_meter(png_ptr, info_ptr)
>      *.03937 +.5)
> }
> 
> float
> png_get_x_offset_inches(png_structp png_ptr, png_infop info_ptr)
> {
>    return ((float)png_get_x_offset_microns(png_ptr, info_ptr)
>      *.03937/1000000. +.5)
> }
> 
> float
> png_get_y_offset_inches(png_structp png_ptr, png_infop info_ptr)
> {
>    return ((float)png_get_y_offset_microns(png_ptr, info_ptr)
>      *.03937/1000000. +.5)
> }
> 
> #if defined(PNG_READ_pHYs_SUPPORTED)
> png_uint_32
> png_get_pHYs_dpi(png_structp png_ptr, png_infop info_ptr,
>    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
> {
>    png_uint_32 retval = 0;
> 
>    if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_pHYs)
>    {
>       png_debug1(1, "in %s retrieval function\n", "pHYs");
>       if (res_x != NULL)
>       {
>          *res_x = info_ptr->x_pixels_per_unit;
>          retval |= PNG_INFO_pHYs;
>       }
>       if (res_y != NULL)
>       {
>          *res_y = info_ptr->y_pixels_per_unit;
>          retval |= PNG_INFO_pHYs;
>       }
>       if (unit_type != NULL)
>       {
>          *unit_type = (int)info_ptr->phys_unit_type;
>          retval |= PNG_INFO_pHYs;
>          if(unit_type == 1)
>          {
>             if (res_x != NULL) *res_x = (png_uint_32)(*res_x * 39.37 + .50);
>             if (res_y != NULL) *res_y = (png_uint_32)(*res_y * 39.37 + .50);
>          }
>       }
>    }
>    return (retval);
> }
> #endif
> 
> #endif  /* PNG_INCH_CONVERSIONS */
> 
> /* png_get_channels really belongs in here, too, but it's been around longer */
> #endif  /* PNG_EASY_ACCESS_SUPPORTED */
> 
34c315
<    if (info_ptr != NULL)
---
>    if (png_ptr != NULL && info_ptr != NULL)
37c318
<       return(0);
---
>       return (0);
43c324
<    if (info_ptr != NULL)
---
>    if (png_ptr != NULL && info_ptr != NULL)
46c327
<       return(NULL);
---
>       return (NULL);
54,55c335,336
<    if (info_ptr != NULL && info_ptr->valid & PNG_INFO_bKGD &&
<       background != NULL)
---
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD)
>       && background != NULL)
71c352
<    if (info_ptr != NULL && info_ptr->valid & PNG_INFO_cHRM)
---
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
100,101c381,382
<    if (info_ptr != NULL && info_ptr->valid & PNG_INFO_gAMA &&
<       file_gamma != NULL)
---
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
>       && file_gamma != NULL)
110a392,406
> #if defined(PNG_READ_sRGB_SUPPORTED)
> png_uint_32
> png_get_sRGB(png_structp png_ptr, png_infop info_ptr, int *file_srgb_intent)
> {
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB)
>       && file_srgb_intent != NULL)
>    {
>       png_debug1(1, "in %s retrieval function\n", "sRGB");
>       *file_srgb_intent = (int)info_ptr->srgb_intent;
>       return (PNG_INFO_sRGB);
>    }
>    return (0);
> }
> #endif
> 
115c411,412
<    if (info_ptr != NULL && info_ptr->valid & PNG_INFO_hIST && hist != NULL)
---
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST)
>       && hist != NULL)
132c429
<    if (info_ptr != NULL && width != NULL && height != NULL &&
---
>    if (png_ptr != NULL && info_ptr != NULL && width != NULL && height != NULL &&
134a432,434
>       int pixel_depth, channels;
>       png_uint_32 rowbytes_per_pixel;
> 
145a446,462
> 
>       /* check for potential overflow of rowbytes */
>       if (*color_type == PNG_COLOR_TYPE_PALETTE)
>          channels = 1;
>       else if (*color_type & PNG_COLOR_MASK_COLOR)
>          channels = 3;
>       else
>          channels = 1;
>       if (*color_type & PNG_COLOR_MASK_ALPHA)
>          channels++;
>       pixel_depth = *bit_depth * channels;
>       rowbytes_per_pixel = (pixel_depth + 7) >> 3;
>       if ((*width > (png_uint_32)2147483647L/rowbytes_per_pixel))
>       {
>          png_warning(png_ptr,
>             "Width too large for libpng to process image data.");
>       }
156,157c473,474
<    if (info_ptr != NULL && info_ptr->valid & PNG_INFO_oFFs &&
<       offset_x != NULL && offset_y != NULL && unit_type != NULL)
---
>    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs)
>       && offset_x != NULL && offset_y != NULL && unit_type != NULL)
175c492
<    if (info_ptr != NULL && info_ptr->valid & PNG_INFO_pCAL &&
---
>    if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_pCAL &&
198,199c515,517
<    if (info_ptr != NULL && info_ptr->valid & PNG_INFO_pHYs &&
<       res_x != NULL && res_y != NULL && unit_type != NULL)
---
>    png_uint_32 retval = 0;
> 
>    if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_pHYs)
202,205c520,534
<       *res_x = info_ptr->x_pixels_per_unit;
<       *res_y = info_ptr->y_pixels_per_unit;
<       *unit_type = (int)info_ptr->phys_unit_type;
<       return (PNG_INFO_pHYs);
---
>       if (res_x != NULL)
>       {
>          *res_x = info_ptr->x_pixels_per_unit;
>          retval |= PNG_INFO_pHYs;
>       }
>       if (res_y != NULL)
>       {
>          *res_y = info_ptr->y_pixels_per_unit;
>          retval |= PNG_INFO_pHYs;
>       }
>       if (unit_type != NULL)
>       {
>          *unit_type = (int)info_ptr->phys_unit_type;
>          retval |= PNG_INFO_pHYs;
>       }
207c536
<    return (0);
---
>    return (retval);
215c544,545
<    if (info_ptr != NULL && info_ptr->valid & PNG_INFO_PLTE && palette != NULL)
---
>    if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_PLTE &&
>        palette != NULL)
230c560,561
<    if (info_ptr != NULL && info_ptr->valid & PNG_INFO_sBIT && sig_bit != NULL)
---
>    if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_sBIT &&
>        sig_bit != NULL)
245c576
<    if ((info_ptr != NULL) || (info_ptr->num_text > 0))
---
>    if (png_ptr != NULL && info_ptr != NULL && info_ptr->num_text > 0)
248c579,580
< 	 (png_ptr->chunk_name[0] == '\0' ? "text" : png_ptr->chunk_name));
---
>          (png_ptr->chunk_name[0] == '\0' ? "text"
>              : (png_const_charp)png_ptr->chunk_name));
253c585
<       return (info_ptr->num_text);
---
>       return ((png_uint_32)info_ptr->num_text);
263c595,596
<    if (info_ptr != NULL && info_ptr->valid & PNG_INFO_tIME && mod_time != NULL)
---
>    if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_tIME &&
>        mod_time != NULL)
278c611,612
<    if (info_ptr != NULL && info_ptr->valid & PNG_INFO_tRNS)
---
>    png_uint_32 retval = 0;
>    if (png_ptr != NULL && info_ptr != NULL && info_ptr->valid & PNG_INFO_tRNS)
281c615
<       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE && trans != NULL)
---
>       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
283c617,623
<           *trans = info_ptr->trans;
---
>           if (trans != NULL)
>           {
>              *trans = info_ptr->trans;
>              retval |= PNG_INFO_tRNS;
>           }
>           if (trans_values != NULL)
>              *trans_values = &(info_ptr->trans_values);
285c625
<       else if (trans_values != NULL)
---
>       else /* if (info_ptr->color_type != PNG_COLOR_TYPE_PALETTE) */
287c627,633
<          *trans_values = &(info_ptr->trans_values);
---
>           if (trans_values != NULL)
>           {
>              *trans_values = &(info_ptr->trans_values);
>              retval |= PNG_INFO_tRNS;
>           }
>           if(trans != NULL)
>              *trans = NULL;
289c635
<       else
---
>       if(num_trans != NULL)
291c637,638
<          return (0);
---
>          *num_trans = info_ptr->num_trans;
>          retval |= PNG_INFO_tRNS;
293,294d639
<       *num_trans = info_ptr->num_trans;
<       return (PNG_INFO_tRNS);
296c641
<    return (0);
---
>    return (retval);
Index: c/pngmem
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngmem,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,12c3,14
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
< 
<    This file provides a location for all memory allocation.  Users which
<    need special memory handling are expected to modify the code in this file
<    to meet their needs.  See the instructions at each function. */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  *
>  * This file provides a location for all memory allocation.  Users which
>  * need special memory handling are expected to modify the code in this file
>  * to meet their needs.  See the instructions at each function.
>  */
16a19,28
> /* The following "hides" PNG_MALLOC and PNG_FREE thus allowing the pngtest
>    application to put a wrapper on top of them. */
> #ifdef PNGTEST_MEMORY_DEBUG
> #define PNG_MALLOC png_debug_malloc
> #define PNG_FREE   png_debug_free
> #else
> #define PNG_MALLOC png_malloc
> #define PNG_FREE   png_free
> #endif
> 
34c46
<      return (png_voidp)NULL;
---
>      return ((png_voidp)NULL);
49a62
>    {
50a64,65
>       struct_ptr = NULL;
>    }
73c88
< png_malloc(png_structp png_ptr, png_uint_32 size)
---
> PNG_MALLOC(png_structp png_ptr, png_uint_32 size)
77c92
<       return ((voidp)NULL);
---
>       return ((png_voidp)NULL);
84c99
<    if (size == (png_uint_32)(65536L))
---
>    if (size == (png_uint_32)65536L)
98a114
>             {
100c116,117
<             ret = NULL;
---
>                ret = NULL;
>             }
116c133
<                png_error(png_ptr, "Out of Memory");
---
>                png_error(png_ptr, "Out Of Memory."); /* Note "O" and "M" */
130c147
<                png_error(png_ptr, "Out of memory");
---
>                png_error(png_ptr, "Out Of memory.");
142c159
<                hptr += 65536L;
---
>                hptr += (png_uint_32)65536L;
152c169
<          png_error(png_ptr, "Out of Memory");
---
>          png_error(png_ptr, "Out of Memory.");
161c178
<       png_error(png_ptr, "Out of Memory");
---
>       png_error(png_ptr, "Out of memory."); /* Note "o" and "m" */
164c181
<    return ret;
---
>    return (ret);
167c184
< /* free a pointer allocated by png_malloc().  In the default
---
> /* free a pointer allocated by PNG_MALLOC().  In the default
171c188
< png_free(png_structp png_ptr, png_voidp ptr)
---
> PNG_FREE(png_structp png_ptr, png_voidp ptr)
198a216
>    {
199a218,219
>       ptr = NULL;
>    }
218c238
<       return (png_voidp)NULL;
---
>       return ((png_voidp)NULL);
241a262
>    {
250a272
>    }
261c283
< png_malloc(png_structp png_ptr, png_uint_32 size)
---
> PNG_MALLOC(png_structp png_ptr, png_uint_32 size)
263a286
> 
265c288
<       return (NULL);
---
>       return ((png_voidp)NULL);
273c296
<    ret = farmalloc((png_size_t)size);
---
>    ret = farmalloc(size);
276c299
<    ret = halloc((png_size_t)size, 1);
---
>    ret = halloc(size, 1);
278c301
<    ret = malloc((png_size_t)size);
---
>    ret = malloc((size_t)size);
287c310
<    return ret;
---
>    return (ret);
290c313
< /* Free a pointer allocated by png_malloc().  In the default
---
> /* Free a pointer allocated by PNG_MALLOC().  In the default
294c317
< png_free(png_structp png_ptr, png_voidp ptr)
---
> PNG_FREE(png_structp png_ptr, png_voidp ptr)
311a335,360
> png_voidp
> png_memcpy_check (png_structp png_ptr, png_voidp s1, png_voidp s2,
>    png_uint_32 length)
> {
>    png_size_t size;
> 
>    size = (png_size_t)length;
>    if ((png_uint_32)size != length)
>       png_error(png_ptr,"Overflow in png_memcpy_check.");
>   
>    return(png_memcpy (s1, s2, size));
> }
> 
> png_voidp
> png_memset_check (png_structp png_ptr, png_voidp s1, int value,
>    png_uint_32 length)
> {
>    png_size_t size;
> 
>    size = (png_size_t)length;
>    if ((png_uint_32)size != length)
>       png_error(png_ptr,"Overflow in png_memset_check.");
> 
>    return (png_memset (s1, value, size));
> 
> }
Index: c/pngpread
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngpread,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,9c3,10
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  */
119,122c120,124
<       and the 4 byte chunk length before proceeding with decoding the
<       chunk data.  To fully decode each of these chunks, we also make
<       sure we have enough data in the buffer for the 4 byte CRC at the
<       end of every chunk (except IDAT, which is handled separately). */
---
>     * and the 4 byte chunk length before proceeding with decoding the
>     * chunk data.  To fully decode each of these chunks, we also make
>     * sure we have enough data in the buffer for the 4 byte CRC at the
>     * end of every chunk (except IDAT, which is handled separately).
>     */
163,164c165,167
<          header chunks, and we can start reading the image (or if this
<          is called after the image has been read - we have an error). */
---
>        * header chunks, and we can start reading the image (or if this
>        * is called after the image has been read - we have an error).
>        */
229a233,244
> #if defined(PNG_READ_sRGB_SUPPORTED)
>    else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))
>    {
>       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
>       {
>          png_push_save_buffer(png_ptr);
>          return;
>       }
> 
>       png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length);
>    }
> #endif
454c469,470
<       png_ptr->save_buffer = (png_bytep)png_malloc(png_ptr, new_max);
---
>       png_ptr->save_buffer = (png_bytep)png_malloc(png_ptr, 
>          (png_uint_32)new_max);
515c531,536
<          save_size = png_ptr->idat_size;
---
>       {
>          save_size = (png_size_t)png_ptr->idat_size;
>          /* check for overflow */
>          if((png_uint_32)save_size != png_ptr->idat_size)
>             png_error(png_ptr, "save_size overflowed in pngpread");
>       }
532c553,558
<          save_size = png_ptr->idat_size;
---
>       {
>          save_size = (png_size_t)png_ptr->idat_size;
>          /* check for overflow */
>          if((png_uint_32)save_size != png_ptr->idat_size)
>             png_error(png_ptr, "save_size overflowed in pngpread");
>       }
568c594
<    while(1)
---
>    for(;;)
606a633
>    
614c641,642
<    png_memcpy(png_ptr->prev_row, png_ptr->row_buf, png_ptr->rowbytes + 1);
---
>    png_memcpy_check(png_ptr, png_ptr->prev_row, png_ptr->row_buf,
>       png_ptr->rowbytes + 1);
749c777,778
<       png_memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
---
>       png_memset_check(png_ptr, png_ptr->prev_row, 0,
>          png_ptr->rowbytes + 1);
758a788
> 
760a791
> 
781c812,816
<       png_error(png_ptr, "Out of place tEXt");
---
>       {
>          png_error(png_ptr, "Out of place tEXt");
>          /* to quiet some compiler warnings */
>          if(info_ptr == NULL) return;
>       }
786c821
<    if (length > 65535L)  /* We can't hold the entire string in memory */
---
>    if (length > (png_uint_32)65535L) /* Can't hold the entire string in memory */
789,790c824,825
<       png_ptr->skip_length = length - 65535L;
<       length = 65535L;
---
>       png_ptr->skip_length = length - (png_uint_32)65535L;
>       length = (png_uint_32)65535L;
794c829,830
<    png_ptr->current_text = (png_charp)png_malloc(png_ptr, length+1);
---
>    png_ptr->current_text = (png_charp)png_malloc(png_ptr, 
>          (png_uint_32)(length+1));
797,798c833,834
<    png_ptr->current_text_size = length;
<    png_ptr->current_text_left = length;
---
>    png_ptr->current_text_size = (png_size_t)length;
>    png_ptr->current_text_left = (png_size_t)length;
845c881
<       text_ptr = (png_textp)png_malloc(png_ptr, sizeof(png_text));
---
>       text_ptr = (png_textp)png_malloc(png_ptr, (png_uint_32)sizeof(png_text));
862c898,902
<       png_error(png_ptr, "Out of place zTXt");
---
>       {
>          png_error(png_ptr, "Out of place zTXt");
>          /* to quiet some compiler warnings */
>          if(info_ptr == NULL) return;
>       }
869c909
<    if (length > 65535L)
---
>    if (length > (png_uint_32)65535L)
877c917,918
<    png_ptr->current_text = (png_charp)png_malloc(png_ptr, length+1);
---
>    png_ptr->current_text = (png_charp)png_malloc(png_ptr,
>        (png_uint_32)(length+1));
880,881c921,922
<    png_ptr->current_text_size = length;
<    png_ptr->current_text_left = length;
---
>    png_ptr->current_text_size = (png_size_t)length;
>    png_ptr->current_text_left = (png_size_t)length;
943c984
<       png_ptr->zstream.avail_out = png_ptr->zbuf_size;
---
>       png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
966,967c1007,1008
<                   png_ptr->zbuf_size - png_ptr->zstream.avail_out +
<                      key_size + 1);
---
>                   (png_uint_32)(png_ptr->zbuf_size - png_ptr->zstream.avail_out +
>                      key_size + 1));
980,981c1021,1023
<                text = png_malloc(png_ptr, text_size +
<                   png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1);
---
>                text = (png_charp)png_malloc(png_ptr, text_size +
>                   (png_uint_32)(png_ptr->zbuf_size - png_ptr->zstream.avail_out
>                    + 1));
1017d1058
<       text_size -= key_size;
1019c1060
<       text_ptr = (png_textp)png_malloc(png_ptr, sizeof(png_text));
---
>       text_ptr = (png_textp)png_malloc(png_ptr, (png_uint_32)sizeof(png_text));
1032,1036c1073,1078
<    chunk.  In the future we will have code here which can handle
<    user-defined callback functions for unknown chunks before they are
<    ignored or cause an error.  If there isn't a problem with the
<    chunk itself (ie a bad chunk name or a critical chunk), the chunk
<    is (currently) silently ignored. */
---
>  * chunk.  In the future we will have code here which can handle
>  * user-defined callback functions for unknown chunks before they are
>  * ignored or cause an error.  If there isn't a problem with the
>  * chunk itself (ie a bad chunk name or a critical chunk), the chunk
>  * is (currently) silently ignored.
>  */
1044,1047c1086,1088
<       char msg[40];
< 
<       sprintf(msg, "Unknown critical chunk %s", png_ptr->chunk_name);
<       png_error(png_ptr, msg);
---
>       png_chunk_error(png_ptr, "unknown critical chunk");
>       /* to quiet some compiler warnings */
>       if(info_ptr == NULL) return;
Index: c/pngread
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngread,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,9c3,13
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  *
>  * This file contains routines that an application calls directly to
>  * read a PNG file or stream.
>  */
16c20
< png_create_read_struct(png_charp user_png_ver, png_voidp error_ptr,
---
> png_create_read_struct(png_const_charp user_png_ver, voidp error_ptr,
57c61,62
<    png_ptr->zbuf = png_malloc(png_ptr, png_ptr->zbuf_size);
---
>    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
>      (png_uint_32)png_ptr->zbuf_size);
79d83
< 
100c104,105
<    png_ptr->zbuf = png_malloc(png_ptr, png_ptr->zbuf_size);
---
>    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
>      (png_uint_32)png_ptr->zbuf_size);
152c157
<    while (1)
---
>    for(;;)
217a223,226
> #if defined(PNG_READ_sRGB_SUPPORTED)
>       else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))
>          png_handle_sRGB(png_ptr, info_ptr, length);
> #endif
250,253c259,263
< /* initialize palette, background, etc, after transformations
<    are set, but before any reading takes place.  This allows
<    the user to obtail a gamma corrected palette, for example.
<    If the user doesn't call this, we will do it ourselves. */
---
> /* Initialize palette, background, etc, after transformations
>  * are set, but before any reading takes place.  This allows
>  * the user to obtail a gamma corrected palette, for example.
>  * If the user doesn't call this, we will do it ourselves.
>  */
402,403c412,415
<    png_ptr->row_info.rowbytes = ((png_ptr->row_info.width *
<       (png_uint_32)png_ptr->row_info.pixel_depth + 7) >> 3);
---
>    {
>       png_ptr->row_info.rowbytes = ((png_ptr->row_info.width *
>          (png_uint_32)png_ptr->row_info.pixel_depth + 7) >> 3);
>    }
409c421,422
<    png_memcpy(png_ptr->prev_row, png_ptr->row_buf, png_ptr->rowbytes + 1);
---
>    png_memcpy_check(png_ptr, png_ptr->prev_row, png_ptr->row_buf,
>       png_ptr->rowbytes + 1);
438a452,454
> 
>    if (png_ptr->read_row_fn != NULL)
>       (*(png_ptr->read_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
442,458c458,477
<    and png_set_interlace_handling() has been called, the rows need to
<    to contain the contents of the rows from the previous pass.  If
<    the image has alpha or transparency, and png_handle_alpha() has been
<    called, the rows contents must be initialized to the contents of the
<    screen.  "row" holds the actual image, and pixels are placed in it
<    as they arrive.  If the image is displayed after each pass, it will
<    appear to "sparkle" in.  "display_row" can be used to display a
<    "chunky" progressive image, with finer detail added as it becomes
<    available.  If you do not want this "chunky" display, you may pass
<    NULL for display_row.  If you do not want the sparkle display, and
<    you have not called png_handle_alpha(), you may pass NULL for rows.
<    If you have called png_handle_alpha(), and the image has either an
<    alpha channel or a transparency chunk, you must provide a buffer for
<    rows.  In this case, you do not have to provide a display_row buffer
<    also, but you may.  If the image is not interlaced, or if you have
<    not called png_set_interlace_handling(), the display_row buffer will
<    be ignored, so pass NULL to it. */
---
>  * and png_set_interlace_handling() has been called, the rows need to
>  * contain the contents of the rows from the previous pass.  If the
>  * image has alpha or transparency, and png_handle_alpha() has been
>  * called, the rows contents must be initialized to the contents of the
>  * screen.
>  * 
>  * "row" holds the actual image, and pixels are placed in it
>  * as they arrive.  If the image is displayed after each pass, it will
>  * appear to "sparkle" in.  "display_row" can be used to display a
>  * "chunky" progressive image, with finer detail added as it becomes
>  * available.  If you do not want this "chunky" display, you may pass
>  * NULL for display_row.  If you do not want the sparkle display, and
>  * you have not called png_handle_alpha(), you may pass NULL for rows.
>  * If you have called png_handle_alpha(), and the image has either an
>  * alpha channel or a transparency chunk, you must provide a buffer for
>  * rows.  In this case, you do not have to provide a display_row buffer
>  * also, but you may.  If the image is not interlaced, or if you have
>  * not called png_set_interlace_handling(), the display_row buffer will
>  * be ignored, so pass NULL to it.
>  */
494,501c513,521
<    chunk, and you have called png_handle_alpha(), you will need to
<    initialize the image to the current image that PNG will be overlaying.
<    We set the num_rows again here, in case it was incorrectly set in
<    png_read_start_row() by a call to png_read_update_info() or
<    png_start_read_image() if png_set_interlace_handling() wasn't called
<    prior to either of these functions like it should have been.  You can
<    only call this function once.  If you desire to have an image for
<    each pass of a interlaced image, use png_read_rows() instead */
---
>  * chunk, and you have called png_handle_alpha(), you will need to
>  * initialize the image to the current image that PNG will be overlaying.
>  * We set the num_rows again here, in case it was incorrectly set in
>  * png_read_start_row() by a call to png_read_update_info() or
>  * png_start_read_image() if png_set_interlace_handling() wasn't called
>  * prior to either of these functions like it should have been.  You can
>  * only call this function once.  If you desire to have an image for
>  * each pass of a interlaced image, use png_read_rows() instead.
>  */
527,528c547,549
<    file, will verify the end is accurate, and will read any comments
<    or time information at the end of the file, if info is not NULL. */
---
>  * file, will verify the end is accurate, and will read any comments
>  * or time information at the end of the file, if info is not NULL.
>  */
596a618,621
> #if defined(PNG_READ_sRGB_SUPPORTED)
>       else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))
>          png_handle_sRGB(png_ptr, info_ptr, length);
> #endif
640a666,668
> #if defined(PNG_READ_tEXt_SUPPORTED) || defined(PNG_READ_zTXt_SUPPORTED)
>       png_free(png_ptr, info_ptr->text);
> #endif
646a675,677
> #if defined(PNG_READ_tEXt_SUPPORTED) || defined(PNG_READ_zTXt_SUPPORTED)
>       png_free(png_ptr, end_info_ptr->text);
> #endif
662d692
<    int i;
691c721
<       png_free(png_ptr, png_ptr->palette);
---
>       png_zfree(png_ptr, png_ptr->palette);
702a733
>       int i;
712a744
>       int i;
720a753
>       int i;
750a784,789
> 
> void
> png_set_read_status_fn(png_structp png_ptr, png_read_status_ptr read_row_fn)
> {
>    png_ptr->read_row_fn = read_row_fn;
> }
Index: c/pngrio
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngrio,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,15c3,17
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
< 
<    This file provides a location for all input.  Users which need
<    special handling are expected to write a function which has the same
<    arguments as this, and perform a similar function, but possibly has
<    a different input method.  Note that you shouldn't change this
<    function, but rather write a replacement function and then make
<    libpng use it at run time with png_set_read_fn(...) */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  *
>  * This file provides a location for all input.  Users which need
>  * special handling are expected to write a function which has the same
>  * arguments as this, and perform a similar function, but possibly has
>  * a different input method.  Note that you shouldn't change this
>  * function, but rather write a replacement function and then make
>  * libpng use it at run time with png_set_read_fn(...).
>  */
34a37
> #if !defined(PNG_NO_STDIO)
43c46,52
<    int check;
---
>    png_size_t check;
> 
>    /* fread() returns 0 on error, so it is OK to store this in a png_size_t
>     * instead of an int, which is what fread() actually returns.
>     */
>    check = (png_size_t)fread(data, (png_size_t)1, length,
>       (FILE *)png_ptr->io_ptr);
45d53
<    check = fread(data, (png_size_t)1, length, (FILE *)png_ptr->io_ptr);
94c102
<    if (check != length)
---
>    if ((png_uint_32)check != (png_uint_32)length)
99a108
> #endif
119a129
> #if !defined(PNG_NO_STDIO)
123a134,136
> #else
>    png_ptr->read_data_fn = read_data_fn;
> #endif
Index: c/pngrtran
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngrtran,v
retrieving revision 1.1
retrieving revision 1.7
diff -r1.1 -r1.7
3,9c3,15
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  *
>  * This file contains functions optionally called by an application 
>  * in order to tell libpng how to handle data when reading a PNG.
>  * Transformations which are used in both reading and writing are
>  * in pngtrans.c.
>  */
16,46c22,111
<    many machines.  However, it does take more operations than the corresponding
<    divide method, so it may be slower on some RISC systems.  There are two
<    shifts (by 8 or 16 bits) and an addition, versus a single integer divide.
<    The results may also be off by one for certain values. */
< 
< /* pixel and background should be in gamma 1.0 space */
< #define png_composite(composite, pixel, trans, background) \
<    { png_uint_16 temp = ((png_uint_16)(pixel) * (png_uint_16)(trans) + \
<                       (png_uint_16)(background)*(png_uint_16)(255 - \
<                       (png_uint_16)(trans)) + (png_uint_16)127); \
<      (composite) = (png_byte)(((temp >> 8) + temp) >> 8); }
< 
< /* pixel and background should be in gamma 1.0 space */
< #define png_composite_16(composite, pixel, trans, background) \
<    { png_uint_32 temp = ((png_uint_32)(pixel) * (png_uint_32)(trans) + \
<                       (png_uint_32)(background)*(png_uint_32)(65535L - \
<                       (png_uint_32)(trans)) + (png_uint_32)32767); \
<      (composite) = (png_uint_16)(((temp >> 16) + temp) >> 16); }
< #else
< /* pixel and background should be in gamma 1.0 space */
< #define png_composite(composite, pixel, trans, background) \
<    (composite) = (png_byte)(((png_uint_16)(pixel) * (png_uint_16)(trans) + \
<      (png_uint_16)(background) * (png_uint_16)(255 - (png_uint_16)(trans)) + \
<      (png_uint_16)127) / 255)
<  
< /* pixel and background should be in gamma 1.0 space */
< #define png_composite_16(composite, pixel, trans, background) \
<    (composite) = (png_uint_16)(((png_uint_32)(pixel) * (png_uint_32)(trans) + \
<      (png_uint_32)(background)*(png_uint_32)(65535L - (png_uint_32)(trans)) + \
<      (png_uint_32)32767) / 65535L)
< #endif
---
>  * many machines.  However, it does take more operations than the corresponding
>  * divide method, so it may be slower on some RISC systems.  There are two
>  * shifts (by 8 or 16 bits) and an addition, versus a single integer divide.
>  *
>  * Note that the rounding factors are NOT supposed to be the same!  128 and
>  * 32768 are correct for the NODIV code; 127 and 32767 are correct for the
>  * standard method.
>  *
>  * [Optimized code by Greg Roelofs and Mark Adler...blame us for bugs. :-) ]
>  */
> 
>    /* fg and bg should be in `gamma 1.0' space; alpha is the opacity */
> #  define png_composite(composite, fg, alpha, bg) \
>      { png_uint_16 temp = ((png_uint_16)(fg) * (png_uint_16)(alpha) + \
>                         (png_uint_16)(bg)*(png_uint_16)(255 - \
>                         (png_uint_16)(alpha)) + (png_uint_16)128); \
>        (composite) = (png_byte)((temp + (temp >> 8)) >> 8); }
> #  define png_composite_16(composite, fg, alpha, bg) \
>      { png_uint_32 temp = ((png_uint_32)(fg) * (png_uint_32)(alpha) + \
>                         (png_uint_32)(bg)*(png_uint_32)(65535L - \
>                         (png_uint_32)(alpha)) + (png_uint_32)32768L); \
>        (composite) = (png_uint_16)((temp + (temp >> 16)) >> 16); }
> 
> #else  /* standard method using integer division */
> 
>    /* fg and bg should be in `gamma 1.0' space; alpha is the opacity */
> #  define png_composite(composite, fg, alpha, bg) \
>      (composite) = (png_byte)(((png_uint_16)(fg) * (png_uint_16)(alpha) + \
>        (png_uint_16)(bg) * (png_uint_16)(255 - (png_uint_16)(alpha)) + \
>        (png_uint_16)127) / 255)
> #  define png_composite_16(composite, fg, alpha, bg) \
>      (composite) = (png_uint_16)(((png_uint_32)(fg) * (png_uint_32)(alpha) + \
>        (png_uint_32)(bg)*(png_uint_32)(65535L - (png_uint_32)(alpha)) + \
>        (png_uint_32)32767) / (png_uint_32)65535L)
> 
> #endif /* ?PNG_READ_COMPOSITE_NODIV_SUPPORTED */
> 
> 
> /* Set the action on getting a CRC error for an ancillary or critical chunk. */
> void
> png_set_crc_action(png_structp png_ptr, int crit_action, int ancil_action)
> {
>    png_debug(1, "in png_set_crc_action\n");
>    /* Tell libpng how we react to CRC errors in critical chunks */
>    switch (crit_action)
>    {
>       case PNG_CRC_NO_CHANGE:                        /* leave setting as is */
>          break;
>       case PNG_CRC_WARN_USE:                               /* warn/use data */
>          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
>          png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;
>          break;
>       case PNG_CRC_QUIET_USE:                             /* quiet/use data */
>          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
>          png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |
>                            PNG_FLAG_CRC_CRITICAL_IGNORE;
>          break;
>       case PNG_CRC_WARN_DISCARD:    /* not a valid action for critical data */
>          png_warning(png_ptr, "Can't discard critical data on CRC error.");
>       case PNG_CRC_ERROR_QUIT:                                /* error/quit */
>       case PNG_CRC_DEFAULT:
>       default:
>          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
>          break;
>    }
> 
>    switch (ancil_action)
>    {
>       case PNG_CRC_NO_CHANGE:                       /* leave setting as is */
>          break;
>       case PNG_CRC_WARN_USE:                              /* warn/use data */
>          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
>          png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;
>          break;
>       case PNG_CRC_QUIET_USE:                            /* quiet/use data */
>          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
>          png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |
>                            PNG_FLAG_CRC_ANCILLARY_NOWARN;
>          break;
>       case PNG_CRC_ERROR_QUIT:                               /* error/quit */
>          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
>          png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;
>          break;
>       case PNG_CRC_WARN_DISCARD:                      /* warn/discard data */
>       case PNG_CRC_DEFAULT:
>       default:
>          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
>          break;
>    }
> }
54a120
>    png_debug(1, "in png_set_background\n");
74a141
>    png_debug(1, "in png_set_strip_16\n");
82a150
>    png_debug(1, "in png_set_strip_alpha\n");
89,94c157,163
<    of elements in the palette, the maximum number of elements
<    allowed, and a histogram if possible.  If the current number
<    of colors is greater then the maximum number, the palette will be
<    modified to fit in the maximum number.  "full_dither" indicates
<    whether we need a dithering cube set up for RGB images, or if we
<    simply are reducing the number of colors in a paletted image. */
---
>  * of elements in the palette, the maximum number of elements
>  * allowed, and a histogram if possible.  If the current number
>  * of colors is greater then the maximum number, the palette will be
>  * modified to fit in the maximum number.  "full_dither" indicates
>  * whether we need a dithering cube set up for RGB images, or if we
>  * simply are reducing the number of colors in a paletted image.
>  */
109a179
>    png_debug(1, "in png_set_dither\n");
117c187
<          num_palette * sizeof (png_byte));
---
>          (png_uint_32)(num_palette * sizeof (png_byte)));
133c203,204
<          sort = (png_bytep)png_malloc(png_ptr, num_palette * sizeof (png_byte));
---
>          sort = (png_bytep)png_malloc(png_ptr, (png_uint_32)(num_palette
>             * sizeof (png_byte)));
176c247
<                if (sort[i] >= maximum_colors)
---
>                if ((int)sort[i] >= maximum_colors)
180c251
<                   while (sort[j] >= maximum_colors);
---
>                   while ((int)sort[j] >= maximum_colors);
194c265
<                if (sort[i] >= maximum_colors)
---
>                if ((int)sort[i] >= maximum_colors)
200c271
<                   while (sort[j] >= maximum_colors);
---
>                   while ((int)sort[j] >= maximum_colors);
214c285
<                if (png_ptr->dither_index[i] >= maximum_colors)
---
>                if ((int)png_ptr->dither_index[i] >= maximum_colors)
261c332
<             num_palette * sizeof (png_byte));
---
>             (png_uint_32)(num_palette * sizeof (png_byte)));
263c334
<             num_palette * sizeof (png_byte));
---
>             (png_uint_32)(num_palette * sizeof (png_byte)));
272c343,344
<          hash = (png_dsortpp)png_malloc(png_ptr, 769 * sizeof (png_dsortp));
---
>          hash = (png_dsortpp)png_malloc(png_ptr, (png_uint_32)(769 * 
>             sizeof (png_dsortp)));
305c377,378
<                      t = png_malloc(png_ptr, sizeof (png_dsort));
---
>                      t = (png_dsortp)png_malloc(png_ptr, (png_uint_32)(sizeof
>                          (png_dsort)));
322,323c395,396
<                      if (index_to_palette[p->left] < num_new_palette &&
<                         index_to_palette[p->right] < num_new_palette)
---
>                      if ((int)index_to_palette[p->left] < num_new_palette &&
>                         (int)index_to_palette[p->right] < num_new_palette)
350c423
<                               if (png_ptr->dither_index[k] ==
---
>                               if ((int)png_ptr->dither_index[k] ==
421c494
<          num_entries * sizeof (png_byte));
---
>          (png_uint_32)(num_entries * sizeof (png_byte)));
425c498,499
<       distance = (png_bytep)png_malloc(png_ptr, num_entries * sizeof(png_byte));
---
>       distance = (png_bytep)png_malloc(png_ptr, (png_uint_32)(num_entries *
>          sizeof(png_byte)));
460c534
<                   if (d < distance[d_index])
---
>                   if (d < (int)distance[d_index])
477,479c551,554
<    only do transformations on images where the file_gamma and screen_gamma
<    are not close reciprocals, otherwise it slows things down slightly, and
<    also needlessly introduces small errors. */
---
>  * only do transformations on images where the file_gamma and screen_gamma
>  * are not close reciprocals, otherwise it slows things down slightly, and
>  * also needlessly introduces small errors.
>  */
481c556
< png_set_gamma(png_structp png_ptr, double screen_gamma, double file_gamma)
---
> png_set_gamma(png_structp png_ptr, double scrn_gamma, double file_gamma)
483c558,559
<    if (fabs(screen_gamma * file_gamma - 1.0) > PNG_GAMMA_THRESHOLD)
---
>    png_debug(1, "in png_set_gamma\n");
>    if (fabs(scrn_gamma * file_gamma - 1.0) > PNG_GAMMA_THRESHOLD)
486c562
<    png_ptr->display_gamma = (float)screen_gamma;
---
>    png_ptr->screen_gamma = (float)scrn_gamma;
492,493c568,570
<    less then 8 bit depth to 8 bit depth, and expand tRNS chunks
<    to alpha channels. */
---
>  * less then 8 bit depth to 8 bit depth, and expand tRNS chunks
>  * to alpha channels.
>  */
496a574
>    png_debug(1, "in png_set_expand\n");
504a583
>    png_debug(1, "in png_set_gray_to_rgb\n");
511,512c590,592
<    allow us, for example, to convert a 24 bpp RGB image into an 8 or
<    16 bpp grayscale image. (Not yet implemented.) */
---
>  * allow us, for example, to convert a 24 bpp RGB image into an 8 or
>  * 16 bpp grayscale image. (Not yet implemented.)
>  */
515a596
>    png_debug(1, "in png_set_rgb_to_gray\n");
517a599,610
>    png_warning(png_ptr, "RGB to GRAY transformation is not yet implemented.");
> }
> #endif
> 
> #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
> void
> png_set_read_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
>    read_user_transform_fn)
> {
>    png_debug(1, "in png_set_read_user_transform_fn\n");
>    png_ptr->transformations |= PNG_USER_TRANSFORM;
>    png_ptr->read_user_transform_fn = read_user_transform_fn;
522c615,616
<    the palette */
---
>  * the palette.
>  */
527a622
>    png_debug(1, "in png_init_read_transformations\n");
567a663,679
> 
> #if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
>         if (png_ptr->transformations & PNG_INVERT_ALPHA)
>         {
> #if defined(PNG_READ_EXPAND_SUPPORTED)
>            if (png_ptr->transformations & !PNG_EXPAND)
> #endif
>            {
>            /* invert the alpha channel (in tRNS) unless the pixels are 
>               going to be expanded, in which case leave it for later */
>               int i;
>               for (i=0; i<(int)png_ptr->num_trans; i++)
>                  png_ptr->trans[i] = 255 - png_ptr->trans[i];
>            }
>         }
> #endif
> 
605c717
<                g = 1.0 / (png_ptr->background_gamma * png_ptr->display_gamma);
---
>                g = 1.0 / (png_ptr->background_gamma * png_ptr->screen_gamma);
610,612c722,724
<                   back.red = png_ptr->background.red;
<                   back.green = png_ptr->background.green;
<                   back.blue = png_ptr->background.blue;
---
>                   back.red = (png_byte)png_ptr->background.red;
>                   back.green = (png_byte)png_ptr->background.green;
>                   back.blue = (png_byte)png_ptr->background.blue;
673d784
<          else
674a786,787
>          else
>          /* color_type != PNG_COLOR_TYPE_PALETTE */
685c798
<                   g = (png_ptr->display_gamma);
---
>                   g = (png_ptr->screen_gamma);
690c803
<                   gs = 1.0 / (png_ptr->gamma * png_ptr->display_gamma);
---
>                   gs = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
695c808
<                      png_ptr->display_gamma);
---
>                      png_ptr->screen_gamma);
700a814
>                /* RGB or RGBA */
715a830
>                /* GRAY or GRAY ALPHA */
723a839
>       /* transformation does not include PNG_BACKGROUND */
745a862
>    /* No GAMMA transformation */
758c875
<       for (i = 0; i < png_ptr->num_trans; i++)
---
>       for (i = 0; i < (int)png_ptr->num_trans; i++)
804,805c921,923
<    info should be updated so a PNG file could be written with it,
<    assuming the transformations result in valid PNG data. */
---
>  * info should be updated so a PNG file could be written with it,
>  * assuming the transformations result in valid PNG data.
>  */
808a927
>    png_debug(1, "in png_read_transform_info\n");
810,811c929
<    if ((png_ptr->transformations & PNG_EXPAND) &&
<       info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
---
>    if (png_ptr->transformations & PNG_EXPAND)
813,824c931,936
<       if (png_ptr->num_trans)
<          info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
<       else
<          info_ptr->color_type = PNG_COLOR_TYPE_RGB;
<       info_ptr->bit_depth = 8;
<       info_ptr->num_trans = 0;
<    }
<    else if (png_ptr->transformations & PNG_EXPAND)
<    {
<       if (png_ptr->num_trans)
<          info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
<       if (info_ptr->bit_depth < 8)
---
>       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
>       {
>          if (png_ptr->num_trans)
>             info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
>          else
>             info_ptr->color_type = PNG_COLOR_TYPE_RGB;
826c938,947
<       info_ptr->num_trans = 0;
---
>          info_ptr->num_trans = 0;
>       }
>       else
>       {
>          if (png_ptr->num_trans)
>             info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
>          if (info_ptr->bit_depth < 8)
>             info_ptr->bit_depth = 8;
>          info_ptr->num_trans = 0;
>       }
874c995
< #if defined(PNG_STRIP_ALPHA_SUPPORTED)
---
> #if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
897,898c1018
<    info_ptr->rowbytes = 
<       (png_size_t)((info_ptr->width * info_ptr->pixel_depth + 7) >> 3);
---
>    info_ptr->rowbytes = ((info_ptr->width * info_ptr->pixel_depth + 7) >> 3);
901,903c1021,1024
< /* transform the row.  The order of transformations is significant,
<    and is very touchy.  If you add a transformation, take care to
<    decide how it fits in with the other transformations here. */
---
> /* Transform the row.  The order of transformations is significant,
>  * and is very touchy.  If you add a transformation, take care to
>  * decide how it fits in with the other transformations here.
>  */
906a1028
>    png_debug(1, "in png_do_read_transformations\n");
909a1032
> #if !defined(PNG_NO_STDIO)
914a1038,1040
> #else
>       png_error(png_ptr, "NULL row buffer");
> #endif
919,925c1045
<    if ((png_ptr->transformations & PNG_EXPAND) &&
<       png_ptr->row_info.color_type == PNG_COLOR_TYPE_PALETTE)
<    {
<       png_do_expand_palette(&(png_ptr->row_info), png_ptr->row_buf + 1,
<          png_ptr->palette, png_ptr->trans, png_ptr->num_trans);
<    }
<    else if (png_ptr->transformations & PNG_EXPAND)
---
>    if (png_ptr->transformations & PNG_EXPAND)
927,932c1047,1060
<       if (png_ptr->num_trans)
<          png_do_expand(&(png_ptr->row_info), png_ptr->row_buf + 1,
<             &(png_ptr->trans_values));
<       else
<          png_do_expand(&(png_ptr->row_info), png_ptr->row_buf + 1,
<             NULL);
---
>       if (png_ptr->row_info.color_type == PNG_COLOR_TYPE_PALETTE)
>       {
>          png_do_expand_palette(&(png_ptr->row_info), png_ptr->row_buf + 1,
>             png_ptr->palette, png_ptr->trans, png_ptr->num_trans);
>       }
>       else if (png_ptr->transformations & PNG_EXPAND)
>       {
>          if (png_ptr->num_trans)
>             png_do_expand(&(png_ptr->row_info), png_ptr->row_buf + 1,
>                &(png_ptr->trans_values));
>          else
>             png_do_expand(&(png_ptr->row_info), png_ptr->row_buf + 1,
>                NULL);
>       }
943c1071,1073
<    if (png_ptr->transformations & PNG_BACKGROUND)
---
>    if ((png_ptr->transformations & PNG_BACKGROUND) &&
>       ((png_ptr->num_trans != 0 ) ||
>       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA)))
962c1092
< #if defined(PNG_RGB_TO_GRAY_SUPPORTED)
---
> #if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
976a1107,1108
>       if(png_ptr->row_info.rowbytes == (png_uint_32)0)
>          png_error(png_ptr, "png_do_dither returned rowbytes=0");
1016a1149,1153
> #if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
>    if (png_ptr->transformations & PNG_INVERT_ALPHA)
>       png_do_read_invert_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
> #endif
> 
1025a1163,1178
> 
> #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
>    if (png_ptr->transformations & PNG_USER_TRANSFORM)
>       if(png_ptr->read_user_transform_fn != NULL)
>         (*(png_ptr->read_user_transform_fn)) /* user read transform function */
>           (png_ptr,                    /* png_ptr */
>            &(png_ptr->row_info),       /* row_info:     */
>              /*  png_uint_32 width;          width of row */
>              /*  png_uint_32 rowbytes;       number of bytes in row */
>              /*  png_byte color_type;        color type of pixels */
>              /*  png_byte bit_depth;         bit depth of samples */
>              /*  png_byte channels;          number of channels (1-4) */
>              /*  png_byte pixel_depth;       bits per pixel (depth*channels) */
>            png_ptr->row_buf + 1);      /* start of pixel data for row */
> #endif
> 
1029,1033c1182,1187
< /* unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,
<    without changing the actual values.  Thus, if you had a row with
<    a bit depth of 1, you would end up with bytes that only contained
<    the numbers 0 or 1.  If you would rather they contain 0 and 255, use
<    png_do_shift() after this. */
---
> /* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,
>  * without changing the actual values.  Thus, if you had a row with
>  * a bit depth of 1, you would end up with bytes that only contained
>  * the numbers 0 or 1.  If you would rather they contain 0 and 255, use
>  * png_do_shift() after this.
>  */
1036a1191
>    png_debug(1, "in png_do_unpack\n");
1112c1267
<       row_info->rowbytes = (png_size_t)row_info->width * row_info->channels;
---
>       row_info->rowbytes = row_info->width * row_info->channels;
1118,1121c1273,1277
< /* reverse the effects of png_do_shift.  This routine merely shifts the
<    pixels back to their significant bits values.  Thus, if you have
<    a row of bit depth 8, but only 5 are significant, this will shift
<    the values back to 0 through 31 */
---
> /* Reverse the effects of png_do_shift.  This routine merely shifts the
>  * pixels back to their significant bits values.  Thus, if you have
>  * a row of bit depth 8, but only 5 are significant, this will shift
>  * the values back to 0 through 31.
>  */
1123,1124c1279
< png_do_unshift(png_row_infop row_info, png_bytep row,
<    png_color_8p sig_bits)
---
> png_do_unshift(png_row_infop row_info, png_bytep row, png_color_8p sig_bits)
1126,1131c1281
<    png_bytep bp;
<    png_uint_16 value;
<    png_uint_32 i;
< #if defined(PNG_USELESS_TESTS_SUPPORTED)
<    if (row != NULL && row_info != NULL && sig_bits != NULL &&
< #else
---
>    png_debug(1, "in png_do_unshift\n");
1132a1283,1284
> #if defined(PNG_USELESS_TESTS_SUPPORTED)
>        row != NULL && row_info != NULL && sig_bits != NULL &&
1134c1286
<       row_info->color_type != PNG_COLOR_TYPE_PALETTE)
---
>        row_info->color_type != PNG_COLOR_TYPE_PALETTE)
1137c1289,1290
<       int channels;
---
>       int channels, c;
>       png_uint_16 value;
1157c1310
<       for (i = 0; i < channels; i++)
---
>       for (c = 0; c < channels; c++)
1159,1160c1312,1313
<          if (shift[i] <= 0)
<             shift[i] = 0;
---
>          if (shift[c] <= 0)
>             shift[c] = 0;
1171a1325,1327
>             png_bytep bp;
>             png_uint_32 i;
> 
1181c1337,1340
<             png_byte  mask;
---
>             png_bytep bp;
>             png_byte mask;
>             png_uint_32 i;
> 
1192a1352,1354
>             png_bytep bp;
>             png_uint_32 i;
> 
1195,1197c1357
<                int c;
< 
<                for (c = 0; c < row_info->channels; c++, bp++)
---
>                for (c = 0; c < (int)row_info->channels; c++, bp++)
1206,1209c1366,1367
<             for (bp = row, i = 0;
<                i < row_info->width; i++)
<             {
<                int c;
---
>             png_bytep bp;
>             png_size_t i;
1211c1369,1371
<                for (c = 0; c < row_info->channels; c++, bp += 2)
---
>             for (bp = row, i = 0; i < row_info->width; i++)
>             {
>                for (c = 0; c < (int)row_info->channels; c++, bp += 2)
1230a1391
>    png_debug(1, "in png_do_chop\n");
1250c1411,1421
<                    (png_uint_32)(*(sp + 1))) * 255 + 127) / 65535;
---
>                    (png_uint_32)(*(sp + 1))) * 255 + 127) / (png_uint_32)65535L;
> 
> 
>           * GRR: no, I think this is what it really should be:
>          *dp = (((((png_uint_32)(*sp) << 8) |
>                    (png_uint_32)(*(sp + 1))) + 128L) / (png_uint_32)257L;
> 
>           * GRR: here's the exact calculation with shifts:
>          temp = (((png_uint_32)(*sp) << 8) | (png_uint_32)(*(sp + 1))) + 128L;
>          *dp = (temp - (temp >> 8)) >> 8;
> 
1264c1435
<       row_info->rowbytes = (png_size_t)row_info->width * row_info->channels;
---
>       row_info->rowbytes = row_info->width * row_info->channels;
1272a1444
>    png_debug(1, "in png_do_read_swap_alpha\n");
1358a1531,1611
> #if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
> void
> png_do_read_invert_alpha(png_row_infop row_info, png_bytep row)
> {
>    png_debug(1, "in png_do_read_invert_alpha\n");
> #if defined(PNG_USELESS_TESTS_SUPPORTED)
>    if (row != NULL && row_info != NULL)
> #endif
>    {
>       if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
>       {
>          /* This inverts the alpha channel in RGBA */
>          if (row_info->bit_depth == 8)
>          {
>             png_bytep sp, dp;
>             png_uint_32 i;
> 
>             for (i = 0, sp = dp = row + row_info->rowbytes;
>                i < row_info->width; i++)
>             {
>                *(--dp) = 255 - *(--sp);
>                *(--dp) = *(--sp);
>                *(--dp) = *(--sp);
>                *(--dp) = *(--sp);
>             }
>          }
>          /* This inverts the alpha channel in RRGGBBAA */
>          else
>          {
>             png_bytep sp, dp;
>             png_uint_32 i;
> 
>             for (i = 0, sp = dp = row + row_info->rowbytes;
>                i < row_info->width; i++)
>             {
>                *(--dp) = 255 - *(--sp);
>                *(--dp) = 255 - *(--sp);
>                *(--dp) = *(--sp);
>                *(--dp) = *(--sp);
>                *(--dp) = *(--sp);
>                *(--dp) = *(--sp);
>                *(--dp) = *(--sp);
>                *(--dp) = *(--sp);
>             }
>          }
>       }
>       else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
>       {
>          /* This inverts the alpha channel in GA */
>          if (row_info->bit_depth == 8)
>          {
>             png_bytep sp, dp;
>             png_uint_32 i;
> 
>             for (i = 0, sp = dp = row + row_info->rowbytes;
>                i < row_info->width; i++)
>             {
>                *(--dp) = 255 - *(--sp);
>                *(--dp) = *(--sp);
>             }
>          }
>          /* This inverts the alpha channel in GGAA */
>          else
>          {
>             png_bytep sp, dp;
>             png_uint_32 i;
> 
>             for (i = 0, sp = dp = row + row_info->rowbytes;
>                i < row_info->width; i++)
>             {
>                *(--dp) = 255 - *(--sp);
>                *(--dp) = 255 - *(--sp);
>                *(--dp) = *(--sp);
>                *(--dp) = *(--sp);
>             }
>          }
>       }
>    }
> }
> #endif
> 
1367a1621,1622
>    png_debug(1, "in png_do_read_filler\n");
>    if (
1369,1372c1624
<    if (row != NULL  && row_info != NULL &&
<       row_info->color_type == PNG_COLOR_TYPE_RGB && row_info->bit_depth == 8)
< #else
<    if (row_info->color_type == PNG_COLOR_TYPE_RGB && row_info->bit_depth == 8)
---
>        row != NULL  && row_info != NULL &&
1373a1626
>        row_info->color_type == PNG_COLOR_TYPE_RGB && row_info->bit_depth == 8)
1391c1644
<          row_info->rowbytes = (png_size_t)row_info->width * 4;
---
>          row_info->rowbytes = row_info->width * 4;
1408c1661
<          row_info->rowbytes = (png_size_t)row_info->width * 4;
---
>          row_info->rowbytes = row_info->width * 4;
1422,1424c1675
< #if defined(PNG_USELESS_TESTS_SUPPORTED)
<    if (row != NULL && row_info != NULL && row_info->bit_depth >= 8 &&
< #else
---
>    png_debug(1, "in png_do_gray_to_rgb\n");
1425a1677,1678
> #if defined(PNG_USELESS_TESTS_SUPPORTED)
>        row != NULL && row_info != NULL &&
1502c1755
<       row_info->rowbytes = (png_size_t)((row_info->width *
---
>       row_info->rowbytes = ((row_info->width *
1508,1511c1761,1765
< /* build a grayscale palette.  Palette is assumed to be 1 << bit_depth
<    large of png_color.  This lets grayscale images be treated as
<    paletted.  Most useful for gamma correction and simplification
<    of code. */
---
> /* Build a grayscale palette.  Palette is assumed to be 1 << bit_depth
>  * large of png_color.  This lets grayscale images be treated as
>  * paletted.  Most useful for gamma correction and simplification
>  * of code.
>  */
1519a1774
>    png_debug(1, "in png_do_build_grayscale_palette\n");
1560a1816
>    png_debug(1, "in png_correct_palette\n");
1581c1837
<          g = 1.0 / (png_ptr->background_gamma * png_ptr->display_gamma);
---
>          g = 1.0 / (png_ptr->background_gamma * png_ptr->screen_gamma);
1692d1947
<          int i;
1699c1954
<          for (i = 0; i < num_palette; i++)
---
>          for (i = 0; i < (int)png_ptr->num_trans; i++)
1701,1702c1956
<             if (i >= (int)png_ptr->num_trans ||
<                png_ptr->trans[i] == 0)
---
>             if (png_ptr->trans[i] == 0)
1708,1709c1962
<             else if (i < (int)png_ptr->num_trans ||
<                png_ptr->trans[i] != 0xff)
---
>             else if (png_ptr->trans[i] != 0xff)
1741,1742c1994,1996
<    "background" is already in the screen gamma, while "background_1" is
<    at a gamma of 1.0.  Paletted files have already been taken care of. */
---
>  * "background" is already in the screen gamma, while "background_1" is
>  * at a gamma of 1.0.  Paletted files have already been taken care of.
>  */
1755,1757c2009
< #if defined(PNG_USELESS_TESTS_SUPPORTED)
<    if (row != NULL && row_info != NULL && background != NULL &&
< #else
---
>    png_debug(1, "in png_do_background\n");
1758a2011,2012
> #if defined(PNG_USELESS_TESTS_SUPPORTED)
>        row != NULL && row_info != NULL &&
1767d2020
<             /* We currently don't do gamma correction for 2 and 4 bit */
1776c2029,2030
<                      if (((*sp >> shift) & 0x1) == trans_values->gray)
---
>                      if ((png_uint_16)((*sp >> shift) & 0x1)
>                         == trans_values->gray)
1797,1798c2051,2052
<                      if (((*sp >> shift) & 0x3) ==
<                         trans_values->gray)
---
>                      if ((png_uint_16)((*sp >> shift) & 0x3)
>                          == trans_values->gray)
1819c2073,2074
<                      if (((*sp >> shift) & 0xf) == trans_values->gray)
---
>                      if ((png_uint_16)((*sp >> shift) & 0xf)
>                          == trans_values->gray)
1843c2098
<                            *sp = background->gray;
---
>                            *sp = (png_byte)background->gray;
1873,1874c2128
<                         v = (png_uint_16)(((png_uint_16)(*sp) << 8) +
<                            (png_uint_16)(*(sp + 1)));
---
>                         v = ((png_uint_16)(*sp) << 8) + *(sp + 1);
1896,1897c2150
<                         v = (png_uint_16)(((png_uint_16)(*sp) << 8) +
<                            (png_uint_16)(*(sp + 1)));
---
>                         v = ((png_uint_16)(*sp) << 8) + *(sp + 1);
1923,1925c2176,2178
<                         *sp = background->red;
<                         *(sp + 1) = background->green;
<                         *(sp + 2) = background->blue;
---
>                         *sp = (png_byte)background->red;
>                         *(sp + 1) = (png_byte)background->green;
>                         *(sp + 2) = (png_byte)background->blue;
1944,1946c2197,2199
<                         *sp = background->red;
<                         *(sp + 1) = background->green;
<                         *(sp + 2) = background->blue;
---
>                         *sp = (png_byte)background->red;
>                         *(sp + 1) = (png_byte)background->green;
>                         *(sp + 2) = (png_byte)background->blue;
1960,1965c2213,2215
<                      r = (png_uint_16)(((png_uint_16)(*sp) << 8) +
<                         (png_uint_16)(*(sp + 1)));
<                      g = (png_uint_16)(((png_uint_16)(*(sp + 2)) << 8) +
<                         (png_uint_16)(*(sp + 3)));
<                      b = (png_uint_16)(((png_uint_16)(*(sp + 4)) << 8) +
<                         (png_uint_16)(*(sp + 5)));
---
>                      r = ((png_uint_16)(*sp) << 8) + *(sp + 1);
>                      g = ((png_uint_16)(*(sp + 2)) << 8) + *(sp + 3);
>                      b = ((png_uint_16)(*(sp + 4)) << 8) + *(sp + 5);
1999,2004c2249,2251
<                      r = (png_uint_16)(((png_uint_16)(*sp) << 8) +
<                         (png_uint_16)(*(sp + 1)));
<                      g = (png_uint_16)(((png_uint_16)(*(sp + 2)) << 8) +
<                         (png_uint_16)(*(sp + 3)));
<                      b = (png_uint_16)(((png_uint_16)(*(sp + 4)) << 8) +
<                         (png_uint_16)(*(sp + 5)));
---
>                      r = ((png_uint_16)(*sp) << 8) + *(sp + 1);
>                      g = ((png_uint_16)(*(sp + 2)) << 8) + *(sp + 3);
>                      b = ((png_uint_16)(*(sp + 4)) << 8) + *(sp + 5);
2041c2288
<                         *dp = background->gray;
---
>                         *dp = (png_byte)background->gray;
2059c2306
<                      png_uint_16 a;
---
>                      png_byte a;
2068c2315
<                         *dp = background->gray;
---
>                         *dp = (png_byte)background->gray;
2088,2089c2335
<                      a = (png_uint_16)(((png_uint_16)(*(sp + 2)) << 8) +
<                         (png_uint_16)(*(sp + 3)));
---
>                      a = ((png_uint_16)(*(sp + 2)) << 8) + *(sp + 3);
2092c2338
<                         png_uint_32 v;
---
>                         png_uint_16 v;
2124,2125c2370
<                      a = (png_uint_16)(((png_uint_16)(*(sp + 2)) << 8) +
<                         (png_uint_16)(*(sp + 3)));
---
>                      a = ((png_uint_16)(*(sp + 2)) << 8) + *(sp + 3);
2139,2140c2384
<                         g = ((png_uint_32)(*sp) << 8) +
<                            (png_uint_32)(*(sp + 1));
---
>                         g = ((png_uint_16)(*sp) << 8) + *(sp + 1);
2161c2405
<                      png_uint_16 a;
---
>                      png_byte a;
2173,2175c2417,2419
<                         *dp = background->red;
<                         *(dp + 1) = background->green;
<                         *(dp + 2) = background->blue;
---
>                         *dp = (png_byte)background->red;
>                         *(dp + 1) = (png_byte)background->green;
>                         *(dp + 2) = (png_byte)background->blue;
2210,2212c2454,2456
<                         *dp = background->red;
<                         *(dp + 1) = background->green;
<                         *(dp + 2) = background->blue;
---
>                         *dp = (png_byte)background->red;
>                         *(dp + 1) = (png_byte)background->green;
>                         *(dp + 2) = (png_byte)background->blue;
2311,2316c2555,2557
<                         r = ((png_uint_32)(*sp) << 8) +
<                            (png_uint_32)(*(sp + 1));
<                         g = ((png_uint_32)(*(sp + 2)) << 8) +
<                            (png_uint_32)(*(sp + 3));
<                         b = ((png_uint_32)(*(sp + 4)) << 8) +
<                            (png_uint_32)(*(sp + 5));
---
>                         r = ((png_uint_16)(*sp) << 8) + *(sp + 1);
>                         g = ((png_uint_16)(*(sp + 2)) << 8) + *(sp + 3);
>                         b = ((png_uint_16)(*(sp + 4)) << 8) + *(sp + 5);
2324c2565
<                         png_composite_16(v, g, a, background->green);
---
>                         png_composite_16(v, b, a, background->blue);
2341c2582
<          row_info->rowbytes = (png_size_t)((row_info->width *
---
>          row_info->rowbytes = ((row_info->width *
2350,2353c2591,2595
<    you do this after you deal with the trasparency issue on grayscale
<    or rgb images. If your bit depth is 8, use gamma_table, if it
<    is 16, use gamma_16_table and gamma_shift.  Build these with
<    build_gamma_table(). */
---
>  * you do this after you deal with the trasparency issue on grayscale
>  * or rgb images. If your bit depth is 8, use gamma_table, if it
>  * is 16, use gamma_16_table and gamma_shift.  Build these with
>  * build_gamma_table().
>  */
2362,2364c2604
< #if defined(PNG_USELESS_TESTS_SUPPORTED)
<    if (row != NULL && row_info != NULL &&
< #else
---
>    png_debug(1, "in png_do_gamma\n");
2365a2606,2607
> #if defined(PNG_USELESS_TESTS_SUPPORTED)
>        row != NULL && row_info != NULL &&
2474a2717,2732
>             if (row_info->bit_depth == 2)
>             {
>                for (i = 0, sp = row; i < row_info->width; i += 4)
>                {
>                   int a = *sp & 0xc0;
>                   int b = *sp & 0x30;
>                   int c = *sp & 0x0c;
>                   int d = *sp & 0x03;
> 
>                   *sp = ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
>                         ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
>                         ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
>                         ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6)       );
>                   sp++;
>                }
>             }
2482,2483c2740,2741
<                   *sp = (((int)gamma_table[msb | msb >> 4] + 8) & 0xf0) |
<                         (((int)gamma_table[lsb << 4 | lsb] + 8) >> 4);
---
>                   *sp = (((int)gamma_table[msb | (msb >> 4)]) & 0xf0) |
>                         (((int)gamma_table[(lsb << 4) | lsb]) >> 4);
2515,2516c2773,2775
< /* expands a palette row to an rgb or rgba row depending
<    upon whether you supply trans and num_trans */
---
> /* Expands a palette row to an rgb or rgba row depending
>  * upon whether you supply trans and num_trans.
>  */
2525,2527c2784
< #if defined(PNG_USELESS_TESTS_SUPPORTED)
<    if (row != NULL && row_info != NULL &&
< #else
---
>    png_debug(1, "in png_do_expand_palette\n");
2528a2786,2787
> #if defined(PNG_USELESS_TESTS_SUPPORTED)
>        row != NULL && row_info != NULL &&
2604c2863
<          row_info->rowbytes = (png_size_t)row_info->width;
---
>          row_info->rowbytes = row_info->width;
2617c2876
<                   if (*sp >= (png_byte)num_trans)
---
>                   if ((int)(*sp) >= num_trans)
2628c2887
<                row_info->rowbytes = (png_size_t)row_info->width * 4;
---
>                row_info->rowbytes = row_info->width * 4;
2646c2905
<                row_info->rowbytes = (png_size_t)row_info->width * 3;
---
>                row_info->rowbytes = row_info->width * 3;
2656,2657c2915,2917
< /* if the bit depth < 8, it is expanded to 8.  Also, if the
<    transparency value is supplied, an alpha channel is built. */
---
> /* If the bit depth < 8, it is expanded to 8.  Also, if the
>  * transparency value is supplied, an alpha channel is built.
>  */
2665a2926
>    png_debug(1, "in png_do_expand\n");
2750c3011
<             row_info->rowbytes = (png_size_t)row_info->width;
---
>             row_info->rowbytes = row_info->width;
2793c3054
<                (png_size_t)((row_info->width * row_info->pixel_depth) >> 3);
---
>                ((row_info->width * row_info->pixel_depth) >> 3);
2848c3109
<             (png_size_t)((row_info->width * row_info->pixel_depth) >> 3);
---
>             ((row_info->width * row_info->pixel_depth) >> 3);
2861a3123
>    png_debug(1, "in png_do_dither\n");
2900c3162
<             ((row_info->width * row_info->pixel_depth + 7) >> 3);
---
>              ((row_info->width * row_info->pixel_depth + 7) >> 3);
2930c3192
<             (png_size_t)((row_info->width * row_info->pixel_depth + 7) >> 3);
---
>             ((row_info->width * row_info->pixel_depth + 7) >> 3);
2950,2952c3212,3215
<    tables, we don't make a full table if we are reducing to 8-bit in
<    the future.  Note also how the gamma_16 tables are segmented so that
<    we don't need to allocate > 64K chunks for a full 16-bit table. */
---
>  * tables, we don't make a full table if we are reducing to 8-bit in
>  * the future.  Note also how the gamma_16 tables are segmented so that
>  * we don't need to allocate > 64K chunks for a full 16-bit table.
>  */
2955a3219
>    png_debug(1, "in png_build_gamma_table\n");
2961c3225
<       g = 1.0 / (png_ptr->gamma * png_ptr->display_gamma);
---
>       g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
2972c3236
< #if defined(PNG_BACKGROUND_SUPPORTED)
---
> #if defined(PNG_READ_BACKGROUND_SUPPORTED)
2986c3250
<          g = 1.0 / (png_ptr->display_gamma);
---
>          g = 1.0 / (png_ptr->screen_gamma);
3039c3303
<       g = 1.0 / (png_ptr->gamma * png_ptr->display_gamma);
---
>       g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
3042c3306
<          num * sizeof (png_uint_16p));
---
>          (png_uint_32)(num * sizeof (png_uint_16p)));
3053c3317
<                256 * sizeof (png_uint_16));
---
>                (png_uint_32)(256 * sizeof (png_uint_16)));
3083c3347
<                256 * sizeof (png_uint_16));
---
>                (png_uint_32)(256 * sizeof (png_uint_16)));
3101c3365
<             num * sizeof (png_uint_16p ));
---
>             (png_uint_32)(num * sizeof (png_uint_16p )));
3106c3370
<                256 * sizeof (png_uint_16));
---
>                (png_uint_32)(256 * sizeof (png_uint_16)));
3117c3381
<          g = 1.0 / (png_ptr->display_gamma);
---
>          g = 1.0 / (png_ptr->screen_gamma);
3120c3384
<             num * sizeof (png_uint_16p));
---
>             (png_uint_32)(num * sizeof (png_uint_16p)));
3125c3389
<                256 * sizeof (png_uint_16));
---
>                (png_uint_32)(256 * sizeof (png_uint_16)));
Index: c/pngrutil
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngrutil,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,9c3,13
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  *
>  * This file contains routines which are only called from within
>  * libpng itself during the course of reading an image.
>  */
26c30
<    return i;
---
>    return (i);
43c47
<    return i;
---
>    return (i);
45c49
< #endif /* PNG_READ_BIG_ENDIAN_SUPPORTED */
---
> #endif /* PNG_READ_pCAL_SUPPORTED */
56c60
<    return i;
---
>    return (i);
60,112d63
< /* Set the action on getting a CRC error for an ancillary or critical chunk. */
< void
< png_set_crc_action(png_structp png_ptr, int crit_action, int ancil_action)
< {
<    png_debug(1, "in png_set_crc_action\n");
<    /* Tell libpng how we react to CRC errors in critical chunks */
<    switch (crit_action)
<    {
<       case PNG_CRC_NO_CHANGE:                        /* leave setting as is */
<          break;
<       case PNG_CRC_WARN_USE:                               /* warn/use data */
<          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
<          png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;
<          break;
<       case PNG_CRC_QUIET_USE:                             /* quiet/use data */
<          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
<          png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |
<                            PNG_FLAG_CRC_CRITICAL_IGNORE;
<          break;
<       case PNG_CRC_WARN_DISCARD:    /* not a valid action for critical data */
<          png_warning(png_ptr, "Can't discard critical data on CRC error.");
<       case PNG_CRC_ERROR_QUIT:                                /* error/quit */
<       case PNG_CRC_DEFAULT:
<       default:
<          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
<          break;
<    }
< 
<    switch (ancil_action)
<    {
<       case PNG_CRC_NO_CHANGE:                       /* leave setting as is */
<          break;
<       case PNG_CRC_WARN_USE:                              /* warn/use data */
<          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
<          png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;
<          break;
<       case PNG_CRC_QUIET_USE:                            /* quiet/use data */
<          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
<          png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |
<                            PNG_FLAG_CRC_ANCILLARY_NOWARN;
<          break;
<       case PNG_CRC_ERROR_QUIT:                               /* error/quit */
<          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
<          png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;
<          break;
<       case PNG_CRC_WARN_DISCARD:                      /* warn/discard data */
<       case PNG_CRC_DEFAULT:
<       default:
<          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
<          break;
<    }
< }
< 
141,144d91
<       char msg[80];
< 
<       sprintf(msg,"CRC error in %s", png_ptr->chunk_name);
< 
150c97
<          png_warning(png_ptr, msg);
---
>          png_chunk_warning(png_ptr, "CRC error");
154c101
<          png_error(png_ptr, msg);
---
>          png_chunk_error(png_ptr, "CRC error");
156c103
<       return 1;
---
>       return (1);
159c106
<    return 0;
---
>    return (0);
162c109
< /* Compare the CRC stored in the PNG file with that calulated by libpng from
---
> /* Compare the CRC stored in the PNG file with that calculated by libpng from
188,192c135
< #ifdef PNG_USE_OWN_CRC
<       return (((crc^0xffffffffL)&0xffffffffL) != (png_ptr->crc&0xffffffffL));
< #else
<       return (crc != png_ptr->crc);
< #endif
---
>       return ((int)(crc != png_ptr->crc));
195c138
<       return 0;
---
>       return (0);
231c174,175
<    if (width == 0 || width > 2147483647 || height == 0 || height > 2147483647)
---
>    if (width == 0 || width > (png_uint_32)2147483647L || height == 0 ||
>         height > (png_uint_32)2147483647L)
249c193
<    if (interlace_type > PNG_INTERLACE_ADAM7)
---
>    if (interlace_type >= PNG_INTERLACE_LAST)
285c229
<       png_ptr->channels);
---
>    png_ptr->channels);
316a261,274
> #if defined (PNG_READ_tRNS_SUPPORTED)
>    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
>    {
>       if (info_ptr != NULL && info_ptr->valid & PNG_INFO_tRNS)
>       {
>          if (png_ptr->num_trans > png_ptr->num_palette)
>          {
>             png_warning(png_ptr, "Truncating incorrect tRNS chunk length");
>             png_ptr->num_trans = png_ptr->num_palette;
>          }
>       }
>    }
> #endif
> 
340c298
<    palette = (png_colorp)png_malloc(png_ptr, num * sizeof (png_color));
---
>    palette = (png_colorp)png_zalloc(png_ptr, (uInt)num, sizeof (png_color));
356a315
> #if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
357a317
> #endif
360a321
> #if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
363,366d323
<       char msg[80];
< 
<       sprintf(msg,"CRC error in %s", png_ptr->chunk_name);
< 
375c332
<             png_error(png_ptr, msg);
---
>             png_chunk_error(png_ptr, "CRC error");
379c336
<             png_warning(png_ptr, msg);
---
>             png_chunk_warning(png_ptr, "CRC error");
381c338
<             png_free(png_ptr, palette);
---
>             png_zfree(png_ptr, palette);
388c345
<          png_warning(png_ptr, msg);
---
>          png_chunk_warning(png_ptr, "CRC error");
391c348
< 
---
> #endif
404a362,365
> 
>       /* to quiet compiler warnings about unused info_ptr */
>       if (info_ptr == NULL)
>          return;
412d372
<       png_crc_finish(png_ptr, length);
413a374
>    png_crc_finish(png_ptr, length);
437c398,403
<    else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_gAMA)
---
> 
>    else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_gAMA
> #if defined(PNG_READ_sRGB_SUPPORTED)
>       && !(info_ptr->valid & PNG_INFO_sRGB)
> #endif
>       )
459a426,438
> #if defined(PNG_READ_sRGB_SUPPORTED)
>    if (info_ptr->valid & PNG_INFO_sRGB)
>       if(igamma != (png_uint_32)45000L)
>       {
>          png_warning(png_ptr,
>            "Ignoring incorrect gAMA value when sRGB is also present");
> #ifndef PNG_NO_STDIO
>          fprintf(stderr, "igamma = %lu\n", igamma);
> #endif
>          return;
>       }
> #endif /* PNG_READ_sRGB_SUPPORTED */
> 
460a440
> #ifdef PNG_READ_GAMMA_SUPPORTED
461a442
> #endif
485a467
>    {
487a470
>    }
548c531,536
<    else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_cHRM)
---
> 
>    else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_cHRM
> #if defined(PNG_READ_sRGB_SUPPORTED)
>       && !(info_ptr->valid & PNG_INFO_sRGB)
> #endif
>       )
618,619c606,607
<    if (blue_x < 0 || blue_x > 0.8 || blue_y < 0 || blue_y > 0.8 ||
<        blue_x + blue_y > 1.0)
---
>    if (blue_x < (float)0 || blue_x > (float)0.8 || blue_y < (float)0 ||
>        blue_y > (float)0.8 || blue_x + blue_y > (float)1.0)
628a617,642
> #if defined(PNG_READ_sRGB_SUPPORTED)
>    if (info_ptr->valid & PNG_INFO_sRGB)
>       {
>       if (fabs(white_x - (float).3127) > (float).001 ||
>           fabs(white_y - (float).3290) > (float).001 ||
>           fabs(  red_x - (float).6400) > (float).001 ||
>           fabs(  red_y - (float).3300) > (float).001 ||
>           fabs(green_x - (float).3000) > (float).001 ||
>           fabs(green_y - (float).6000) > (float).001 ||
>           fabs( blue_x - (float).1500) > (float).001 ||
>           fabs( blue_y - (float).0600) > (float).001)
>          {
> 
>             png_warning(png_ptr,
>               "Ignoring incorrect cHRM value when sRGB is also present");
> #ifndef PNG_NO_STDIO
>             fprintf(stderr,"wx=%f, wy=%f, rx=%f, ry=%f\n",
>                white_x, white_y, red_x, red_y);
>             fprintf(stderr,"gx=%f, gy=%f, bx=%f, by=%f\n",
>                green_x, green_y, blue_x, blue_y);
> #endif
>          }
>          return;
>       }
> #endif /* PNG_READ_sRGB_SUPPORTED */
> 
633a648,726
> #if defined(PNG_READ_sRGB_SUPPORTED)
> void
> png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
> {
>    int intent;
>    png_byte buf[1];
> 
>    png_debug(1, "in png_handle_sRGB\n");
> 
>    if (!(png_ptr->mode & PNG_HAVE_IHDR))
>       png_error(png_ptr, "Missing IHDR before sRGB");
>    else if (png_ptr->mode & PNG_HAVE_IDAT)
>    {
>       png_warning(png_ptr, "Invalid sRGB after IDAT");
>       png_crc_finish(png_ptr, length);
>       return;
>    }
>    else if (png_ptr->mode & PNG_HAVE_PLTE)
>       /* Should be an error, but we can cope with it */
>       png_warning(png_ptr, "Out of place sRGB chunk");
> 
>    else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_sRGB)
>    {
>       png_warning(png_ptr, "Duplicate sRGB chunk");
>       png_crc_finish(png_ptr, length);
>       return;
>    }
> 
>    if (length != 1)
>    {
>       png_warning(png_ptr, "Incorrect sRGB chunk length");
>       png_crc_finish(png_ptr, length);
>       return;
>    }
> 
>    png_crc_read(png_ptr, buf, 1);
>    if (png_crc_finish(png_ptr, 0))
>       return;
> 
>    intent = buf[0];
>    /* check for bad intent */
>    if (intent >= PNG_sRGB_INTENT_LAST)
>    {
>       png_warning(png_ptr, "Unknown sRGB intent");
>       return;
>    }
> 
> #if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)
>    if ((info_ptr->valid & PNG_INFO_gAMA))
>       if((png_uint_32)(png_ptr->gamma*(float)100000.+.5) != (png_uint_32)45000L)
>       {
>          png_warning(png_ptr,
>            "Ignoring incorrect gAMA value when sRGB is also present");
> #ifndef PNG_NO_STDIO
>            fprintf(stderr,"gamma=%f\n",png_ptr->gamma);
> #endif
>       }
> #endif /* PNG_READ_gAMA_SUPPORTED */
> 
> #ifdef PNG_READ_cHRM_SUPPORTED
>    if (info_ptr->valid & PNG_INFO_cHRM)
>       if (fabs(info_ptr->x_white - (float).3127) > (float).001 ||
>           fabs(info_ptr->y_white - (float).3290) > (float).001 ||
>           fabs(  info_ptr->x_red - (float).6400) > (float).001 ||
>           fabs(  info_ptr->y_red - (float).3300) > (float).001 ||
>           fabs(info_ptr->x_green - (float).3000) > (float).001 ||
>           fabs(info_ptr->y_green - (float).6000) > (float).001 ||
>           fabs( info_ptr->x_blue - (float).1500) > (float).001 ||
>           fabs( info_ptr->y_blue - (float).0600) > (float).001)
>          {
>             png_warning(png_ptr,
>               "Ignoring incorrect cHRM value when sRGB is also present");
>          }
> #endif /* PNG_READ_cHRM_SUPPORTED */
> 
>    png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, intent);
> }
> #endif /* PNG_READ_sRGB_SUPPORTED */
> 
650c743
<       png_warning(png_ptr, "Duplcate tRNS chunk");
---
>       png_warning(png_ptr, "Duplicate tRNS chunk");
686c779
<       png_ptr->num_trans = 3;
---
>       png_ptr->num_trans = 1;
828c921
<    if (length != 2 * png_ptr->num_palette)
---
>    if (length != (png_uint_32)(2 * png_ptr->num_palette))
837c930
<       num * sizeof (png_uint_16));
---
>       (png_uint_32)(num * sizeof (png_uint_16)));
949a1043
>    png_size_t slength;
972c1066,1067
<    png_crc_read(png_ptr, (png_bytep)purpose, (png_size_t)length);
---
>    slength = (png_size_t)length;
>    png_crc_read(png_ptr, (png_bytep)purpose, slength);
980c1075
<    purpose[length] = '\0'; /* null terminate the last string */
---
>    purpose[slength] = 0x00; /* null terminate the last string */
986c1081
<    endptr = purpose + length;
---
>    endptr = purpose + slength;
1022c1117
<    for (buf = units; *buf != '\0'; buf++);
---
>    for (buf = units; *buf != 0x00; buf++);
1025c1120,1121
<    params = (png_charpp)png_malloc(png_ptr, nparams*sizeof(png_charp)) ;
---
>    params = (png_charpp)png_malloc(png_ptr, (png_uint_32)(nparams
>       *sizeof(png_charp))) ;
1028c1124
<    for (i = 0; i < nparams; i++)
---
>    for (i = 0; i < (int)nparams; i++)
1034c1130
<       for (params[i] = buf; *buf != '\0' && buf <= endptr; buf++);
---
>       for (params[i] = buf; *buf != 0x00 && buf <= endptr; buf++);
1105a1202
>    png_size_t slength;
1116c1213
<    if (length > 65535L)
---
>    if (length > (png_uint_32)65535L)
1119,1120c1216,1217
<       skip = length - 65535L;
<       length = 65535L;
---
>       skip = length - (png_uint_32)65535L;
>       length = (png_uint_32)65535L;
1125c1222,1223
<    png_crc_read(png_ptr, (png_bytep)key, (png_size_t)length);
---
>    slength = (png_size_t)length;
>    png_crc_read(png_ptr, (png_bytep)key, slength);
1133c1231
<    key[length] = '\0';
---
>    key[slength] = 0x00;
1138c1236
<    if (text != key + (png_size_t)length)
---
>    if (text != key + slength)
1141c1239
<    text_ptr = (png_textp)png_malloc(png_ptr, sizeof(png_text));
---
>    text_ptr = (png_textp)png_malloc(png_ptr, (png_uint_32)sizeof(png_text));
1161a1260
>    png_size_t slength;
1174c1273
<    if (length > 65535L)
---
>    if (length > (png_uint_32)65535L)
1183c1282,1283
<    png_crc_read(png_ptr, (png_bytep)key, (png_size_t)length);
---
>    slength = (png_size_t)length;
>    png_crc_read(png_ptr, (png_bytep)key, slength);
1190c1290
<    key[length] = '\0';
---
>    key[slength] = 0x00;
1196c1296
<    if (text == key + (png_size_t)length)
---
>    if (text == key + slength)
1208c1308
<       png_ptr->zstream.avail_out = png_ptr->zbuf_size;
---
>       png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
1210c1310
<       key_size = text - key;
---
>       key_size = (png_size_t)(text - key);
1231c1331
<                text = (png_charp)png_malloc(png_ptr, text_size);
---
>                text = (png_charp)png_malloc(png_ptr, (png_uint_32)text_size);
1235c1335
<             text[text_size - 1] = '\0';
---
>             text[text_size - 1] = 0x00;
1238c1338
<             text_size = length - (text - key) - 1;
---
>             text_size = (png_size_t)(slength - (text - key) - 1);
1248,1249c1348,1349
<                   png_ptr->zbuf_size - png_ptr->zstream.avail_out +
<                      key_size + 1);
---
>                   (png_uint_32)(png_ptr->zbuf_size - png_ptr->zstream.avail_out
>                      + key_size + 1));
1255c1355
<                *(text + text_size) = '\0';
---
>                *(text + text_size) = 0x00;
1262,1263c1362,1363
<                text = png_malloc(png_ptr, text_size +
<                   png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1);
---
>                text = (png_charp)png_malloc(png_ptr, (png_uint_32)(text_size +
>                   png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1));
1269c1369
<                *(text + text_size) = '\0';
---
>                *(text + text_size) = 0x00;
1289d1388
<       text_size -= key_size;
1293a1393
> #if !defined(PNG_NO_STDIO)
1297a1398,1400
> #else
>       png_warning(png_ptr, "Unknown zTXt compression type");
> #endif
1300c1403
<       text_size = (png_size_t)length - (text - key) - 1;
---
>       text_size = (png_size_t)(slength - (text - key) - 1);
1305c1408
<    text_ptr = (png_textp)png_malloc(png_ptr, sizeof(png_text));
---
>    text_ptr = (png_textp)png_malloc(png_ptr, (png_uint_32)sizeof(png_text));
1332c1435
<       char msg[40];
---
>       png_chunk_error(png_ptr, "unknown critical chunk");
1334,1335c1437,1439
<       sprintf(msg, "Unknown critical chunk %s", png_ptr->chunk_name);
<       png_error(png_ptr, msg);
---
>       /* to quiet compiler warnings about unused info_ptr */
>       if (info_ptr == NULL)
>          return;
1341a1446
> 
1359,1363c1464
<       char msg[45];
< 
<       sprintf(msg, "Invalid chunk type 0x%02X 0x%02X 0x%02X 0x%02X",
<          chunk_name[0], chunk_name[1], chunk_name[2], chunk_name[3]);
<       png_error(png_ptr, msg);
---
>       png_chunk_error(png_ptr, "invalid chunk type");
1630c1731
<                 s_inc = +1;
---
>                 s_inc = 1;
1663,1664c1764
<             png_byte v;
<             png_uint_32 i, j;
---
>             png_uint_32 i;
1666,1667c1766,1767
<             sp = row + (png_size_t)((row_info->width - 1) >> 2);
<             dp = row + (png_size_t)((final_width - 1) >> 2);
---
>             sp = row + (png_uint_32)((row_info->width - 1) >> 2);
>             dp = row + (png_uint_32)((final_width - 1) >> 2);
1671,1672c1771,1772
<                sshift = (png_size_t)(((row_info->width + 3) & 3) << 1);
<                dshift = (png_size_t)(((final_width + 3) & 3) << 1);
---
>                sshift = (int)(((row_info->width + 3) & 3) << 1);
>                dshift = (int)(((final_width + 3) & 3) << 1);
1680,1681c1780,1781
<                sshift = (png_size_t)((3 - ((row_info->width + 3) & 3)) << 1);
<                dshift = (png_size_t)((3 - ((final_width + 3) & 3)) << 1);
---
>                sshift = (int)((3 - ((row_info->width + 3) & 3)) << 1);
>                dshift = (int)((3 - ((final_width + 3) & 3)) << 1);
1684c1784
<                s_inc = +2;
---
>                s_inc = 2;
1688a1789,1791
>                png_byte v;
>                int j;
> 
1717d1819
<             png_byte v;
1719d1820
<             int j;
1726,1727c1827,1828
<                sshift = (png_size_t)(((row_info->width + 1) & 1) << 2);
<                dshift = (png_size_t)(((final_width + 1) & 1) << 2);
---
>                sshift = (int)(((row_info->width + 1) & 1) << 2);
>                dshift = (int)(((final_width + 1) & 1) << 2);
1735,1736c1836,1837
<                sshift = (png_size_t)((1 - ((row_info->width + 1) & 1)) << 2);
<                dshift = (png_size_t)((1 - ((final_width + 1) & 1)) << 2);
---
>                sshift = (int)((1 - ((row_info->width + 1) & 1)) << 2);
>                dshift = (int)((1 - ((final_width + 1) & 1)) << 2);
1743a1845,1847
>                png_byte v;
>                int j;
> 
1770d1873
<             png_byte v[8];
1773d1875
<             int j;
1777,1778c1879,1880
<             sp = row + (row_info->width - 1) * pixel_bytes;
<             dp = row + (final_width - 1) * pixel_bytes;
---
>             sp = row + (png_size_t)(row_info->width - 1) * pixel_bytes;
>             dp = row + (png_size_t)(final_width - 1) * pixel_bytes;
1780a1883,1885
>                png_byte v[8];
>                int j;
> 
1805a1911
> 
1919c2025
<       png_memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
---
>       png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
1929,1930c2035,2037
<          png_ptr->irowbytes = ((png_ptr->iwidth *
<             png_ptr->pixel_depth + 7) >> 3) + 1;
---
>             png_ptr->irowbytes = ((png_ptr->iwidth *
>                (png_uint_32)png_ptr->pixel_depth + 7) >> 3) +1;
> 
1955c2062
<       do
---
>       for(;;)
1998c2105
<       } while (1);
---
>       }
2031,2032c2138,2143
<       png_ptr->irowbytes = ((png_ptr->iwidth *
<          png_ptr->pixel_depth + 7) >> 3) + 1;
---
> 
>          rowbytes = ((png_ptr->iwidth *
>             (png_uint_32)png_ptr->pixel_depth + 7) >> 3) +1;
>          png_ptr->irowbytes = (png_size_t)rowbytes;
>          if((png_uint_32)png_ptr->irowbytes != rowbytes)
>             png_error(png_ptr, "Rowbytes overflow in png_read_start_row");
2112c2223
<    if (rowbytes > 65536L)
---
>    if (rowbytes > (png_uint_32)65536L)
2118c2229
<    if (png_ptr->rowbytes + 1 > 65536L)
---
>    if ((png_uint_32)png_ptr->rowbytes + 1 > (png_uint_32)65536L)
2121c2232,2233
<    png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, png_ptr->rowbytes + 1);
---
>    png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
>       png_ptr->rowbytes + 1));
2123c2235
<    png_memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
---
>    png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
Index: c/pngset
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngset,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,9c3,15
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  *
>  * The functions here are used during reads to store data from the file
>  * into the info struct, and during writes to store application data
>  * into the info struct for writing into the file.  This abstracts the
>  * info struct and allows us to change the structure in the future.
>  */
19c25
<    if (info_ptr == NULL)
---
>    if (png_ptr == NULL || info_ptr == NULL)
34c40
<    if (info_ptr == NULL)
---
>    if (png_ptr == NULL || info_ptr == NULL)
54c60
<    if (info_ptr == NULL)
---
>    if (png_ptr == NULL || info_ptr == NULL)
67c73
<    if (info_ptr == NULL)
---
>    if (png_ptr == NULL || info_ptr == NULL)
80a87
>    int rowbytes_per_pixel;
82c89
<    if (info_ptr == NULL)
---
>    if (png_ptr == NULL || info_ptr == NULL)
101c108,117
<    info_ptr->rowbytes = ((info_ptr->width * info_ptr->pixel_depth + 7) >> 3);
---
> 
>    /* check for overflow */
>    rowbytes_per_pixel = (info_ptr->pixel_depth + 7) >> 3;
>    info_ptr->rowbytes = info_ptr->width * rowbytes_per_pixel;
>    if (( width > (png_uint_32)2147483647L/rowbytes_per_pixel))
>    {
>       png_warning(png_ptr,
>          "Width too large to process image data; rowbytes will overflow.");
>       info_ptr->rowbytes = (png_size_t)0;
>    }
110c126
<    if (info_ptr == NULL)
---
>    if (png_ptr == NULL || info_ptr == NULL)
130c146
<    if (info_ptr == NULL)
---
>    if (png_ptr == NULL || info_ptr == NULL)
136c152
<    png_memcpy(info_ptr->pcal_purpose, purpose, length);
---
>    png_memcpy(info_ptr->pcal_purpose, purpose, (png_size_t)length);
147c163
<    png_memcpy(info_ptr->pcal_units, units, length);
---
>    png_memcpy(info_ptr->pcal_units, units, (png_size_t)length);
150c166
<       (nparams + 1) * sizeof(png_charp));
---
>       (png_uint_32)((nparams + 1) * sizeof(png_charp)));
158c174
<       png_memcpy(info_ptr->pcal_params[i], params[i], length);
---
>       png_memcpy(info_ptr->pcal_params[i], params[i], (png_size_t)length);
171c187
<    if (info_ptr == NULL)
---
>    if (png_ptr == NULL || info_ptr == NULL)
186c202
<    if (info_ptr == NULL)
---
>    if (png_ptr == NULL || info_ptr == NULL)
200c216
<    if (info_ptr == NULL)
---
>    if (png_ptr == NULL || info_ptr == NULL)
208,209c224,274
< #if defined(PNG_READ_tEXt_SUPPORTED) || defined(PNG_WRITE_zTXt_SUPPORTED) || \
<     defined(PNG_READ_tEXt_SUPPORTED) || defined(PNG_WRITE_zTXt_SUPPORTED)
---
> #if defined(PNG_READ_sRGB_SUPPORTED) || defined(PNG_WRITE_sRGB_SUPPORTED)
> void
> png_set_sRGB(png_structp png_ptr, png_infop info_ptr, int intent)
> {
>    png_debug1(1, "in %s storage function\n", "sRGB");
>    if (png_ptr == NULL || info_ptr == NULL)
>       return;
> 
>    info_ptr->srgb_intent = (png_byte)intent;
>    info_ptr->valid |= PNG_INFO_sRGB;
> }
> void
> png_set_sRGB_gAMA_and_cHRM(png_structp png_ptr, png_infop info_ptr,
>    int intent)
> {
> #if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_WRITE_gAMA_SUPPORTED)
>    float file_gamma;
> #endif
> #if defined(PNG_READ_cHRM_SUPPORTED) || defined(PNG_WRITE_cHRM_SUPPORTED)
>    float white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;
> #endif
>    png_debug1(1, "in %s storage function\n", "sRGB_gAMA_and_cHRM");
>    if (png_ptr == NULL || info_ptr == NULL)
>       return;
> 
>    png_set_sRGB(png_ptr, info_ptr, intent);
> 
> #if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_WRITE_gAMA_SUPPORTED)
>    file_gamma = (float).45;
>    png_set_gAMA(png_ptr, info_ptr, file_gamma);
> #endif
> 
> #if defined(PNG_READ_cHRM_SUPPORTED) || defined(PNG_WRITE_cHRM_SUPPORTED)
>    white_x = (float).3127;
>    white_y = (float).3290;
>    red_x   = (float).64;
>    red_y   = (float).33;
>    green_x = (float).30;
>    green_y = (float).60;
>    blue_x  = (float).15;
>    blue_y  = (float).06;
> 
>    png_set_cHRM(png_ptr, info_ptr,
>       white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
> 
> #endif
> }
> #endif
> 
> #if defined(PNG_READ_tEXt_SUPPORTED) || defined(PNG_WRITE_tEXt_SUPPORTED) || \
>     defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_WRITE_zTXt_SUPPORTED)
217c282
<       "text" : png_ptr->chunk_name));
---
>       "text" : (png_const_charp)png_ptr->chunk_name));
219c284
<    if (info_ptr == NULL || num_text == 0)
---
>    if (png_ptr == NULL || info_ptr == NULL || num_text == 0)
236,237c301,303
<             info_ptr->max_text * sizeof (png_text));
<          png_memcpy(info_ptr->text, old_text, old_max * sizeof(png_text));
---
>             (png_uint_32)(info_ptr->max_text * sizeof (png_text)));
>          png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *
>             sizeof(png_text)));
245c311
<             info_ptr->max_text * sizeof (png_text));
---
>             (png_uint_32)(info_ptr->max_text * sizeof (png_text)));
256c322
<          text_ptr[i].text = "";
---
>          text_ptr[i].text = (png_charp)"";
265c331
<          textp->text_length = strlen(text_ptr[i].text);
---
>          textp->text_length = png_strlen(text_ptr[i].text);
281c347
<    if (info_ptr == NULL)
---
>    if (png_ptr == NULL || info_ptr == NULL)
295c361
<    if (info_ptr == NULL)
---
>    if (png_ptr == NULL || info_ptr == NULL)
302c368,369
<    else
---
> 
>    if (trans_values != NULL)
305a373,374
>       if (num_trans == 0)
>         num_trans = 1;
Index: c/pngtest
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngtest,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,9c3,28
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  *
>  * This program reads in a PNG image, writes it out again, and then
>  * compares the two files.  If the files are identical, this shows that
>  * the basic chunk handling, filtering, and (de)compression code is working
>  * properly.  It does not currently test all of the transforms, although
>  * it probably should.
>  *
>  * The program will fail in certain legitimate cases:
>  * 1) when the compression level or filter selection method is changed.
>  * 2) when the chunk size is smaller than 8K.
>  * 3) unknown ancillary chunks exist in the input file.
>  * 4) others not listed here...
>  * In these cases, it is best to check with another tool such as "pngcheck"
>  * to see what the differences between the two images are.
>  *
>  * If a filename is given on the command-line, then this file is used
>  * for the input, rather than the default "pngtest.png".  This allows
>  * testing a wide variety of files easily.
>  */
20a40,41
> int test_one_file PNGARG((PNG_CONST char *inname, PNG_CONST char *outname));
> 
29,32c50,274
< /* input and output filenames */
< #ifdef RISCOS
< char *inname = "pngtest_png";
< char *outname = "pngout_png";
---
> /* example of using row callbacks to make a simple progress meter */
> static int status_pass=1;
> static int status_dots_requested=0;
> static int status_dots=1;
> 
> void
> read_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)
> {
>     if(png_ptr == NULL || row_number > 0x3fffffffL) return;
>     if(status_pass != pass)
>     {
>        fprintf(stdout,"\n Pass %d: ",pass);
>        status_pass = pass;
>        status_dots = 30;
>     }
>     status_dots--;
>     if(status_dots == 0)
>     {
>        fprintf(stdout, "\n         ");
>        status_dots=30;
>     }
>     fprintf(stdout, "r");
> }
> 
> void
> write_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)
> {
>     if(png_ptr == NULL || row_number > 0x3fffffffL || pass > 7) return;
>     fprintf(stdout, "w");
> }
> 
> 
> #if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
> /* example of using user transform callback (we don't transform anything,
>    but merely count the black pixels) */
> 
> static png_uint_32 black_pixels;
> 
> void
> count_black_pixels(png_structp png_ptr, png_row_infop row_info, png_bytep data)
> {
>    png_bytep dp = data;
>    if(png_ptr == NULL)return; 
> 
>    /* contents of row_info:
>     *  png_uint_32 width      width of row
>     *  png_uint_32 rowbytes   number of bytes in row
>     *  png_byte color_type    color type of pixels
>     *  png_byte bit_depth     bit depth of samples
>     *  png_byte channels      number of channels (1-4)
>     *  png_byte pixel_depth   bits per pixel (depth*channels)
>     */
> 
>     /* counts the number of black pixels (or zero pixels if color_type is 3 */
> 
>     if(row_info->color_type == 0 || row_info->color_type == 3)
>     {
>        int pos=0;
>        png_uint_32 n;
>        for (n=0; n<row_info->width; n++)
>        {
>           if(row_info->bit_depth == 1)
>              if(((*dp << pos++ )& 0x80) == 0) black_pixels++;
>              if(pos == 8)
>              {
>                 pos=0;
>                 dp++;
>              }
>           if(row_info->bit_depth == 2)
>              if(((*dp << (pos+=2))& 0xc0) == 0) black_pixels++;
>              if(pos == 8)
>              {
>                 pos=0;
>                 dp++;
>              }
>           if(row_info->bit_depth == 4)
>              if(((*dp << (pos+=4))& 0xf0) == 0) black_pixels++;
>              if(pos == 8)
>              {
>                 pos=0;
>                 dp++;
>              }
>           if(row_info->bit_depth == 8)
>              if(*dp++ == 0) black_pixels++;
>           if(row_info->bit_depth == 16)
>           {
>              if((*dp | *(dp+1)) == 0) black_pixels++;
>              dp+=2;
>           }
>        }
>     }
>     else /* other color types */
>     {
>        png_uint_32 n;
>        int channel;
>        int color_channels = row_info->channels;
>        if(row_info->color_type > 3)color_channels--;
> 
>        for (n=0; n<row_info->width; n++)
>        {
>           for (channel = 0; channel < color_channels; channel++)
>           {
>              if(row_info->bit_depth == 8)
>                 if(*dp++ == 0) black_pixels++;
>              if(row_info->bit_depth == 16)
>              {
>                 if((*dp | *(dp+1)) == 0) black_pixels++;
>                 dp+=2;
>              }
>           }
>           if(row_info->color_type > 3)
>           {
>              dp++;
>              if(row_info->bit_depth == 16)dp++;
>           }
>        }
>     }
> }
> #endif /* PNG_WRITE_USER_TRANSFORM_SUPPORTED */
> 
> static int verbose = 0;
> static int wrote_question = 0;
> 
> #if defined(PNG_NO_STDIO)
> /* START of code to validate stdio-free compilation */
> /* These copies of the default read/write functions come from pngrio.c and */
> /* pngwio.c.  They allow "don't include stdio" testing of the library. */
> /* This is the function which does the actual reading of data.  If you are
>    not reading from a standard C stream, you should create a replacement
>    read_data function and use it at run time with png_set_read_fn(), rather
>    than changing the library. */
> #ifndef USE_FAR_KEYWORD
> static void
> png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
> {
>    png_size_t check;
> 
>    /* fread() returns 0 on error, so it is OK to store this in a png_size_t
>     * instead of an int, which is what fread() actually returns.
>     */
>    check = (png_size_t)fread(data, (png_size_t)1, length,
>       (FILE *)png_ptr->io_ptr);
> 
>    if (check != length)
>    {
>       png_error(png_ptr, "Read Error");
>    }
> }
> #else
> /* this is the model-independent version. Since the standard I/O library
>    can't handle far buffers in the medium and small models, we have to copy
>    the data.
> */
>  
> #define NEAR_BUF_SIZE 1024
> #define MIN(a,b) (a <= b ? a : b)
>  
> static void
> png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
> {
>    int check;
>    png_byte *n_data;
>    FILE *io_ptr;
> 
>    /* Check if data really is near. If so, use usual code. */
>    n_data = (png_byte *)CVT_PTR_NOCHECK(data);
>    io_ptr = (FILE *)CVT_PTR(png_ptr->io_ptr);
>    if ((png_bytep)n_data == data)
>    {
>       check = fread(n_data, 1, length, io_ptr);
>    }
>    else
>    {
>       png_byte buf[NEAR_BUF_SIZE];
>       png_size_t read, remaining, err;
>       check = 0;
>       remaining = length;
>       do
>       {
>          read = MIN(NEAR_BUF_SIZE, remaining);
>          err = fread(buf, (png_size_t)1, read, io_ptr);
>          png_memcpy(data, buf, read); /* copy far buffer to near buffer */
>          if(err != read)
>             break;
>          else
>             check += err;
>          data += read;
>          remaining -= read;
>       }
>       while (remaining != 0);
>    }
>    if (check != length)
>    {
>       png_error(png_ptr, "read Error");
>    }
> }
> #endif /* USE_FAR_KEYWORD */
> 
> #if defined(PNG_WRITE_FLUSH_SUPPORTED)
> static void
> png_default_flush(png_structp png_ptr)
> {
>    FILE *io_ptr;
>    io_ptr = (FILE *)CVT_PTR((png_ptr->io_ptr));
>    if (io_ptr != NULL)
>       fflush(io_ptr);
> }
> #endif
> 
> /* This is the function which does the actual writing of data.  If you are
>    not writing to a standard C stream, you should create a replacement
>    write_data function and use it at run time with png_set_write_fn(), rather
>    than changing the library. */
> #ifndef USE_FAR_KEYWORD
> static void
> png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
> {
>    png_uint_32 check;
> 
>    check = fwrite(data, 1, length, (FILE *)(png_ptr->io_ptr));
>    if (check != length)
>    {
>       png_error(png_ptr, "Write Error");
>    }
> }
34,35c276,420
< char *inname = "pngtest.png";
< char *outname = "pngout.png";
---
> /* this is the model-independent version. Since the standard I/O library
>    can't handle far buffers in the medium and small models, we have to copy
>    the data.
> */
> 
> #define NEAR_BUF_SIZE 1024
> #define MIN(a,b) (a <= b ? a : b)
> 
> static void
> png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
> {
>    png_uint_32 check;
>    png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
>    FILE *io_ptr;
> 
>    /* Check if data really is near. If so, use usual code. */
>    near_data = (png_byte *)CVT_PTR_NOCHECK(data);
>    io_ptr = (FILE *)CVT_PTR(png_ptr->io_ptr);
>    if ((png_bytep)near_data == data)
>    {
>       check = fwrite(near_data, 1, length, io_ptr);
>    }
>    else
>    {
>       png_byte buf[NEAR_BUF_SIZE];
>       png_size_t written, remaining, err;
>       check = 0;
>       remaining = length;
>       do
>       {
>          written = MIN(NEAR_BUF_SIZE, remaining);
>          png_memcpy(buf, data, written); /* copy far buffer to near buffer */
>          err = fwrite(buf, 1, written, io_ptr);
>          if (err != written)
>             break;
>          else
>             check += err;
>          data += written;
>          remaining -= written;
>       }
>       while (remaining != 0);
>    }
>    if (check != length)
>    {
>       png_error(png_ptr, "Write Error");
>    }
> }
> 
> #endif /* USE_FAR_KEYWORD */
> 
> /* This function is called when there is a warning, but the library thinks
>  * it can continue anyway.  Replacement functions don't have to do anything
>  * here if you don't want to.  In the default configuration, png_ptr is
>  * not used, but it is passed in case it may be useful.
>  */
> static void
> png_default_warning(png_structp png_ptr, png_const_charp message)
> {
>    PNG_CONST char *name = "UNKNOWN (ERROR!)";
>    if (png_ptr != NULL && png_ptr->error_ptr != NULL)
>       name = png_ptr->error_ptr;
>    fprintf(STDERR, "%s: libpng warning: %s\n", name, message);
> }
> 
> /* This is the default error handling function.  Note that replacements for
>  * this function MUST NOT RETURN, or the program will likely crash.  This
>  * function is used by default, or if the program supplies NULL for the
>  * error function pointer in png_set_error_fn().
>  */
> static void
> png_default_error(png_structp png_ptr, png_const_charp message)
> {
>    png_default_warning(png_ptr, message);
>    /* We can return because png_error calls the default handler which is
>     * actually ok in this case. */
> }
> #endif /* PNG_NO_STDIO */
> /* END of code to validate stdio-free compilation */
> 
> /* START of code to validate memory allocation and deallocation */
> #ifdef PNGTEST_MEMORY_DEBUG
> /* Borland DOS special memory handler */
> #if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
> ERROR - memory debugging is not supported on this platform
> #else
> 
> /* Allocate memory.  For reasonable files, size should never exceed
>    64K.  However, zlib may allocate more then 64K if you don't tell
>    it not to.  See zconf.h and png.h for more information.  zlib does
>    need to allocate exactly 64K, so whatever you call here must
>    have the ability to do that.
> 
>    This piece of code can be compiled to validate max 64K allocations
>    by setting MAXSEG_64K in zlib zconf.h *or* PNG_MAX_MALLOC_64K. */
> typedef struct memory_information {
>    png_uint_32                    size;
>    png_voidp                      pointer;
>    struct memory_information FAR *next;
> } memory_information;
> typedef memory_information FAR *memory_infop;
> 
> static memory_infop pinformation = NULL;
> static int current_allocation = 0;
> static int maximum_allocation = 0;
> 
> extern PNG_EXPORT(png_voidp,png_debug_malloc) PNGARG((png_structp png_ptr,
>    png_uint_32 size));
> extern PNG_EXPORT(void,png_debug_free) PNGARG((png_structp png_ptr,
>    png_voidp ptr));
> 
> png_voidp
> png_malloc(png_structp png_ptr, png_uint_32 size) {
>    if (png_ptr == NULL) {
>       fprintf(STDERR, "NULL pointer to memory allocator\n");
>       return (NULL);
>    }
>    if (size == 0)
>       return (png_voidp)(NULL);
> 
>    /* This calls the library allocator twice, once to get the requested
>       buffer and once to get a new free list entry. */
>    {
>       memory_infop pinfo = png_debug_malloc(png_ptr, sizeof *pinfo);
>       pinfo->size = size;
>       current_allocation += size;
>       if (current_allocation > maximum_allocation)
>          maximum_allocation = current_allocation;
>       pinfo->pointer = png_debug_malloc(png_ptr, size);
>       pinfo->next = pinformation;
>       pinformation = pinfo;
>       /* Make sure the caller isn't assuming zeroed memory. */
>       png_memset(pinfo->pointer, 0xdd, pinfo->size);
>       return (png_voidp)(pinfo->pointer);
>    }
> }
> 
> /* Free a pointer.  It is removed from the list at the same time. */
> void
> png_free(png_structp png_ptr, png_voidp ptr)
> {
>    if (png_ptr == NULL)
>       fprintf(STDERR, "NULL pointer to memory allocator\n");
>    if (ptr == 0) {
> #if 0 /* This happens all the time. */
>       fprintf(STDERR, "WARNING: freeing NULL pointer\n");
36a422,423
>       return;
>    }
38c425,447
< char inbuf[256], outbuf[256];
---
>    /* Unlink the element from the list. */
>    {
>       memory_infop FAR *ppinfo = &pinformation;
>       for (;;) {
>          memory_infop pinfo = *ppinfo;
>          if (pinfo->pointer == ptr) {
>             *ppinfo = pinfo->next;
>             current_allocation -= pinfo->size;
>             if (current_allocation < 0)
>                fprintf(STDERR, "Duplicate free of memory\n");
>             /* We must free the list element too, but first kill
>                the memory which is to be freed. */
>             memset(ptr, 0x55, pinfo->size);
>             png_debug_free(png_ptr, pinfo);
>             break;
>          }
>          if (pinfo->next == NULL) {
>             fprintf(STDERR, "Pointer %x not found\n", ptr);
>             break;
>          }
>          ppinfo = &pinfo->next;
>       }
>    }
39a449,456
>    /* Finally free the data. */
>    png_debug_free(png_ptr, ptr);
> }
> #endif /* Not Borland DOS special memory handler */
> #endif
> /* END of code to test memory allocation/deallocation */
> 
> /* Test one file */
41c458
< main(int argc, char *argv[])
---
> test_one_file(PNG_CONST char *inname, PNG_CONST char *outname)
43c460
<    FILE *fpin, *fpout;
---
>    static FILE *fpin, *fpout;  /* "static" prevents setjmp corruption */
47d463
<    png_byte *near_row_buf;
55,56c471,472
<    row_buf = (png_bytep)NULL;
<    near_row_buf = (png_byte *)NULL;
---
>    
>    char inbuf[256], outbuf[256];
58,78c474
<    fprintf(STDERR, "Testing libpng version %s\n", PNG_LIBPNG_VER_STRING);
< 
<    if (strcmp(png_libpng_ver, PNG_LIBPNG_VER_STRING))
<    {
<       fprintf(STDERR,
<          "Warning: versions are different between png.h and png.c\n");
<       fprintf(STDERR, "  png.h version: %s\n", PNG_LIBPNG_VER_STRING);
<       fprintf(STDERR, "  png.c version: %s\n\n", png_libpng_ver);
<    }
< 
<    if (argc > 1)
<      inname = argv[1];
< 
<    if (argc > 2)
<      outname = argv[2];
< 
<    if (argc > 3)
<    {
<      fprintf(stderr, "usage: %s [infile.png] [outfile.png]\n", argv[0]);
<      exit(1);
<    }
---
>    row_buf = (png_bytep)NULL;
83c479
<       return 1;
---
>       return (1);
90c486
<       return 1;
---
>       return (1);
95a492,495
> #if defined(PNG_NO_STDIO)
>    png_set_error_fn(read_ptr, (png_voidp)inname, png_default_error,
>        png_default_warning);
> #endif
97a498,501
> #if defined(PNG_NO_STDIO)
>    png_set_error_fn(write_ptr, (png_voidp)inname, png_default_error,
>        png_default_warning);
> #endif
100c504
<    write_info_ptr = png_create_info_struct(read_ptr);
---
>    write_info_ptr = png_create_info_struct(write_ptr);
110c514
<       fprintf(STDERR, "libpng read error\n");
---
>       fprintf(STDERR, "%s -> %s: libpng read error\n", inname, outname);
115c519
<       return 1;
---
>       return (1);
126c530
<       fprintf(STDERR, "libpng write error\n");
---
>       fprintf(STDERR, "%s -> %s: libpng write error\n", inname, outname);
131c535
<       return 1;
---
>       return (1);
137a542
> #if !defined(PNG_NO_STDIO)
139a545,568
> #else
>    png_set_read_fn(read_ptr, (png_voidp)fpin, png_default_read_data);
>    png_set_write_fn(write_ptr, (png_voidp)fpout,  png_default_write_data,
> #if defined(PNG_WRITE_FLUSH_SUPPORTED)
>       png_default_flush);
> #else
>       NULL);
> #endif
> #endif
>    if(status_dots_requested == 1)
>    {
>       png_set_write_status_fn(write_ptr, write_row_callback);
>       png_set_read_status_fn(read_ptr, read_row_callback);
>    }
>    else
>    {
>       png_set_write_status_fn(write_ptr, NULL);
>       png_set_read_status_fn(read_ptr, NULL);
>    }
> 
> #  if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
>      black_pixels=0;
>      png_set_write_user_transform_fn(write_ptr, count_black_pixels);
> #  endif
151a581
> #if defined(PNG_WRITE_INTERLACING_SUPPORTED)
152a583,585
> #else
>             color_type, PNG_INTERLACE_NONE, compression_type, filter_type);
> #endif
186a620,629
> #if defined(PNG_READ_sRGB_SUPPORTED) && defined(PNG_WRITE_sRGB_SUPPORTED)
>    {
>       int intent;
> 
>       if (png_get_sRGB(read_ptr, read_info_ptr, &intent))
>       {
>          png_set_sRGB(write_ptr, write_info_ptr, intent);
>       }
>    }
> #endif
294c737,738
<    near_row_buf = (png_byte *)png_malloc(read_ptr, 
---
>    png_debug(0, "\nAllocating row buffer \n");
>    row_buf = (png_bytep)png_malloc(read_ptr, 
296d739
<    row_buf = (png_bytep)near_row_buf;
304c747
<       return 1;
---
>       return (1);
305a749
>    png_debug(0, "Writing row data\n");
311a756
>       png_debug1(0, "Writing row data for pass %d\n",pass);
321a767,777
>  
> #ifdef PNG_EASY_ACCESS_SUPPORTED
>    if(verbose)
>    {
>       png_uint_32 iwidth, iheight;
>       iwidth = png_get_image_width(write_ptr, write_info_ptr);
>       iheight = png_get_image_height(write_ptr, write_info_ptr);
>       fprintf(STDERR, "Image width = %lu, height = %lu\n",
>          iwidth, iheight);
>    }
> #endif
323a780
>    png_free(read_ptr, row_buf);
330,331d786
<    free((png_byte *)near_row_buf);
< 
336c791
<       return 1;
---
>       return (1);
343c798
<       return 1;
---
>       return (1);
346c801
<    while (1)
---
>    for(;;)
356a812,822
>          if(wrote_question == 0)
>          {
>             fprintf(STDERR,
>               "   Was %s written with the same chunk size (8k),",inname);
>             fprintf(STDERR,
>               " filtering\n   heuristic (libpng default), compression");
>             fprintf(STDERR,
>               " level (zlib default)\n   and zlib version (%s)?\n\n",
>               ZLIB_VERSION);
>             wrote_question=1;
>          }
359c825
<          return 1;
---
>          return (0);
367a834,844
>          if(wrote_question == 0)
>          {
>             fprintf(STDERR,
>               "   Was %s written with the same chunk size (8k),",inname);
>             fprintf(STDERR,
>               " filtering\n   heuristic (libpng default), compression");
>             fprintf(STDERR,
>               " level (zlib default)\n   and zlib version (%s)?\n\n",
>               ZLIB_VERSION);
>             wrote_question=1;
>          }
370c847
<          return 1;
---
>          return (0);
376d852
<    fprintf(STDERR, "libpng passes test\n");
378c854
<    return 0;
---
>    return (0);
380a857,1036
> /* input and output filenames */
> #ifdef RISCOS
> PNG_CONST char *inname = "pngtest/png";
> PNG_CONST char *outname = "pngout/png";
> #else
> static PNG_CONST char *inname = "pngtest.png";
> static PNG_CONST char *outname = "pngout.png";
> #endif
> 
> int
> main(int argc, char *argv[])
> {
>    int multiple = 0;
>    int ierror = 0;
> 
>    fprintf(STDERR, "Testing libpng version %s\n", PNG_LIBPNG_VER_STRING);
>    fprintf(STDERR, "   with zlib   version %s\n", ZLIB_VERSION);
> 
>    /* Do some consistency checking on the memory allocation settings, I'm
>       not sure this matters, but it is nice to know, the first of these
>       tests should be impossible because of the way the macros are set
>       in pngconf.h */
> #if defined(MAXSEG_64K) && !defined(PNG_MAX_MALLOC_64K)
>       fprintf(STDERR, " NOTE: Zlib compiled for max 64k, libpng not\n");
> #endif
>    /* I think the following can happen. */
> #if !defined(MAXSEG_64K) && defined(PNG_MAX_MALLOC_64K)
>       fprintf(STDERR, " NOTE: libpng compiled for max 64k, zlib not\n");
> #endif
> 
>    if (strcmp(png_libpng_ver, PNG_LIBPNG_VER_STRING))
>    {
>       fprintf(STDERR,
>          "Warning: versions are different between png.h and png.c\n");
>       fprintf(STDERR, "  png.h version: %s\n", PNG_LIBPNG_VER_STRING);
>       fprintf(STDERR, "  png.c version: %s\n\n", png_libpng_ver);
>       ++ierror;
>    }
> 
>    if (argc > 1)
>    {
>       if (strcmp(argv[1], "-m") == 0)
>       {
>          multiple = 1;
>          status_dots_requested = 0;
>       }
>       else if (strcmp(argv[1], "-mv") == 0 ||
>                strcmp(argv[1], "-vm") == 0 )
>       {
>          multiple = 1;
>          verbose = 1;
>          status_dots_requested = 1;
>       }
>       else if (strcmp(argv[1], "-v") == 0)
>       {
>          verbose = 1;
>          status_dots_requested = 1;
>          inname = argv[2];
>       }
>       else
>       {
>          inname = argv[1];
>          status_dots_requested = 0;
>       }
>    }
> 
>    if (!multiple && argc == 3+verbose)
>      outname = argv[2+verbose];
> 
>    if ((!multiple && argc > 3+verbose) || (multiple && argc < 2))
>    {
>      fprintf(STDERR,
>        "usage: %s [infile.png] [outfile.png]\n\t%s -m {infile.png}\n",
>         argv[0], argv[0]);
>      fprintf(STDERR,
>        "  reads/writes one PNG file (without -m) or multiple files (-m)\n");
>      fprintf(STDERR,
>        "  with -m %s is used as a temporary file\n", outname);
>      exit(1);
>    }
> 
>    if (multiple)
>    {
>       int i;
> #ifdef PNGTEST_MEMORY_DEBUG
>       int allocation_now = current_allocation;
> #endif
>       for (i=2; i<argc; ++i)
>       {
>          int kerror;
>          fprintf(STDERR, "Testing %s:",argv[i]);
>          kerror = test_one_file(argv[i], outname);
>          if (kerror == 0) 
> #if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
>             fprintf(STDERR, " PASS (%lu black pixels)\n",black_pixels);
> #else
>             fprintf(STDERR, " PASS\n");
> #endif
>          else {
>             fprintf(STDERR, " FAIL\n");
>             ierror += kerror;
>             }
> #ifdef PNGTEST_MEMORY_DEBUG
>          if (allocation_now != current_allocation)
>             fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n",
>                current_allocation-allocation_now);
>          if (current_allocation != 0) {
>             memory_infop pinfo = pinformation;
> 
>             fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n",
>                current_allocation);
>             while (pinfo != NULL) {
>                fprintf(STDERR, " %d bytes at %x\n", pinfo->size, pinfo->pointer);
>                pinfo = pinfo->next;
>                }
>          }
> #endif
>       }
> #ifdef PNGTEST_MEMORY_DEBUG
>          fprintf(STDERR, "Maximum memory allocation: %d bytes\n",
>             maximum_allocation);
> #endif
>    }
>    else
>    {
>       int i;
>       for (i=0; i<3; ++i) {
>          int kerror;
> #ifdef PNGTEST_MEMORY_DEBUG
>          int allocation_now = current_allocation;
> #endif
>          if (i == 1) status_dots_requested = 1;
>          else if(verbose == 0)status_dots_requested = 0;
>          if (i == 0 || verbose == 1 || ierror != 0)
>             fprintf(STDERR, "Testing %s:",inname);
>          kerror = test_one_file(inname, outname);
>          if(kerror == 0)
>          {
>             if(verbose == 1 || i == 2)
> #if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
>                 fprintf(STDERR, " PASS (%lu black pixels)\n",black_pixels);
> #else
>                 fprintf(STDERR, " PASS\n");
> #endif
>          }
>          else
>          {
>             if(verbose == 0 && i != 2)
>                fprintf(STDERR, "Testing %s:",inname);
>             fprintf(STDERR, " FAIL\n");
>             ierror += kerror;
>          }
> #ifdef PNGTEST_MEMORY_DEBUG
>          if (allocation_now != current_allocation)
>              fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n",
>                current_allocation-allocation_now);
>          if (current_allocation != 0) {
>              memory_infop pinfo = pinformation;
>    
>              fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n",
>                 current_allocation);
>              while (pinfo != NULL) {
>                 fprintf(STDERR, " %d bytes at %x\n", pinfo->size, pinfo->pointer);
>                 pinfo = pinfo->next;
>              }
>           }
> #endif
>        }
> #ifdef PNGTEST_MEMORY_DEBUG
>        fprintf(STDERR, "Maximum memory allocation: %d bytes\n",
>           maximum_allocation);
> #endif
>    }
> 
>    if (ierror == 0)
>       fprintf(STDERR, "libpng passes test\n");
>    else
>       fprintf(STDERR, "libpng FAILS test\n");
>    return (int)(ierror != 0);
> }
Index: c/pngtrans
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngtrans,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,9c3,10
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  */
18a20
>    png_debug(1, "in png_set_bgr\n");
27a30
>    png_debug(1, "in png_set_swap\n");
37a41
>    png_debug(1, "in png_set_packing\n");
50a55
>    png_debug(1, "in png_set_packswap\n");
59a65
>    png_debug(1, "in png_set_shift\n");
65c71,72
< #if defined(PNG_READ_INTERLACING_SUPPORTED) || defined(PNG_WRITE_INTERLACING_SUPPORTED)
---
> #if defined(PNG_READ_INTERLACING_SUPPORTED) || \
>     defined(PNG_WRITE_INTERLACING_SUPPORTED)
68a76
>    png_debug(1, "in png_set_interlace handling\n");
72c80
<       return 7;
---
>       return (7);
75c83
<    return 1;
---
>    return (1);
87a96
>    png_debug(1, "in png_set_filler\n");
107a117
>    png_debug(1, "in png_set_swap_alpha\n");
111a122,131
> #if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
>     defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
> void
> png_set_invert_alpha(png_structp png_ptr)
> {
>    png_debug(1, "in png_set_invert_alpha\n");
>    png_ptr->transformations |= PNG_INVERT_ALPHA;
> }
> #endif
> 
115a136
>    png_debug(1, "in png_set_invert_mono\n");
123,125c144
< #if defined(PNG_USELESS_TESTS_SUPPORTED)
<    if (row != NULL && row_info != NULL && row_info->bit_depth == 1 &&
< #else
---
>    png_debug(1, "in png_do_invert\n");
126a146,147
> #if defined(PNG_USELESS_TESTS_SUPPORTED)
>        row != NULL && row_info != NULL &&
128c149
<       row_info->color_type == PNG_COLOR_TYPE_GRAY)
---
>        row_info->color_type == PNG_COLOR_TYPE_GRAY)
145a167,168
>    png_debug(1, "in png_do_swap\n");
>    if (
147,149c170
<    if (row != NULL && row_info != NULL && row_info->bit_depth == 16)
< #else
<    if (row_info->bit_depth == 16)
---
>        row != NULL && row_info != NULL &&
150a172
>        row_info->bit_depth == 16)
277a300,301
>    png_debug(1, "in png_do_packswap\n");
>    if (
279,281c303
<    if (row != NULL && row_info != NULL && row_info->bit_depth < 8)
< #else
<    if (row_info->bit_depth < 8)
---
>        row != NULL && row_info != NULL &&
282a305
>        row_info->bit_depth < 8)
308a332
>    png_debug(1, "in png_do_strip_filler\n");
479,481c503
< #if defined(PNG_USELESS_TESTS_SUPPORTED)
<    if (row != NULL && row_info != NULL &&
< #else
---
>    png_debug(1, "in png_do_bgr\n");
482a505,506
> #if defined(PNG_USELESS_TESTS_SUPPORTED)
>        row != NULL && row_info != NULL &&
Index: c/pngwio
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngwio,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,15c3,17
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
< 
<    This file provides a location for all output.  Users which need
<    special handling are expected to write functions which have the same
<    arguments as these, and perform similar functions, but possibly use
<    different output methods.  Note that you shouldn't change these
<    functions, but rather write replacement functions and then change
<    them at run time with png_set_write_fn(...) */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  *
>  * This file provides a location for all output.  Users which need
>  * special handling are expected to write functions which have the same
>  * arguments as these, and perform similar functions, but possibly use
>  * different output methods.  Note that you shouldn't change these
>  * functions, but rather write replacement functions and then change
>  * them at run time with png_set_write_fn(...).
>  */
34a37
> #if !defined(PNG_NO_STDIO)
100a104
> #endif
112a117
> #if !defined(PNG_NO_STDIO)
121a127
> #endif
150a157
> #if !defined(PNG_NO_STDIO)
154a162,164
> #else
>    png_ptr->write_data_fn = write_data_fn;
> #endif
156a167
> #if !defined(PNG_NO_STDIO)
160a172,174
> #else
>    png_ptr->output_flush_fn = output_flush_fn;
> #endif
169c183
< void *far_to_near(png_structp png_ptr,png_voidp ptr, int check)
---
> void *png_far_to_near(png_structp png_ptr,png_voidp ptr, int check)
181c195
< void *far_to_near(png_structp png_ptr,png_voidp ptr, int check)
---
> void *png_far_to_near(png_structp png_ptr,png_voidp ptr, int check)
Index: c/pngwrite
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngwrite,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,9c3,10
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  */
26a28
> #if defined(PNG_WRITE_tEXt_SUPPORTED) || defined(PNG_WRITE_zTXt_SUPPORTED)
27a30
> #endif
34c37,42
<       info_ptr->filter_type, info_ptr->interlace_type);
---
>       info_ptr->filter_type,
> #if defined(PNG_WRITE_INTERLACING_SUPPORTED)
>       info_ptr->interlace_type);
> #else
>       0);
> #endif
40a49,52
> #if defined(PNG_WRITE_sRGB_SUPPORTED)
>    if (info_ptr->valid & PNG_INFO_sRGB)
>       png_write_sRGB(png_ptr, (int)info_ptr->srgb_intent);
> #endif
57a70
> 
59a73,83
>       {
> #if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
>          /* invert the alpha channel (in tRNS) */
>          if (png_ptr->transformations & PNG_INVERT_ALPHA &&
>             info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
>          {
>             int j;
>             for (j=0; j<(int)info_ptr->num_trans; j++)
>                info_ptr->trans[j] = 255 - info_ptr->trans[j];
>          }
> #endif
61a86
>       }
130,133c155,159
< /* writes the end of the PNG file.  If you don't want to write comments or
<    time information, you can pass NULL for info.  If you already wrote these
<    in png_write_info(), do not write them again here.  If you have long
<    comments, I suggest writing them here, and compressing them. */
---
> /* Writes the end of the PNG file.  If you don't want to write comments or
>  * time information, you can pass NULL for info.  If you already wrote these
>  * in png_write_info(), do not write them again here.  If you have long
>  * comments, I suggest writing them here, and compressing them.
>  */
143a170
> #if defined(PNG_WRITE_tEXt_SUPPORTED) || defined(PNG_WRITE_zTXt_SUPPORTED)
144a172
> #endif
192a221,257
> #if defined(PNG_TIME_RFC1123_SUPPORTED)
> /* Convert the supplied time into an RFC 1123 string suitable for use in
>  * a "Creation Time" or other text-based time string.
>  */
> png_charp
> png_convert_to_rfc1123(png_structp png_ptr, png_timep ptime)
> {
>    static PNG_CONST char short_months[12][4] =
> 	{"Jan", "Feb", "Mar", "Apr", "May", "Jun",
> 	 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
> 
>    if (png_ptr->time_buffer == NULL)
>    {
>       png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*
>          sizeof(char)));
>    }
> 
> #ifdef USE_FAR_KEYWORD
>    {
>       char near_time_buf[29];
>       sprintf(near_time_buf, "%d %s %d %02d:%02d:%02d +0000",
>                ptime->day % 31, short_months[ptime->month],
>                ptime->year, ptime->hour % 24, ptime->minute % 60,
>                ptime->second % 61);
>       png_memcpy(png_ptr->time_buffer, near_time_buf,
>       29*sizeof(char));
>    }
> #else
>    sprintf(png_ptr->time_buffer, "%d %s %d %02d:%02d:%02d +0000",
>                ptime->day % 31, short_months[ptime->month],
>                ptime->year, ptime->hour % 24, ptime->minute % 60,
>                ptime->second % 61);
> #endif
>    return ((png_charp)png_ptr->time_buffer);
> }
> #endif /* PNG_TIME_RFC1123_SUPPORTED */
> 
229c294
<       return (png_structp)NULL;
---
>       return ((png_structp)NULL);
239c304
<       return (png_structp)NULL;
---
>       return ((png_structp)NULL);
260c325,326
<    png_ptr->zbuf = png_malloc(png_ptr, png_ptr->zbuf_size);
---
>    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
>       (png_uint_32)png_ptr->zbuf_size);
264c330,335
<    return (png_ptr);
---
> #if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
>    png_set_filter_heuristics(png_ptr, PNG_FILTER_HEURISTIC_DEFAULT,
>       1, NULL, NULL);
> #endif
> 
>    return ((png_structp)png_ptr);
286c357,358
<    png_ptr->zbuf = png_malloc(png_ptr, png_ptr->zbuf_size);
---
>    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
>       (png_uint_32)png_ptr->zbuf_size);
295,298c367,371
< /* write a few rows of image data.  If the image is interlaced,
<    either you will have to write the 7 sub images, or, if you
<    have called png_set_interlace_handling(), you will have to
<    "write" the image seven times */
---
> /* Write a few rows of image data.  If the image is interlaced,
>  * either you will have to write the 7 sub images, or, if you
>  * have called png_set_interlace_handling(), you will have to
>  * "write" the image seven times.
>  */
314,315c387,389
< /* write the image.  You only need to call this function once, even
<    if you are writing an interlaced image. */
---
> /* Write the image.  You only need to call this function once, even
>  * if you are writing an interlaced image.
>  */
323a398
> #if defined(PNG_WRITE_INTERLACING_SUPPORTED)
326a402,404
> #else
>    num_pass = 1;
> #endif
342c420,421
<    png_debug(1, "in png_write_row\n");
---
>    png_debug2(1, "in png_write_row (row %ld, pass %d)\n",
>       png_ptr->row_number, png_ptr->pass);
414a494
> 
417a498,504
>    png_debug1(3, "row_info->color_type = %d\n", png_ptr->row_info.color_type);
>    png_debug1(3, "row_info->width = %d\n", png_ptr->row_info.width);
>    png_debug1(3, "row_info->channels = %d\n", png_ptr->row_info.channels);
>    png_debug1(3, "row_info->bit_depth = %d\n", png_ptr->row_info.bit_depth);
>    png_debug1(3, "row_info->pixel_depth = %d\n", png_ptr->row_info.pixel_depth);
>    png_debug1(3, "row_info->rowbytes = %d\n", png_ptr->row_info.rowbytes);
> 
419c506,507
<    png_memcpy(png_ptr->row_buf + 1, row, png_ptr->row_info.rowbytes);
---
>    png_memcpy_check(png_ptr, png_ptr->row_buf + 1, row,
>       png_ptr->row_info.rowbytes);
442a531,533
> 
>    if (png_ptr->write_row_fn != NULL)
>       (*(png_ptr->write_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
522a614,629
> #ifdef PNG_WRITE_tEXt_SUPPORTED
>       png_free(png_ptr, info_ptr->text);
> #endif
> #if defined(PNG_READ_pCAL_SUPPORTED)
>       png_free(png_ptr, info_ptr->pcal_purpose);
>       png_free(png_ptr, info_ptr->pcal_units);
>       if (info_ptr->pcal_params != NULL)
>       {
>          int i;
>          for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
>          {
>             png_free(png_ptr, info_ptr->pcal_params[i]);
>          }
>          png_free(png_ptr, info_ptr->pcal_params);
>       }
> #endif
556a664,666
> #if defined(PNG_TIME_RFC1123_SUPPORTED)
>    png_free(png_ptr, png_ptr->time_buffer);
> #endif /* PNG_TIME_RFC1123_SUPPORTED */
616c726
<                png_ptr->rowbytes + 1);
---
>               (png_ptr->rowbytes + 1));
630c740
<                   png_ptr->rowbytes + 1);
---
>                   (png_ptr->rowbytes + 1));
645c755
<                   png_ptr->rowbytes + 1);
---
>                   (png_ptr->rowbytes + 1));
660,661c770,771
<                png_ptr->paeth_row = (png_bytep )png_malloc(png_ptr,
<                   png_ptr->rowbytes + 1);
---
>                png_ptr->paeth_row = (png_bytep)png_malloc(png_ptr,
>                   (png_ptr->rowbytes + 1));
679c789,790
<  * better compression. */
---
>  * better compression.
>  */
685a797
> #if defined(PNG_WRITE_tEXt_SUPPORTED) || defined(PNG_WRITE_zTXt_SUPPORTED)
686a799
> #endif
714c827
<             sizeof(png_byte) * num_weights);
---
>             (png_uint_32)(sizeof(png_byte) * num_weights));
725,726c838,839
<          png_ptr->filter_weights = (png_uint_16p)png_malloc(png_ptr,
<             sizeof(png_uint_16) * num_weights);
---
>          png_ptr->filter_weights = (png_uint_16p) png_malloc(png_ptr,
>             (png_uint_32)(sizeof(png_uint_16) * num_weights));
728,729c841,842
<          png_ptr->inv_filter_weights = (png_uint_16p)png_malloc(png_ptr,
<             sizeof(png_uint_16) * num_weights);
---
>          png_ptr->inv_filter_weights = (png_uint_16p) png_malloc(png_ptr,
>             (png_uint_32)(sizeof(png_uint_16) * num_weights));
760,761c873,874
<       png_ptr->filter_costs = (png_uint_16p)png_malloc(png_ptr,
<          sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST);
---
>       png_ptr->filter_costs = (png_uint_16p) png_malloc(png_ptr,
>          (png_uint_32)(sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));
763,764c876,877
<       png_ptr->inv_filter_costs = (png_uint_16p)png_malloc(png_ptr,
<          sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST);
---
>       png_ptr->inv_filter_costs = (png_uint_16p) png_malloc(png_ptr,
>          (png_uint_32)(sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));
840a954,970
> void
> png_set_write_status_fn(png_structp png_ptr, png_write_status_ptr write_row_fn)
> {
>    png_ptr->write_row_fn = write_row_fn;
> }
> 
> #if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
> void
> png_set_write_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
>    write_user_transform_fn)
> {
>    png_debug(1, "in png_set_write_user_transform_fn\n");
>    png_ptr->transformations |= PNG_USER_TRANSFORM;
>    png_ptr->write_user_transform_fn = write_user_transform_fn;
> }
> #endif
> 
Index: c/pngwtran
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngwtran,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,9c3,10
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  */
14,15c15,17
< /* transform the data according to the users wishes.  The order of
<    transformations is significant. */
---
> /* Transform the data according to the users wishes.  The order of
>  * transformations is significant.
>  */
19a22,36
> 
> #if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
>    if (png_ptr->transformations & PNG_USER_TRANSFORM)
>       if(png_ptr->write_user_transform_fn != NULL)
>         (*(png_ptr->write_user_transform_fn)) /* user write transform function */
>           (png_ptr,                    /* png_ptr */
>            &(png_ptr->row_info),       /* row_info:     */
>              /*  png_uint_32 width;          width of row */
>              /*  png_uint_32 rowbytes;       number of bytes in row */
>              /*  png_byte color_type;        color type of pixels */
>              /*  png_byte bit_depth;         bit depth of samples */
>              /*  png_byte channels;          number of channels (1-4) */
>              /*  png_byte pixel_depth;       bits per pixel (depth*channels) */
>            png_ptr->row_buf + 1);      /* start of pixel data for row */
> #endif
24a42,45
> #if defined(PNG_WRITE_PACKSWAP_SUPPORTED)
>    if (png_ptr->transformations & PNG_PACKSWAP)
>       png_do_packswap(&(png_ptr->row_info), png_ptr->row_buf + 1);
> #endif
38a60,63
> #if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
>    if (png_ptr->transformations & PNG_INVERT_ALPHA)
>       png_do_write_invert_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
> #endif
54,56c79,82
< /* pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
<    row_info bit depth should be 8 (one pixel per byte).  The channels
<    should be 1 (this only happens on grayscale and paletted images) */
---
> /* Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
>  * row_info bit depth should be 8 (one pixel per byte).  The channels
>  * should be 1 (this only happens on grayscale and paletted images).
>  */
60a87
>    if (row_info->bit_depth == 8 &&
62,64c89
<    if (row != NULL && row_info != NULL && row_info->bit_depth < 8 &&
< #else
<    if (row_info->bit_depth < 8 &&
---
>        row != NULL && row_info != NULL &&
72,76c97,99
<             png_bytep sp;
<             png_bytep dp;
<             int mask;
<             png_int_32 i;
<             int v;
---
>             png_bytep sp, dp;
>             int mask, v;
>             png_uint_32 i;
103,108c126,128
<             png_bytep sp;
<             png_bytep dp;
<             int shift;
<             png_int_32 i;
<             int v;
<             png_byte value;
---
>             png_bytep sp, dp;
>             int shift, v;
>             png_uint_32 i;
115a136,137
>                png_byte value;
> 
135,140c157,159
<             png_bytep sp;
<             png_bytep dp;
<             int shift;
<             png_int_32 i;
<             int v;
<             png_byte value;
---
>             png_bytep sp, dp;
>             int shift, v;
>             png_uint_32 i;
147a167,168
>                png_byte value;
> 
168,169c189,190
<       row_info->bit_depth = bit_depth;
<       row_info->pixel_depth = (png_uint_16)(bit_depth * row_info->channels);
---
>       row_info->bit_depth = (png_byte)bit_depth;
>       row_info->pixel_depth = (png_byte)(bit_depth * row_info->channels);
177,182c198,204
< /* shift pixel values to take advantage of whole range.  Pass the
<    true number of bits in bit_depth.  The row should be packed
<    according to row_info->bit_depth.  Thus, if you had a row of
<    bit depth 4, but the pixels only had values from 0 to 7, you
<    would pass 3 as bit_depth, and this routine would translate the
<    data to 0 to 15. */
---
> /* Shift pixel values to take advantage of whole range.  Pass the
>  * true number of bits in bit_depth.  The row should be packed
>  * according to row_info->bit_depth.  Thus, if you had a row of
>  * bit depth 4, but the pixels only had values from 0 to 7, you
>  * would pass 3 as bit_depth, and this routine would translate the
>  * data to 0 to 15.
>  */
195c217
<       int channels;
---
>       png_uint_32 channels;
223c245
<       /* with low row dephts, could only be grayscale, so one channel */
---
>       /* with low row depths, could only be grayscale, so one channel */
228d249
<          int j;
240c261,262
<             int v;
---
>             png_uint_16 v;
>             int j;
257d278
<          int j;
261c282
<             int c;
---
>             png_uint_32 c;
265c286,287
<                int v;
---
>                png_uint_16 v;
>                int j;
283d304
<          int j;
285,287c306
<          for (bp = row, i = 0;
<             i < row_info->width * row_info->channels;
<             i++)
---
>          for (bp = row, i = 0; i < row_info->width * row_info->channels; i++)
289c308
<             int c;
---
>             png_uint_32 c;
293a313
>                int j;
295,296c315
<                v = (png_uint_16)(((png_uint_16)(*bp) << 8) +
<                   (png_uint_16)(*(bp + 1)));
---
>                v = ((png_uint_16)(*bp) << 8) + *(bp + 1);
400a420,495
> #if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
> void
> png_do_write_invert_alpha(png_row_infop row_info, png_bytep row)
> {
>    png_debug(1, "in png_do_write_invert_alpha\n");
> #if defined(PNG_USELESS_TESTS_SUPPORTED)
>    if (row != NULL && row_info != NULL)
> #endif
>    {
>       if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
>       {
>          /* This inverts the alpha channel in RGBA */
>          if (row_info->bit_depth == 8)
>          {
>             png_bytep sp, dp;
>             png_uint_32 i;
> 
>             for (i = 0, sp = dp = row; i < row_info->width; i++)
>             {
>                *(dp++) = *(sp++);
>                *(dp++) = *(sp++);
>                *(dp++) = *(sp++);
>                *(dp++) = 255 - *(sp++);
>             }
>          }
>          /* This inverts the alpha channel in RRGGBBAA */
>          else
>          {
>             png_bytep sp, dp;
>             png_uint_32 i;
> 
>             for (i = 0, sp = dp = row; i < row_info->width; i++)
>             {
>                *(dp++) = *(sp++);
>                *(dp++) = *(sp++);
>                *(dp++) = *(sp++);
>                *(dp++) = *(sp++);
>                *(dp++) = *(sp++);
>                *(dp++) = *(sp++);
>                *(dp++) = 255 - *(sp++);
>                *(dp++) = 255 - *(sp++);
>             }
>          }
>       }
>       else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
>       {
>          /* This inverts the alpha channel in GA */
>          if (row_info->bit_depth == 8)
>          {
>             png_bytep sp, dp;
>             png_uint_32 i;
> 
>             for (i = 0, sp = dp = row; i < row_info->width; i++)
>             {
>                *(dp++) = *(sp++);
>                *(dp++) = 255 - *(sp++);
>             }
>          }
>          /* This inverts the alpha channel in GGAA */
>          else
>          {
>             png_bytep sp, dp;
>             png_uint_32 i;
> 
>             for (i = 0, sp = dp = row; i < row_info->width; i++)
>             {
>                *(dp++) = *(sp++);
>                *(dp++) = *(sp++);
>                *(dp++) = 255 - *(sp++);
>                *(dp++) = 255 - *(sp++);
>             }
>          }
>       }
>    }
> }
> #endif
Index: c/pngwutil
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/c/pngwutil,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
3,9c3,10
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  */
29,30c30,32
<    complement format.  If this isn't the case, then this routine needs to
<    be modified to write data in two's complement format. */
---
>  * complement format.  If this isn't the case, then this routine needs to
>  * be modified to write data in two's complement format.
>  */
41c43,46
< /* Place a 16-bit number into a buffer in PNG byte order. */
---
> /* Place a 16-bit number into a buffer in PNG byte order.
>  * The parameter is declared unsigned int, not png_uint_16,
>  * just to avoid potential problems on pre-ANSI C compilers.
>  */
43c48
< png_save_uint_16(png_bytep buf, png_uint_16 i)
---
> png_save_uint_16(png_bytep buf, unsigned int i)
50,56c55,62
<    representing the chunk name.  The array must be at least 4 bytes in
<    length, and does not need to be null terminated.  To be safe, pass the
<    pre-defined chunk names here, and if you need a new one, define it
<    where the others are defined.  The length is the length of the data.
<    All the data must be present.  If that is not possible, use the
<    png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()
<    functions instead.  */
---
>  * representing the chunk name.  The array must be at least 4 bytes in
>  * length, and does not need to be null terminated.  To be safe, pass the
>  * pre-defined chunk names here, and if you need a new one, define it
>  * where the others are defined.  The length is the length of the data.
>  * All the data must be present.  If that is not possible, use the
>  * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()
>  * functions instead.
>  */
67,68c73,75
<    The total_length is the sum of the lengths of all the data you will be
<    passing in png_write_chunk_data() */
---
>  * The total_length is the sum of the lengths of all the data you will be
>  * passing in png_write_chunk_data().
>  */
88,90c95,98
<    Note that multiple calls to this function are allowed, and that the
<    sum of the lengths from these calls *must* add up to the total_length
<    given to png_write_chunk_start(). */
---
>  * Note that multiple calls to this function are allowed, and that the
>  * sum of the lengths from these calls *must* add up to the total_length
>  * given to png_write_chunk_start().
>  */
109,111d116
< #ifdef PNG_USE_OWN_CRC
<    png_save_uint_32(buf, ~png_ptr->crc);
< #else
113d117
< #endif
122c126,127
<  * bytes have already been written. */
---
>  * bytes have already been written.
>  */
132,133c137,139
<    information.  Note that the rest of this code depends upon this
<    information being correct.  */
---
>  * information.  Note that the rest of this code depends upon this
>  * information being correct.
>  */
196a203
> #ifdef PNG_WRITE_INTERLACING_SUPPORTED
202a210,212
> #else
>    interlace_type=PNG_INTERLACE_NONE;
> #endif
267,268c277,279
<    correct order for PNG, so people can redefine it to any convient
<    structure. */
---
>  * correct order for PNG, so people can redefine it to any convient
>  * structure.
>  */
272c283
<    int i;
---
>    png_uint_32 i;
338a350,365
> #if defined(PNG_WRITE_sRGB_SUPPORTED)
> /* write a sRGB chunk */
> void
> png_write_sRGB(png_structp png_ptr, int srgb_intent)
> {
>    png_byte buf[1];
> 
>    png_debug(1, "in png_write_sRGB\n");
>    if(srgb_intent >= PNG_sRGB_INTENT_LAST)
>          png_warning(png_ptr,
>             "Invalid sRGB rendering intent specified");
>    buf[0]=(png_byte)srgb_intent;
>    png_write_chunk(png_ptr, png_sRGB, buf, (png_size_t)1);
> }
> #endif
> 
351c378
<       int maxbits;
---
>       png_byte maxbits;
462c489
<       if (num_trans <= 0 || num_trans > png_ptr->num_palette)
---
>       if (num_trans <= 0 || num_trans > (int)png_ptr->num_palette)
486c513
<       png_warning(png_ptr, "Can't write tRNS with and alpha channel");
---
>       png_warning(png_ptr, "Can't write tRNS with an alpha channel");
527c554
< png_write_hIST(png_structp png_ptr, png_uint_16p hist, png_uint_32 num_hist)
---
> png_write_hIST(png_structp png_ptr, png_uint_16p hist, int num_hist)
533c560
<    if (num_hist > png_ptr->num_palette)
---
>    if (num_hist > (int)png_ptr->num_palette)
541c568
<    png_write_chunk_start(png_ptr, png_hIST, num_hist * 2);
---
>    png_write_chunk_start(png_ptr, png_hIST, (png_uint_32)(num_hist * 2));
556a584,587
>  *
>  * The new_key is allocated to hold the corrected keyword and must be freed
>  * by the calling routine.  This avoids problems with trying to write to
>  * static keywords without having to have duplicate copies of the strings.
559c590
< png_check_keyword(png_structp png_ptr, png_charp key)
---
> png_check_keyword(png_structp png_ptr, png_charp key, png_charpp new_key)
565a597,598
>    *new_key = NULL;
> 
568,572c601,602
<       char msg[40];
< 
<       sprintf(msg, "Zero length %s keyword", png_ptr->chunk_name);
<       png_warning(png_ptr, msg);
<       return 0;
---
>       png_chunk_warning(png_ptr, "zero length keyword");
>       return ((png_size_t)0);
576a607,608
>    *new_key = (png_charp)png_malloc(png_ptr, (png_uint_32)(key_len + 1));
> 
578c610
<    for (kp = key; *kp != '\0'; kp++)
---
>    for (kp = key, dp = *new_key; *kp != '\0'; kp++, dp++)
580,588c612,627
<      if (*kp < 0x20 || ((png_byte)*kp > 0x7E && (png_byte)*kp < 0xA1))
<      {
<        char msg[40];
< 
<        sprintf(msg, "Invalid %s keyword character 0x%02X",
<           png_ptr->chunk_name, *kp);
<        png_warning(png_ptr, msg);
<        *kp = ' ';
<      }
---
>       if (*kp < 0x20 || (*kp > 0x7E && (png_byte)*kp < 0xA1))
>       {
> #if !defined(PNG_NO_STDIO)
>          char msg[40];
> 
>          sprintf(msg, "invalid keyword character 0x%02X", *kp);
>          png_chunk_warning(png_ptr, msg);
> #else
>          png_chunk_warning(png_ptr, "invalid character in keyword");
> #endif
>          *dp = ' ';
>       }
>       else
>       {
>          *dp = *kp;
>       }
589a629
>    *dp = '\0';
592c632
<    kp = key + key_len - 1;
---
>    kp = *new_key + key_len - 1;
595,599c635
<       char msg[50];
<       sprintf(msg, "Trailing spaces removed from %s keyword",
<          png_ptr->chunk_name);
< 
<       png_warning(png_ptr, msg);
---
>       png_chunk_warning(png_ptr, "trailing spaces removed from keyword");
609c645
<    kp = key;
---
>    kp = *new_key;
612,616c648
<       char msg[50];
<       sprintf(msg, "Leading spaces removed from %s keyword",
<          png_ptr->chunk_name);
< 
<       png_warning(png_ptr, msg);
---
>       png_chunk_warning(png_ptr, "leading spaces removed from keyword");
628c660
<    for (kflag = 0, dp = key; *kp != '\0'; kp++)
---
>    for (kflag = 0, dp = *new_key; *kp != '\0'; kp++)
649,652c681
<       char msg[40];
< 
<       sprintf(msg, "Zero length %s keyword", png_ptr->chunk_name);
<       png_warning(png_ptr, msg);
---
>       png_chunk_warning(png_ptr, "zero length keyword");
657,662c686,687
<       char msg[50];
< 
<       sprintf(msg, "%s keyword length must be 1 - 79 characters",
<          png_ptr->chunk_name);
<       png_warning(png_ptr, msg);
<       key[79] = '\0';
---
>       png_chunk_warning(png_ptr, "keyword length must be 1 - 79 characters");
>       new_key[79] = '\0';
666c691
<    return key_len;
---
>    return (key_len);
676a702
>    png_charp new_key;
679c705
<    if (key == NULL || (key_len = png_check_keyword(png_ptr, key)) == 0)
---
>    if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
681,684c707
<       char msg[40];
< 
<       sprintf(msg, "Empty keyword in %s chunk", "tEXt");
<       png_warning(png_ptr, msg);
---
>       png_warning(png_ptr, "Empty keyword in tEXt chunk");
693c716
<    png_write_chunk_data(png_ptr, (png_bytep)key, key_len + 1);
---
>    png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);
697a721
>    png_free(png_ptr, new_key);
708a733
>    png_charp new_key;
715,717d739
<    if (key == NULL || (key_len = png_check_keyword(png_ptr, key)) == 0)
<    {
<       char msg[40];
719,720c741,743
<       sprintf(msg, "Empty keyword in %s chunk", "zTXt");
<       png_warning(png_ptr, msg);
---
>    if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
>    {
>       png_warning(png_ptr, "Empty keyword in zTXt chunk");
726c749,750
<       png_write_tEXt(png_ptr, key, text, (png_size_t)0);
---
>       png_write_tEXt(png_ptr, new_key, text, (png_size_t)0);
>       png_free(png_ptr, new_key);
729a754,755
>    png_free(png_ptr, new_key);
> 
731a758
> #if !defined(PNG_NO_STDIO)
734a762,764
> #else
>       png_warning(png_ptr, "Unknown zTXt compression type");
> #endif
788c818
<                   max_output_ptr * sizeof (png_charpp));
---
>                   (png_uint_32)(max_output_ptr * sizeof (png_charpp)));
794c824
<                   max_output_ptr * sizeof (png_charp));
---
>                   (png_uint_32)(max_output_ptr * sizeof (png_charp)));
798c828,829
<          output_ptr[num_output_ptr] = png_malloc(png_ptr, png_ptr->zbuf_size);
---
>          output_ptr[num_output_ptr] = (png_charp)png_malloc(png_ptr,
>             (png_uint_32)png_ptr->zbuf_size);
841c872
<                   max_output_ptr * sizeof (png_charpp));
---
>                   (png_uint_32)(max_output_ptr * sizeof (png_charpp)));
847c878
<                   max_output_ptr * sizeof (png_charp));
---
>                   (png_uint_32)(max_output_ptr * sizeof (png_charp)));
851,852c882,883
<          output_ptr[num_output_ptr] = png_malloc(png_ptr,
<             png_ptr->zbuf_size);
---
>          output_ptr[num_output_ptr] = (png_charp)png_malloc(png_ptr,
>             (png_uint_32)png_ptr->zbuf_size);
926a958
>    png_charp new_purpose;
933c965
<    purpose_len = png_check_keyword(png_ptr, purpose) + 1;
---
>    purpose_len = png_check_keyword(png_ptr, purpose, &new_purpose) + 1;
939c971,972
<    params_len = (png_uint_32p)png_malloc(png_ptr, nparams*sizeof(png_uint_32));
---
>    params_len = (png_uint_32p)png_malloc(png_ptr, (png_uint_32)(nparams
>       *sizeof(png_uint_32)));
951,952c984,985
<    png_write_chunk_start(png_ptr, png_pCAL, total_len);
<    png_write_chunk_data(png_ptr, (png_bytep)purpose, purpose_len);
---
>    png_write_chunk_start(png_ptr, png_pCAL, (png_uint_32)total_len);
>    png_write_chunk_data(png_ptr, (png_bytep)new_purpose, purpose_len);
959a993,994
>    png_free(png_ptr, new_purpose);
> 
965a1001
>    png_free(png_ptr, params_len);
992,993c1028,1030
< /* write the tIME chunk.  Use either png_convert_from_struct_tm()
<    or png_convert_from_time_t(), or fill in the structure yourself */
---
> /* Write the tIME chunk.  Use either png_convert_from_struct_tm()
>  * or png_convert_from_time_t(), or fill in the structure yourself.
>  */
1030c1067
<    png_ptr->row_buf = (png_bytep)png_malloc(png_ptr, buf_size);
---
>    png_ptr->row_buf = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
1037c1074
<          png_ptr->rowbytes + 1);
---
>          (png_ptr->rowbytes + 1));
1045c1082
<       png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, buf_size);
---
>       png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
1051c1088
<             png_ptr->rowbytes + 1);
---
>             (png_ptr->rowbytes + 1));
1057,1058c1094,1095
<          png_ptr->avg_row = (png_bytep )png_malloc(png_ptr,
<             png_ptr->rowbytes + 1);
---
>          png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,
>             (png_ptr->rowbytes + 1));
1065c1102
<             png_ptr->rowbytes + 1);
---
>             (png_ptr->rowbytes + 1));
1069a1107
> #ifdef PNG_WRITE_INTERLACING_SUPPORTED
1086a1125
> #endif
1108a1148
> #ifdef PNG_WRITE_INTERLACING_SUPPORTED
1149a1190
> #endif
1185,1192c1226,1232
< /* pick out the correct pixels for the interlace pass.
< 
<    The basic idea here is to go through the row with a source
<    pointer and a destination pointer (sp and dp), and copy the
<    correct pixels for the pass.  As the row gets compacted,
<    sp will always be >= dp, so we should never overwrite anything.
<    See the default: case for the easiest code to understand.
<    */
---
> /* Pick out the correct pixels for the interlace pass.
>  * The basic idea here is to go through the row with a source
>  * pointer and a destination pointer (sp and dp), and copy the
>  * correct pixels for the pass.  As the row gets compacted,
>  * sp will always be >= dp, so we should never overwrite anything.
>  * See the default: case for the easiest code to understand.
>  */
1321c1361
<                sp = row + i * pixel_bytes;
---
>                sp = row + (png_size_t)i * pixel_bytes;
1336,1338c1376,1377
<       row_info->rowbytes = ((row_info->width *
<          row_info->pixel_depth + 7) >> 3);
< 
---
>          row_info->rowbytes = ((row_info->width *
>             row_info->pixel_depth + 7) >> 3);
1345,1346c1384,1386
<  * chosen filter. */
< #define PNG_MAXSUM (~0x0UL >> 1)
---
>  * chosen filter.
>  */
> #define PNG_MAXSUM (~((png_uint_32)0) >> 1)
1348,1349c1388,1389
< #define PNG_LOMASK 0xffffL
< #define PNG_HIMASK (~PNG_LOMASK >> PNG_HISHIFT)
---
> #define PNG_LOMASK ((png_uint_32)0xffffL)
> #define PNG_HIMASK ((png_uint_32)(~PNG_LOMASK >> PNG_HISHIFT))
1354,1355c1394
<    png_uint_32 mins;
<    int bpp;
---
>    png_uint_32 mins, bpp;
1369c1408
<     * heruistics are the "weighted minumum sum of absolute differences"
---
>     * heuristics are the "weighted minumum sum of absolute differences"
1385c1424,1425
<       int i, v;
---
>       png_uint_32 i;
>       int v;
1401c1441
<          for (i = 0; i < png_ptr->num_prev_filters; i++)
---
>          for (i = 0; i < (png_uint_32)png_ptr->num_prev_filters; i++)
1435c1475,1476
<       int i, v;
---
>       png_uint_32 i;
>       int v;
1448c1489
<          for (i = 0; i < png_ptr->num_prev_filters; i++)
---
>          for (i = 0; i < (png_uint_32)png_ptr->num_prev_filters; i++)
1478c1519,1520
<       for (lp = row_buf + 1; i < row_info->rowbytes; i++, rp++, lp++, dp++)
---
>       for (lp = row_buf + 1; i < row_info->rowbytes;
>          i++, rp++, lp++, dp++)
1495c1537
<          for (i = 0; i < png_ptr->num_prev_filters; i++)
---
>          for (i = 0; i < (png_uint_32)png_ptr->num_prev_filters; i++)
1530c1572,1573
<       int i, v;
---
>       png_uint_32 i;
>       int v;
1539c1582
<          for (i = 0; i < png_ptr->num_prev_filters; i++)
---
>          for (i = 0; i < (png_uint_32)png_ptr->num_prev_filters; i++)
1563c1606,1607
<            pp = prev_row + 1; i < row_info->rowbytes; i++, rp++, pp++, dp++)
---
>            pp = prev_row + 1; i < row_info->rowbytes;
>            i++, rp++, pp++, dp++)
1580c1624
<          for (i = 0; i < png_ptr->num_prev_filters; i++)
---
>          for (i = 0; i < (png_uint_32)png_ptr->num_prev_filters; i++)
1615c1659,1660
<       int i, v;
---
>       png_uint_32 i;
>       int v;
1624c1669
<          for (i = 0; i < png_ptr->num_prev_filters; i++)
---
>          for (i = 0; i < (png_uint_32)png_ptr->num_prev_filters; i++)
1707c1752,1753
<       int i, v;
---
>       png_uint_32 i;
>       int v;
1740c1786
<            pp = prev_row + 1; i < bpp; i++, rp++, pp++, dp++)
---
>            pp = prev_row + 1; (unsigned)i < bpp; i++, rp++, pp++, dp++)
1818c1864
<       int j;
---
>       int i;
1820c1866
<       for (j = 1; j < png_ptr->num_prev_filters; j++)
---
>       for (i = 1; i < (int)png_ptr->num_prev_filters; i++)
1822c1868
<          png_ptr->prev_filters[j] = png_ptr->prev_filters[j - 1];
---
>          png_ptr->prev_filters[i] = png_ptr->prev_filters[i - 1];
1824c1870
<       png_ptr->prev_filters[j] = best_row[0];
---
>       png_ptr->prev_filters[i] = best_row[0];
1889d1934
< 
Index: h/png
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/h/png,v
retrieving revision 1.1
retrieving revision 1.6
diff -r1.1 -r1.6
3,62c3,87
< 
<    libpng 1.0 beta 5 - version 0.95
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
< 
<    BETA NOTICE:
<       This is a beta version.  It reads and writes valid files on the
<       platforms I have, and has had a wide testing program.  You may
<       have to modify the includes below to get it to work on your
<       system, and you may have to supply the correct compiler flags in
<       the makefile if you can't find a makefile suitable for your
<       operating system/compiler combination.  Read libpng.txt for more
<       information, including how to contact the authors if you have any
<       problems, or if you want your compiler/platform to be supported in
<       the next official libpng release.
< 
<    See libpng.txt for more information.
< 
<    Contributing Authors:
<       Sam Bushell
<       Kevin Bracey
<       Andreas Dilger
<       Magnus Holmgren
<       Dave Martindale
<       Greg Roelofs
<       Guy Eric Schalnat
<       Paul Schmidt
<       Tom Tanner
<       Tim Wegner
< 
<    The contributing authors would like to thank all those who helped
<    with testing, bug fixes, and patience.  This wouldn't have been
<    possible without all of you.
< 
<    Thanks to Frank J. T. Wojcik for helping with the documentation.
< 
<    The PNG Reference Library is supplied "AS IS".  The Contributing Authors
<    and Group 42, Inc. disclaim all warranties, expressed or implied,
<    including, without limitation, the warranties of merchantability and of
<    fitness for any purpose.  The Contributing Authors and Group 42, Inc.
<    assume no liability for direct, indirect, incidental, special, exemplary,
<    or consequential damages, which may result from the use of the PNG
<    Reference Library, even if advised of the possibility of such damage.
< 
<    Permission is hereby granted to use, copy, modify, and distribute this
<    source code, or portions hereof, for any purpose, without fee, subject
<    to the following restrictions:
<    1. The origin of this source code must not be misrepresented.
<    2. Altered versions must be plainly marked as such and must not be
<       misrepresented as being the original source.
<    3. This Copyright notice may not be removed or altered from any source or
<       altered source distribution.
< 
<    The Contributing Authors and Group 42, Inc. specifically permit, without
<    fee, and encourage the use of this source code as a component to
<    supporting the PNG file format in commercial products.  If you use this
<    source code in a product, acknowledgment is not required but would be
<    appreciated.
< */
---
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see the COPYRIGHT NOTICE below.
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998 Glenn Randers-Pehrson
>  * March 8, 1998
>  *
>  * Note about libpng version numbers:
>  *
>  *    Due to various miscommunications, unforeseen code incompatibilities
>  *    and occasional factors outside the authors' control, version numbering
>  *    on the library has not always been consistent and straightforward.
>  *    The following table summarizes matters since version 0.89c, which was
>  *    the first widely used release:
>  *
>  *      source                    png.h     shared-lib
>  *      version                   string    version
>  *      -------                   ------    ----------
>  *      0.89c ("1.0 beta 3")      0.89      1.0.89
>  *      0.90  ("1.0 beta 4")      0.90      0.90  [should have been 2.0.90]
>  *      0.95  ("1.0 beta 5")      0.95      0.95  [should have been 2.0.95]
>  *      0.96  ("1.0 beta 6")      0.96      0.96  [should have been 2.0.96]
>  *      0.97b ("1.00.97 beta 7")  1.00.97   1.0.0 [should have been 2.0.97]
>  *      0.97c                     0.97      2.0.97
>  *      0.98                      0.98      2.0.98
>  *      0.99                      0.99      2.0.99
>  *      0.99a-m                   0.99      2.0.99
>  *      1.0.0                     1.00      2.1.0
>  *
>  *    Henceforth the source version will match the shared-library minor
>  *    and patch numbers; the shared-library major version number will be
>  *    used for changes in backward compatibility, as it is intended.
>  *
>  * See libpng.txt for more information.  The PNG specification is available
>  * as RFC 2083 <ftp://ftp.uu.net/graphics/png/documents/>
>  * and as a W3C Recommendation <http://www.w3.org/TR/REC.png.html>
>  *
>  * Contributing Authors:
>  *    John Bowler
>  *    Kevin Bracey
>  *    Sam Bushell
>  *    Andreas Dilger
>  *    Magnus Holmgren
>  *    Tom Lane
>  *    Dave Martindale
>  *    Glenn Randers-Pehrson
>  *    Greg Roelofs
>  *    Guy Eric Schalnat
>  *    Paul Schmidt
>  *    Tom Tanner
>  *    Willem van Schaik
>  *    Tim Wegner
>  *
>  * The contributing authors would like to thank all those who helped
>  * with testing, bug fixes, and patience.  This wouldn't have been
>  * possible without all of you.
>  *
>  * Thanks to Frank J. T. Wojcik for helping with the documentation.
>  *
>  * COPYRIGHT NOTICE:
>  *
>  * The PNG Reference Library is supplied "AS IS".  The Contributing Authors
>  * and Group 42, Inc. disclaim all warranties, expressed or implied,
>  * including, without limitation, the warranties of merchantability and of
>  * fitness for any purpose.  The Contributing Authors and Group 42, Inc.
>  * assume no liability for direct, indirect, incidental, special, exemplary,
>  * or consequential damages, which may result from the use of the PNG
>  * Reference Library, even if advised of the possibility of such damage.
>  *
>  * Permission is hereby granted to use, copy, modify, and distribute this
>  * source code, or portions hereof, for any purpose, without fee, subject
>  * to the following restrictions:
>  * 1. The origin of this source code must not be misrepresented.
>  * 2. Altered versions must be plainly marked as such and must not be
>  *    misrepresented as being the original source.
>  * 3. This Copyright notice may not be removed or altered from any source or
>  *    altered source distribution.
>  *
>  * The Contributing Authors and Group 42, Inc. specifically permit, without
>  * fee, and encourage the use of this source code as a component to
>  * supporting the PNG file format in commercial products.  If you use this
>  * source code in a product, acknowledgment is not required but would be
>  * appreciated.
>  */
90c115
< #define PNG_LIBPNG_VER_STRING "0.95"
---
> #define PNG_LIBPNG_VER_STRING "1.0.0"
93c118
<  * Version 1.0 will be 100 here, etc.
---
>  * Version 1.0.0 will be 100 here, etc.
95c120
< #define PNG_LIBPNG_VER 95
---
> #define PNG_LIBPNG_VER  100
98c123
< #ifndef PNG_NO_EXTERN
---
> #if !defined(PNG_NO_EXTERN) || defined(PNG_ALWAYS_EXTERN)
102c127
< extern char png_libpng_ver[];
---
> extern char png_libpng_ver[6];
105,110c130,135
< extern int FARDATA png_pass_start[];
< extern int FARDATA png_pass_inc[];
< extern int FARDATA png_pass_ystart[];
< extern int FARDATA png_pass_yinc[];
< extern int FARDATA png_pass_mask[];
< extern int FARDATA png_pass_dsp_mask[];
---
> extern int FARDATA png_pass_start[7];
> extern int FARDATA png_pass_inc[7];
> extern int FARDATA png_pass_ystart[7];
> extern int FARDATA png_pass_yinc[7];
> extern int FARDATA png_pass_mask[7];
> extern int FARDATA png_pass_dsp_mask[7];
112,113c137,138
< extern int FARDATA png_pass_width[];
< extern int FARDATA png_pass_height[];
---
> extern int FARDATA png_pass_width[7];
> extern int FARDATA png_pass_height[7];
173,176c198,202
<    Two conversions are provided, both from time_t and struct tm.  There
<    is no portable way to convert to either of these structures, as far
<    as I know.  If you know of a portable way, send it to me.  As a side
<    note - PNG is Year 2000 compliant! */
---
>  * Two conversions are provided, both from time_t and struct tm.  There
>  * is no portable way to convert to either of these structures, as far
>  * as I know.  If you know of a portable way, send it to me.  As a side
>  * note - PNG is Year 2000 compliant!
>  */
199,203c225,230
<  * order of the values had to remain fixed.  With libpng 0.95, however,
<  * there are now functions which abstract the contents of png_info_struct
<  * from the application, so this makes it easier to use libpng with
<  * dynamic libraries, and even makes it possible to use libraries that
<  * don't have all of the libpng ancillary chunk-handing functionality.
---
>  * order of the values had to remain fixed.  With libpng 0.95 and later,
>  * however, * there are now functions which abstract the contents of
>  * png_info_struct from the application, so this makes it easier to use
>  * libpng with dynamic libraries, and even makes it possible to use
>  * libraries that don't have all of the libpng ancillary chunk-handing
>  * functionality.
215c242
<    png_size_t rowbytes;     /* bytes needed to hold an untransformed row */
---
>    png_uint_32 rowbytes;    /* bytes needed to hold an untransformed row */
237c264,265
< #if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_WRITE_gAMA_SUPPORTED)
---
> #if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_WRITE_gAMA_SUPPORTED) || \
>     defined(PNG_READ_GAMMA_SUPPORTED)
243a272,278
> 
> #if defined(PNG_READ_sRGB_SUPPORTED) || defined(PNG_WRITE_sRGB_SUPPORTED)
>     /* GR-P, 0.96a */
>     /* Data valid if (valid & PNG_INFO_sRGB) non-zero. */
>    png_byte srgb_intent; /* sRGB rendering intent [0, 1, 2, or 3] */
> #endif /* PNG_READ_sRGB_SUPPORTED || PNG_WRITE_sRGB_SUPPORTED */
> 
285c320,321
< #if defined(PNG_READ_bKGD_SUPPORTED) || defined(PNG_WRITE_bKGD_SUPPORTED)
---
> #if defined(PNG_READ_bKGD_SUPPORTED) || defined(PNG_WRITE_bKGD_SUPPORTED) || \
>     defined(PNG_READ_BACKGROUND_SUPPORTED)
377a414
> #define PNG_COMPRESSION_TYPE_DEFAULT PNG_COMPRESSION_TYPE_BASE
380a418
> #define PNG_FILTER_TYPE_DEFAULT   PNG_FILTER_TYPE_BASE
403a442,450
> /* These are for the sRGB chunk.  These values should NOT be changed. */
> #define PNG_sRGB_INTENT_SATURATION 0
> #define PNG_sRGB_INTENT_PERCEPTUAL 1
> #define PNG_sRGB_INTENT_ABSOLUTE   2
> #define PNG_sRGB_INTENT_RELATIVE   3
> #define PNG_sRGB_INTENT_LAST       4 /* Not a valid value */
>                         
> 
> 
419a467
> #define PNG_INFO_sRGB 0x0800   /* GR-P, 0.96a */
428c476
<    png_size_t rowbytes; /* number of bytes in row */
---
>    png_uint_32 rowbytes; /* number of bytes in row */
448a497,498
> typedef void (*png_read_status_ptr) PNGARG((png_structp, png_uint_32, int));
> typedef void (*png_write_status_ptr) PNGARG((png_structp, png_uint_32, int));
455a506,511
> #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
>     defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
> typedef void (*png_user_transform_ptr) PNGARG((png_structp,
>     png_row_infop, png_bytep));
> #endif /* PNG_READ|WRITE_USER_TRANSFORM_SUPPORTED */
> 
471a528,532
> #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
>     defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
>    png_user_transform_ptr read_user_transform_fn; /* user read transform */
>    png_user_transform_ptr write_user_transform_fn; /* user write transform */
> #endif
474c535
<    png_uint_32 mode;          /* tells us whre we are in the PNG file */
---
>    png_uint_32 mode;          /* tells us where we are in the PNG file */
491,492c552,553
<    png_size_t rowbytes;       /* size of row in bytes */
<    png_size_t irowbytes;      /* size of current interlaced row in bytes */
---
>    png_uint_32 rowbytes;      /* size of row in bytes */
>    png_uint_32 irowbytes;     /* size of current interlaced row in bytes */
522d582
< 
540,542c600,602
<    int gamma_shift;           /* number of "insignificant" bits 16-bit gamma */
<    float gamma;               /* file gamma value */
<    float display_gamma;       /* display gamma value */
---
>    int gamma_shift;      /* number of "insignificant" bits 16-bit gamma */
>    float gamma;          /* file gamma value */
>    float screen_gamma;   /* screen gamma value (display_gamma/viewing_gamma */
561a622,623
>    png_read_status_ptr read_row_fn;   /* called after each row is decoded */
>    png_write_status_ptr write_row_fn; /* called after each row is encoded */
564c626
<    png_progressive_row_ptr row_fn;   /* called after each row is decoded */
---
>    png_progressive_row_ptr row_fn;   /* called after each prog. row is decoded */
583a646
> #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
591,592c654
< #endif /* PNG_PROGRESSIVE_READ_SUPPORTED&&__TURBOC__&&!_Windows&&!__FLAT__ */
< #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
---
> #endif /* __TURBOC__&&!_Windows&&!__FLAT__ */
596d657
<    png_uint_16p hist;                /* histogram */
597a659,661
> #if defined(PNG_READ_DITHER_SUPPORTED) || defined(PNG_READ_hIST_SUPPORTED)
>    png_uint_16p hist;                /* histogram */
> #endif
606a671,673
> #if defined(PNG_TIME_RFC1123_SUPPORTED)
>    png_charp time_buffer;            /* String to hold RFC 1123 time text */
> #endif /* PNG_TIME_RFC1123_SUPPORTED */
617,618d683
< extern PNG_EXPORT(void,png_init) PNGARG((void));
< 
640,641c705,706
<    PNGARG((png_charp user_png_ver, voidp error_ptr, png_error_ptr error_fn,
<    png_error_ptr warn_fn));
---
>    PNGARG((png_const_charp user_png_ver, voidp error_ptr,
>    png_error_ptr error_fn, png_error_ptr warn_fn));
647a713,727
> /* Write a PNG chunk - size, type, (optional) data, CRC. */
> extern PNG_EXPORT(void,png_write_chunk) PNGARG((png_structp png_ptr,
>    png_bytep chunk_name, png_bytep data, png_size_t length));
> 
> /* Write the start of a PNG chunk - length and chunk name. */
> extern PNG_EXPORT(void,png_write_chunk_start) PNGARG((png_structp png_ptr,
>    png_bytep chunk_name, png_uint_32 length));
> 
> /* Write the data of a PNG chunk started with png_write_chunk_start(). */
> extern PNG_EXPORT(void,png_write_chunk_data) PNGARG((png_structp png_ptr,
>    png_bytep data, png_size_t length));
> 
> /* Finish a chunk started with png_write_chunk_start() (includes CRC). */
> extern PNG_EXPORT(void,png_write_chunk_end) PNGARG((png_structp png_ptr));
> 
662a743,747
> #if defined(PNG_TIME_RFC1123_SUPPORTED)
> extern PNG_EXPORT(png_charp,png_convert_to_rfc1123)
>    PNGARG((png_structp png_ptr, png_timep ptime));
> #endif /* PNG_TIME_RFC1123_SUPPORTED */
> 
704a790,794
> #if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
>     defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
> extern PNG_EXPORT(void,png_set_invert_alpha) PNGARG((png_structp png_ptr));
> #endif /* PNG_READ_INVERT_ALPHA_SUPPORTED || PNG_WRITE_INVERT_ALPHA_SUPPORTED */
> 
725c815
< #if defined(PNG_READ_PACKSWAP_SUPPORTED) || defined(PNG_WRITE_PACKSWAP_SUPPOR)
---
> #if defined(PNG_READ_PACKSWAP_SUPPORTED) || defined(PNG_WRITE_PACKSWAP_SUPPORTED)
771c861
< /* Handle gamma correction. */
---
> /* Handle gamma correction. Screen_gamma=(display_gamma/viewing_gamma) */
839a930,932
> /* free any memory used in info_ptr struct (old method - NOT DLL EXPORTED) */
> extern void png_write_destroy_info PNGARG((png_infop info_ptr));
> 
868c961,962
<  * header file (zlib.h) for an explination of the compression functions. */
---
>  * header file (zlib.h) for an explination of the compression functions.
>  */
871c965,966
<  * value for "method" is 0 */
---
>  * value for "method" is 0.
>  */
971a1067
> #if !defined(PNG_NO_STDIO)
973a1070
> #endif
1002a1100,1115
> extern PNG_EXPORT(void,png_set_read_status_fn) PNGARG((png_structp png_ptr,
>    png_read_status_ptr read_row_fn));
> 
> extern PNG_EXPORT(void,png_set_write_status_fn) PNGARG((png_structp png_ptr,
>    png_write_status_ptr write_row_fn));
> 
> #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
> extern PNG_EXPORT(void,png_set_read_user_transform_fn) PNGARG((png_structp
>    png_ptr, png_user_transform_ptr read_user_transform_fn));
> #endif
> 
> #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
> extern PNG_EXPORT(void,png_set_write_user_transform_fn) PNGARG((png_structp
>    png_ptr, png_user_transform_ptr write_user_transform_fn));
> #endif
> 
1030c1143
< /* free's a pointer allocated by png_malloc() */
---
> /* frees a pointer allocated by png_malloc() */
1032a1146,1158
> extern PNG_EXPORT(png_voidp,png_memcpy_check) PNGARG((png_structp png_ptr,
>    png_voidp s1, png_voidp s2, png_uint_32 size));
> 
> extern PNG_EXPORT(png_voidp,png_memset_check) PNGARG((png_structp png_ptr,
>    png_voidp s1, int value, png_uint_32 size));
> 
> #ifdef PNGTEST_MEMORY_DEBUG
> /* debugging versions of png_malloc() and png_free() */
> extern PNG_EXPORT(png_voidp,png_debug_malloc) PNGARG((png_structp png_ptr,
>    png_uint_32 size));
> extern PNG_EXPORT(void,png_debug_free) PNGARG((png_structp png_ptr,
>    png_voidp ptr));
> #endif
1034c1160,1161
< extern void *far_to_near PNGARG((png_structp png_ptr,png_voidp ptr,int check));
---
> extern void *png_far_to_near PNGARG((png_structp png_ptr,png_voidp ptr,
>    int check));
1040a1168,1171
> /* The same, but the chunk name is prepended to the error string. */
> extern PNG_EXPORT(void,png_chunk_error) PNGARG((png_structp png_ptr,
>    png_const_charp error));
> 
1044a1176,1179
> /* Non-fatal error in libpng, chunk name is prepended to message. */
> extern PNG_EXPORT(void,png_chunk_warning) PNGARG((png_structp png_ptr,
>    png_const_charp message));
> 
1057c1192
< /* Returns "flag" if chunk data is valid in info_ptr */
---
> /* Returns "flag" if chunk data is valid in info_ptr. */
1061c1196
< /* Returns number of bytes needed to hold a transformed row */
---
> /* Returns number of bytes needed to hold a transformed row. */
1065c1200
< /* Returns number of color channels in image */
---
> /* Returns number of color channels in image. */
1068a1204,1256
> #ifdef PNG_EASY_ACCESS_SUPPORTED
> /* Returns image width in pixels. */
> extern PNG_EXPORT(png_uint_32, png_get_image_width) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> 
> /* Returns image height in pixels. */
> extern PNG_EXPORT(png_uint_32, png_get_image_height) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> 
> /* Returns image bit_depth. */
> extern PNG_EXPORT(png_byte, png_get_bit_depth) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> 
> /* Returns image color_type. */
> extern PNG_EXPORT(png_byte, png_get_color_type) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> 
> /* Returns image filter_type. */
> extern PNG_EXPORT(png_byte, png_get_filter_type) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> 
> /* Returns image interlace_type. */
> extern PNG_EXPORT(png_byte, png_get_interlace_type) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> 
> /* Returns image compression_type. */
> extern PNG_EXPORT(png_byte, png_get_compression_type) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> 
> /* Returns image resolution in pixels per meter, from pHYs chunk data. */
> extern PNG_EXPORT(png_uint_32, png_get_pixels_per_meter) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> extern PNG_EXPORT(png_uint_32, png_get_x_pixels_per_meter) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> extern PNG_EXPORT(png_uint_32, png_get_y_pixels_per_meter) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> 
> /* Returns pixel aspect ratio, computed from pHYs chunk data.  */
> extern PNG_EXPORT(float, png_get_pixel_aspect_ratio) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> 
> /* Returns image x, y offset in pixels or microns, from oFFs chunk data. */
> extern PNG_EXPORT(png_uint_32, png_get_x_offset_pixels) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> extern PNG_EXPORT(png_uint_32, png_get_y_offset_pixels) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> extern PNG_EXPORT(png_uint_32, png_get_x_offset_microns) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> extern PNG_EXPORT(png_uint_32, png_get_y_offset_microns) PNGARG((png_structp
> png_ptr, png_infop info_ptr));
> 
> #endif /* PNG_EASY_ACCESS_SUPPORTED */
> 
1120c1308
< 
---
>   
1174a1363,1374
> #if defined(PNG_READ_sRGB_SUPPORTED)
> extern PNG_EXPORT(png_uint_32,png_get_sRGB) PNGARG((png_structp png_ptr,
>    png_infop info_ptr, int *intent));
> #endif /* PNG_READ_sRGB_SUPPORTED */
> 
> #if defined(PNG_READ_sRGB_SUPPORTED) || defined(PNG_WRITE_sRGB_SUPPORTED)
> extern PNG_EXPORT(void,png_set_sRGB) PNGARG((png_structp png_ptr,
>    png_infop info_ptr, int intent));
> extern PNG_EXPORT(void,png_set_sRGB_gAMA_and_cHRM) PNGARG((png_structp png_ptr,
>    png_infop info_ptr, int intent));
> #endif /* PNG_READ_sRGB_SUPPORTED || PNG_WRITE_sRGB_SUPPORTED */
> 
1215a1416,1418
> #ifdef PNG_NO_STDIO
> #include <stdio.h>
> #endif
1244c1447,1448
<    zero automatically when the structure is created. */
---
>  * zero automatically when the structure is created.
>  */
1250a1455,1457
> #define PNG_HAVE_gAMA         0x20
> #define PNG_HAVE_cHRM         0x40
> #define PNG_HAVE_sRGB         0x80
1279,1281c1486,1490
< #define PNG_PACKSWAP          0x10000
< #define PNG_SWAP_ALPHA        0x20000
< #define PNG_STRIP_ALPHA       0x40000
---
> #define PNG_PACKSWAP          0x10000L
> #define PNG_SWAP_ALPHA        0x20000L
> #define PNG_STRIP_ALPHA       0x40000L
> #define PNG_INVERT_ALPHA      0x80000L
> #define PNG_USER_TRANSFORM   0x100000L
1309,1310c1518,1519
< #define PNG_FLAG_HAVE_CHUNK_HEADER        0x8000
< #define PNG_FLAG_WROTE_tIME              0x10000
---
> #define PNG_FLAG_HAVE_CHUNK_HEADER        0x8000L
> #define PNG_FLAG_WROTE_tIME              0x10000L
1327,1350c1536,1561
< #ifndef PNG_NO_EXTERN
< /* place to hold the signiture string for a PNG file. */
< extern png_byte FARDATA png_sig[];
< 
< /* constant strings for known chunk types.  If you need to add a chunk,
<    add a string holding the name here.  See png.c for more details.  We
<    can't selectively include these, since we still check for chunk in the
<    wrong locations with these labels. */
< extern png_byte FARDATA png_IHDR[];
< extern png_byte FARDATA png_IDAT[];
< extern png_byte FARDATA png_IEND[];
< extern png_byte FARDATA png_PLTE[];
< extern png_byte FARDATA png_bKGD[];
< extern png_byte FARDATA png_cHRM[];
< extern png_byte FARDATA png_gAMA[];
< extern png_byte FARDATA png_hIST[];
< extern png_byte FARDATA png_oFFs[];
< extern png_byte FARDATA png_pCAL[];
< extern png_byte FARDATA png_pHYs[];
< extern png_byte FARDATA png_sBIT[];
< extern png_byte FARDATA png_tEXt[];
< extern png_byte FARDATA png_tIME[];
< extern png_byte FARDATA png_tRNS[];
< extern png_byte FARDATA png_zTXt[];
---
> #if !defined(PNG_NO_EXTERN) || defined(PNG_ALWAYS_EXTERN)
> /* place to hold the signature string for a PNG file. */
> extern png_byte FARDATA png_sig[8];
> 
> /* Constant strings for known chunk types.  If you need to add a chunk,
>  * add a string holding the name here.  See png.c for more details.  We
>  * can't selectively include these, since we still check for chunk in the
>  * wrong locations with these labels.
>  */
> extern png_byte FARDATA png_IHDR[5];
> extern png_byte FARDATA png_IDAT[5];
> extern png_byte FARDATA png_IEND[5];
> extern png_byte FARDATA png_PLTE[5];
> extern png_byte FARDATA png_bKGD[5];
> extern png_byte FARDATA png_cHRM[5];
> extern png_byte FARDATA png_gAMA[5];
> extern png_byte FARDATA png_hIST[5];
> extern png_byte FARDATA png_oFFs[5];
> extern png_byte FARDATA png_pCAL[5];
> extern png_byte FARDATA png_pHYs[5];
> extern png_byte FARDATA png_sBIT[5];
> extern png_byte FARDATA png_sRGB[5];
> extern png_byte FARDATA png_tEXt[5];
> extern png_byte FARDATA png_tIME[5];
> extern png_byte FARDATA png_tRNS[5];
> extern png_byte FARDATA png_zTXt[5];
1376,1377c1587,1589
< /* Initialize png_ptr struct for reading, and allocate any other memory
<  * (old interface - NOT DLL EXPORTED) */
---
> /* Initialize png_ptr struct for reading, and allocate any other memory.
>  * (old interface - NOT DLL EXPORTED).
>  */
1380,1381c1592,1594
< /* Initialize png_ptr struct for writing, and allocate any other memory
<  * (old interface - NOT DLL EXPORTED) */
---
> /* Initialize png_ptr struct for writing, and allocate any other memory.
>  * (old interface - NOT DLL EXPORTED).
>  */
1433c1646
<  * The only currently known PNG chunk that uses unsigned numbers is
---
>  * The only currently known PNG chunk that uses signed numbers is
1442,1458c1655,1659
< /* place a 16 bit number into a buffer in PNG byte order */
< PNG_EXTERN void png_save_uint_16 PNGARG((png_bytep buf, png_uint_16 i));
< 
< /* Write a PNG chunk - size, type, (optional) data, CRC. */
< PNG_EXTERN void png_write_chunk PNGARG((png_structp png_ptr,
<    png_bytep chunk_name, png_bytep data, png_size_t length));
< 
< /* Write the start of a PNG chunk - length and chunk name. */
< PNG_EXTERN void png_write_chunk_start PNGARG((png_structp png_ptr,
<    png_bytep chunk_name, png_uint_32 length));
< 
< /* Write the data of a PNG chunk started with png_write_chunk_start(). */
< PNG_EXTERN void png_write_chunk_data PNGARG((png_structp png_ptr,
<    png_bytep data, png_size_t length));
< 
< /* Finish a chunk started with png_write_chunk_start() (includes CRC). */
< PNG_EXTERN void png_write_chunk_end PNGARG((png_structp png_ptr));
---
> /* Place a 16 bit number into a buffer in PNG byte order.
>  * The parameter is declared unsigned int, not png_uint_16,
>  * just to avoid potential problems on pre-ANSI C compilers.
>  */
> PNG_EXTERN void png_save_uint_16 PNGARG((png_bytep buf, unsigned int i));
1460c1661
< /* simple function to write the signiture */
---
> /* simple function to write the signature */
1466c1667,1668
<    information. */
---
>  * information.
>  */
1495a1698,1702
> #if defined(PNG_WRITE_sRGB_SUPPORTED)
> PNG_EXTERN void png_write_sRGB PNGARG((png_structp png_ptr,
>    int intent));
> #endif
> 
1508c1715
<    png_uint_32 num_hist));
---
>    int num_hist));
1513c1720
<    png_charp key));
---
>    png_charp key, png_charpp new_key));
1609a1817,1826
> #if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
> PNG_EXTERN void png_do_read_invert_alpha PNGARG((png_row_infop row_info,
>    png_bytep row));
> #endif
> 
> #if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
> PNG_EXTERN void png_do_write_invert_alpha PNGARG((png_row_infop row_info,
>    png_bytep row));
> #endif
> 
1698c1915,1916
<  * then calls the appropriate callback for the chunk if it is valid */
---
>  * then calls the appropriate callback for the chunk if it is valid.
>  */
1722a1941,1945
> #if defined(PNG_READ_sRGB_SUPPORTED)
> PNG_EXTERN void png_handle_sRGB PNGARG((png_structp png_ptr, png_infop info_ptr,
>    png_uint_32 length));
> #endif
> 
Index: h/pngconf
===================================================================
RCS file: /home/ahodgkin/ROOL/Batch2/Munged-Repository/RiscOS/Sources/Lib/ImageLib/PNG/h/pngconf,v
retrieving revision 1.1
retrieving revision 1.10
diff -r1.1 -r1.10
2,9c2,10
< /* pngconf.c - machine configurable file for libpng
< 
<    libpng 1.0 beta 5 - version 0.95
<    For conditions of distribution and use, see copyright notice in png.h
<    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
<    Copyright (c) 1996, 1997 Andreas Dilger
<    March 30, 1997
<    */
---
> /* pngconf.h - machine configurable file for libpng
>  *
>  * libpng 1.0.0
>  * For conditions of distribution and use, see copyright notice in png.h
>  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
>  * Copyright (c) 1996, 1997 Andreas Dilger
>  * Copyright (c) 1998, Glenn Randers-Pehrson
>  * March 8, 1998
>  */
12,14c13,16
<    are configuring libpng for a machine, you may want to read the section
<    starting here down to where it starts to typedef png_color, png_text,
<    and png_info */
---
>  * are configuring libpng for a machine, you may want to read the section
>  * starting here down to where it starts to typedef png_color, png_text,
>  * and png_info.
>  */
20,29c22,32
<    an IDAT chunk.  Make this whatever size you feel is best for your
<    machine.  One of these will be allocated per png_struct.  When this
<    is full, it writes the data to the disk, and does some other
<    calculations.  Making this an extreamly small size will slow
<    the library down, but you may want to experiment to determine
<    where it becomes significant, if you are concerned with memory
<    usage.  Note that zlib allocates at least 32Kb also.  For readers,
<    this describes the size of the buffer available to read the data in.
<    Unless this gets smaller then the size of a row (compressed),
<    it should not make much difference how big this is.  */
---
>  * an IDAT chunk.  Make this whatever size you feel is best for your
>  * machine.  One of these will be allocated per png_struct.  When this
>  * is full, it writes the data to the disk, and does some other
>  * calculations.  Making this an extremely small size will slow
>  * the library down, but you may want to experiment to determine
>  * where it becomes significant, if you are concerned with memory
>  * usage.  Note that zlib allocates at least 32Kb also.  For readers,
>  * this describes the size of the buffer available to read the data in.
>  * Unless this gets smaller than the size of a row (compressed),
>  * it should not make much difference how big this is.
>  */
30a34
> #ifndef PNG_ZBUF_SIZE
31a36
> #endif
34,38c39,43
<    than 64K of memory at once, uncomment this.  While libpng will not
<    normally need that much memory in a chunk (unless you load up a very
<    large file), zlib needs to know how big of a chunk it can use, and
<    libpng thus makes sure to check any memory allocation to verify it
<    will fit into memory.
---
>  * than 64K of memory at once, uncomment this.  While libpng will not
>  * normally need that much memory in a chunk (unless you load up a very
>  * large file), zlib needs to know how big of a chunk it can use, and
>  * libpng thus makes sure to check any memory allocation to verify it
>  * will fit into memory.
40c45
< */
---
>  */
46,51c51,56
<    and thus don't have or would rather us not use the stdio types:
<    stdin, stdout, and stderr.  The only one currently used is stderr
<    in png_error() and png_warning().  #defining PNG_NO_STDIO will
<    prevent these from being compiled and used. */
< 
< #define PNG_NO_STDIO
---
>  * and thus don't have or would rather us not use the stdio types:
>  * stdin, stdout, and stderr.  The only one currently used is stderr
>  * in png_error() and png_warning().  #defining PNG_NO_STDIO will
>  * prevent these from being compiled and used.
>  * #define PNG_NO_STDIO
>  */
53,54c58
< /* for FILE.  If you are not using standard io, you don't need this */
< /*#ifndef PNG_NO_STDIO*/
---
> #ifndef PNG_NO_STDIO 
56c60
< /*#endif*/
---
> #endif
59,63c63,68
<    prototypes (ie K&R style headers).  If your compiler does not handle
<    function prototypes, define this macro and use the included ansi2knr.
<    I've always been able to use _NO_PROTO as the indicator, but you may
<    need to drag the empty declaration out in front of here, or change the
<    ifdef to suit your own needs. */
---
>  * prototypes (ie K&R style headers).  If your compiler does not handle
>  * function prototypes, define this macro and use the included ansi2knr.
>  * I've always been able to use _NO_PROTO as the indicator, but you may
>  * need to drag the empty declaration out in front of here, or change the
>  * ifdef to suit your own needs.
>  */
80,81c85,91
< /* Try to determine if we are compiling on a Mac */
< #if defined(__MWERKS__) ||defined(applec) ||defined(THINK_C) ||defined(__SC__)
---
> /* Try to determine if we are compiling on a Mac.  Note that testing for
>  * just __MWERKS__ is not good enough, because the Codewarrior is now used
>  * on non-Mac platforms.
>  */
> #ifndef MACOS
> #if (defined(__MWERKS__) && defined(macintosh)) || defined(applec) || \
>     defined(THINK_C) || defined(__SC__) || defined(TARGET_OS_MAC)
83a94
> #endif
91,92c102,104
<    the X config stuff didn't define _BSD_SOURCE we wouldn't need this. */
< #ifdef linux
---
>  * the X config stuff didn't define _BSD_SOURCE we wouldn't need this.
>  */
> #ifdef __linux__
98,99c110,111
< error  __png_h_already_includes_setjmp_h__
< error  __dont_include_it_again__
---
> __png.h__ already includes setjmp.h
> __dont__ include it again
101c113
< #endif /* linux */
---
> #endif /* __linux__ */
106c118
< #ifdef linux
---
> #ifdef __linux__
111c123
< #endif /* linux */
---
> #endif /* __linux__ */
122,124d133
< /* Where do we need this???
< #include <ctype.h>
< */
136c145,146
<    them inside an appropriate ifdef/endif pair for portability */
---
>  * them inside an appropriate ifdef/endif pair for portability.
>  */
140,141c150,152
<    as it seems it doesn't agree with <fp.h>, yet we should really use
<    <fp.h> if possible. */
---
>  * as it seems it doesn't agree with <fp.h>, yet we should really use
>  * <fp.h> if possible.
>  */
148a160,164
> /* Codewarrior on NT has linking problems without this. */
> #if defined(__MWERKS__) && defined(WIN32)
> #define PNG_ALWAYS_EXTERN
> #endif
> 
150,151c166,168
<    stdlib.h like it should (I think).  Or perhaps this is a C++
<    "feature"? */
---
>  * stdlib.h like it should (I think).  Or perhaps this is a C++
>  * "feature"?
>  */
162,163c179,182
<    a largish chunk of memory (32K), those who are not as concerned
<    with dithering quality can decrease some or all of these. */
---
>  * a largish chunk of memory (32K), those who are not as concerned
>  * with dithering quality can decrease some or all of these.
>  */
> #ifndef PNG_DITHER_RED_BITS
164a184,185
> #endif
> #ifndef PNG_DITHER_GREEN_BITS
165a187,188
> #endif
> #ifndef PNG_DITHER_BLUE_BITS
166a190
> #endif
169,173c193,197
<    are only interested in 8 bits anyway.  Increasing this value
<    results in more memory being used, and more pow() functions
<    being called to fill in the gamma tables.  Don't set this
<    value less then 8, and even that may not work (I haven't tested
<    it). */
---
>  * are only interested in 8 bits anyway.  Increasing this value
>  * results in more memory being used, and more pow() functions
>  * being called to fill in the gamma tables.  Don't set this value
>  * less then 8, and even that may not work (I haven't tested it).
>  */
174a199
> #ifndef PNG_MAX_GAMMA_8
175a201
> #endif
178c204,206
<    we actually start doing gamma conversion.  */
---
>  * we actually start doing gamma conversion.
>  */
> #ifndef PNG_GAMMA_THRESHOLD
179a208
> #endif
184,189c213,215
<    and warning message functions, so some compilers won't complain.
<    If you want to use const, define PNG_USE_CONST here.  It is not
<    normally defined to make configuration easier, as it is not a
<    critical part of the code.
<    */
< #define PNG_USE_CONST
---
>  * and warning message functions, so some compilers won't complain.
>  * If you do not want to use const, define PNG_NO_CONST here.
>  */
191c217
< #ifdef PNG_USE_CONST
---
> #ifndef PNG_NO_CONST
198,208c224,235
<    library that you will not be using.  I wish I could figure out how to
<    automate this, but I can't do that without making it seriously hard
<    on the users.  So if you are not using an ability, change the #define
<    to and #undef, and that part of the library will not be compiled.  If
<    your linker can't find a function, you may want to make sure the
<    ability is defined here.  Some of these depend upon some others being
<    defined.  I haven't figured out all the interactions here, so you may
<    have to experiment awhile to get everything to compile.  If you are
<    creating or using a shared library, you probably shouldn't touch this,
<    as it will affect the size of the structures, and this will cause bad
<    things to happen if the library and/or application ever change. */
---
>  * library that you will not be using.  I wish I could figure out how to
>  * automate this, but I can't do that without making it seriously hard
>  * on the users.  So if you are not using an ability, change the #define
>  * to and #undef, and that part of the library will not be compiled.  If
>  * your linker can't find a function, you may want to make sure the
>  * ability is defined here.  Some of these depend upon some others being
>  * defined.  I haven't figured out all the interactions here, so you may
>  * have to experiment awhile to get everything to compile.  If you are
>  * creating or using a shared library, you probably shouldn't touch this,
>  * as it will affect the size of the structures, and this will cause bad
>  * things to happen if the library and/or application ever change.
>  */
211,213c238,256
< #define PNG_PROGRESSIVE_READ_SUPPORTED
< #define PNG_READ_OPT_PLTE_SUPPORTED
< #define PNG_READ_INTERLACING_SUPPORTED
---
> 
> /* GR-P, 0.96a: Set "*TRANSFORMS_SUPPORTED as default but allow user
>    to turn it off with "*TRANSFORMS_NOT_SUPPORTED" on the compile line,
>    then pick and choose which ones to define without having to edit
>    this file. It is safe to use the *TRANSFORMS_NOT_SUPPORTED if you
>    only want to have a png-compliant reader/writer but don't need
>    any of the extra transformations.  This saves about 80 kbytes in a
>    typical installation of the library.
>  */
> 
> 
> #ifndef PNG_READ_TRANSFORMS_NOT_SUPPORTED
> #define PNG_READ_TRANSFORMS_SUPPORTED
> #endif
> #ifndef PNG_WRITE_TRANSFORMS_NOT_SUPPORTED
> #define PNG_WRITE_TRANSFORMS_SUPPORTED
> #endif
> 
> #ifdef PNG_READ_TRANSFORMS_SUPPORTED
215,218c258,261
< #undef  PNG_READ_SHIFT_SUPPORTED
< #undef  PNG_READ_PACK_SUPPORTED
< #undef  PNG_READ_BGR_SUPPORTED
< #undef  PNG_READ_SWAP_SUPPORTED
---
> #define PNG_READ_SHIFT_SUPPORTED
> #define PNG_READ_PACK_SUPPORTED
> #define PNG_READ_BGR_SUPPORTED
> #define PNG_READ_SWAP_SUPPORTED
220c263
< #undef  PNG_READ_INVERT_SUPPORTED
---
> #define PNG_READ_INVERT_SUPPORTED
222c265
< #undef  PNG_READ_BACKGROUND_SUPPORTED
---
> #define PNG_READ_BACKGROUND_SUPPORTED
226,228c269,277
< #undef  PNG_READ_GRAY_TO_RGB_SUPPORTED
< #undef  PNG_READ_SWAP_ALPHA_SUPPORTED
< #undef  PNG_READ_STRIP_ALPHA_SUPPORTED
---
> #define PNG_READ_GRAY_TO_RGB_SUPPORTED
> #define PNG_READ_SWAP_ALPHA_SUPPORTED
> #define PNG_READ_INVERT_ALPHA_SUPPORTED
> #define PNG_READ_STRIP_ALPHA_SUPPORTED
> #define PNG_READ_USER_TRANSFORM_SUPPORTED
> /* the following aren't implemented yet
> #define PNG_READ_RGB_TO_GRAY_SUPPORTED
>  */
> #endif /* PNG_READ_TRANSFORMS_SUPPORTED */
230c279,286
< #define PNG_WRITE_INTERLACING_SUPPORTED
---
> #ifndef PNG_PROGRESSIVE_READ_NOT_SUPPORTED   /* if you don't do progressive   */
> #define PNG_PROGRESSIVE_READ_SUPPORTED       /* reading.  This is not talking */
> #endif                               /* about interlacing capability!  You'll */
>               /* still have interlacing unless you change the following line: */
> #define PNG_READ_INTERLACING_SUPPORTED /* required for PNG-compliant decoders */
> #define PNG_READ_COMPOSITE_NODIV_SUPPORTED    /* well tested on Intel and SGI */
> 
> #ifdef PNG_WRITE_TRANSFORMS_SUPPORTED
236c292
< #undef  PNG_WRITE_INVERT_SUPPORTED
---
> #define PNG_WRITE_INVERT_SUPPORTED
239a296
> #define PNG_WRITE_INVERT_ALPHA_SUPPORTED
240a298,329
> #define PNG_WRITE_USER_TRANSFORM_SUPPORTED
> #endif /* PNG_WRITE_TRANSFORMS_SUPPORTED */
> 
> #define PNG_WRITE_INTERLACING_SUPPORTED  /* not required for PNG-compliant
>                                             encoders, but can cause trouble
>                                             if left undefined */
> 
> #if !defined(PNG_NO_STDIO)
> #define PNG_TIME_RFC1123_SUPPORTED
> #endif
> 
> /* This adds extra functions in pngget.c for accessing data from the
>  * info pointer (added in version 0.99)
>  * png_get_image_width()
>  * png_get_image_height()
>  * png_get_bit_depth()
>  * png_get_color_type()
>  * png_get_compression_type()
>  * png_get_filter_type()
>  * png_get_interlace_type()
>  * png_get_pixel_aspect_ratio()
>  * png_get_pixels_per_meter()
>  * png_get_x_offset_pixels()
>  * png_get_y_offset_pixels()
>  * png_get_x_offset_microns()
>  * png_get_y_offset_microns()
>  */
> #if !defined(PNG_NO_EASY_ACCESS)
> #define PNG_EASY_ACCESS_SUPPORTED
> #endif
> 
> /* These are currently experimental features, define them if you want */
242,244c331,334
< /* These are currently experimental features */
< #undef PNG_READ_16_TO_8_ACCURATE_SHIFT_SUPPORTED /* very little testing */
< #undef PNG_READ_COMPOSITE_NODIV_SUPPORTED        /* very little testing */
---
> /* very little testing */
> /*
> #define PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
> */
247c337,340
< #undef PNG_READ_BIG_ENDIAN_SUPPORTED             /* some testing */
---
> /* some testing */
> /*
> #define PNG_READ_BIG_ENDIAN_SUPPORTED
> */
250,252c343,346
< #undef  PNG_USE_OWN_CRC
< #undef  PNG_USELESS_TESTS_SUPPORTED
< #undef  PNG_CORRECT_PALETTE_SUPPORTED
---
> /*
> #define  PNG_USELESS_TESTS_SUPPORTED
> #define  PNG_CORRECT_PALETTE_SUPPORTED
> */
257,258c351
<  * a bit smaller.  OPT_PLTE only disables the optional palette in RGB
<  * and RGBA images.
---
>  * a bit smaller.
260a354,361
> #ifndef PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED
> #define PNG_READ_ANCILLARY_CHUNKS_SUPPORTED
> #endif
> #ifndef PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED
> #define PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED
> #endif
> 
> #ifdef PNG_READ_ANCILLARY_CHUNKS_SUPPORTED
262c363
< #undef  PNG_READ_cHRM_SUPPORTED
---
> #define PNG_READ_cHRM_SUPPORTED
264,266c365,367
< #undef  PNG_READ_hIST_SUPPORTED
< #undef  PNG_READ_oFFs_SUPPORTED
< #undef  PNG_READ_pCAL_SUPPORTED
---
> #define PNG_READ_hIST_SUPPORTED
> #define PNG_READ_oFFs_SUPPORTED
> #define PNG_READ_pCAL_SUPPORTED
269,270c370,372
< #undef  PNG_READ_tEXt_SUPPORTED
< #undef  PNG_READ_tIME_SUPPORTED
---
> #define PNG_READ_sRGB_SUPPORTED
> #define PNG_READ_tEXt_SUPPORTED
> #define PNG_READ_tIME_SUPPORTED
272c374,377
< #undef  PNG_READ_zTXt_SUPPORTED
---
> #define PNG_READ_zTXt_SUPPORTED
> #define PNG_READ_OPT_PLTE_SUPPORTED /* only affects support of the optional */
>                                     /* PLTE chunk in RGB and RGBA images */
> #endif /* PNG_READ_ANCILLARY_CHUNKS_SUPPORTED */
273a379
> #ifdef PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED
281a388
> #define PNG_WRITE_sRGB_SUPPORTED
285a393
> #endif /* PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED */
339,340c447,448
<    Uncomment it if you want. Could also define FARDATA as
<    const if your compiler supports it. (SJT)
---
>  * Uncomment it if you want. Could also define FARDATA as
>  * const if your compiler supports it. (SJT)
342c450
< */
---
>  */
349,350c457,459
<    FAR.  The Watcom compiler defines both __MEDIUM__ and M_I86MM,
<    making reliance oncertain keywords suspect. (SJT) */
---
>  * FAR.  The Watcom compiler defines both __MEDIUM__ and M_I86MM,
>  * making reliance oncertain keywords suspect. (SJT)
>  */
401c510
< typedef z_stream FAR *  png_zstreamp;
---
> typedef z_stream FAR *  png_zstreamp; 
403c512
< /* allow for compilation as dll under windows */
---
> /* allow for compilation as dll under MS Windows */
407a517,526
> /* allow for compilation as dll with BORLAND C++ 5.0 */
> #if defined(__BORLANDC__) && defined(_Windows) && defined(__DLL__)
> #   define PNG_EXPORT(type,symbol) type _export symbol
> #endif
> 
> /* allow for compilation as shared lib under BeOS */
> #ifdef __BEOSDLL__
> #define PNG_EXPORT(type,symbol) __declspec(export) type symbol
> #endif
> 
409c528
< #define PNG_EXPORT(t,s) t s
---
> #define PNG_EXPORT(type,symbol) type symbol
414c533,534
<    that are passed far data must be model independent. */
---
>  * that are passed far data must be model independent.
>  */
420,421c540,541
< #   define CVT_PTR(ptr) (far_to_near(png_ptr,ptr,CHECK))
< #   define CVT_PTR_NOCHECK(ptr) (far_to_near(png_ptr,ptr,NOCHECK))
---
> #   define CVT_PTR(ptr) (png_far_to_near(png_ptr,ptr,CHECK))
> #   define CVT_PTR_NOCHECK(ptr) (png_far_to_near(png_ptr,ptr,NOCHECK))
437c557
<  * contradictory.
---
>  * contradictory. 
