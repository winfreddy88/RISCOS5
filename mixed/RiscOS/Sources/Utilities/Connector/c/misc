/*
 * Copyright (c) 1995, Andreas Zieringer
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#include "Desk/WimpSWIs.h"
#include "Desk/Wimp.h"
#include "Desk/linklist.h"
#include "Desk/screen.h"
#include "Desk/Event.h"
#include "Desk/Icon.h"
#include "Desk/DeskMem.h"
#include "Desk/Time.h"
#include "Desk/Window.h"
#include "Desk/SWI.h"
#include "Desk/Template.h"
#include "Desk/KernelSWIs.h"
#include "Desk/Menu.h"
#include "Desk/GFX.h"
#include "Desk/Font.h"
#include "Desk/Pane2.h"
#include "Desk/Sprite.h"
#include "Desk/Str.h"

#include "osserialop.h"
#include "WimpSpriteOp.h"

#include "global.h"
#include "iconnames.h"
#include "vt100.h"
#include "ansi.h"
#include "text.h"
#include "Chat.h"
#include "event.h"
#include "console.h"
#include "flex.h"
#include "spool.h"
#include "misc.h"
#include "serialbuff.h"

#include <stdarg.h>
#include <stdio.h>
#include <time.h>

#define BTX_BUFFER_SIZE 1024
#define CEPT_XSIZE 480
#define CEPT_YSIZE 240

#define CONNECTOR "Connector"

extern int (*driver_load(char*))(int,...);

extern void init_colormap(void);
extern void init_fonts(void);
extern void init_layer6(void);

extern void redraw_screen_rect(int x1,int y1,int x2,int y2);
extern void convert_colormap(void);

extern int rows;

static char btx_serial_buffer[BTX_BUFFER_SIZE];
static int btx_serial_buffer_index=0;
static int btx_serial_buffer_end=0;

char *online_time_str="00:00:00";
static char iconbar_spritename[12];

static unsigned char G_font[11*6]=
{
  0x00,0x00,0x00,0x00,0x00,0x00,
  0x78,0x84,0x84,0x84,0x78,0x00, 0x04,0x0c,0x14,0x04,0x04,0x00,
  0x78,0x84,0x18,0x20,0x7c,0x00, 0x78,0x04,0x38,0x04,0x78,0x00,
  0x84,0x84,0xfc,0x04,0x04,0x00, 0xfc,0x80,0xf8,0x04,0xf8,0x00,
  0x30,0x40,0xf8,0x84,0x78,0x00, 0xfc,0x04,0x08,0x10,0x10,0x00,
  0x78,0x84,0x78,0x84,0x78,0x00, 0x78,0x84,0x7c,0x08,0x30,0x00
};


void create_toolbar(int spool,int sinfo)
{
  Desk_wimp_point paneoffset;
  Desk_icon_handle ihandle;
  Desk_icon_createblock icon;
  Desk_window_openblock open;

  if(!toolbar)
    return;

  open.window=tools_window;

  switch(toolbar_type)
  {
    case 1:
      Desk_Window_SetExtent(tools_window,0,-200,56,0);
      open.screenrect.min.x=0;
      open.screenrect.min.y=-200;
      open.screenrect.max.x=56;
      open.screenrect.max.y=0;
      open.behind=-1;
      Desk_Wimp_OpenWindow(&open);
      Desk_Wimp_CloseWindow(tools_window);

      //xwimp_resize_icon((wimp_w)tools_window,(wimp_i)1,68,-4,132,-68);
      icon.window=tools_window;
      Desk_Wimp_GetIconState(tools_window,TOOLS_DIRECTORY,&icon.icondata);
      Desk_Wimp_DeleteIcon(tools_window,TOOLS_DIRECTORY);
      icon.icondata.workarearect.min.x=4;
      icon.icondata.workarearect.min.y=-100;
      icon.icondata.workarearect.max.x=52;
      icon.icondata.workarearect.max.y=-52;
      Desk_Wimp_CreateIcon(&icon,&ihandle);

      Desk_Wimp_GetIconState(tools_window,TOOLS_HANGUP,&icon.icondata);
      Desk_Wimp_DeleteIcon(tools_window,TOOLS_HANGUP);
      icon.icondata.workarearect.min.x=4;
      icon.icondata.workarearect.min.y=-148;
      icon.icondata.workarearect.max.x=52;
      icon.icondata.workarearect.max.y=-100;
      Desk_Wimp_CreateIcon(&icon,&ihandle);

      Desk_Wimp_GetIconState(tools_window,TOOLS_DIAL,&icon.icondata);
      Desk_Wimp_DeleteIcon(tools_window,TOOLS_DIAL);
      icon.icondata.workarearect.min.x=4;
      icon.icondata.workarearect.min.y=-196;
      icon.icondata.workarearect.max.x=52;
      icon.icondata.workarearect.max.y=-148;
      Desk_Wimp_CreateIcon(&icon,&ihandle);
      paneoffset.x=-60;
      paneoffset.y=0;
      Desk_Pane2_AddPane(haupt_window, tools_window, &paneoffset, NULL,
                         Desk_pane2_FIXED|Desk_pane2_MAINTOP|Desk_pane2_PANETOP);
    break;

    case 2:
      Desk_Window_SetExtent(tools_window,0,-56,200,0);
      open.screenrect.min.x=0;
      open.screenrect.min.y=-56;
      open.screenrect.max.x=200;
      open.screenrect.max.y=0;
      open.behind=-1;
      Desk_Wimp_OpenWindow(&open);
      Desk_Wimp_CloseWindow(tools_window);


      //xwimp_resize_icon((wimp_w)tools_window,(wimp_i)1,68,-4,132,-68);
      icon.window=tools_window;
      Desk_Wimp_GetIconState(tools_window,TOOLS_DIRECTORY,&icon.icondata);
      Desk_Wimp_DeleteIcon(tools_window,TOOLS_DIRECTORY);
      icon.icondata.workarearect.min.x=52;
      icon.icondata.workarearect.min.y=-52;
      icon.icondata.workarearect.max.x=100;
      icon.icondata.workarearect.max.y=-4;
      Desk_Wimp_CreateIcon(&icon,&ihandle);

      Desk_Wimp_GetIconState(tools_window,TOOLS_HANGUP,&icon.icondata);
      Desk_Wimp_DeleteIcon(tools_window,TOOLS_HANGUP);
      icon.icondata.workarearect.min.x=100;
      icon.icondata.workarearect.min.y=-52;
      icon.icondata.workarearect.max.x=149;
      icon.icondata.workarearect.max.y=-4;
      Desk_Wimp_CreateIcon(&icon,&ihandle);

      Desk_Wimp_GetIconState(tools_window,TOOLS_DIAL,&icon.icondata);
      Desk_Wimp_DeleteIcon(tools_window,TOOLS_DIAL);
      icon.icondata.workarearect.min.x=148;
      icon.icondata.workarearect.min.y=-52;
      icon.icondata.workarearect.max.x=196;
      icon.icondata.workarearect.max.y=-4;
      Desk_Wimp_CreateIcon(&icon,&ihandle);

      paneoffset.x=0;
      paneoffset.y=4;
      if(spool)
        paneoffset.y+=56;
      if(sinfo)
        paneoffset.y+=56;
      Desk_Pane2_AddPane(haupt_window, tools_window, &paneoffset, NULL,
                         Desk_pane2_FIXED|Desk_pane2_PANETOP);
    break;
  }

}

void Icon_printf_Update(Desk_window_handle window,Desk_icon_handle icon,char *s,...)
{
  Desk_icon_block iconstr;
  int size;
  va_list va;

  va_start(va, s);
  vsprintf(gstring, s, va);
  va_end(va);

  Desk_Wimp_GetIconState(window,icon,&iconstr);
  size=iconstr.data.indirecttext.bufflen;
  strncpy(iconstr.data.indirecttext.buffer,gstring,size-1);
  iconstr.data.indirecttext.buffer[size-1]=0;

  Desk_Window_ForceRedraw(window,iconstr.workarearect.min.x+8,iconstr.workarearect.min.y+8,
                     iconstr.workarearect.max.x-8,iconstr.workarearect.max.y-8);
}


void Icon_SetText_Update(Desk_window_handle window,Desk_icon_handle icon,char *text)
{
  Desk_icon_block iconstr;
  //window_redrawblock  update;
  //BOOL            more;
  int size;

  Desk_Wimp_GetIconState(window,icon,&iconstr);
  size=iconstr.data.indirecttext.bufflen;
  strncpy(iconstr.data.indirecttext.buffer,text,size-1);
  iconstr.data.indirecttext.buffer[size-1]=0;

  Desk_Window_ForceRedraw(window,iconstr.workarearect.min.x+8,iconstr.workarearect.min.y+8,
                     iconstr.workarearect.max.x-8,iconstr.workarearect.max.y-8);
/*
  update.window=window;
  update.rect.min.x=iconstr.workarearect.min.x; // +8;
  update.rect.min.y=iconstr.workarearect.min.y; // +8;
  update.rect.max.x=iconstr.workarearect.max.x; // -8;
  update.rect.max.y=iconstr.workarearect.max.y; // -8;

  Wimp_EUpdateWindow(&update,&more);
  while(more)
    Wimp_EGetRectangle(&update,&more);
*/
}

void Icon_SetInteger_Update(Desk_window_handle window,Desk_icon_handle icon,int value)
{
  Desk_icon_block iconstr;
  //window_redrawblock  update;
  //BOOL            more;
  int size;

  Desk_Wimp_GetIconState(window,icon,&iconstr);
  size=iconstr.data.indirecttext.bufflen;
  sprintf(gstring,"%d",value);
  strncpy(iconstr.data.indirecttext.buffer,gstring,size-1);
  iconstr.data.indirecttext.buffer[size-1]=0;

  Desk_Window_ForceRedraw(window,iconstr.workarearect.min.x+8,iconstr.workarearect.min.y+8,
                     iconstr.workarearect.max.x-8,iconstr.workarearect.max.y-8);

/*
  update.window=window;
  update.rect.min.x=iconstr.workarearect.min.x; // +8;
  update.rect.min.y=iconstr.workarearect.min.y; // +8;
  update.rect.max.x=iconstr.workarearect.max.x; // -8;
  update.rect.max.y=iconstr.workarearect.max.y; // -8;

  Wimp_EUpdateWindow(&update,&more);
  while(more)
    Wimp_EGetRectangle(&update,&more);
*/
}
/*
void Icon_SetText_NoFlicker(window_handle window,icon_handle icon,char *text,char *oldtext)
{
  icon_block iconstr;
  int size;
  int x0,y0,x1,y1;
  int fx0,fy0,fx1,fy1;
  int icon_width,font_width;
  int i;
  char hilf[2];

  hilf[1]=0;
  Wimp_EGetIconState(window,icon,&iconstr);
  size=iconstr.data.indirecttext.bufflen;
  strncpy(iconstr.data.indirecttext.buffer,text,size-1);
  iconstr.data.indirecttext.buffer[size-1]=0;

  x0=iconstr.workarearect.min.x;
  y0=iconstr.workarearect.min.y;
  x1=iconstr.workarearect.max.x;
  y1=iconstr.workarearect.max.y;

  xfont_string_bbox(text,&fx0,&fy0,&fx1,&fy1);
  xfont_convertto_os(fx0,fy0,&fx0,&fy0);
  xfont_convertto_os(fx1,fy1,&fx1,&fy1);

  icon_width=x1-x0;
  font_width=fx1-fx0;

  x0+=(icon_width-font_width)>>1;

  for(i=0;i<strlen(text);i++)
  {
    hilf[0]=oldtext[i];
    xfont_string_bbox(hilf,&fx0,&fy0,&fx1,&fy1);
    xfont_convertto_os(fx0,fy0,&fx0,&fy0);
    xfont_convertto_os(fx1,fy1,&fx1,&fy1);
    font_width=(fx1-fx0)+2;

    x1=x0+font_width;

    if(text[i]!=oldtext[i])
      Window_ForceRedraw(window,x0,y0,x1,y1);
    x0+=font_width;
  }
  print_in_status_window(MESSAGE,"%d,%d",x0,x1);
}
*/


void init_text_buffer(int mem)
{
  int i;

  tb_all=text_buffer_size*80;
  tb_above=(text_buffer_size-terminal_height)*80;
  screen_above=(text_buffer_size-terminal_height)*ZA;
  if(mem)
  {
    if(text_buffer!=NULL)
      Desk_DeskMem_Free(text_buffer);
    text_buffer = (unsigned int *)Desk_DeskMem_Malloc(text_buffer_size*80*4+4+80);
    //else
    //  DeskMem_Realloc(text_buffer,text_buffer_size*80*4+4);
    /*
    if(text_buffer==NULL)
      flex_alloc((flex_ptr)&text_buffer,text_buffer_size*80*4+4);
    else
    {
      flex_extend((flex_ptr)&text_buffer,text_buffer_size*80*4+4);
    }
    */
    for(i=0;i<tb_all;i++)
      text_buffer[i]=normal_attr|32;
  }
}

void sec2time(int s,char *str)
{
  int ss;

  ss=s/3600;
  str[0]=48+ss/10;
  str[1]=48+ss%10;
  str[2]=':';

  s-=ss*3600;
  ss=s/60;
  str[3]=48+ss/10;
  str[4]=48+ss%10;
  str[5]=':';

  s-=ss*60;
  str[6]=48+s/10;
  str[7]=48+s%10;
  str[8]=0;
}

void show_time(Desk_window_handle window, Desk_icon_handle icon,int s0,int s1,Desk_bool always)
{
  char h[4];
  char m[4];
  char ss[3];
  char str[12];
  char all[22];
  int hilf,k;
  int s;

  s=s0;

  for(k=0;k<2;k++)
  {
    hilf=s-(s/100)*100;
    if( always || hilf>=98 || hilf<=2 )
    {
      if((hilf=s/360000)<10)
        sprintf(h,"0%u:",hilf);
      else
        sprintf(h,"%u:",hilf);
      s-=hilf*360000;

      if((hilf=s/6000)<10)
        sprintf(m,"0%u:",hilf);
      else
        sprintf(m,"%u:",hilf);
      s-=hilf*6000;

      if((hilf=s/100)<10)
        sprintf(ss,"0%u",hilf);
      else
        sprintf(ss,"%u",hilf);

      if(k==0)
      {
        strcpy(str,h);
        strcat(str,m);
        strcat(str,ss);
      }
      s=s1;
    }
    sprintf(all,"%s / %s%s%s",str,h,m,ss);
    Icon_SetText_Update(window,icon,all);
    //strcpy(old_time_str,str);
  }
}

#if 0
void show_online_time(int s,int *olds)
{
  int ss,os;
  int hilf;
  static int blink=0;
  Desk_icon_block iconstr;
  int size;

  if( (s-*olds)>=100 )
  {
    hilf=s;

    if(blink)
      online_time_str[2]=' ';
    else
      online_time_str[2]=':';
    blink=~blink;

    ss=s/360000;
    os=*olds/360000;
    if(os != ss)
    {
      online_time_str[0]=48+ss/10;
      online_time_str[1]=48+ss%10;
      Desk_Icon_SetText(unten_window,UNTEN_TIME,online_time_str);
    }
    s-=ss*360000;
    *olds-=os*360000;

    ss=s/6000;
    os=*olds/6000;
    if(os != ss)
    {
      online_time_str[3]=48+ss/10;
      online_time_str[4]=48+ss%10;
      Desk_Icon_SetText(unten_window,UNTEN_TIME,online_time_str);
    }
    /*
    s-=ss*6000;
    *olds-=os*6000;

    ss=s/100;
    os=*olds/100;
    if(ss/10 != os/10 )
      online_time_str[3]=48+ss/10;
    online_time_str[4]=48+ss%10;
    */
    *olds=hilf;

    Desk_Wimp_GetIconState(unten_window,UNTEN_TIME,&iconstr);
    size=iconstr.data.indirecttext.bufflen;
    strncpy(iconstr.data.indirecttext.buffer,online_time_str,size-1);
    iconstr.data.indirecttext.buffer[size-1]=0;
    Desk_Window_ForceRedraw(unten_window,iconstr.workarearect.min.x+44,iconstr.workarearect.min.y+8,
                     iconstr.workarearect.max.x-44,iconstr.workarearect.max.y-8);


    //Desk_Icon_SetText(unten_window,UNTEN_TIME,online_time_str);
    //Desk_Icon_ForceRedraw(unten_window,UNTEN_TIME);
    //update_time(online_time_str);

/*
    Desk_Sprite_Redirect(usericonsprites,"time",NULL,&sprite_state);
    Desk_GFX_GCOL(0,1);
    Desk_GFX_RectangleFill(0,0,148,36);
    xwimptextop_set_colour(os_COLOUR_BLACK,os_COLOUR_TRANSPARENT);
    xwimptextop_paint(wimptextop_GIVEN_BASELINE,online_time_str,0,0);
    Desk_Sprite_UnRedirect(&sprite_state);
    Desk_Icon_ForceRedraw(unten_window,UNTEN_TIME);
*/
  }
}
#endif

void reset_online_time(void)
{
  online_time_str[0]=48;
  online_time_str[1]=48;
  online_time_str[3]=48;
  online_time_str[4]=48;
  online_time_str[6]=48;
  online_time_str[7]=48;
  Desk_Icon_SetText(unten_window,UNTEN_TIME,online_time_str);
}

void show_online_time(int s,int *olds)
{
  int ss,os;
  int hilf;
  Desk_icon_block iconstr;
  int size;
  int update;
  int width;
  
  update=0;

  if( (s-*olds)>=100 )
  {
    hilf=s;

    ss=s/360000;
    os=*olds/360000;
    if(os != ss)
    {
      online_time_str[0]=48+ss/10;
      online_time_str[1]=48+ss%10;
      update=1;
    }
    s-=ss*360000;
    *olds-=os*360000;

    ss=s/6000;
    os=*olds/6000;
    if(os != ss)
    {
      online_time_str[3]=48+ss/10;
      online_time_str[4]=48+ss%10;
      update=1;
    }
    s-=ss*6000;
    *olds-=os*6000;

    ss=s/100;
    os=*olds/100;
    if(ss/10 != os/10 )
    {
      online_time_str[6]=48+ss/10;
      update=1;
    }
    online_time_str[7]=48+ss%10;

    *olds=hilf;

    Desk_Wimp_GetIconState(unten_window,UNTEN_TIME,&iconstr);
    size=iconstr.data.indirecttext.bufflen;
    strncpy(iconstr.data.indirecttext.buffer,online_time_str,size-1);
    iconstr.data.indirecttext.buffer[size-1]=0;

    if(update)
    {
      Desk_Window_ForceRedraw(unten_window,iconstr.workarearect.min.x+8,
      iconstr.workarearect.min.y+8,iconstr.workarearect.max.x-8,iconstr.workarearect.max.y-8);
    }
    else
    {
      width=((iconstr.workarearect.max.x-iconstr.workarearect.min.x)-online_time_width)/2;
      if(width<0)
        width=8;
      Desk_Window_ForceRedraw(unten_window,iconstr.workarearect.max.x-width-24,iconstr.workarearect.min.y+8,iconstr.workarearect.max.x-width,iconstr.workarearect.max.y-8);
    }
  }
}


int show_ok(char *str1,char *str2)
{
  int icon;

  Desk_Icon_SetText(Desk_Dialog_WindowHandle(ok_dialog),OK_TEXT,str1);
  Desk_Icon_SetText(Desk_Dialog_WindowHandle(ok_dialog),OK_OK,str2);
  Desk_Dialog_ShowStatic(ok_dialog,Desk_open_CENTERED);
  icon=Desk_Dialog_WaitForClick(ok_dialog);
  Desk_Dialog_Hide(ok_dialog);
  return(icon==OK_OK);
}

void show_message(char *str)
{
  Desk_Icon_SetText(Desk_Dialog_WindowHandle(message_dialog),MESSAGE_TEXT,str);
  message_dialog->lastclicked=Desk_dialog_NOCHOICE;
  Desk_Dialog_Show(message_dialog);
  //Dialog_ShowStatic(message_dialog,open_CENTERED);
  //Dialog_WaitForClick(message_dialog);
  //Dialog_Hide(message_dialog);
  message_open_time=Desk_Time_Monotonic();
  message_open=TRUE;
  //Dialog_WaitForClick(message_dialog);
  //Dialog_Hide(message_dialog);
}

/*
static void plot_iconbar_text(char *text,int y)
{
  Desk_wimp_point pos;
  int nm,i,j,x;
  unsigned char  cur;
  int width;

  width=strlen(text)*8;
  x=(64-width)/2;

  while(*text!='\0')
  {
    nm=((*text++)-' ');
    if(nm>58) nm-=' ';
      nm*=6;
    for(i=0;i<6;i++)
    {
      cur=G_font[nm++];
      for(j=0;j<8;j++)
      {
        pos.x=x+j;
        pos.y=y+6-i;
        if(cur&(0x80>>j))
        {
          Desk_Sprite_WritePixel(usericonsprites,iconbar_spritename,&pos,7,0);
          Desk_Sprite_WriteMaskPixel(usericonsprites,iconbar_spritename,&pos,Desk_TRUE);
        }
        else
        {
          //Desk_Sprite_WritePixel(usericonsprites,iconbar_spritename,&pos,1,0);
          Desk_Sprite_WriteMaskPixel(usericonsprites,iconbar_spritename,&pos,Desk_FALSE);
        }
      }
    }
    x+=8;
  }
}
*/


/*
void set_iconbar_text_above(char *text)
{
  plot_iconbar_text(text,33);
  Desk_Icon_ForceRedraw(Desk_window_ICONBAR,baricon);
}


void set_iconbar_text(char *text)
{
  plot_iconbar_text(text,0);
  Desk_Icon_ForceRedraw(Desk_window_ICONBAR,baricon);
}
*/

static void set_iconbar(char *sprite)
{
  strcpy(iconbar_spritename,sprite);
  strcpy(Desk_Icon_GetTextPtr(Desk_window_ICONBAR,baricon),sprite);
  Desk_Icon_ForceRedraw(Desk_window_ICONBAR,baricon);
}

void show_modem_status(void)
{
  int out;
  out=(*driver)(DRIVER_MODEMCONTROL,portnumber,0,0);

  if(out&8)
  {
    //set_iconbar_text(STANDBY);
    Desk_Icon_SetText(unten_window,UNTEN_MSTATUS,"Online");
    if(logon==0)
      Desk_Icon_SetText(unten_window,UNTEN_LSTATUS," ");
  }
  if( ((out&1) || (out&2)) && !(out&8))
  {
    //set_iconbar_text(STANDBY);
    Desk_Icon_SetText(unten_window,UNTEN_MSTATUS,"Standby");
    if(logon==0)
      Desk_Icon_SetText(unten_window,UNTEN_LSTATUS," ");
  }
  if( !(out&1) && !(out&2) && !(out&8))
  {
    //set_iconbar_text(BUSY);
    Desk_Icon_SetText(unten_window,UNTEN_MSTATUS,"Busy");
    if(logon==0)
      Desk_Icon_SetText(unten_window,UNTEN_LSTATUS," ");
  }
}


void create_cept_sprite(void)
{
  int mode[6];
  os_error *e = NULL;
  int spritesize;

  spritesize=((CEPT_XSIZE*CEPT_YSIZE*Desk_screen_bpp)>>3)+sizeof(osspriteop_header)+sizeof(osspriteop_area);

  if(cept_spritearea!=NULL)
    Desk_DeskMem_Free(cept_spritearea);
  cept_spritearea = (osspriteop_area *) Desk_DeskMem_Malloc(spritesize);
  //else
  //DeskMem_Realloc(cept_spritearea,spritesize);

  /*
  if(cept_spritearea==NULL)
    flex_alloc((flex_ptr)&cept_spritearea,spritesize);
  else
    flex_extend((flex_ptr)&cept_spritearea,spritesize);
  */

  cept_spritearea->size=spritesize;
  cept_spritearea->first=16;
  xosspriteop_clear_sprites(osspriteop_PTR,cept_spritearea);

  switch(log2bpp)
  {
    case 0:
      e=xosspriteop_create_sprite(osspriteop_PTR,cept_spritearea,"cept",FALSE,CEPT_XSIZE,
                                  CEPT_YSIZE,os_MODE1BPP90X90);
    break;
    case 1:
      e=xosspriteop_create_sprite(osspriteop_PTR,cept_spritearea,"cept",FALSE,CEPT_XSIZE,
                                  CEPT_YSIZE,os_MODE2BPP90X90);
    break;
    case 2:
      e=xosspriteop_create_sprite(osspriteop_PTR,cept_spritearea,"cept",FALSE,CEPT_XSIZE,
                                  CEPT_YSIZE,os_MODE4BPP90X90);
    break;
    case 3:
      e=xosspriteop_create_sprite(osspriteop_PTR,cept_spritearea,"cept",FALSE,CEPT_XSIZE,
                                  CEPT_YSIZE,os_MODE8BPP90X90);
    break;
    case 4:
      mode[0]=1;
      mode[1]=CEPT_XSIZE;
      mode[2]=CEPT_YSIZE;
      mode[3]=4;
      mode[4]=-1;
      mode[5]=-1;
      e=xosspriteop_create_sprite(osspriteop_PTR,cept_spritearea,"cept",FALSE,CEPT_XSIZE,CEPT_YSIZE,(os_mode)mode);
    break;
    case 5:
      mode[0]=1;
      mode[1]=CEPT_XSIZE;
      mode[2]=CEPT_YSIZE;
      mode[3]=5;
      mode[4]=-1;
      mode[5]=-1;
      e=xosspriteop_create_sprite(osspriteop_PTR,cept_spritearea,"cept",FALSE,CEPT_XSIZE,CEPT_YSIZE,(os_mode)mode);
    break;
  }
  if(e!=NULL)
    Desk_Error_Report(0,e->errmess);

  cept_sprite_id=(osspriteop_id) (osspriteop_header *) ((char *)cept_spritearea+cept_spritearea->first);
}

void delete_cept_sprite(void)
{
  if(cept_spritearea!=NULL)
    Desk_DeskMem_Free(cept_spritearea);
    //flex_free((flex_ptr)&cept_spritearea);
  cept_spritearea=NULL;
}


void setmodemspeed(int terminalnr,int baudnr,int datanr,int transfernr,Desk_bool draw)
{
  static int old_local_echo=0;
  static int old_crtocrlf=0;
  static int chat=0;
  static int old_autowrap=0;
  static int old_terminalnr=-1;
  int i;

  dial_terminal_nr=terminalnr;
  dial_baud_nr=baudnr;
  dial_data_nr=datanr;
  transfer_type_nr=transfernr;


  if(draw)
  {
    Desk_Icon_SetText(unten_window,UNTEN_TERMINAL,terminal[dial_terminal_nr].string);
    Desk_Icon_SetText(unten_window,UNTEN_BAUD,baud[dial_baud_nr].string);
    Desk_Icon_SetText(unten_window,UNTEN_DATA,data[dial_data_nr].string);
    Desk_Icon_SetText(unten_window,UNTEN_TRANSFER,transfer[transfer_type_nr]);
  }


  (*driver)(DRIVER_TXSPEED,portnumber,baud[baudnr].value,0);
  (*driver)(DRIVER_RXSPEED,portnumber,baud[baudnr].value,0);
  (*driver)(DRIVER_WORDFORMAT,portnumber,data[datanr].value,0);

  if(terminalnr!=old_terminalnr || draw)
  {
    modechange(NULL,NULL);
    switch(terminalnr)
    {
      case 0:  /* VT100 */
        //delete_cept_sprite(); //sonst schreibt er nach dem Wechsel in vt100/ansi irgendwo im Speicher
                                //rum, da er noch im read1 ist (rekursiv verschachtelt)
        VTInit();
        if(terminal_height!=24)
        {
          if(cursorY>23)
            cursorY=23;
          terminal_height=24;
          init_text_buffer(0);
        }
        normal_attr=((backcolor<<12)|(forecolor<<8))&0x0000ff00;
        normal_attr|=(normal_attr<<8);
        normal_attr|=VT100;
        for(i=0;i<tb_all;i++)
          text_buffer[i]=(text_buffer[i]&0x000000ff)|normal_attr;
        //Window_ForceWholeRedraw(haupt_window);
        if(chat)
        {
          local_echo=old_local_echo;
          crtocrlf=old_crtocrlf;
          autowrap=old_autowrap;
          chat=0;
        }
        if(Desk_Window_IsOpen(haupt_window))
        {
          open_haupt_window(2);
          Desk_Window_ForceWholeRedraw(haupt_window);
        }
      break;
      case 1:  /* Ansi */
        //delete_cept_sprite();
        ansiInit();
        if(ansi_terminal_height!=terminal_height)
        {
          if(ansi_terminal_height==25)
            lineMode=1;
          else
            lineMode=0;
          terminal_height=ansi_terminal_height;
          init_text_buffer(0);

        }
        consoleSetup();
        normal_attr=0x00070700;
        for(i=0;i<tb_all;i++)
          text_buffer[i]=(text_buffer[i]&0x000000ff)|normal_attr;
        //Window_ForceWholeRedraw(haupt_window);
        if(chat)
        {
          local_echo=old_local_echo;
          crtocrlf=old_crtocrlf;
          autowrap=old_autowrap;
          chat=0;
        }
        if(Desk_Window_IsOpen(haupt_window))
        {
          open_haupt_window(2);
          Desk_Window_ForceWholeRedraw(haupt_window);
        }
      break;
      case 2: /* chat */
        //delete_cept_sprite();
        chat=1;
        VTInit();
        normal_attr=((backcolor<<12)|(forecolor<<8))&0x0000ff00;
        normal_attr|=(normal_attr<<8);
        normal_attr|=VT100;
        old_local_echo=local_echo;
        old_crtocrlf=crtocrlf;
        old_autowrap=autowrap;
        local_echo=1;
        crtocrlf=1;
        autowrap=1;
        if(chat_special)
          insertmode=1;
        for(i=0;i<tb_all;i++)
          text_buffer[i]=normal_attr|32;
        //Window_ForceWholeRedraw(haupt_window);
        init_chat();
        if(Desk_Window_IsOpen(haupt_window))
        {
          open_haupt_window(2);
          Desk_Window_ForceWholeRedraw(haupt_window);
        }
      break;
      case 3: // Cept
        create_cept_sprite();
        init_colormap();
        init_fonts();
        init_layer6();
        if(Desk_Window_IsOpen(haupt_window))
        {
          open_haupt_window(2);
          Desk_Window_ForceWholeRedraw(haupt_window);
        }
      break;
    }
    old_terminalnr=terminalnr;
  }
  attrib=normal_attr;
  if(dial_terminal_nr==1)
  {
    if(highres)
    {
      bit_font=&bitfont[0];
    }
    else
    {
      bit_font=&bitfont[ZA*256/2];
    }
    Desk_Window_ForceWholeRedraw(haupt_window);
  }
  else
  {
    if(highres)
    {
      bit_font=&iso_bitfont[0];
    }
    else
    {
      bit_font=&iso_bitfont[ZA*256/2];
    }
    Desk_Window_ForceWholeRedraw(haupt_window);
  }
}

void pause(int t)
{
    t=Desk_Time_Monotonic()+t;
    pause_status=TRUE;
    while (t>Desk_Time_Monotonic())
      Desk_Event_Poll();
    pause_status=FALSE;
}

static void wait(int t)
{
  t=Desk_Time_Monotonic()+t;
  while (t>Desk_Time_Monotonic());
    //Event_Poll();
}

void send_string(char *str)
{
  int i=0;

  //pause_status=TRUE;
  
  while(str[i]>0)
  {
    if (str[i]!='|')
    {
      while((*driver)(DRIVER_PUTBYTE,portnumber,str[i],0)==-1);
      pause(1);
      //wait(2);
    }
    else
    {
      i++;
      if(str[i]=='W')
        pause(100);
      else
        while((*driver)(DRIVER_PUTBYTE,portnumber,str[i]-64,0)==-1);
    }
    i++;
  }
  
  //pause_status=FALSE;
}

void send_stringt(int t,char *str)
{
  int i=0;

  if(!f_keys || strlen(str)==0)
  {
    Desk_Wimp_ProcessKey(t);
    return;
  }

  while(str[i]>0)
  {
    if (str[i]!='|')
    {
      (*driver)(DRIVER_PUTBYTE,portnumber,str[i],0);
      wait(2);
    }
    else
    {
      i++;
      (*driver)(DRIVER_PUTBYTE,portnumber,str[i]-64,0);
    }
    i++;
  }
}

void hangup(void)
{
  int t;

    //pause_status=FALSE;
    t_online=0;
    dialing=FALSE;
    dial_time=0;
    dial_delay_time=0;
    if(toolbar)
      Desk_Icon_Shade(tools_window,TOOLS_HANGUP);

    Desk_Menu_SetFlags(modem_menu,3,0,1);

    //set_iconbar_text(HANGUP);
    Desk_Icon_SetText(unten_window,UNTEN_MSTATUS,"Hangup");

    if(drop_dtr)
    {
      send_string("+");
      (*driver)(DRIVER_CONTROLLINES,portnumber,0,0);
      pause_status=1;
      t=Desk_Time_Monotonic()+100;
      while(Desk_Time_Monotonic()<t)
        Desk_Event_Poll();
      pause_status=0;
      (*driver)(DRIVER_CONTROLLINES,portnumber,3,0);
    }
    else
      send_string(modem.hangup);
    pause_status=0;

    show_modem_status();


    if(toolbar)
    {
      Desk_Icon_Unshade(tools_window,TOOLS_HANGUP);
      Desk_Icon_Unshade(tools_window,TOOLS_DIAL);
    }
    Desk_Menu_SetFlags(modem_menu,1,0,0);
    Desk_Menu_SetFlags(modem_menu,3,0,0);

    if(!script_hangup)
    {
      if(logon_file!=-1)
      {
        Desk_File_Close(logon_file);
        logon_file=-1;
      }
      logon=0;
    }
    Desk_Icon_SetText(unten_window,UNTEN_LSTATUS," ");
}

void answer(void)
{
    dialing=FALSE;
    send_string(modem.answer);
}


void dial(char *number)
{
  int i;

  for(i=0;i<20;i++)
      wsl[i]=32;
  if( number[0]>=32 )
  {
    if(toolbar)
      Desk_Icon_Shade(tools_window,TOOLS_DIAL);
    Desk_Menu_SetFlags(modem_menu,1,0,1);

    //set_iconbar_text(DIALLING);
    Desk_Icon_SetText(unten_window,UNTEN_MSTATUS,"Dialling");
    newline = 0;


    insertmode = 0;

    dialing=autodial;
    strcpy(old_number,number);

    dial_time=Desk_Time_Monotonic();

    /* nur zum testen */
    // online=TRUE;
    send_string(modem.dialprefix);
    send_string(number);
    send_string(modem.dialsuffix);
  }
}


static void bit21bit()
{
  unsigned int i;
  unsigned char *zw;

  zw=(unsigned char *)zeichen;

  // normal
  for(i=0;i<256;i++)
    *zw++=i^255;

  // bold
  for(i=0;i<256;i++)
    *zw++=((i^255)|((i^255)>>1));
}

static void bit22bit()
{
  unsigned int i,b;
  unsigned short *zw;
  unsigned int hilf;
  int x;

  zw=(unsigned short *)zeichen;

// normal

  for(i=0;i<256;i++)
  {
    b=i;
    hilf=0;
    for(x=0;x<8;x++)
    {
      if( (b&128)==128 )
        hilf=(hilf&0xfffc)|0x0;
      else
        hilf=(hilf&0xfffc)|0x3;
      hilf<<=2;
      b<<=1;
    }
    *zw++=hilf>>2;
  }

// bold

  for(i=0;i<256;i++)
  {
    b=(((i^255)|((i^255)>>1))^255);
    hilf=0;
    for(x=0;x<8;x++)
    {
      if( (b&128)==128 )
        hilf=(hilf&0xfffc)|0x0;
      else
        hilf=(hilf&0xfffc)|0x3;
      hilf<<=2;
      b<<=1;
    }
    *zw++=hilf>>2;
  }
}


static void bit24bit(void)
{
  unsigned int i,b;
  unsigned int *zw;
  unsigned int hilf;
  int x;

  zw=(unsigned int *)zeichen;

// normal

  for(i=0;i<256;i++)
  {
    b=i;
    hilf=0;
    for(x=0;x<8;x++)
    {
      if( (b&128)==128 )
        hilf=(hilf&0xfffffff0)|0x0;
      else
        hilf=(hilf&0xfffffff0)|0xf;
      if(x!=7)
        hilf<<=4;
      b<<=1;
    }
    *zw++=hilf;
  }

// bold

  for(i=0;i<256;i++)
  {
    b=(((i^255)|((i^255)>>1))^255);
    hilf=0;
    for(x=0;x<8;x++)
    {
      if( (b&128)==128 )
        hilf=(hilf&0xfffffff0)|0x0;
      else
        hilf=(hilf&0xfffffff0)|0xf;
      if(x!=7)
        hilf<<=4;
      b<<=1;
    }
    *zw++=hilf;
  }
}

static void bit28bit(void)
{
  unsigned int i,b;
  unsigned char *zw;
  int x;

  zw=(unsigned char *)zeichen;

  // normal

  for(i=0;i<256;i++)
  {
    b=i;
    for(x=0;x<8;x++)
    {
      if((b&1)==1)
        *zw++=0;
      else
        *zw++=0xff;
      b>>=1;
    }
  }

  // bold

  for(i=0;i<256;i++)
  {
    b=(((i^255)|((i^255)>>1))^255);
    for(x=0;x<8;x++)
    {
      if((b&1)==1)
        *zw++=0;
      else
        *zw++=0xff;
      b>>=1;
    }
  }
}

static void bit216bit(void)
{
  unsigned int i,b;
  unsigned short *zw;
  int x;

  zw=(unsigned short *)zeichen;

  // normal

  for(i=0;i<256;i++)
  {
    b=i;
    for(x=0;x<8;x++)
    {
      if((b&1)==1)
        *zw++=0;
      else
        *zw++=0xffff;
      b>>=1;
    }
  }

  // bold

  for(i=0;i<256;i++)
  {
    b=(((i^255)|((i^255)>>1))^255);
    for(x=0;x<8;x++)
    {
      if((b&1)==1)
        *zw++=0;
      else
        *zw++=0xffff;
      b>>=1;
    }
  }
}


static void bit232bit(void)
{
  unsigned int i,b;
  unsigned int *zw;
  int x;


  zw=(unsigned int *)zeichen;

  // normal

  for(i=0;i<256;i++)
  {
    b=i;
    for(x=0;x<8;x++)
    {
      if((b&1)==1)
        *zw++=0;
      else
        *zw++=0xffffffff;
      b>>=1;
    }
  }

  // bold

  for(i=0;i<256;i++)
  {
    b=(((i^255)|((i^255)>>1))^255);
    for(x=0;x<8;x++)
    {
      if((b&1)==1)
        *zw++=0;
      else
        *zw++=0xffffffff;
      b>>=1;
    }
  }
}

static unsigned int *get_screen_address(void)
{
  int mem[3];
  int out;

  mem[0]=148;
  mem[1]=-1;
  Desk_SWI(2,0,Desk_SWI_OS_ReadVduVariables,mem,&out);
  return((unsigned int *)out);
}

void set_cept_zoom(void)
{
  if(highres)
  {
    factors.xmul=cept_zoom;
    factors.ymul=(((cept_zoom*480)/133)*100)/240;
    factors.xdiv=100;
    factors.ydiv=100;
  }
  else
  {
    factors.xmul=cept_zoom;
    factors.ymul=cept_zoom;
    factors.xdiv=100;
    factors.ydiv=100;
  }
}

Desk_bool modechange(Desk_event_pollblock *poll_block, void *reference)
{
  int mode[6];
  int spritesize,zeichensize;
  Desk_window_state state;
  int LSPR_HEIGHT=8;
  int HSPR_HEIGHT=16;
  Desk_window_block *wblock;

  Desk_Screen_CacheModeInfo();
  screen_address=get_screen_address();

  Desk_Wimp_GetWindowState(haupt_window,&state);
  if(state.flags.data.focus)
    input_focus=haupt_window;

  /* immer noch besser als den logarithmus zu berechnen */
  Desk_OS_ReadModeVariable(-1, Desk_modevar_LOG2BPP, &log2bpp);
  Desk_OS_ReadModeVariable(-1, Desk_modevar_NCOLOUR, &ncolour);
  Desk_OS_ReadModeVariable(-1, Desk_modevar_MODEFLAGS, &modeflags);

  /* Check assumptions about running in an RGB colour space */
  if((modeflags&0x3000)!=0) Desk_Error_ReportFatal(0,"Require an RGB desktop");

  zeichensize=(64*64*Desk_screen_bpp)>>3; 
  if(zeichen!=NULL)
    Desk_DeskMem_Free(zeichen);
  zeichen = (unsigned char *) Desk_DeskMem_Malloc(zeichensize);

  spritesize=((80*144*Desk_screen_bpp)>>3)+sizeof(Desk_sprite_header)+sizeof(Desk_sprite_info);
  if(spritearea!=NULL)
    Desk_DeskMem_Free(spritearea);
  spritearea = (Desk_sprite_area) Desk_DeskMem_Malloc(spritesize);

  spritearea->areasize=spritesize;
  spritearea->firstoffset=16;
  Desk_Sprite_InitArea(spritearea);

  if(Desk_screen_eig.y==Desk_screen_eig.x)
  {
    highres=TRUE;
    if(dial_terminal_nr==1)
    {
      bit_font=&bitfont[0];
      ZA=ansi_charheight<<1;
    }
    else
    {
      bit_font=&iso_bitfont[0];
      ZA=vt_charheight<<1;
    }
    HSPR_HEIGHT=ZA>>1;
  }
  else
  {
    highres=FALSE;
    if(dial_terminal_nr==1)
    {
      bit_font=&bitfont[ZA*256/2];
      ZA=ansi_charheight<<1;
    }
    else
    {
      bit_font=&iso_bitfont[ZA*256/2];
      ZA=vt_charheight<<1;
    }
    LSPR_HEIGHT=ZA>>2;
  }

  switch(log2bpp)
  {
    case 0:
      bit21bit();
      if(highres)
        Desk_Sprite_Create(spritearea,"z",0,640,HSPR_HEIGHT,25);
      else
        Desk_Sprite_Create(spritearea,"z",0,640,LSPR_HEIGHT,0);
    break;
    case 1:
      bit22bit();
      if(highres)
        Desk_Sprite_Create(spritearea,"z",0,640,HSPR_HEIGHT,26);
      else
        Desk_Sprite_Create(spritearea,"z",0,640,LSPR_HEIGHT,8);
    break;
    case 2:
      bit24bit();
      if(highres)
        Desk_Sprite_Create(spritearea,"z",0,640,HSPR_HEIGHT,27);
      else
        Desk_Sprite_Create(spritearea,"z",0,640,LSPR_HEIGHT,9);
    break;
    case 3:
      bit28bit();
      if(highres)
        Desk_Sprite_Create(spritearea,"z",0,640,HSPR_HEIGHT,28);
      else
        Desk_Sprite_Create(spritearea,"z",0,640,LSPR_HEIGHT,15);
    break;
    case 4:
      bit216bit();
      mode[0]=1;
      mode[1]=640;
      mode[3]=4;
      mode[4]=-1;
      mode[5]=-1;
      if(highres)
      {
        mode[2]=HSPR_HEIGHT;
        Desk_Sprite_Create(spritearea,"z",0,640,HSPR_HEIGHT,(int)mode);
      }
      else
      {
        mode[2]=LSPR_HEIGHT;
        Desk_Sprite_Create(spritearea,"z",0,640,LSPR_HEIGHT,(int)mode);
      }
    break;
    case 5:
      bit232bit();

      mode[0]=1;
      mode[1]=640;
      mode[3]=5;
      mode[4]=-1;
      mode[5]=-1;
      if(highres)
      {
        mode[2]=HSPR_HEIGHT;
        Desk_Sprite_Create(spritearea,"z",0,640,HSPR_HEIGHT,(int)mode);
      }
      else
      {
        mode[2]=LSPR_HEIGHT;
        Desk_Sprite_Create(spritearea,"z",0,640,LSPR_HEIGHT,(int)mode);
      }
    break;
    default:
      Desk_Error_ReportFatal(0,"Unknown log2bpp of %d",log2bpp);
    break;
  }
  set_cept_zoom();

  if(dial_terminal_nr==3)
  {
    xclip0=0;
    yclip0=0;
    xclip1=(Desk_screen_size.x>>Desk_screen_eig.x);
    yclip1=(Desk_screen_size.y>>Desk_screen_eig.y);
    create_cept_sprite();
    convert_colormap();
    redraw_screen_rect(0,0,39,rows-1);
    //init_colormap();
    //init_fonts();
    //init_layer6();
    if(Desk_Window_IsOpen(haupt_window))
    {
      open_haupt_window(0);
      Desk_Window_ForceWholeRedraw(haupt_window);
    }
  }

#ifdef banner
  if(banner_exist)
  {
    if(Desk_Window_IsOpen(banner_window))
    {
      Desk_Event_Poll();
      open_banner_window();
    }
  }
#endif

  return(Desk_TRUE);
}


void init_zmodem_receive_string(void)
{
  zmodem_receive_string[0]='*';
  zmodem_receive_string[1]='*';
  zmodem_receive_string[2]=0x18;
  zmodem_receive_string[3]='B';
  zmodem_receive_string[4]='0';
  zmodem_receive_string[5]='0';
  zmodem_receive_string[6]=0;
  
  zmodem_send_string[0]='*';
  zmodem_send_string[1]='*';
  zmodem_send_string[2]=0x18;
  zmodem_send_string[3]='B';
  zmodem_send_string[4]='0';
  zmodem_send_string[5]='1';
  zmodem_send_string[6]=0;
}

void icon_change_sprite(int window_handle,int icon_handle,char *sprite)
{
  Desk_icon_createblock icon;

  icon.window=window_handle;
  Desk_Wimp_GetIconState(window_handle,icon_handle,&icon.icondata);
  strcpy(icon.icondata.data.spritename,sprite);
  Desk_Wimp_DeleteIcon(window_handle,icon_handle);
  Desk_Wimp_CreateIcon(&icon,&icon_handle);
  Desk_Icon_ForceRedraw(window_handle,icon_handle);
}



/*
void print_in_status_window(int was,char *report, ...)
{
  va_list va;
  char string[255];
  icon_handle iconhandle;
  icon_createblock icon;
  int worky,size;
  window_state state;

  va_start(va, report);
  vsprintf(string, report, va);
  va_end(va);
  size=strlen(string)+1;

  icon.icondata.data.indirecttext.buffer=(char *)DeskMem_Malloc(size);
  if(icon.icondata.data.indirecttext.buffer==NULL)
  {
    delete_status_icons(number_of_icons);
    number_of_icons=0;
    icon.icondata.data.indirecttext.buffer=(char *)DeskMem_Malloc(size);
    if(icon.icondata.data.indirecttext.buffer==NULL)
      return;
  }

  worky=number_of_icons*STATUS_ICON_HIGHT;
  if(worky<270)
    worky=270-STATUS_ICON_HIGHT-12;

  Window_SetExtent(status_window,0,-(worky+STATUS_ICON_HIGHT+12),STATUS_WIDTH,0);

  worky=number_of_icons*STATUS_ICON_HIGHT;

  icon.window = status_window;
  icon.icondata.workarearect.min.x=20;
  icon.icondata.workarearect.min.y=-worky-STATUS_ICON_HIGHT-12;
  icon.icondata.workarearect.max.x=STATUS_WIDTH-20;
  icon.icondata.workarearect.max.y=-worky;
  if(was==MESSAGE)
    icon.icondata.flags.value=0x1700a101;
  else
  {
    icon.icondata.flags.value=0x1b00a101;

  }
  icon.icondata.data.indirecttext.bufflen=size;
  icon.icondata.data.indirecttext.validstring=NULL;

  strncpy(icon.icondata.data.indirecttext.buffer,string,size-1);
  icon.icondata.data.indirecttext.buffer[size-1]=0;
  Wimp_ECreateIcon(&icon,&iconhandle);

  Window_ForceRedraw(status_window,icon.icondata.workarearect.min.x,
                     icon.icondata.workarearect.min.y,icon.icondata.workarearect.max.x,
                     icon.icondata.workarearect.max.y);

  if(Window_IsOpen(status_window))
  {
    Wimp_EGetWindowState(status_window,&state);
    state.openblock.scroll.y=-(worky+STATUS_ICON_HIGHT);
    Wimp_EOpenWindow(&state.openblock);
  }
  number_of_icons++;
}
*/

/*
int read1(int w)
{
  int c;

  if(w)
  {
    while((c=(*driver)(DRIVER_GETBYTE,portnumber,0,0))==-1)
      Event_Poll();
  }
  else
  {
    while((c=(*driver)(DRIVER_EXAMINE,portnumber,0,0))==-1)
      Event_Poll();
  }
  return(c);
}
*/



int read1(int readflag)
{
  /* unget 1 character */
  //int size;
  static int flag=0;
  //int got;

  if(!readflag)
  {
      btx_serial_buffer_index--;
      if(btx_serial_buffer_index<0 && flag)
        btx_serial_buffer_index+=BTX_BUFFER_SIZE;
      else
        if(btx_serial_buffer_index<0)
          btx_serial_buffer_index=0;

      return(0);
   }

   if(btx_serial_buffer_index>(BTX_BUFFER_SIZE-1))
     btx_serial_buffer_index-=BTX_BUFFER_SIZE;

   if(btx_serial_buffer_index==btx_serial_buffer_end)
   {
     if(spool_action==PLAY)
     {
       btx_serial_buffer[btx_serial_buffer_end++]=Desk_File_ReadChar(spool_file);
     }
     else
     {
       btx_wait=1;
       if((*driver)(DRIVER_CHECKRX,portnumber,0,0)==0)
       {
         //Desk_Window_ForceWholeRedraw(haupt_window);
         /*
         Desk_Window_ForceRedraw(haupt_window,(((cept_xmin-1)*12*factors.xmul)/100)<<1,-(cept_ymax)*((10*factors.ymul)/100)<<1,((cept_xmax*12*factors.xmul)/100)<<1,-(cept_ymin-1)*((10*factors.ymul)/100)<<1);
         */
         Desk_Window_ForceRedraw(haupt_window,0,-(cept_ymax)*((10*factors.ymul)/100)<<1,(960*factors.xmul)/100,-(cept_ymin-1)*((10*factors.ymul)/100)<<1);

         while((*driver)(DRIVER_CHECKRX,portnumber,0,0)==0 && dial_terminal_nr==3)
           Desk_Event_Poll();
       }
       btx_wait=0;
       btx_serial_buffer[btx_serial_buffer_end++]=(*driver)(DRIVER_GETBYTE,portnumber,0,0);
     }
     if(spool_action==REC && !export_data_text)
       spool_rec(btx_serial_buffer[btx_serial_buffer_end-1]);
     if(btx_serial_buffer_end>(BTX_BUFFER_SIZE-1))
     {
       flag=1;
       btx_serial_buffer_end-=BTX_BUFFER_SIZE;
     }
   }
   return(btx_serial_buffer[btx_serial_buffer_index++]);
}


static void send_serial_port_claim_message(void)
{
  Desk_message_block msg_devclaim;

  msg_devclaim.header.size=sizeof(Desk_message_block);
  msg_devclaim.header.sender=Desk_Event_taskhandle;
  msg_devclaim.header.myref=0;
  msg_devclaim.header.yourref=0;
  msg_devclaim.header.action=Desk_message_DEVICECLAIM;
  msg_devclaim.data.deviceclaim.major=2;

  msg_devclaim.data.deviceclaim.minor=driver_number+portnumber;

  strcpy(msg_devclaim.data.deviceclaim.info,"Connector");

  Desk_Wimp_SendMessage(Desk_event_SENDWANTACK, &msg_devclaim, 0, 0);
}


void set_baud_menu(int nr)
{
  int i,j,speed;

  for(j=0;j<MAX_BAUD_NR;j++)
  {
    Desk_Menu_SetFlags(baud_menu,j,0,1);
    i=0;
    while((speed=driver_speedtable[i])!=0)
    {
      i++;
      if(speed==baud[j].value)
      {
        if(j!=nr)
          Desk_Menu_SetFlags(baud_menu,j,0,0);
        else
          Desk_Menu_SetFlags(baud_menu,j,1,0);
        break;
      }
    }
    if(i==0)
    {
      if(j!=nr)
        Desk_Menu_SetFlags(baud_menu,j,0,0);
      else
        Desk_Menu_SetFlags(baud_menu,j,1,0);
    }
  }

/*
  int old_baud;
  char b[12];

  if(baud_menu!=NULL)
    Desk_Menu_SDispose(baud_menu);

  old_baud=baud[nr].value;

  strcpy(gstring,"");

  i=0;
  while((speed=driver_speedtable[i++])!=0)
  {
    sprintf(b,"%d,",speed);
    strcat(gstring,b);
  }
  gstring[strlen(gstring)-1]=0;
  baud_menu = Desk_Menu_New("Baud",(char*)gstring);
  //Desk_Menu_SetFlags(baud_menu,j,1,0);
*/
}

void get_serial_output_buffer_size(void)
{
  (*driver)(DRIVER_FLUSHTX,portnumber,0,0);
  serial_output_buffer_size=(*driver)(DRIVER_CHECKTX,portnumber,0,0);
  //Desk_Error_Report(0,"%d",serial_output_buffer_size);
}

void claim_serial_port(void)
{
  int t;
  char *error;


  if(!serial_port_claimed)
  {
    set_iconbar("connectorm");
    
    if ((driver=driver_load(drivers[driver_nr].file))==NULL)
      Desk_Error_ReportFatal(0,"Can't load %s driver",drivers[driver_nr].file);
      
    if((error=(char *)(*driver)(DRIVER_INITIALISE,-1))!=NULL)
      Desk_Error_Report(0,"Error when initialising driver: %s",error);
    set_driver_vars();
    
    send_serial_port_claim_message();

    t=Desk_Time_Monotonic();
    while(t+100>Desk_Time_Monotonic())
      Desk_Wimp_Poll(Desk_Event_mask, &Desk_Event_lastevent);

    if(Desk_stricmp(drivers[driver_nr].file,"InternalPC") &&
     Desk_stricmp(drivers[driver_nr].file,"Internal") &&
     Desk_stricmp(drivers[driver_nr].file,"Internal32") )
    {
      serial_input_buffer=0;
      serial_output_buffer=0;
      if(!Desk_stricmp(drivers[driver_nr].file,"PipeA") || 
         !Desk_stricmp(drivers[driver_nr].file,"PipeB"))
      {
        serial_input_buffer_size=2048;
      }
      internal_driver=0;
    }
    else
    {
      internal_driver=1;
      install_serial_buffer();
    }
    
    if((error=(char *)driver_initialise())!=NULL)
      Desk_Error_Report(0,"Error when initialising driver: %s",error);
    set_driver_vars();
    
    get_serial_output_buffer_size();
    //Desk_Error_Report(0,"size: %d",serial_output_buffer_size);
                         
    if(portnumber>max_port_nr)
      portnumber=max_port_nr;
    
    /* Setzt den Status auf den Originalwert !
       durch Zansi (z.B.) wird er veraendert dadurch geht nichts
       mehr ueber 19200 Baud                                 */
    xosserialop_status(554696966,0,NULL,NULL);
    //Desk_Icon_AlterValidation(Desk_window_ICONBAR,baricon,"S!connector");

    set_iconbar("connector");
    Desk_Icon_SetText(sinfo_window,SINFO_DRIVER,drivers[driver_nr].file);  
    Desk_Icon_SetInteger(sinfo_window,SINFO_PORT,portnumber);
    Desk_Icon_SetText(sinfo_window,SINFO_FLOW,flow[flow_type_nr]);
    show_modem_status();
    serial_port_claimed=TRUE;
  }
}


void release_serial_port(void)
{
  if(serial_port_claimed)
  {
    //Desk_Error_Report(0,"Release");
    deinstall_serial_buffer();
    (*driver)(DRIVER_CLOSEDOWN,portnumber,0,0);
    serial_port_claimed=FALSE;
    //Desk_Icon_AlterValidation(Desk_window_ICONBAR,baricon,"Sconnectors");
    Desk_Icon_SetText(unten_window,UNTEN_MSTATUS,"Busy");
    set_iconbar("connectors");
    //set_iconbar_text(BUSY);
  }
}

Desk_bool claim_device_handler(Desk_event_pollblock *poll_block, void *reference)
{
  if(poll_block->data.message.header.sender!=Desk_Event_taskhandle &&
     poll_block->data.message.data.deviceclaim.major==2)
  {
    if(poll_block->data.message.data.deviceclaim.minor==(driver_number+portnumber))
      release_serial_port();
  }

  return(Desk_TRUE);
}


void write_logfile(int status)
{
  FILE *f=NULL;
  char *s;
  time_t log_end_time;
  int diff;
  char time_str[12];

  if( (status && !online) || log_start_time==(time_t)-1)
    return;

  time(&log_end_time);
  diff=(int)difftime(log_end_time,log_start_time);
  if(diff==0)
    return;

  Desk_File_CreateDirectory("<Wimp$ScrapDir>.Connector");
  f=fopen("<Wimp$ScrapDir>.Connector.logfile","a+");
  if(f==NULL)
  {
    Desk_Error_Report(0,"Couldn't open logfile");
    return;
  }
  s=ctime(&log_start_time);
  s[strlen(s)-1]=0; // remove CR

  sec2time(diff,time_str);
  if(strlen(log_name) && strlen(log_number))
    fprintf(f,"%s: %s %s online %s\n",s,log_name,log_number,time_str);
  else if(strlen(log_number))
         fprintf(f,"%s: %s online %s\n",s,log_number,time_str);
       else
         fprintf(f,"%s: online %s\n",s,time_str);

  fclose(f);
  log_start_time=(time_t)-1;
  strcpy(log_number,"");
  strcpy(log_name,"");
}

int get_title_bar_height(void)
{
  Desk_window_outline     outline;
  Desk_window_state       state;

  Desk_Window_Show(send_window,Desk_open_CENTERED);
  Desk_Wimp_GetWindowState(send_window,&state);
  outline.window = send_window;
  Desk_Wimp_GetWindowOutline(&outline);
  Desk_Window_Hide(send_window);
  return(outline.screenrect.max.y-state.openblock.screenrect.max.y);

}


void create_send_list(void)
{
  Desk_icon_handle iconh;
  Desk_icon_createblock icon;
  Desk_window_openblock open;
  Desk_window_state state;
  int ypos,worky,i;
  int nr_of_send_files;
  file_des *current_file;
  char *validstring;
  char type[4];
  static int nr_of_icons=0;
  char *size_str;
  
  
  if(nr_of_icons>0)
  {
    for(i=0;i<nr_of_icons;i++)
      Desk_Wimp_DeleteIcon(send_window,i);
  }
  
  icon.window =send_window;
  
  //icon.icondata.flags.value=0x1700b113; //0x77018511;
  
  ypos=0;
  nr_of_send_files=0;
  nr_of_icons=0;
  current_file=Desk_LinkList_FirstItem(&Files);
  
  while(current_file!=NULL)
  {
    icon.icondata.workarearect.min.x=8;
    icon.icondata.workarearect.max.x=600-200-8;
  
    icon.icondata.workarearect.min.y=ypos-48;
    icon.icondata.workarearect.max.y=ypos;
    
    validstring=Desk_DeskMem_Malloc(sizeof("Ssmall_fff")+1);
    strcpy(validstring,"Ssmall_");
    sprintf(type,"%x",current_file->filetype);
    switch(strlen(type))
    {
      case 0:
        strcpy(type,"xxx");
      break;
      case 1:
        sprintf(type,"00%x",current_file->filetype);
      break;
      case 2:
        sprintf(type,"0%x",current_file->filetype); 
      break;
    }
    strcat(validstring,type);
    if(xwimpspriteop_select_sprite(validstring+1,NULL)) // falls sprite nicht existiert
      strcpy(validstring,"Ssmall_xxx");
    
    icon.icondata.data.indirecttext.buffer=current_file->name;
    icon.icondata.data.indirecttext.bufflen=strlen(current_file->name)+1;
    icon.icondata.data.indirecttext.validstring=validstring;
    if(current_file->selected)
      icon.icondata.flags.value=0x1700b113+(1<<21);
    else
      icon.icondata.flags.value=0x1700b113;
      
    Desk_Wimp_CreateIcon(&icon,&iconh);
    
    // size icon
    
    icon.icondata.flags.value=0x1701a791;
    icon.icondata.workarearect.min.x=8+600-200-8;
    icon.icondata.workarearect.max.x=icon.icondata.workarearect.min.x+200-8;
    size_str=Desk_DeskMem_Malloc(sizeof("1000000K")+1);
    if(current_file->size>1024)
      sprintf(size_str,"%dK",current_file->size/1024);
    else
      sprintf(size_str,"%d",current_file->size);
    icon.icondata.data.indirecttext.buffer=size_str;
    icon.icondata.data.indirecttext.bufflen=strlen(size_str)+1;
    icon.icondata.data.indirecttext.validstring=NULL;
    Desk_Wimp_CreateIcon(&icon,&iconh);
   
    
    
    ypos-=48;
    nr_of_send_files++;
    nr_of_icons+=2;
    current_file = (file_des *) current_file->header.next;
  }
  
  worky=nr_of_send_files*48+8; 
  if (worky>300)
    Desk_Window_SetExtent(send_window,0,-worky,600,0);
  else
    Desk_Window_SetExtent(send_window,0,-300,600,0);
  Desk_Window_ForceWholeRedraw(send_window);
  
  if(Desk_Window_IsOpen(send_window))
  {
    open.window=send_window;
    Desk_Wimp_GetWindowState(send_window,&state);
    open.screenrect.min.x=state.openblock.screenrect.min.x;
    open.screenrect.min.y=state.openblock.screenrect.min.y;
    open.screenrect.max.x=state.openblock.screenrect.max.x;
    open.screenrect.max.y=state.openblock.screenrect.max.y;
    open.behind=state.openblock.behind;
    open.scroll.y=0;
    open.scroll.x=0;
    Desk_Pane2_OpenWindow(send_window,&open);
  }
  
}

void disable_sent_record(int nr)
{
  Desk_Icon_Shade(send_window,nr);
}


static void back(Desk_file_handle file)
{
  Desk_file_position pos;

  if(Desk_File_EOF(file))
    return;

  pos=Desk_File_ReturnPos(file);
  Desk_File_Seek(file,pos-1);
}


static void next_line(Desk_file_handle file)
{
  while(!Desk_File_EOF(file) && Desk_File_ReadChar(file)!=0x0d);
  Desk_File_ReadChar(file); // skip 0x0a
  //back(file);
}

static void skip_blanks(Desk_file_handle file)
{
  int z;

  //while( (z<=32) && !Desk_FileEOF(file))

  if(!Desk_File_EOF(file))
  {
    z=Desk_File_ReadChar(file);
    while((z==32 || z==9) && !Desk_File_EOF(file))
      z=Desk_File_ReadChar(file);
    back(file);
  }
}

static void get_text(Desk_file_handle file,char *text)
{
  int z,i;

  if(Desk_File_EOF(file))
    return;

  i=0;
  while(!Desk_File_EOF(file) && (z=Desk_File_ReadChar(file))>32)
    text[i++]=z;
  text[i]=0;
  back(file);
}



#define TMPNAME "<Wimp$Scrap>"

void create_filetypes_from_dosmap(void)
{
  Desk_file_handle file;
  
  strcpy(gstring,"DosMap { > ");
  strcat(gstring,TMPNAME);
  strcat(gstring," }");
  system(gstring);

  file=Desk_File_Open(TMPNAME,Desk_file_READ);
  if(file==NULL)
  {
    sprintf(gstring,"Couldn't open file %s",TMPNAME);
    show_message(gstring);
    return;
  }

  next_line(file);
  next_line(file);
    
  //strcat(filetypes,",");  
  filetypes[0]=0;  
  
  while(!Desk_File_EOF(file))
  {
    skip_blanks(file);
    get_text(file,gstring);
    if(gstring[0]==0 || gstring[0]=='-')
      break;
    strcat(filetypes,gstring);
    skip_blanks(file);
    get_text(file,gstring);
    skip_blanks(file);
    get_text(file,gstring);
    strcat(filetypes," ");
    strcat(filetypes,gstring);
    strcat(filetypes,",");
    next_line(file);
  }
  
  if(filetypes[strlen(filetypes)-1]==',')
    filetypes[strlen(filetypes)-1]=0;
    
  filetypes_menu=Desk_Menu_New("Filetypes",filetypes);
  
  //Desk_Error_Report(0,"%d",strlen(filetypes));   
    
  Desk_File_Close(file);
  Desk_File_Delete(TMPNAME);
}
