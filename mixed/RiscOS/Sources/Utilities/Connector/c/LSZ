/*  lsz.c cosmetic modifications by Matt Porter
 *  from the Public Domain version of sz.c by Chuck Forsberg,
 *  Omen Technology INC
 *
 *  A program for Linux to send files and commands to computers running
 *  zmodem, ymodem, or xmodem protocols.
 *
 */

#include <signal.h>
#include <setjmp.h>

#include "Desk/Time.h"
#include "Desk/File.h"
#include "Desk/DeskMem.h"
#include "Desk/Icon.h"

#include "global.h"
#include "iconnames.h"
#include "misc.h"
#include "zmodem.h"
#include "zm.h"
#include "crctab.h"
#include "zmisc.h"

//extern unsigned int alarm(unsigned int);

#define NEW_ERROR

//int my_count=0;

//char *getenv();
void zperr(char *s,...);
//int wcs(char *oname);
int wcs(file_des *current_file);
int getnak(void);
void canit(void);
int zsendcmd(char *buf,int blen);
void saybibi(void);
int wctxpn(char *name);
int zsendfile(char *buf,int blen);
int wcputsec(char *buf,int sectnum,int cseclen);
int getzrxinit(void);
int filbuf(register char *buf,int count);
void purgeline(void);


int sendzsinit(void);
int zsendfdata(void);
int getinsync(int flag);
static int calc_blklen(long total_sent);
void countem(/*int argc,register char ** argv*/);
int wcsend(/*int argc,char *argp[]*/);


#define SS_NORMAL 0
#define LOGFILE "log"
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
//#include <signal.h>
//#include <setjmp.h>
#include <ctype.h>
#include <errno.h>


#include <limits.h>
//define PATH_MAX 1024
#include "timing.h"

#define PATHLEN 256
#define OK 0
#define ZERROR (-1)
/* Ward Christensen / CP/M parameters - Don't change these! */
#define RETRYMAX 10
#define WANTG 0107	/* Send G not NAK to get nonstop batch xmsn */

unsigned Txwindow;	/* Control the size of the transmitted window */
unsigned Txwspac;	/* Spacing between zcrcq requests */
unsigned Txwcnt;	/* Counter used to space ack requests */
long Lrxpos;		/* Receiver's last reported offset */

int Canseek=1; /* 1: can; 0: only rewind, -1: neither */

static int wctx(int flen);

int Filesleft;
long Totalleft;

/*
 * Attention string to be executed by receiver to interrupt streaming data
 *  when an error is detected.  A pause (0336) may be needed before the
 *  ^C (03) or after it.
 */
char Myattn[] = { 0 };

FILE *in;

#define MAX_BLOCK 8192
char txbuf[MAX_BLOCK];

long vpos = 0;			/* Number of bytes read from file */
int Modem2=0;		/* XMODEM Protocol - don't send pathnames */
int Ascii=0;		/* Add CR's for brain damaged programs */
int Fullname=0;		/* transmit full pathname */
int Unlinkafter=0;	/* Unlink file after it is sent */
int Dottoslash=0;	/* Change foo.bar.baz to foo/bar/baz */
int firstsec;
int errcnt=0;		/* number of files unreadable */
int blklen=128;		/* length of transmitted records */
int Optiong;		/* Let it rip no wait for sector ACK's */

int Totsecs;		/* total number of sectors this file */
int Filcnt=0;		/* count of number of files opened */
int Lfseen=0;
unsigned Rxbuflen = 16384;	/* Receiver's max buffer length */
int Tframlen = 0;	/* Override for tx frame length */
int blkopt=0;		/* Override value for zmodem blklen */
int Rxflags = 0;
int Rxflags2 = 0;
long bytcnt;
int Wantfcs32 = TRUE;	/* want to send 32 bit FCS */
char Lzconv;	/* Local ZMODEM file conversion request */

int Lskipnocor;
char Lztrans;

int Command;		/* Send a command, then exit. */
char *Cmdstr;		/* Pointer to the command string */
int Cmdtries = 11;
int Cmdack1;		/* Rx ACKs command, then do it */
int Exitcode;

char *qbf="The quick brown fox jumped over the lazy dog's back 1234567890\r\n";
long Lastsync;		/* Last offset to which we got a ZRPOS */
int Beenhereb4;		/* How many times we've been ZRPOS'd same place */


int max_blklen=1024;
int start_blklen=1024;
#ifdef NEW_ERROR
int error_count;
#define OVERHEAD 18
#define OVER_ERR 20
#endif
#define MK_STRING(x) MK_STRING2(x)
#define MK_STRING2(x) #x

static char fullname[1024];
static int filetype;

//static jmp_buf intrjmp;

/* Called when ZMODEM gets an interrupt (^X) */
/*
void onintr(c)
{
  	Desk_Error_Report(0,"hier2");
	signal(SIGINT, SIG_IGN);
	//longjmp(intrjmp, -1);
}
*/

static void unixify(char *name)
{
  int i;

  for(i=0;i<strlen(name);i++)
  {
    if (name[i]=='/')
      name[i]='.';
  }
}

void send(/*int npats,char **patts,*/int type)
{
	register char *cp;
	int dm;
	int under_rsh=FALSE;

        filetr_finished=FALSE;
	in=NULL;

	Rxtimeout = 600;
	Readnum=2;

	start_blklen=1024;


	if(send_crashrecovery)
	  Lzconv = ZCRESUM; // resume

	Modem2=0;
	Zmodem=0;
	error_count=0;


	vfile("Negotiating...");

	switch(type)
	{
		case 0:
			Desk_Window_SetTitle(filetrans_window,"Xmodem sending");
			if(xmodem_k)
			  start_blklen=1024;
			else
			  start_blklen=128;
			Modem2++;
		break;
		case 1:
			Desk_Window_SetTitle(filetrans_window,"Ymodem sending");
			Nozmodem = TRUE; //ymodem
			if(ymodem_k)
                          start_blklen=1024;
			else
			  start_blklen=128;
		break;
		case 2:
			Desk_Window_SetTitle(filetrans_window,"Zmodem sending");
			Nozmodem = FALSE;
			start_blklen=1024;
		break;
	}


	blklen=start_blklen;

	if(tx_window_size)
	{
	  Txwindow = tx_window_size*1024;
	  if (Txwindow < 256)
		Txwindow = 256;
  	  Txwindow = (Txwindow/64) * 64;
	  Txwspac = Txwindow/4;
	  if (blkopt > Txwspac || (!blkopt && Txwspac < MAX_BLOCK))
		blkopt = Txwspac;
	}
	else
	{
	  blkopt=0;
	}


	mode(1);


	if ( !Modem2)
	{
		if (!Nozmodem)
		{
			//printf("rz\r");  //fflush(stdout);
			sendline('r');
			sendline('z');
			sendline('\r');
		}
		countem(/*npats, patts*/);
		if (!Nozmodem)
		{
			stohdr(0L);
			if (Command)
				Txhdr[ZF0] = ZCOMMAND;
			zshhdr(ZRQINIT, Txhdr);
		}
	}
	//fflush(stdout);


	if (wcsend(/*npats, patts*/)==ZERROR)
	{
		Exitcode=0200;
		canit();
	}
	//fflush(stdout);

	mode(0);

	dm = ((errcnt != 0) | Exitcode);
	/*
	if (dm)
	{
		cucheck();  //exit(dm);
	}
	*/
	//exit(SS_NORMAL);
	/*NOTREACHED*/
}


#if 0

int main(int argc, char **argv)
{
	register char *cp;
	register npats;
	int dm;
	int under_rsh=FALSE;
	char **patts;

	if ((cp = getenv("ZNULLS")) && *cp)
		Znulls = atoi(cp);
	if ((cp=getenv("SHELL")) && (strstr(cp, "rsh") || strstr(cp, "rksh")
		|| strstr(cp, "rbash")))
	{
		under_rsh=TRUE;
		Restricted=1;
	}
	if ((cp=getenv("ZMODEM_RESTRICTED"))!=NULL)
		Restricted=1;
	from_cu();
	chkinvok(argv[0]);

	Rxtimeout = 600;
	npats=0;
	if (argc<2)
		usage();
	while (--argc) {
		cp = *++argv;
		if (*cp++ == '-' && *cp) {
			while ( *cp) {
				switch(*cp++) {
				case '\\':
					 *cp = toupper(*cp);  continue;
				case '+':
					Lzmanag = ZMAPND; break;
#ifdef CSTOPB
				case '2':
					Twostop = TRUE; break;
#endif
				case '8':
					if (max_blklen==8192)
						start_blklen=8192;
					else
						max_blklen=8192;
					break;
				case 'a':
					Lzconv = ZCNL;
					Ascii = TRUE; break;
				case 'b':
					Lzconv = ZCBIN; break;
				case 'C':
					if (--argc < 1) {
						usage();
					}
					Cmdtries = atoi(*++argv);
					break;
				case 'i':
					Cmdack1 = ZCACK1;
					/* **** FALL THROUGH TO **** */
				case 'c':
					if (--argc != 1) {
						usage();
					}
					Command = TRUE;
					Cmdstr = *++argv;
					break;
				case 'd':
					++Dottoslash;
					/* **** FALL THROUGH TO **** */
				case 'f':
					Fullname=TRUE; break;
				case 'e':
					Zctlesc = 1; break;
				case 'h':
					usage(); break;
				case 'k':
					start_blklen=1024; break;
				case 'L':
					if (--argc < 1) {
						usage();
					}
					blkopt = atoi(*++argv);
					if (blkopt<24 || blkopt>MAX_BLOCK)
						usage();
					break;
				case 'l':
					if (--argc < 1) {
						usage();
					}
					Tframlen = atoi(*++argv);
					if (Tframlen<32 || Tframlen>MAX_BLOCK)
						usage();
					break;
				case 'N':
					Lzmanag = ZMNEWL;  break;
				case 'n':
					Lzmanag = ZMNEW;  break;
				case 'o':
					Wantfcs32 = FALSE; break;
				case 'O':
					no_timeout = TRUE; break;
				case 'p':
					Lzmanag = ZMPROT;  break;
				case 'r':
					Lzconv = ZCRESUM; break;
				case 'R':
					Restricted = TRUE; break;
				case 'q':
					Quiet=TRUE; Verbose=0; break;
				case 'S':
				    enable_timesync=1;
				    break;
				case 't':
					if (--argc < 1) {
						usage();
					}
					Rxtimeout = atoi(*++argv);
					if (Rxtimeout<10 || Rxtimeout>1000)
						usage();
					break;
				case 'T':
					if (++Test > 1) {
						chartest(1); chartest(2);
						mode(0);  //exit(0);
					}
					break;
				case 'u':
					++Unlinkafter; break;
				case 'U':
					if (!under_rsh)
						Restricted=0;
					else {
fprintf(stderr,"security violation: running under restricted shell\n",stderr);
						//exit(1);
					}
					break;
				case 'v':
					++Verbose; break;
				case 'w':
					if (--argc < 1) {
						usage();
					}
					Txwindow = atoi(*++argv);
					if (Txwindow < 256)
						Txwindow = 256;
					Txwindow = (Txwindow/64) * 64;
					Txwspac = Txwindow/4;
					if (blkopt > Txwspac
					 || (!blkopt && Txwspac < MAX_BLOCK))
						blkopt = Txwspac;
					break;
				case 'X':
					++Modem2; break;
				case 'Y':
					Lskipnocor = TRUE;
					/* **** FALLL THROUGH TO **** */
				case 'y':
					Lzmanag = ZMCLOB; break;
				default:
					usage();
				}
			}
		}
		else if ( !npats && argc>0) {
			if (argv[0][0]) {
				npats=argc;
				patts=argv;
				if ( !strcmp(*patts, "-"))
					iofd = 1;
			}
		}
	}
	if (npats < 1 && !Command)
		usage();
	if (Command && Restricted) {
		printf("Can't send command in restricted mode\n");
		//exit(1);
	}

	if (Verbose)
	{
#if 0
		if (freopen(LOGFILE, "a", stderr)==NULL) {
			printf("Can't open log file %s\n",LOGFILE);
			//exit(0200);
		}
#endif
		setbuf(stderr, NULL);
	}
	if (Fromcu && !Quiet) {
		if (Verbose == 0)
			Verbose = 2;
	}
	vfile("%s %s for %s\n", Progname, VERSION, OS);

	{
		/* we write max_blocklen (data) + 18 (ZModem protocol overhead)
		 * + escape overhead (about 4 %), so buffer has to be
		 * somewhat larger than max_blklen
		 */
		//char *s=send_disc_buffer;
		/*
		char *s=malloc(max_blklen+1024);
		if (!s)
		{
			fprintf(stderr,"lsz: out of memory\n");
			//exit(1);
		}
		*/
		
		setvbuf(stdout,send_disc_buffer,_IOFBF,max_blklen+1024);
	}
	blklen=start_blklen;

	mode(1);


	if ( !Modem2) {
		if (!Nozmodem) {
			printf("rz\r");  //fflush(stdout);
		}
		countem(npats, patts);
		if (!Nozmodem) {
			stohdr(0L);
			if (Command)
				Txhdr[ZF0] = ZCOMMAND;
			zshhdr(ZRQINIT, Txhdr);
		}
	}
	//fflush(stdout);

	if (Command) {
		if (getzrxinit()) {
			Exitcode=0200; canit();
		}
		else if (zsendcmd(Cmdstr, 1+strlen(Cmdstr))) {
			Exitcode=0200; canit();
		}
	} else if (wcsend(npats, patts)==ZERROR) {
		Exitcode=0200;
		canit();
	}
	//fflush(stdout);
	mode(0);
	dm = ((errcnt != 0) | Exitcode);
	if (dm) {
		cucheck();  //exit(dm);
	}
	//exit(SS_NORMAL);
	/*NOTREACHED*/
}
#endif


int wcsend(/*int argc,char *argp[]*/)
{
	register int n;
	file_des *current_file;
	file_des *next_current_file;

	Crcflg=FALSE;
	firstsec=TRUE;
	bytcnt = -1;
	/*
	for (n=0; n<argc; ++n)
	{
		Totsecs = 0;
		if (wcs(argp[n])==ZERROR)
			return ZERROR;
	}
	*/
	current_file=Desk_LinkList_FirstItem(&Files);
	while(current_file!=NULL)
        {
          next_current_file = (file_des *) current_file->header.next;
          Totsecs = 0;
          if(current_file->selected || send_all)
          {
	    if (wcs(current_file)==ZERROR)
	      return ZERROR;
	  }
          if(current_file->sent)
          {
            Desk_LinkList_Unlink(&Files,&(current_file->header));
            Desk_DeskMem_Free(current_file);
            create_send_list();
          }
          current_file=next_current_file;
        }
        
	Totsecs = 0;
	if (Filcnt==0) {	/* bitch if we couldn't open ANY files */
		if ( !Modem2)
		{
			Command = TRUE;
			Cmdstr = "echo \"lsz: Can't open any requested files\"";
			if (getnak()) {
				Exitcode=0200; canit();
			}
			if (!Zmodem)
				canit();
			else if (zsendcmd(Cmdstr, 1+strlen(Cmdstr))) {
				Exitcode=0200; canit();
			}
			Exitcode = 1; return OK;
		}
		canit();
		vfile("Can't open any requested files.");
		return ZERROR;
	}
	if (Zmodem)
		saybibi();
	else if ( !Modem2)
		wctxpn("");
	return OK;
}

//int wcs(char *oname)
int wcs(file_des *current_file)
{
	register int c;
	register char *p;
	//struct stat f;
	char name[PATHLEN];
	static char *s=send_disc_buffer;

	strcpy(name, current_file->name);
        strcpy(file_path,current_file->path);
        
        
	if (Restricted)
	{
		/* restrict pathnames to current tree or uucppublic */
		if ( strstr(name, "../")
#ifdef PUBDIR
		 || (name[0]== '/' && strncmp(name, MK_STRING(PUBDIR),
		 	strlen(MK_STRING(PUBDIR))))
#endif
		) {
			canit();
			vfile("Security Violation");
			return ZERROR;
		}
	}

/*
	if ( !strcmp(oname, "-"))
	{
		if ((p = getenv("ONAME")) && *p)
			strcpy(name, p);
		else
			sprintf(name, "s%d.lsz", getpid());
		in = stdin;
	}
	else
*/
        filetr_finished=FALSE;
        if(strcmp(file_path,"<Wimp$Scrap>"))
          sprintf(fullname,"%s.%s",file_path,current_file->name);
        else
          strcpy(fullname,file_path);

	if ((in=fopen(fullname, "r"))==NULL)
	{
		++errcnt;
		return OK;	/* pass over it, there may be others */
	}
	filesize=Desk_File_GetLength(fullname);//current_file->size;
	filetype=current_file->filetype; //Desk_File_GetType(fullname);
	if(filetype==0xfff) // text
	{
	  Lzconv = ZCNL;
	  Ascii = TRUE;
	}
	else
	{
	  Lzconv = ZCBIN;
	}

        //if(Desk_File_GetLength(fullname,&filesize)!=NULL)
        //  filesize=-1;
	Icon_printf_Update(filetrans_window,FILETRANS_SIZE,"%d / %d",0,filesize);
	unixify(name);
	Desk_Icon_SetText(filetrans_window,FILETRANS_FILENAME,name);
		/*
		if (!s)
		{
			s=(char *)malloc(16384);
			if (!s)
			{
				vfile("lsz: out of memory\n");
				//exit(1);
			}
		}
		*/
		setvbuf(in,s,_IOFBF,16384);

	//timing(1);
	Eofseen = 0;  vpos = 0;
	/* Check for directory or block special files */
	/*
	fstat(fileno(in), &f);
	c = f.st_mode & S_IFMT;
	if (c == S_IFDIR || c == S_IFBLK)
	{
		fclose(in);
		return OK;
	}
        */
	++Filcnt;
	switch (wctxpn(name))
	{
	case ZERROR:
		return ZERROR;
	case ZSKIP:
		return OK;
	}
	if (!Zmodem && wctx(filesize)==ZERROR)
		return ZERROR;

	//if (Unlinkafter)
	//	unlink(oname);
	if(!filetr_abort)
	  current_file->sent=1;
	
	return 0;
}

/*
 * generate and transmit pathname block consisting of
 *  pathname (null terminated),
 *  file length, mode time and file mode in octal
 *  as provided by the Unix fstat call.
 *  N.B.: modifies the passed name, may extend it!
 */
int wctxpn(char *name)
{
	register char *p, *q, *p2;
	char name2[PATHLEN];

	if (Modem2) // xmodem
	{
	  	/*
		if ((in!=stdin) && *name) // && fstat(fileno(in), &f)!= -1)
		{
			vfile("Sending %s, %ld blocks: ",name, (long) (filesize>>7));
		}
		*/
		//vfile("Give your local XMODEM receive command now");
		timing(1);
		return OK;
	}
	if ( !Zmodem)
		if (getnak())
			return ZERROR;

	q = (char *) 0;
	if (Dottoslash) {		/* change . to . */
		for (p=name; *p; ++p) {
			if (*p == '/')
				q = p;
			else if (*p == '.')
				*(q=p) = '/';
		}
		if (q && strlen(++q) > 8) {	/* If name>8 chars */
			q += 8;			/*   make it .ext */
			strcpy(name2, q);	/* save excess of name */
			*q = '.';
			strcpy(++q, name2);	/* add it back */
		}
	}
	for (p=name, q=txbuf ; *p; )
		if ((*q++ = *p++) == '/' && !Fullname)
			q = txbuf;
	*q++ = 0;
	p=q;

	while (q < (txbuf + MAX_BLOCK))
		*q++ = 0;

	if (/*!Ascii &&*/ (in!=stdin) && *name)  // && fstat(fileno(in), &f)!= -1)
		sprintf(p, "%lu %lo %o 0 %d %ld", (long) filesize, 0/*time*/,
		  0/*mode*/, Filesleft, Totalleft);

        p2 = p+1+strlen(p);  // RiscOs filetype
        sprintf(p2,"type &%x",filetype);
	//vfile("Sending: %s",name);

	timing(1);
	Totalleft -= filesize;
	//filesize = f.st_size;
	//filetransfer_window->init_send(txbuf);
	if (--Filesleft <= 0)
		Totalleft = 0;
	if (Totalleft < 0)
		Totalleft = 0;

	/* force 1k blocks if name won't fit in 128 byte block */
	if (txbuf[125])
		blklen=1024;
	else {		/* A little goodie for IMP/KMD */
		txbuf[127] = (filesize + 127) >>7;
		txbuf[126] = (filesize + 127) >>15;
	}
	
	if (Zmodem)
		return zsendfile(txbuf, 1+strlen(p)+(p-txbuf)+1+strlen(p2));
	if (wcputsec(txbuf, 0, 128)==ZERROR)
		return ZERROR;
	return OK;
}

int getnak(void)
{
	register int firstch;

	Lastrx = 0;
	while(!filetr_abort)
	{
		switch (firstch = readline(800)) {
		case ZPAD:
			if (getzrxinit())
				return ZERROR;
			Ascii = 0;	/* Receiver does the conversion */
			return FALSE;
		case TIMEOUT:
			zperr("Timeout on pathname");
			return TRUE;
		case WANTG:
/*
#ifdef MODE2OK
			mode(2);
#endif
*/
			Optiong = TRUE;
			blklen=1024;
		case WANTCRC:
			Crcflg = TRUE;
		case NAK:
			return FALSE;
		case CAN:
			if ((firstch = readline(20)) == CAN && Lastrx == CAN)
				return TRUE;
		default:
			break;
		}
		Lastrx = firstch;
	}
	
}


static int wctx(int flen)
{
	register int thisblklen;
	register int sectnum, attempts, firstch;
	long charssent;
	int hilf;

	charssent = 0;  firstsec=TRUE;  thisblklen = blklen;
	//vfile("wctx:file length=%ld", (long) flen);

	while ((firstch=readline(Rxtimeout))!=NAK && firstch != WANTCRC
	  && firstch != WANTG && firstch!=TIMEOUT && firstch!=CAN)
		;
	if (firstch==CAN)
	{
		zperr("Receiver Cancelled");
		return ZERROR;
	}
	if (firstch==WANTCRC)
		Crcflg=TRUE;
	if (firstch==WANTG)
		Crcflg=TRUE;
	sectnum=0;
	vfile("Sending...");
	while(!filetr_abort)
	{
		if (flen <= (charssent + 896L))
			thisblklen = 128;
		if ( !filbuf(txbuf, thisblklen))
			break;
		if (wcputsec(txbuf, ++sectnum, thisblklen)==ZERROR)
			return ZERROR;
		charssent += thisblklen;
		last_bps=((charssent*100)/timing(0));
		if (last_bps > 0)
		{
		  hilf=filesize-charssent;
		  if(hilf>21000000)
		    timeleft = (hilf/last_bps)*100;
		  else
		    timeleft = (hilf*100)/last_bps;
		}
		show_time(filetrans_window,FILETRANS_EXPECTED,timing(0),timeleft,TRUE);
		Icon_printf_Update(filetrans_window,FILETRANS_SIZE,"%d / %d",charssent,filesize);
		Icon_SetInteger_Update(filetrans_window,FILETRANS_CPS,last_bps);
		if(filesize>0)
	        Desk_Slider_SetValue(&filetrans_slider,(charssent*100)/filesize, NULL, NULL);
	}
	fclose(in);
	attempts=0;
	do
	{
		purgeline();
		sendline(EOT);
		flushmo();
		//fflush(stdout);
		++attempts;
	}
	while ((firstch=(readline(Rxtimeout)) != ACK) && attempts < RETRYMAX);
	if (attempts == RETRYMAX)
	{
		zperr("No ACK on EOT");
		return ZERROR;
	}
	else
	{
	  	filetr_finished=TRUE;
	  	vfile("Finished.");
		return OK;
	}
}

int wcputsec(char *buf,int sectnum,int cseclen) /* data length of this sector to send */
{
	register int checksum, wcj;
	register char *cp;
	unsigned oldcrc;
	int firstch;
	int attempts;
	int i;

	firstch=0;	/* part of logic to detect CAN CAN */

	//if (Verbose>1)
	//	fprintf(stderr, "\rYmodem sectors/kbytes sent: %3d/%2dk", Totsecs, Totsecs/8 );
	for (attempts=0; attempts <= RETRYMAX; attempts++)
	{
		Lastrx= firstch;
		sendline(cseclen==1024?STX:SOH);
		sendline(sectnum);
		sendline(-sectnum -1);
		oldcrc=checksum=0;
		/* hier */
		//serial_port->Write(buf,cseclen);
		//(*driver)(DRIVER_PUTBLOCK,portnumber,buf,cseclen);
		
		/*
		for(i=0;i<cseclen;i++)
		{
		  while((*driver)(DRIVER_PUTBYTE,portnumber,buf[i],0)==-1)
		    Desk_Event_Poll();
		}
		*/
		
		for (wcj=cseclen,cp=buf; --wcj>=0; )
		{
			sendline(*cp);
			oldcrc=updcrc((0377& *cp), oldcrc);
			checksum += *cp++;
		}
		if (Crcflg)
		{
			oldcrc=updcrc(0,updcrc(0,oldcrc));
			sendline((int)oldcrc>>8);
			sendline((int)oldcrc);
		}
		else
			sendline(checksum);

		flushmo();

		if (Optiong) {
			firstsec = FALSE; return OK;
		}
		firstch = readline(Rxtimeout);
gotnak:
		switch (firstch) {
		case CAN:
			if(Lastrx == CAN) {
cancan:
				zperr("Cancelled");  return ZERROR;
			}
			break;
		case TIMEOUT:
			zperr("Timeout on sector ACK"); continue;
		case WANTCRC:
			if (firstsec)
				Crcflg = TRUE;
		case NAK:
			zperr("NAK on sector"); continue;
		case ACK:
			firstsec=FALSE;
			Totsecs += (cseclen>>7);
			return OK;
		case ZERROR:
			zperr("Got burst for sector ACK"); break;
		default:
			zperr("Got %02x for sector ACK", firstch); break;
		}
		while(!filetr_abort)
		{
			Lastrx = firstch;
			if ((firstch = readline(Rxtimeout)) == TIMEOUT)
				break;
			if (firstch == NAK || firstch == WANTCRC)
				goto gotnak;
			if (firstch == CAN && Lastrx == CAN)
				goto cancan;
		}
	}
	zperr("Retry Count Exceeded");
	return ZERROR;
}

/* fill buf with count chars padding with ^Z for CPM */
int filbuf(register char *buf,int count)
{
	register int c, m;

	//Desk_Error_Report(0,"hier !!");
	if ( !Ascii)
	{
		//m = read(fileno(in), buf, count);
		m = fread(buf,1,count,in);
		if (m <= 0)
			return 0;
		while (m < count)
			buf[m++] = 032;
		return count;
	}
	m=count;
	if (Lfseen) {
		*buf++ = 012; --m; Lfseen = 0;
	}
	while ((c=getc(in))!=EOF) {
		if (c == 012) {
			*buf++ = 015;
			if (--m == 0) {
				Lfseen = TRUE; break;
			}
		}
		*buf++ =c;
		if (--m == 0)
			break;
	}
	if (m==count)
		return 0;
	else
		while (--m>=0)
			*buf++ = CPMEOF;
	return count;
}

/* Fill buffer with blklen chars */
int zfilbuf()
{
	int n;

	n = fread(txbuf, 1, blklen, in);
	if (n < blklen)
		Eofseen = 1;
	return n;
}



/*
 * Get the receiver's init parameters
 */
int getzrxinit(void)
{
	register int n;

	for (n=10; --n>=0; ) {

		switch (zgethdr(Rxhdr, 1)) {
		case ZCHALLENGE:	/* Echo receiver's challenge numbr */
			stohdr(Rxpos);
			zshhdr(ZACK, Txhdr);
			continue;
		case ZCOMMAND:		/* They didn't see out ZRQINIT */
			stohdr(0L);
			zshhdr(ZRQINIT, Txhdr);
			continue;
		case ZRINIT:
		     	//rx_check=0;
			Rxflags = 0377 & Rxhdr[ZF0];
			Rxflags2 = 0377 & Rxhdr[ZF1];
			Txfcs32 = (Wantfcs32 && (Rxflags & CANFC32));
			Zctlesc |= Rxflags & TESCCTL;
			Rxbuflen = (0377 & Rxhdr[ZP0])+((0377 & Rxhdr[ZP1])<<8);
			if ( !(Rxflags & CANFDX))
				Txwindow = 0;
			//vfile("Rxbuflen=%d Tframlen=%d", Rxbuflen, Tframlen);
/*
#ifdef MODE2OK
			mode(2);
#endif
*/

/*
#ifndef READCHECK
			if (Rxbuflen < 32 || Rxbuflen > MAX_BLOCK) {
				Rxbuflen = MAX_BLOCK;
				vfile("Rxbuflen=%d", Rxbuflen);
			}
#endif
*/
			/* Override to force shorter frame length */
			if (Rxbuflen && (Rxbuflen>Tframlen) && (Tframlen>=32))
				Rxbuflen = Tframlen;
			if ( !Rxbuflen && (Tframlen>=32) && (Tframlen<=MAX_BLOCK))
				Rxbuflen = Tframlen;
			//vfile("Rxbuflen=%d", Rxbuflen);
			//Desk_Icon_printf(unten_window,UNTEN_LSTATUS,"Rxbuflen=%d", Rxbuflen);

			/* If using a pipe for testing set lower buf len */
			/*
			fstat(iofd, &f);
			if ((f.st_mode & S_IFMT) != S_IFCHR)
			{
				Rxbuflen = MAX_BLOCK;
			}
			*/
			/*
			 * If input is not a regular file, force ACK's to
			 *  prevent running beyond the buffer limits
			 */
			/*
			if ( !Command)
			{
				fstat(fileno(in), &f);

				if ((f.st_mode & S_IFMT) != S_IFREG)
				{
					Canseek = -1;
					return ZERROR;
				}
			}
			*/
			/* Set initial subpacket length */
			if (blklen < 1024) {	/* Command line override? */
				if (Baudrate > 300)
					blklen = 256;
				if (Baudrate > 1200)
					blklen = 512;
				if (Baudrate > 2400)
					blklen = 1024;
			}
			if (Rxbuflen && blklen>Rxbuflen)
				blklen = Rxbuflen;
			if (blkopt && blklen > blkopt)
				blklen = blkopt;
			//vfile("Rxbuflen=%d blklen=%d", Rxbuflen, blklen);
			//vfile("Txwindow = %u Txwspac = %d", Txwindow, Txwspac);

			return (sendzsinit());
		case ZCAN:
		case TIMEOUT:
			return ZERROR;
		case ZRQINIT:
			if (Rxhdr[ZF0] == ZCOMMAND)
				continue;
		default:
			zshhdr(ZNAK, Txhdr);
			continue;
		}
	}
	return ZERROR;
}

/* Send send-init information */
int sendzsinit(void)
{
	register int c;

	if (Myattn[0] == '\0' && (!Zctlesc || (Rxflags & TESCCTL)))
		return OK;
	errors = 0;
	while(!filetr_abort)
	{
		stohdr(0L);
		if (Zctlesc) {
			Txhdr[ZF0] |= TESCCTL; zshhdr(ZSINIT, Txhdr);
		}
		else
			zsbhdr(ZSINIT, Txhdr);
		zsdata(Myattn, 1+strlen(Myattn), ZCRCW);
		c = zgethdr(Rxhdr, 1);
		switch (c) {
		case ZCAN:
			return ZERROR;
		case ZACK:
			return OK;
		default:
			if (++errors > 19)
				return ZERROR;
			continue;
		}
	}
}

/* Send file name and related info */
int zsendfile(char *buf,int blen)
{
	register int c;
	register unsigned long crc;

	vfile("Sending...");
	while(!filetr_abort)
	{
		Txhdr[ZF0] = Lzconv;	/* file conversion request */
		Txhdr[ZF1] = Lzmanag;	/* file management request */
		if (Lskipnocor)
			Txhdr[ZF1] |= ZMSKNOLOC;
		Txhdr[ZF2] = Lztrans;	/* file transport request */
		Txhdr[ZF3] = 0;
		zsbhdr(ZFILE, Txhdr);
		zsdata(buf, blen, ZCRCW);
again:
		c = zgethdr(Rxhdr, 1);

		switch (c)
		{
		case ZRINIT:
			while ((c = readline(50)) > 0)
				if (c == ZPAD) {
					goto again;
				}
			/* **** FALL THRU TO **** */
		default:
			continue;
		case ZCAN:
		case TIMEOUT:
		case ZABORT:
		case ZFIN:
			return ZERROR;
		case ZCRC:
			crc = 0xFFFFFFFFL;

			if (Canseek >= 0) {
				while (((c = getc(in)) != EOF) && --Rxpos)
					crc = UPDC32(c, crc);
				crc = ~crc;
				clearerr(in);	/* Clear EOF */
				fseek(in, 0L, 0);
			}
			stohdr(crc);
			zsbhdr(ZCRC, Txhdr);
			goto again;
		case ZSKIP:
			if (in)
				fclose(in);
			return c;
		case ZRPOS:
			/*
			 * Suppress zcrcw request otherwise triggered by
			 * lastyunc==bytcnt
			 */

			if (Rxpos && fseek(in, Rxpos, 0))
				return ZERROR;
			bytcnt = Txpos = Rxpos;
			Lastsync = Rxpos -1;
			return zsendfdata();
		}
		if(Desk_Time_Monotonic()-null_event_time>=5)
       		  Desk_Event_Poll();
	}
}

/* Send the data in the file */
int zsendfdata(void)
{
	register int c, e, n;
	register int newcnt;
	register long tcount = 0;
	int junkcount;		/* Counts garbage chars received by TX */
	static int tleft = 6;	/* Counter for test mode */
	long last_txpos=0;
	long not_printed=0;
	static long total_sent=0;
	int hilf;

	Lrxpos = 0;
	junkcount = 0;
	Beenhereb4 = 0;
	//my_count=0;
	//rx_check=0;

somemore:
        //printf("somemore !!!!!!\n");
	//if (setjmp(intrjmp))
	//if(!serialbufferempty())
	//if (setjmp(rxjmp))
	if(0)
	{
	  //rx_check=0;
	  //Desk_Icon_SetInteger(unten_window,UNTEN_LSTATUS,my_count++);
waitack:
		//printf("waitack\n");
		junkcount = 0;
		c = getinsync(0);
gotack:
		switch (c)
		{
		default:
		case ZCAN:
			if (in)
				fclose(in);
			return ZERROR;
		case ZSKIP:
			if (in)
				fclose(in);
			return c;
		case ZACK:
		case ZRPOS:
			break;
		case ZRINIT:
			return OK;
		}
		/*
		 * If the reverse channel can be tested for data,
		 *  this logic may be used to detect error packets
		 *  sent by the receiver, in place of setjmp/longjmp
		 *  rdchk(fdes) returns non 0 if a character is available
		 */
		while (!serialbufferempty())
		{
			switch (readline(1))
			{
			case CAN:
			case ZPAD:
				c = getinsync(1);
				goto gotack;
			case XOFF:
			case XOFF|0200:
				readline(100);
			}

		}
	}

        // signal
        //rx_check=1;
        //signal(SIGINT, onintr);

	newcnt = Rxbuflen;
	Txwcnt = 0;
	stohdr(Txpos);
	zsbhdr(ZDATA, Txhdr);

	do
	{
#ifdef NEW_ERROR
		int old=blklen;
		blklen=calc_blklen(total_sent);
		total_sent+=blklen+OVERHEAD;
		//if (blklen!=old)
		//	vfile("blklen now %ld",blklen);
#endif

		n = zfilbuf();
		if (Eofseen)
			e = ZCRCE;
		else if (junkcount > 3)
			e = ZCRCW;
		else if (bytcnt == Lastsync)
			e = ZCRCW;
		else if (Rxbuflen && (newcnt -= n) <= 0)
			e = ZCRCW;
		else if (Txwindow && (Txwcnt += n) >= Txwspac) {
			Txwcnt = 0;  e = ZCRCQ;
		}
		else
			e = ZCRCG;
		if ((not_printed > 5 || Txpos > last_bps / 2 + last_txpos))
		{
			last_bps=((Txpos*100)/timing(0));
			if (last_bps > 0)
			{
			  	hilf=filesize-Txpos;
			  	if(hilf>21000000)
				  timeleft = (hilf/last_bps)*100;
				else
				  timeleft = (hilf*100)/last_bps;
			}
			//vfile("Bytes Sent:%7ld/%7ld   BPS:%-6d",Txpos, filesize, last_bps);
			show_time(filetrans_window,FILETRANS_EXPECTED,timing(0),timeleft,TRUE);
			Icon_printf_Update(filetrans_window,FILETRANS_SIZE,"%d / %d",Txpos,filesize);
		        Icon_SetInteger_Update(filetrans_window,FILETRANS_CPS,last_bps);
		        if(filesize>0)
	                Desk_Slider_SetValue(&filetrans_slider,(Txpos*100)/filesize, NULL, NULL);
			last_txpos=Txpos;
		}
		else
		  not_printed++;
		if(Desk_Time_Monotonic()-null_event_time>=5)
       		  Desk_Event_Poll();
       		//Desk_Error_Report(0,"senddata davor: %d",serialbufferempty());
		zsdata(txbuf, n, e);
		//Desk_Error_Report(0,"senddata danach: %d",serialbufferempty());
		bytcnt = Txpos += n;
		if (e == ZCRCW)
			goto waitack;
		/*
		 * If the reverse channel can be tested for data,
		 *  this logic may be used to detect error packets
		 *  sent by the receiver, in place of setjmp/longjmp
		 *  rdchk(fdes) returns non 0 if a character is available
		 */
		//fflush(stdout);

		while (!serialbufferempty())
		{
			switch ((hilf=readline(1)))
			{
			case CAN:
			case ZPAD:
				c = getinsync(1);
				if (c == ZACK)
					break;

				zsdata(txbuf, 0, ZCRCE);
				goto gotack;
			case XOFF:
			case XOFF|0200:
				readline(100);
			default:
			//Desk_Icon_printf(unten_window,UNTEN_LSTATUS,"%d,%d",junkcount,hilf);
				++junkcount;
			}
		}

		if (Txwindow)
		{
			while ((tcount = Txpos - Lrxpos) >= Txwindow)
			{
				//vfile("%ld window >= %u", tcount, Txwindow);
				if (e != ZCRCQ)
					zsdata(txbuf, 0, e = ZCRCQ);
				c = getinsync(1);
				if (c != ZACK) {
					zsdata(txbuf, 0, ZCRCE);
					goto gotack;
				}
			}
			//vfile("window = %ld", tcount);
		}
		if(Desk_Time_Monotonic()-null_event_time>=5)
       		 Desk_Event_Poll();
	}
	while (!Eofseen && !filetr_abort);
	//signal(SIGINT, SIG_IGN);
	//rx_check=0;
	show_time(filetrans_window,FILETRANS_EXPECTED,timing(0),timeleft,TRUE);
	Icon_printf_Update(filetrans_window,FILETRANS_SIZE,"%d / %d",Txpos,filesize);
	Icon_SetInteger_Update(filetrans_window,FILETRANS_CPS,last_bps);
	if(filesize>0)
	Desk_Slider_SetValue(&filetrans_slider,Txpos*100/filesize, NULL, NULL);
	//vfile("\rBytes Sent:%7ld   BPS:%-6d                       \n",filesize,last_bps);

	while(!filetr_abort)
	{
		stohdr(Txpos);
		zsbhdr(ZEOF, Txhdr);
		switch (getinsync(0))
		{
		case ZACK:
			continue;
		case ZRPOS:
			goto somemore;
		case ZRINIT:
			return OK;
		case ZSKIP:
		     	filetr_finished=TRUE;
		     	vfile("Finished.");
			if (in)
				fclose(in);
			return c;
		default:
			//vfile("Finished.");
			if (in)
				fclose(in);
			return ZERROR;
		}
		if(Desk_Time_Monotonic()-null_event_time>=5)
       		  Desk_Event_Poll();
	}
}


#if 0
#ifdef NEW_ERROR
int calc_blklen(long total_sent)
{
	static long total_bytes=0;
	static int calcs_done=0;
	static long last_error_count=0;
	static int last_blklen=0;
	static long last_bytes_per_error=0;
	long best_bytes=0;
	long best_size=0;
	long bytes_per_error;
	long d;
	int i;
	if (total_bytes==0)
	{
		/* called from countem */
		total_bytes=total_sent;
		return 0;
	}

	/* it's not good to calc blklen too early */
	if (calcs_done++ < 5) {
		if (error_count && start_blklen >1024)
			return last_blklen=1024;
		else
			last_blklen/=2;
		return last_blklen=start_blklen;
	}

	if (!error_count) {
		/* that's fine */
		if (start_blklen==max_blklen)
			return start_blklen;
		bytes_per_error=LONG_MAX;
		goto calcit;
	}

	if (error_count!=last_error_count) {
		/* the last block was bad. shorten blocks until one block is
		 * ok. this is because very often many errors come in an
		 * short period */
		if (error_count & 2)
		{
			last_blklen/=2;
			if (last_blklen < 32)
				last_blklen = 32;
			else if (last_blklen > 512)
				last_blklen=512;

			vfile("calc_blklen: reduced to %d due to error\n",last_blklen);
			last_error_count=error_count;
			last_bytes_per_error=0; /* force recalc */
		}
		return last_blklen;
	}

	bytes_per_error=total_sent / error_count;
		/* we do not get told about every error!
		 * from my experience the value is ok */
	bytes_per_error/=2;
	/* there has to be a margin */
	if (bytes_per_error<100)
		bytes_per_error=100;

	/* be nice to the poor machine and do the complicated things not
	 * too often
	 */
	if (last_bytes_per_error>bytes_per_error)
		d=last_bytes_per_error-bytes_per_error;
	else
		d=bytes_per_error-last_bytes_per_error;
	if (d<4)
	{
		vfile("calc_blklen: returned old value %d due to low bpe diff\n",last_blklen);
		vfile("calc_blklen: old %ld, new %ld, d %ld\n",
				last_bytes_per_error,bytes_per_error,d );
		return last_blklen;
	}
	last_bytes_per_error=bytes_per_error;

calcit:
	vfile("calc_blklen: calc total_bytes=%ld, bpe=%ld\n",total_bytes,bytes_per_error);
	for (i=32;i<=max_blklen;i*=2) {
		long ok; /* some many ok blocks do we need */
		long failed; /* and that's the number of blocks not transmitted ok */
		long transmitted;
		ok=total_bytes / i + 1;
		failed=((long) i + OVERHEAD) * ok / bytes_per_error;
		transmitted=ok * ((long) i+OVERHEAD)
			+ failed * ((long) i+OVERHEAD+OVER_ERR);
		vfile("calc_blklen: blklen %d, ok %ld, failed %ld -> %ld\n",i,ok,failed,transmitted);
		if (transmitted < best_bytes || !best_bytes)
		{
			best_bytes=transmitted;
			best_size=i;
		}
	}
	if (best_size > 2*last_blklen)
		best_size=2*last_blklen;
	last_blklen=best_size;
	vfile("calc_blklen: returned %d as best\n",last_blklen);
	return last_blklen;
}
#endif
#endif



#ifdef NEW_ERROR
static int calc_blklen(long total_sent)
{
	static long total_bytes=0;
	static int calcs_done=0;
	static long last_error_count=0;
	static int last_blklen=0;
	static long last_bytes_per_error=0;
	unsigned long best_bytes=0;
	long best_size=0;
	long this_bytes_per_error;
	long d;
	int i;
	if (total_bytes==0)
	{
		/* called from countem */
		total_bytes=total_sent;
		return 0;
	}

	/* it's not good to calc blklen too early */
	if (calcs_done++ < 5) {
		if (error_count && start_blklen >1024)
			return last_blklen=1024;
		else 
			last_blklen/=2;
		return last_blklen=start_blklen;
	}

	if (!error_count) {
		/* that's fine */
		if (start_blklen==max_blklen)
			return start_blklen;
		this_bytes_per_error=LONG_MAX;
		goto calcit;
	}

	if (error_count!=last_error_count) {
		/* the last block was bad. shorten blocks until one block is
		 * ok. this is because very often many errors come in an
		 * short period */
		if (error_count & 2)
		{
			last_blklen/=2;
			if (last_blklen < 32)
				last_blklen = 32;
			else if (last_blklen > 512)
				last_blklen=512;
			//if (Verbose > 3)
			//  fprintf(stderr,"calc_blklen: reduced to %d due to error\n",last_blklen);
		}
		last_error_count=error_count;
		last_bytes_per_error=0; /* force recalc */
		return last_blklen;
	}

	this_bytes_per_error=total_sent / error_count;
		/* we do not get told about every error, because
		 * there may be more than one error per failed block.
		 * but one the other hand some errors are reported more
		 * than once: If a modem buffers more than one block we
		 * get at least two ZRPOS for the same position in case
		 * *one* block has to be resent.
		 * so don't do this:
		 * this_bytes_per_error/=2;
		 */
	/* there has to be a margin */
	if (this_bytes_per_error<100)
		this_bytes_per_error=100;

	/* be nice to the poor machine and do the complicated things not
	 * too often
	 */
	if (last_bytes_per_error>this_bytes_per_error)
		d=last_bytes_per_error-this_bytes_per_error;
	else
		d=this_bytes_per_error-last_bytes_per_error;
	if (d<4)
	{
	  	/*
		if (Verbose > 3)
		{
			fprintf(stderr,"calc_blklen: returned old value %d due to low bpe diff\n",
				last_blklen);
			fprintf(stderr,"calc_blklen: old %ld, new %ld, d %ld\n",
				last_bytes_per_error,this_bytes_per_error,d );
		}
		*/
		return last_blklen;
	}
	last_bytes_per_error=this_bytes_per_error;

calcit:
	/*
	if (Verbose > 3)
		fprintf(stderr,"calc_blklen: calc total_bytes=%ld, bpe=%ld, ec=%ld\n",
			total_bytes,this_bytes_per_error,(long) error_count);
	*/
	for (i=32;i<=max_blklen;i*=2) {
		long ok; /* some many ok blocks do we need */
		long failed; /* and that's the number of blocks not transmitted ok */
		unsigned long transmitted;
		ok=total_bytes / i + 1;
		failed=((long) i + OVERHEAD) * ok / this_bytes_per_error;
		transmitted=total_bytes + ok * OVERHEAD  
			+ failed * ((long) i+OVERHEAD+OVER_ERR);
		/*
		if (Verbose > 4)
			fprintf(stderr,"calc_blklen: blklen %d, ok %ld, failed %ld -> %lu\n",
				i,ok,failed,transmitted);
		*/
		if (transmitted < best_bytes || !best_bytes)
		{
			best_bytes=transmitted;
			best_size=i;
		}
	}
	if (best_size > 2*last_blklen)
		best_size=2*last_blklen;
	last_blklen=best_size;
	/*
	if (Verbose > 3)
		fprintf(stderr,"calc_blklen: returned %d as best\n",
			last_blklen);
	*/
	return last_blklen;
}
#endif



/*
 * Respond to receiver's complaint, get back in sync with receiver
 */
int getinsync(int flag)
{
	register int c;

	//for (;;)
	while(!filetr_abort)
	{
                //Desk_Error_Report(0,"warum?");
		c = zgethdr(Rxhdr, 0);
		switch (c)
		{
		case ZCAN:
		case ZABORT:
		case ZFIN:
		case TIMEOUT:
			return ZERROR;
		case ZRPOS:
			/* ************************************* */
			/*  If sending to a buffered modem, you  */
			/*   might send a break at this point to */
			/*   dump the modem's buffer.		 */
			//clearerr(in);	/* In case file EOF seen */

			(*driver)(DRIVER_FLUSHTX,portnumber,0,0);

			if (fseek(in, Rxpos, 0))
				return ZERROR;
			Eofseen = 0;
			bytcnt = Lrxpos = Txpos = Rxpos;
			if (Lastsync == Rxpos) {
#ifndef NEW_ERROR
				if (++Beenhereb4 > 4)
					if (blklen > 32)
					{
						blklen /= 2;
						vfile("Falldown to %d blklen",blklen);
					}
#else
				error_count++;
#endif
			}
			Lastsync = Rxpos-1;
			return c;
		case ZACK:
			Lrxpos = Rxpos;
			if (flag || Txpos == Rxpos)
				return ZACK;
			continue;
		case ZRINIT:
		case ZSKIP:
			if (in)
				fclose(in);
			filetr_finished=TRUE;
			vfile("Finished.");
			return c;
		case ZERROR:
		default:
#ifdef NEW_ERROR
				error_count++;
#endif
			zsbhdr(ZNAK, Txhdr);
			continue;
		}
	}
}


/* Say "bibi" to the receiver, try to do it cleanly */
void saybibi(void)
{
	while(!filetr_abort)
	{
		stohdr(0L);		/* CAF Was zsbhdr - minor change */
		zshhdr(ZFIN, Txhdr);	/*  to make debugging easier */
		switch (zgethdr(Rxhdr, 0)) {
		case ZFIN:
			sendline('O'); sendline('O'); flushmo();
		case ZCAN:
		case TIMEOUT:
			return;
		}
	}
}


/* Send command and related info */
int zsendcmd(char *buf,int blen)
{
	register int c;
	long cmdnum;

	//cmdnum = getpid();
	cmdnum=0;
	errors = 0;
	while(!filetr_abort)
	{
		stohdr(cmdnum);
		Txhdr[ZF0] = Cmdack1;
		zsbhdr(ZCOMMAND, Txhdr);
		zsdata(buf, blen, ZCRCW);
listen:
		Rxtimeout = 100;		/* Ten second wait for resp. */
		c = zgethdr(Rxhdr, 1);

		switch (c) {
		case ZRINIT:
			goto listen;	/* CAF 8-21-87 */
		case ZERROR:
		case TIMEOUT:
			if (++errors > Cmdtries)
				return ZERROR;
			continue;
		case ZCAN:
		case ZABORT:
		case ZFIN:
		case ZSKIP:
		case ZRPOS:
			return ZERROR;
		default:
			if (++errors > 20)
				return ZERROR;
			continue;
		case ZCOMPL:
			Exitcode = Rxpos;
			saybibi();
			return OK;
		case ZRQINIT:
			//vfile("******** RZ *******");
			system("rz");
			//vfile("******** SZ *******");
			goto listen;
		}
	}
}

/*
 * If called as lsb use YMODEM protocol
 */
/*

void chkinvok(char *s)
{
	register char *p;

	p = s;
	while (*p == '-')
		s = ++p;
	while (*p)
		if (*p++ == '/')
			s = p;
	if (*s == 'v') {
		Verbose=1; ++s;
	}
	Progname = s;
	if ((s[0]=='s' && s[1]=='b')
		|| (s[0]=='l' && s[1]=='s' && s[2]=='b')) {
		Nozmodem = TRUE; blklen=1024;
	}
	if ((s[0]=='s' && s[1]=='x')
		|| (s[0]=='l' && s[1]=='s' && s[2]=='x')) {
		Modem2 = TRUE;
	}
}

*/

void countem(/*int argc,register char ** argv*/)
{
	register int c;
	//struct stat f;
	int fsize;
	file_des *current_file;

	current_file=Desk_LinkList_FirstItem(&Files);
	//for (Totalleft = 0, Filesleft = 0; --argc >=0; ++argv)
	//{
	Totalleft = 0;
	Filesleft = 0;
	while(current_file!=NULL)
        { 
		fsize = -1;
		//vfile("Countem: %03d %s ", argc, *argv);
		if(strcmp(current_file->path,"<Wimp$Scrap>"))
		  sprintf(fullname,"%s.%s",current_file->path,current_file->name);
		else
		  strcpy(fullname,current_file->path);
		fsize=Desk_File_GetLength(fullname);
		//if(Desk_File_GetLength(fullname,&fsize)!=NULL)
		//  fsize=-1;
		//if ( access(*argv, 04) >= 0 && stat(*argv, &f) >= 0)
		if(fsize>=0)
		{
			//c = f.st_mode & S_IFMT;
			//if (c != S_IFDIR && c != S_IFBLK)
			//{
				++Filesleft;  Totalleft += fsize;
			//}
		}
		//vfile("%d",fsize);
		current_file = (file_des *) current_file->header.next;
	}
	//vfile("countem: Total %d %ld\n",Filesleft, Totalleft);
#ifdef NEW_ERROR
	calc_blklen(Totalleft);
#endif
}

