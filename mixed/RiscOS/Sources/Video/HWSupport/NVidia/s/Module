; Copyright 2008 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    Module header => NVidia.s.Module

        AREA    |!!!ModuleHeader|, CODE, READONLY, PIC


Origin
        &       0
        &       InitModule - Origin
        &       KillModule - Origin
        &       ServiceEntry - Origin
        &       ModuleTitle - Origin
        &       HelpString - Origin
        &       CommandTable - Origin
        &       0
        &       0
        &       0
        &       0
 [ International_Help <> 0
        DCD     message_filename - Origin
 |
        DCD     0
 ]
        &       ModuleFlags - Origin

ModuleTitle
        [ POST_Only
        =       "NVTest", 0
HelpString
        =       "NVTest", 9, 9, "$Module_MajorVersion ($Module_Date)"
        |
        =       "NVidia", 0
HelpString
        =       "NVidia", 9, 9, "$Module_MajorVersion ($Module_Date)"
        ]
        [       Module_MinorVersion <> ""
        =       " $Module_MinorVersion"
        ]
        ALIGN
ModuleFlags
        &       ModuleFlag_32bit
; On Tungsten, some cards get 'confused' on startup and report wrong
;  configuration information.
; For any PCI slot occupied when the ROM is programmed we store it's
;  PCI ID and default strap value here.
; Tungsten has 4 PCI slots, so up to 4 sets of info are stored
; second word is strap info, first word (of the pair) is the
; PCI device ID of the graphics card found, or -1 if none
; (this table is located after the 32bit flags to be readily found).
; Note that this table is now only used as a last resort; the preferred STRAP
; table is now in the HAL, to make compressed ROMs easier to patch during
; flashing
DefaultStraps
        DCD     -1                 ; PCI Vendor/Product ID, -1 = none
        DCD     0                  ; bus 0 slot 6 strap info
        DCD     -1
        DCD     0                  ; bus 0 slot 7
        DCD     -1
        DCD     0                  ; bus 1 slot 8
        DCD     -1
        DCD     0                  ; bus 1 slot 9

        [ Debug_Mod
errout  DCD     0
errm    =       "1234567890123456789012345678901234567890",0
        ]
        ALIGN

        ^       0,      wp                              ; Store
                                                        ; this MUST match the start of shared_info in h.DriverInterface
        Word    message_file_block, 4                   ; File handle for MessageTrans
        Word    message_file_open                       ; Opened message file flag
        Word    card_type                               ; 0 => original, 1 => new
        Word    card_post                               ; actual POR_Boot
        Word    MMIO                                    ; Pointer to control registers
        Word    FrameBufferPhys                         ; Pointer to frame buffer
        Word    FrameBufferSize                         ; reported size of frame buffer area
        Word    FBLogicalAddr                           ; frame buffer logical address
        Word    PCIHandle                               ; PCI Manager handle
        Word    PCIDevNo                                ; PCI interrupt device number
        Word    PCISlot
        Word    PCIIrqsEnabled                          ; PCI interrupts enabled
        Word    OurMode                                 ; non-zero if we're the driver
        Word    PRAMDAC
        Word    PRAMDAC2
        Word    PRAMIN
        Word    PFB
        Word    PFB2
        Word    PGRAPH
        Word    PCIO
        Word    PCIO2
        Word    PDIO
        Word    PDIO2
        Word    PVIO
        Word    CURSOR
        Word    VBLANK
        Word    VBLANKENABLE
        Word    RAMAmount                               ; Total RAM fitted
        Word    CrystalFreqKHz
	Word    psCardType;
	Word    psCardArch;
	Word    SysVcoMin;
        Word    SysVcoMax;
	Word    PixVcoMin;
	Word    PixVcoMax;
	Word    Pix2VcoMin;
	Word    Pix2VcoMax;

        Word    width                                   ; Display width
        Word    height                                  ; Display height
        Word    VWindLimit
        Word    hTotal
        Word    hHalfStart0
        Word    hHalfStart1
        Word    hStart
        Word    hEnd
        Word    hDisplay
        Word    hLineOffset0
        Word    hLineOffset1
        Word    vTotal
        Word    vStart
        Word    vEnd
        Word    vDisplay
        Word    CursordoubleScan
        Word    dotClock                                ; Ideal pixel rate
        Word    StartAddress01
        Word    StartAddress11
        Word    StartAddress02
        Word    StartAddress12
        Word    offset0
        Word    offset1
        Word    offset2
        Word    offset3
        Word    pitch0                                  ; FB line length (?)
        Word    pitch1
        Word    pitch2
        Word    pitch3
        Word    LineExtraBytes
        Word    cursor2
        Word    pllsel
        Word    config
        Word    general
        Word    vpll
        Word    Cursor2bpp                              ; -> OS' 2bpp cursor data
        Word    CursorPalette,2                         ; 16bpp cursor palette
        Word    FifoEmptyCount
        Word    FifoFreeCount
        Word    RFFTimeout
        Word    IsSolid
        Word    currentRop
        Word    Rop
        Word    Clip
        Word    Patt
        Word    Blt
        Word    Bitmap
        Word    Line
        Word    RenderAdd
        Word    PaletteCache,256                        ; local cache of the palette regs on the PCI card
        Word    CMOSAddress                             ; -1 if none
        Word    GVPixelFormats, 3*7
        Byte    instance                                ; module instance number
        Byte    GVinstance                              ; GraphicsV driver number
        Byte    DualHead                                ; dual head card in NZ
        Byte    CurrentHead                             ; 0 or 1
        Byte    syncPols
        Byte    bpp                                     ; 8, 16 or 32
        Byte    is64k                                   ; zero/nonzero if 64K colour mode
        Byte    RBSwapMode                              ; nonzero if we should red/blue swap cursor+palette
        Byte    cursor0
        Byte    cursor1
        Byte    fifo_burst
        Byte    fifo_lwm
        Byte    horiz
        Byte    pixel
        Byte    screen
        Byte    repaint0
        Byte    repaint1
        Byte    interlacestate0
        Byte    interlacestate1
        Byte    syncFrame
        Byte    CursorHeight
        Byte    pllScaleFactor
        Byte    BlankState
        Byte    CMOSSize                                ; Number of CMOS bytes available to us
        Byte    Config                                  ; CMOS settings
Config_ManualRGB * 1                                    ; RGB order specified manually
Config_Swap8bpp  * 2                                    ; Swap 8bpp modes
Config_Swap16bpp * 4                                    ; Swap 16bpp modes
Config_Swap32bpp * 8                                    ; Swap 32bpp modes
Config_CheckBit  * 16                                   ; If zero, assume CMOS invalid
Config_Alt16bpp * 32                                    ; Invert palette+cursor swap behaviour in 16bpp modes; doesn't affect which modes we advertise to the OS
Config_ValidBits * Config_ManualRGB+Config_Swap8bpp+Config_Swap16bpp+Config_Swap32bpp+Config_CheckBit+Config_Alt16bpp
        Byte    OldAemulor                              ; Nonzero if an old version of Aemulor is running
        Byte    DriverName, 32
        AlignSpace

        AlignSpace
TotalRAMRequired *      :INDEX: @

        ALIGN
        SUBT    Initialisation code
        OPT     OptPage

        [ Debug_Mod
XDebugIt_WriteC * 0x6ba82
        InsertDebugRoutines
        EXPORT  |PStr|
PStr    Push    "r1,lr"
        mov     r1,r0
1       ldrb    r0,[r1],#1
        teq     r0,#0
        Pull    "r1,pc", EQ
        bl      PChar
        b       %bt1

        EXPORT  |PReg|
PReg    Push    "r0,r1,r2,lr"
        sub     sp,sp,#16
        mov     r1,sp
        mov     r2,#16
        swi     XOS_ConvertHex8
        mov     r2,#&20
        strb    r2,[r1],#1
        mov     r2,#&0
        strb    r2,[r1],#1
        bl      PStr
        add     sp,sp,#16
        Pull    "r0,r1,r2,pc"
        EXPORT  |PChar|
PChar   Push    "lr"
;        swi     XOS_WriteC
        swi     XDebugIt_WriteC
        Pull    "pc"
        ]

TryNext Push    "r0,r1,r2,lr"
        SUB     sp, sp, #32          ; enough for module title + 5 chars min
        MOV     r1, sp
        ADR     r0, ModuleTitle
1       LDRB    r2, [r0],#1
        TEQ     r2, #0
        STRNEB  r2, [r1],#1
        BNE     %BT1                 ;
        MOV     r2, #'%'
        STRB    r2, [r1], #1
        LDRB    r2, instance
        ADD     r2, r2, #'1'
        STRB    r2, [r1], #1         ; modname%instance
        MOV     lr, #' '
        STRB    lr, [r1], #1
        STRB    r2, [r1], #1         ; modname%instance instance
        STRB    lr, [r1], #1
        LDR     r0, PCIHandle
 [ DebugModule
        BREG    r0, " try from handle: "
 ]
        mov     r2, #4
        SWI     XOS_ConvertCardinal1 ; modname%instance instance PCIHandle
        MOV     lr, #' '
        STRB    lr, [r1], #1
        MOV     r2, #0
        STRB    r2, [r1]
        MOV     r1, sp
        MOV     r0, #14
        SWI     XOS_Module
        ADD     sp, sp, #32
        Pull    "r0,r1,r2,pc"

        ENTRY
InitModule
        Push    "r7-r11,lr"

; __RelocCode is needed to maybe set up some C addresses.
; In this module we make a point of passing in the structure pointer (si)
; into any C routine.. C statics are not used.. (except perhaps in debugging)
; _RelocCode only acts if it finds the pointer(s) not pointing to the correct
; place, so we'll leave it in as a safety net.
        IMPORT  __RelocCode
        BL      __RelocCode

 [ standalone
        IMPORT  Resources
        BL      Resources
        SWI     XResourceFS_RegisterFiles               ; ignore errors
 ]
        IMPORT  |shared_info_size|
        MOV     r11, #0
        BL      |shared_info_size|
        MOV     r3, r0
;        ADD     r3, r3, r0
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        BVS     ExitInitModule
 [ DebugModule
        DREG    r2, "rma at = "
        DREG    r3, "total rma length = "
 ]
        STR     r2, [r12]
        MOV     r12, r2
        MOV     r0, #0
10      SUBS    r3, r3, #4                              ; zero the workspace
        STRPL   r0, [r12, r3]
        BPL     %BT10

        MOV     r0, #-1
        STR     r0, CMOSAddress

        MOV     r0, #10
        MOV     r1, r10
        SWI     XOS_ReadUnsigned            ; first param.. either dev id
        BVS     NoID                        ; or instance number
        MOV     r4, r2
        STRB    r4, instance
 [ DebugModule
        DREG    r4, " This instance is: "
 ]
        SWI     XOS_ReadUnsigned            ; 2nd param is card to start from,
        BVS     got_id                      ; if first is present as instance id
        MOV     r3, r2
 [ DebugModule
        DREG    r3, " start ID is: "
 ]
        B       SomeID                      ; try from here on

NoID    MOV     r3, #0

SomeID  LDR     r0, =PCI_Class_VGA
        LDR     r1, =&ffff00                ;
 [ DebugModule
        DREG    r3, " hunt from ID: "
 ]
        SWI     XPCI_FindByClass
        BVS     ExitInitModule
 [ DebugModule
        DREG    r3, " found ID: "
 ]
        TEQ     r3, #0
        BEQ     BadHardware                             ; no more video cards

; found a video card.. of interest?
        sub     sp, sp, #6*4
        mov     r1, sp
        mov     r2, #6*4
        ldr     r0, =PCI_ReadInfo_DevFn + PCI_ReadInfo_Bus + PCI_ReadInfo_Slot + PCI_ReadInfo_DeviceID + PCI_ReadInfo_CMOSAddress + PCI_ReadInfo_CMOSSize
        SWI     XPCI_ReadInfo           ; read card info
;        addvs   sp, sp, #4*4
;        BVS     ExitInitModule
        teq     r2, #6*4                ; did we get it?
        addne   sp, sp, #6*4
        bne     BadHardware
        ldmia   sp!,{r0-r2,r4-r5,r7}    ; get dev/fn and restore stack
 [ DebugModule
        DREG    r0, " DevFn : "
        DREG    r1, " Bus   : "
        DREG    r2, " slot  : "
        DREG    r4, " dev ID: "
        DREG    r5, " CMOS  : "
        DREG    r7, " ..size: "
 ]

        LDR     lr, =VendorID_NVidia
        MOV     r6, r4, lsl #16
        MOV     r6, r6, lsr #16         ; vendor only
 [ DebugModule
        DREG    lr, " V1 : "
        DREG    r6, " V2 : "
 ]
        TEQ     lr, r6
        BNE     SomeID                  ; unrecognised video card

got_id
        CMP     r7, #0
        MOVEQ   r5, #-1
        CMP     r7, #255
        MOVHI   r7, #255
        STR     r3, PCIHandle
        STR     r5, CMOSAddress
        STRB    r7, CMOSSize
        stmfd   r13!, {r0-r6,r8}

        ; check for HAL device containing STRAP info
        LDR     r0, =HALDeviceType_Video + HALDeviceVideo_VDU
        MOV     r1, #0
        MOV     r8, #4
findnv_hal
        SWI     XOS_Hardware
        BVS     findnv_modules
        CMP     r1, #-1
        BEQ     findnv_modules
        LDRH    r3,[r2,#HALDevice_ID]
        CMP     r3,#HALDeviceID_VDU_Tungsten
        BNE     findnv_hal
        LDR     lr, [r2,#HALDevice_VDUDeviceSpecificField]
        B       nvf2

findnv_modules
        mov     r0, #19                 ; enumerate rom modules
        mov     r1, #0
        mov     r2, #-1                 ; system rom
findnv  swi     XOS_Module
        adrl    r4, ModuleTitle
        mov     r5, #HelpString-ModuleTitle-1
findnv2 ldrb    r6, [r4, r5]
        ldrb    lr, [r3, r5]
        teq     lr, r6
        bne     notnv1
        subs    r5, r5, #1
        bgt     findnv2
        b       nvfound
notnv1  cmp     r1, #50                 ; MUST be within first 50 modules in ROM
        blt     findnv
        adrl    lr, DefaultStraps       ; cannot find rom stuff
        b       nvf2

nvfound add     lr, r3, #DefaultStraps-ModuleTitle; rom based ones
nvf2    ldmfd   r13!, {r0-r6,r8}
; find the rom based default strap info
 [ DebugModule
        DREG    lr, " straps at: "
 ]

        sub     r0, r0, #&30            ; first PCI slot
;        adrl    lr, DefaultStraps
        add     lr, r0, lr
        ldmia   lr, {r5, r6}            ; get strap patch info

;        SWI     XPCI_ReadID
; [ DebugModule
;        DREG    r0, "ID1 = "
; ]
;        BVS     BadHardware
 [ GeForce2Only
        mov     lr, r4, lsr #16
        teq     lr, #DeviceID_GeForce2
        LDRNE   r3, PCIHandle
        bne     SomeID
 ]



; 3 12 05 .. enforce patch if this is an nvidia card .. this'll be an issue
; if cards are swapped .. just have to use another slot to program rom
; to ignore first.
;        teq     r5, r0                  ; is it the expected card type?
;        movne   r5, #-1                 ;; no .. flag so

;  [ ForceCardType = -1
        IMPORT  |nv_identify_card|
        IMPORT  |PokeHandles|
        mov     r0, r4                  ; vendor/product ID
        Push    "r0-r12"
        MOV     r0, r12
;uint8* PokeHandles(shared_info* si)
 [ DebugModule
        DREG    r0, "cardtype1 = "
 ]
        BL      |PokeHandles|       ; give PCIHandle and Shared info base, and find where to put the ROM copy
        Pull    "r0"
        mov     r1, r12
 [ DebugModule
        DREG    r0, "cardtype1 = "
 ]
        BL      |nv_identify_card|
 [ DebugModule
        DREG    r0, "cardtype1 = "
 ]
        Pull    "r1-r12"
        TEQ     r0, #0         ; anything found:
        SETV    EQ             ; no..
;        [ Debug_Mod
;        SETV
;        ADRL    r0, errout
;        add r1,r1,#'0'
;        str r1,[r0,#4]
;        ]

        BVS     BadHardware

;  |
;        MOV     r1, #ForceCardType
;  ]
 [ DebugModule
        DREG    r1, "cardtype1a = "
 ]
        STR     r1, card_type
        MOV     r0, #0
        MOV     r1, #0
        LDR     r3, PCIHandle
        SWI     XPCI_HardwareAddress
        BVS     BadHardware
        STR     r4, MMIO
        adds    r5, r5, #1          ; is it -1

        ldr     r0, =NV32_NVSTRAPINFO2
        ldr     r5, [r4,r0]
        str     r5, card_post          ; lets see what was found
        strne   r6, [r4,r0]            ; no.. poke it in place

        MOV     r0, #1:SHL:31
        MOV     r1, #1
        SWI     XPCI_HardwareAddress
        BVS     BadHardware
        STR     r1, FrameBufferPhys
        STR     r2, FrameBufferSize
;        [ Debug_Mod
;        Pull    "pc"
;        ]
        BL      InitialiseCardAddresses
 [ :LNOT:POST_Only
        ; Generate driver name string: NVidia#PCIHandle
        ADR     r0, ModuleTitle
        ADRL    r1, DriverName
1
        LDRB    r2, [r0], #1
        CMP     r2, #0
        STRNEB  r2, [r1], #1
        BNE     %BT1
        MOV     r2, #'#'
        STRB    r2, [r1], #1
        LDR     r0, PCIHandle
        MOV     r2, #4
        SWI     XOS_ConvertCardinal1

        MOV     r0, #ScreenModeReason_RegisterDriver
        MOV     r1, #0
        ADRL    r2, DriverName
        SWI     XOS_ScreenMode                          ; get a driver number
        BVS     ExitInitModule
        STRB    r0, GVinstance

        BL      ClaimInterrupts
        BVS     BadHardware

        MOV     r0, #GraphicsV                          ; grab GraphicsV
        ADRL    r1, GraphicsV_Handler
        MOV     r2, r12
        SWI     XOS_Claim
 ]
  [ Debug_Mod
  DWriteS "About to init card\n"
        LDR     r0, card_type
  DREG    r0, "card_type = "
  ]
        BL      InitialiseCard
  [ Debug_Mod
  DWriteS "init card done\n"
  ]

  [ :LNOT:POST_Only
        BL      ReadCMOSSettings
        MOV     r0, #ScreenModeReason_StartDriver
        LDRB    r1, GVinstance
        SWI     XOS_ScreenMode                          ; let the OS know we're ready
  ]

InitModuleTryMore
        ADRL    r0, TryNext
        MOV     r1, wp
        SWI     XOS_AddCallBack
ExitInitModule
        Pull    "r7-r11,pc"

BadHardware
  [ Debug_Mod
  DWriteS "Bad Hardware "
        LDR     r1, card_type
  DREG    r1, "card_type = "
  ]
        ADR     r0, ErrorBlock_BadHard
        BL      copy_error_zero
        B       ExitInitModule

        MakeErrorBlock  BadHard
        ALIGN

KillModule
        LDR     wp, [r12]
        MOV     r6, lr
40
 [ :LNOT:POST_Only
        MOV     r0, #ScreenModeReason_StopDriver
        LDRB    r1, GVinstance
        SWI     XOS_ScreenMode                ; tell the OS we're leaving

        MOV     r0, #GraphicsV
        ADRL    r1, GraphicsV_Handler
        MOV     r2, r12
        SWI     XOS_Release

        BL      ReleaseInterrupts
 ]
        BL      UnShadowBIOS
        BL      DisableCard

 [ :LNOT:POST_Only
        MOV     r0, #ScreenModeReason_DeregisterDriver
        LDRB    r1, GVinstance
        SWI     XOS_ScreenMode
 ]

        BL      close_message_file

 [ standalone
        BL      Resources
        SWI     XResourceFS_DeregisterFiles   ; ignore errors
 ]

        CLRV
        MOV     pc, r6

ReadCMOSSettings ROUT
        ; Read and sanitise CMOS settings
        Entry   "r0-r4"
        LDRB    r3, CMOSSize
        ADD     r2, r3, #3
        BIC     r2, r2, #3
        SUB     sp, sp, r2
        LDR     r1, CMOSAddress
        CMP     r1, #-1
        BEQ     %FT05
        MOV     r0, #3 ; Read bytes
        MOV     r2, sp
        SWI     XOS_NVMemory
        BVS     %FT05
        ; At the moment we only use one byte for our settings. Check that all
        ; the others are zero.
01
        SUBS    r3, r3, #1
        LDRB    r2, [sp, r3]
        TEQNE   r2, #0
        BNE     %FT05
        TEQ     r3, #0
        BNE     %BT01
        ; Now have r2 = first byte
        ; Check for unknown bits being set
        BICS    r0, r2, #Config_ValidBits
        BNE     %FT05
        ; Check the check bit
        TST     r2, #Config_CheckBit
        BEQ     %FT05
        ; If in automatic mode, the manual setting bits should be clear
        TST     r2, #Config_ManualRGB
        BNE     %FT10
        TST     r2, #Config_Swap8bpp+Config_Swap16bpp+Config_Swap32bpp+Config_Alt16bpp
        BEQ     %FT10
05
        ; Bad CMOS config. Use defaults.
        MOV     r2, #Config_CheckBit
10
        ; If auto mode enabled, determine settings to use
        ; We assume that 8bpp & 32bpp modes will be correct and only 16bpp modes might need swapping in the OS
        TST     r2, #Config_ManualRGB
        BNE     %FT20
        ; Test if NVDAC_GENCTRL_RBSwapBit supported
        LDR     r0, PRAMDAC
        LDR     r1, [r0, #NVDAC_GENCTRL-&680000]
        ORR     r1, r1, #NVDAC_GENCTRL_RBSwapBit
        STR     r1, [r0, #NVDAC_GENCTRL-&680000]
        LDR     r1, [r0, #NVDAC_GENCTRL-&680000]
        TST     r1, #NVDAC_GENCTRL_RBSwapBit
        ORRNE   r2, r2, #Config_Swap16bpp
20
        ; Warn the OS that things are happening
        Push    "r2"
        MOV     r0, #DisplayStatus_Changing
        MOV     r1, #Service_DisplayStatus
        LDRB    r2, GVinstance
        SWI     XOS_ServiceCall
        Pull    "r2"
        ; Store new config
        STRB    r2, Config
        ; Build the pixel format list for reporting via GraphicsV
        ; See also r1 calculation in GV_DisplayFeatures, and ModeFlags
        ; validation in GV_VetMode
        ADR     r0, PixelFormats
        ADRL    r1, GVPixelFormats
        LDMIA   r0!, {r3-r4,lr} ; 8bpp
        STMIA   r1!, {r3-r4,lr}
        LDMIA   r0!, {r3-r4,lr} ; 32K
        TST     r2, #Config_Swap16bpp
        ORRNE   r4, r4, #ModeFlag_DataFormatSub_RGB
        STMIA   r1!, {r3-r4,lr}
        LDMIA   r0!, {r3-r4,lr} ; 64K
        ORRNE   r4, r4, #ModeFlag_DataFormatSub_RGB
        STMIA   r1!, {r3-r4,lr}
        LDMIA   r0!, {r3-r4,lr} ; 16M
        TST     r2, #Config_Swap32bpp
        ORRNE   r4, r4, #ModeFlag_DataFormatSub_RGB
        STMIA   r1!, {r3-r4,lr}
      [ AemulorSupport
        ; See notes in GV_PixelFormats
        LDMIA   r0!, {r3-r4,lr} ; 1bpp
        STMIA   r1!, {r3-r4,lr}
        LDMIA   r0!, {r3-r4,lr} ; 2bpp
        STMIA   r1!, {r3-r4,lr}
        LDMIA   r0!, {r3-r4,lr} ; 4bpp
        STMIA   r1!, {r3-r4,lr}
      ]
        ; Let the OS know that everything is OK
        MOV     r0, #DisplayStatus_Changed
        MOV     r1, #Service_DisplayStatus
        LDRB    r2, GVinstance
        SWI     XOS_ServiceCall

        LDRB    r3, CMOSSize
        ADD     r2, r3, #3
        BIC     r2, r2, #3
        ADD     sp, sp, r2
        EXIT

WriteCMOSSettings
        ; Write CMOS settings and update our Config variable
        ; In: r0 = new value
        ALTENTRY
        LDRB    r3, CMOSSize
        ADD     r2, r3, #3
        BIC     r2, r2, #3
        SUB     sp, sp, r2
        ; If auto mode enabled, knock out our old detection state
        TST     r0, #Config_ManualRGB
        BICEQ   r0, r0, #Config_Swap8bpp+Config_Swap16bpp+Config_Swap32bpp+Config_Alt16bpp
        ; Ensure settings count as valid
        ORR     r0, r0, #Config_CheckBit
        AND     r2, r0, #Config_ValidBits
        ; Write CMOS. We write all the bytes assigned to us, to make sure
        ; any settings left by other drivers are wiped.
        LDR     r1, CMOSAddress
        CMP     r1, #-1
        BEQ     %BT10
        STRB    r2, [sp]
        MOV     r0, #0
        MOV     lr, #1
01
        TEQ     lr, r3
        STRNEB  r0, [sp, lr]
        ADDNE   lr, lr, #1
        BNE     %BT01        
        MOV     r0, #4 ; Write bytes
        MOV     r2, sp
        SWI     XOS_NVMemory
        ; Now refresh our state
        LDRB    r2, [sp]
        B       %BT10

        ASSERT  GVPixelFormat_NColour = 0
        ASSERT  GVPixelFormat_ModeFlags = 4
        ASSERT  GVPixelFormat_Log2BPP = 8
        ASSERT  GVPixelFormat_Size = 12

PixelFormats
        DCD     255,ModeFlag_FullPalette,3
        DCD     65535,0,4
        DCD     65535,ModeFlag_64k,4
        DCD     -1,0,5
 [ AemulorSupport
        DCD     1,0,0
        DCD     3,0,1
        DCD     15,0,2
 ]

        [ :LNOT: ReleaseVersion :LAND: :LNOT: Debug_Mod
        InsertDebugRoutines
        ]

        ASSERT  Service_PreReset < Service_PCI
        ASSERT  Service_PCI < Service_ModulePostInit
        ASSERT  Service_ModulePostInit < Service_ModulePostFinal
ServiceTable
        DCD     0
        DCD     ServiceEntry2 - Origin
        DCD     Service_PreReset
        DCD     Service_PCI
      [ AemulorSupport
        DCD     Service_ModulePostInit
        DCD     Service_ModulePostFinal
      ]
        DCD     0

        DCD     ServiceTable - Origin
ServiceEntry
        MOV     r0, r0
        TEQ     r1, #Service_PreReset
        TEQNE   r1, #Service_PCI
      [ AemulorSupport
        TEQNE   r1, #Service_ModulePostInit
        TEQNE   r1, #Service_ModulePostFinal
      ]
        MOVNE   pc, lr

ServiceEntry2
        LDR     wp, [r12]
    [ AemulorSupport
        ; Has Aemulor just started or stopped?
        TEQ      r1, #Service_ModulePostInit
        TEQNE    r1, #Service_ModulePostFinal
        BNE      %FT09
        Entry    "r0,r2-r3"
        ADRL     r0, Module_Aemulor
01
        LDRB     r3, [r0], #1
        LDRB     lr, [r2], #1
        TEQ      r3, lr
        BNE      %FT08
        TEQ      r3, #0
        BNE      %BT01
        ; Our compatibility hacks are only needed with version 2.34 and below
        CMP      r4, #&23400
        CMPLE    r1, #Service_ModulePostInit
        MOVEQ    r0, #1
        MOVNE    r0, #0
        STRB     r0, OldAemulor
08
        EXIT
09
    ]
        TEQ     r1, #Service_PCI
        BNE     DisableCardLeaveVSyncs

ServicePCIHandler
        CMP     r2, #1
        MOVHI   pc, lr
        Push    "r0-r1,lr"
        SWI     XPCI_ReadID
        Pull    "r0-r1,pc",VS

        TEQ     r2, #1
        BEQ     %FT20

        ; R2 = 0 => lookup description
        Push    "r2-r12"
        MOV     r11, #0
        MOV     r1, wp
        BL      |nv_identify_card|
        Pull    "r2-r12"

        TEQ     R0, #0
        Pull    "r0-r1,pc",EQ
        MOV     R2, R0              ; any info:
        B       %FT30               ; claim it
20
        ; R2 = 1 => lookup vendor
        LDR     lr, =VendorID_NVidia
        MOV     r0, r0, LSL #16
        TEQ     r0, lr, LSL #16
        Pull    "r0-r1,pc",NE
        ADR     r2, Vendor
30
        Pull    "r0-r1,lr"
        MOV     r1, #0
        MOV     pc, lr

Vendor
        = "NVidia", 0
 [ AemulorSupport
Module_Aemulor
        = "Aemulor", 0
 ] 
        ALIGN
        LTORG

Module_BaseAddr  * Origin

CommandTable
        Command NVidia, 6, 1, Status_Keyword_Flag:OR:International_Help, NVidiaConfig
      [ TestCommand
        Command TestCmd, 11,11
      ]
        DCB     0

NVidiaConfig_Help
        = "HC", 0
NVidiaConfig_Syntax
        = "SC", 0
NVidiaConfig_Syntax2
        = "NVidia [-device <D>] -auto | -manual [-swap8bpp] [-swap16bpp] [-swap32bpp] [-alt16bpp]", 10, 13
        = 0
Option_Auto
        = " -auto", 0
Option_Manual
        = " -manual", 0
Option_Swap8bpp
        = " -swap8bpp", 0
Option_Swap16bpp
        = " -swap16bpp", 0
Option_Swap32bpp
        = " -swap32bpp", 0
Option_Alt16bpp
        = " -alt16bpp", 0
Option_String
        = "device/e,auto/s,manual/s,swap8bpp/s,swap16bpp/s,swap32bpp/s,alt16bpp/s", 0
        ALIGN

                   ^ 0
Index_Device       # 4
Index_Auto         # 4
Index_Manual       # 4
Index_Swap8bpp     # 4
Index_Swap16bpp    # 4
Index_Swap32bpp    # 4
Index_Alt16bpp     # 4
                   # 8 ; 8 bytes needed to store value of device option
Index_BufferSize   # 0

NVidiaConfig_Code ROUT
; In:   r0 = 0  => print syntax only
;       r0 = 1  => print current status
;       r0 > 1  => configure new value
;
        Entry   "r1-r8", Index_BufferSize
        LDR     r12, [r12]
        CMP     r0, #1
        BEQ     %FT10
        BHI     %FT50
        ADRL    r0, NVidiaConfig_Syntax2
        SWI     XOS_Write0
        EXIT
10
        ; Iterate through all module instances
        MOV     r0, #ModHandReason_LookupName
        ADRL    r1, ModuleTitle
        SWI     XOS_Module
        BVS     %FT99
        MOV     r8, r1
15
        MOV     r0, #ModHandReason_GetNames
        SWI     XOS_Module
        BVS     %FT99
        MOV     r6, r1
        MOV     r7, r2
        MOV     r12, r4 ; Switch to this instance
        LDRB    r5, Config
        SWI     XOS_WriteS
        DCB     "NVidia -device ", 0
        ALIGN
        LDR     r0, PCIHandle
        MOV     r1, sp
        MOV     r2, #16
        SWI     XOS_ConvertCardinal4
        SWIVC   XOS_Write0
        BVS     %FT99
        TST     r5, #Config_ManualRGB
        ADREQL  r0, Option_Auto
        ADRNEL  r0, Option_Manual
        SWI     XOS_Write0
        BVS     %FT99
        TST     r5, #Config_ManualRGB
        BEQ     %FT20
        TST     r5, #Config_Swap8bpp
        ADRNEL  r0, Option_Swap8bpp
        SWINE   XOS_Write0
        BVS     %FT99
        TST     r5, #Config_Swap16bpp
        ADRNEL  r0, Option_Swap16bpp
        SWINE   XOS_Write0
        BVS     %FT99
        TST     r5, #Config_Swap32bpp
        ADRNEL  r0, Option_Swap32bpp
        SWINE   XOS_Write0
        BVS     %FT99
        TST     r5, #Config_Alt16bpp
        ADRNEL  r0, Option_Alt16bpp
        SWINE   XOS_Write0
        BVS     %FT99
20
        SWI     XOS_NewLine
        BVS     %FT99
        ; Find the next instance
        TEQ     r6, r8
        EXIT    NE
        MOV     r1, r6
        MOV     r2, r7
        B       %BT15

50
        ; Parse the options string
        MOV     r1, r0
        ADRL    r0, Option_String
        MOV     r2, sp
        MOV     r3, #Index_BufferSize
        SWI     XOS_ReadArgs
        ; When things go wrong OS_ReadArgs returns many weird and wonderful
        ; error messages, none of which make very much sense from a user's
        ; perspective. Just return the generic 'configure option not recognised'
        ; error.
        BVS     %FT90
        ; Check syntax is valid, build new config value
        MOV     r8, #0
        LDR     r0, [sp, #Index_Auto]
        LDR     r1, [sp, #Index_Manual]
        CMP     r0, #0
        MOVNE   r0, #1
        CMP     r1, #0
        MOVNE   r1, #1
        CMP     r0, r1
        BEQ     %FT90 ; Only one of auto/manual shall be specified
        CMP     r1, #0
        MOVNE   r8, #Config_ManualRGB
        LDR     lr, [sp, #Index_Swap8bpp]
        CMP     lr, #0
        ORRNE   r8, r8, #Config_Swap8bpp
        LDR     lr, [sp, #Index_Swap16bpp]
        CMP     lr, #0
        ORRNE   r8, r8, #Config_Swap16bpp
        LDR     lr, [sp, #Index_Swap32bpp]
        CMP     lr, #0
        ORRNE   r8, r8, #Config_Swap32bpp
        LDR     lr, [sp, #Index_Alt16bpp]
        CMP     lr, #0
        ORRNE   r8, r8, #Config_Alt16bpp
        CMP     r0, #0
        TSTNE   r8, #Config_Swap8bpp+Config_Swap16bpp+Config_Swap32bpp+Config_Alt16bpp
        BNE     %FT90 ; Can't specify swap settings if in auto mode
        MOV     r7, #-1 ; Write to all cards if device not specified
        LDR     r0, [sp, #Index_Device]
        CMP     r0, #0
        BEQ     %FT55
        LDMIA   r0, {r0,r1}
        TST     r0, #255
        BNE     %FT90 ; Device isn't a number
        MOV     r1, r1, LSL #24
        ORR     r7, r1, r0, LSR #8
55
        ; Now iterate through all instances, setting config to R8 if
        ; PCIHandle=R7 or R7=-1
        MOV     r0, #ModHandReason_LookupName
        ADRL    r1, ModuleTitle
        SWI     XOS_Module
        BVS     %FT99
        MOV     r6, r1
60
        MOV     r0, #ModHandReason_GetNames
        SWI     XOS_Module
        BVS     %FT99
        MOV     r12, r4 ; Switch to this instance
        LDR     r0, PCIHandle
        CMP     r0, r7
        CMPNE   r7, #-1
        ORREQ   r8, r8, #Config_CheckBit
        MOVEQ   r0, r8
        BLEQ    WriteCMOSSettings
        ; Next instance
        CMP     r1, r6
        BEQ     %BT60
        ; Did we do anything?
        TST     r8, #Config_CheckBit
        BEQ     %FT90
        CLRV
        EXIT

90
        ; Error!
        MOV     r0, #0 ; "Configure option not recognised"
        SETV
99
        EXIT

        [ TestCommand
TestCmd_Help
        = " ",10,13
TestCmd_Syntax
        = "Syntax: TestCmd a b c d e f g h i j k l where",10,13
        = "a = desired frq Khz",10,13
        = "b = VCO min frq Khz",10,13
        = "c = VCO max frq Khz",10,13
        = "d = Discriminator min frq Khz",10,13
        = "e = Discriminator max frq Khz",10,13
        = "f = max M ",10,13
        = "g = min M ",10,13
        = "i = max P ",10,13
        = "j = min P ",10,13
        = "k = 2ndscalar ",10,13
        = "l = PLL ref frq Khz",10,13
        = 0
        ALIGN

;void nv_find_MNP( uint32 clkwanted,                        /* required frequency                  */
;                  uint32 vco_min, uint32 vco_max,          /* VCO min/max frequency               */
;                  uint32 discr_low, uint32 discr_high,     /* PLL discriminator min/max frequency */
;                  uint8 m_max, uint8 m_min,                /* Max and min M */
;                  uint8 p_max, uint8 p_min,                /* Max and min P */
;                  uint8 second_scaler, uint32 fref,        /* 2nd scaler value if not 0           */
;                  uint32 *clockgot, uint8 *m_ans,
;                  uint8 *n_ans, uint8 *p_ans)              /* answers          */
TestCmd_Code
        Push    "r0-r11,lr"
	ldr	r12, [r12]
	mov     r3, sp
	mov	r1, r0
	mov	r0, #0x8000000a
	swi	XOS_ReadUnsigned
	bvs	param_err
        Push    "r2"                      ; clkwanted
	mov	r0, #0x8000000a
	swi	XOS_ReadUnsigned
	bvs	param_err
        Push    "r2"                      ; vco_min
	mov	r0, #0x8000000a
	swi	XOS_ReadUnsigned
	bvs	param_err
        Push    "r2"                      ; vco_max
	mov	r0, #0x8000000a
	swi	XOS_ReadUnsigned
	bvs	param_err
        Push    "r2"                      ; disc_min
	mov	r0, #0x8000000a
	swi	XOS_ReadUnsigned
	bvs	param_err
        Push    "r2"                      ; disc_max
	mov	r0, #0xc000000a
	swi	XOS_ReadUnsigned
	bvs	param_err
        Push    "r2"                      ; M min
	mov	r0, #0xc000000a
	swi	XOS_ReadUnsigned
	bvs	param_err
        Push    "r2"                      ; M max
	mov	r0, #0xc000000a
	swi	XOS_ReadUnsigned
	bvs	param_err
        Push    "r2"                      ; P min
	mov	r0, #0xc000000a
	swi	XOS_ReadUnsigned
	bvs	param_err
        Push    "r2"                      ; P max
	mov	r0, #0x8000000a
	swi	XOS_ReadUnsigned
	bvs	param_err
        Push    "r2"                      ; second_scalar
	mov	r0, #0x8000000a
	swi	XOS_ReadUnsigned
	bvs	param_err
        Push    "r2"                      ; f_ref
        Pull    "r10"
        Pull    "r9"
        Pull    "r8"
        Pull    "r7"
        Pull    "r6"
        Pull    "r5"
        Pull    "r4"
        Pull    "r3"
        Pull    "r2"
        Pull    "r1"
        Pull    "r0"
        sub     sp, sp, #4*4
        add     r11, sp, #4*3
        Push    "r11"
        add     r11, sp, #4*3
        Push    "r11"
        add     r11, sp, #4*3
        Push    "r11"
        add     r11, sp, #4*3
        Push    "r11"
        Push    "r4-r10"
        bl      nv_find_MNP2
        add     sp, sp, #4*11
        Pull    "r1-r4"
        mov     r0, r1
        bl      mprintd
        mov     r0, r2
        bl      mprinth2
        mov     r0, r3
        bl      mprinth2
        mov     r0, r4
        bl      mprinth2
        Pull    "r0-r11,pc"
param_err
        mov     sp, r3
        Pull    "r0-r11,pc"

mprinth2 Push    "r0-r4,lr"
        sub     sp, sp, #32
        mov     r1, #' '
        strb    r1, [sp]
        add     r1, sp ,#1
        mov     r2, #32
        swi     XOS_ConvertHex2
        mov     r0, sp
        swi     XOS_Write0
        add     sp, sp, #32
        Pull    "r0-r4,pc"

mprinth8 Push    "r0-r4,lr"
        sub     sp, sp, #32
        mov     r1, #' '
        strb    r1, [sp]
        add     r1, sp ,#1
        mov     r2, #32
        swi     XOS_ConvertHex8
        mov     r0, sp
        swi     XOS_Write0
        add     sp, sp, #32
        Pull    "r0-r4,pc"

mprintd Push    "r0-r4,lr"
        sub     sp, sp, #32
        mov     r1, #' '
        strb    r1, [sp]
        add     r1, sp ,#1
        mov     r2, #32
        swi     XOS_ConvertCardinal4
        mov     r0, sp
        swi     XOS_Write0
        add     sp, sp, #32
        Pull    "r0-r4,pc"

mprints Push    "r0-r4,lr"
        swi     XOS_Write0

        Pull    "r0-r4,pc"
        ]

        END
