; Copyright 2008 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        EXPORT |CWriteCRTC2|
        EXPORT |CWriteCRTC|
        EXPORT |CReadCRTC2|
        EXPORT |CReadCRTC|
        EXPORT  |CWriteATTR|
        EXPORT  |CWriteATTR2|

CWriteATTR2
        STMFD  sp!,{r3,r12,lr}
        mov    r12, r2
        BL     WriteAttr2
        LDMFD  sp!,{r3,r12,pc}
CWriteATTR
        STMFD  sp!,{r3,r12,lr}
        mov    r12, r2
        BL     WriteAttr
        LDMFD  sp!,{r3,r12,pc}

CWriteCRTC2
        STMFD  sp!,{r3,r12,lr}
        mov    r12, r2
        BL     WriteCRTC2
        LDMFD  sp!,{r3,r12,pc}

CWriteCRTC
        STMFD  sp!,{r3,r12,lr}
        mov    r12, r2
        BL     WriteCRTC
        LDMFD  sp!,{r3,r12,pc}

CReadCRTC2
        STMFD  sp!,{r1,r3,r12,lr}
        mov    r12, r1
        BL     ReadCRTC2
        MOV    r0, r1
        LDMFD  sp!,{r1,r3,r12,pc}
CReadCRTC
        STMFD  sp!,{r1,r3,r12,lr}
        mov    r12, r1
        BL     ReadCRTC
        MOV    r0, r1
        LDMFD  sp!,{r1,r3,r12,pc}



WriteCRTC2
        LDR     r3, PCIO2
        B       WriteCRTC_r3
WriteCRTC
        LDRB    r3, CurrentHead
        TST     r3, #1
        LDRNE   r3, PCIO2
        LDREQ   r3, PCIO
WriteCRTC_r3
        Push    "r4,lr"
        MRS     r4, CPSR
        ORR     lr, r4, #I32_bit
        MSR     CPSR_c, lr
 [ DebugModule
        BREG    r0, "WrIndex: = "
        BREG    r1, ", "
        DREG    r3, ", "
 ]
        STRB    r0, [r3, #VGACRTCIndex]
        STRB    r1, [r3, #VGACRTCData]
        MSR     CPSR_c, r4
        Pull    "r4,pc"

ReadCRTC2
        LDR     r3, PCIO2
        B       ReadCRTC_r3
ReadCRTC
        LDRB    r3, CurrentHead
        TST     r3, #1
        LDRNE   r3, PCIO2
        LDREQ   r3, PCIO
ReadCRTC_r3
        Push    "r4,lr"
        MRS     r4, CPSR
        ORR     lr, r4, #I32_bit
        MSR     CPSR_c, lr
        STRB    r0, [r3, #VGACRTCIndex]
        LDRB    r1, [r3, #VGACRTCData]
 [ DebugModule
        BREG    r0, "RdIndex: = "
        BREG    r1, ", "
        DREG    r3, ", "
 ]
        MSR     CPSR_c, r4
        Pull    "r4,pc"

WriteSeq
        LDR     r3, PVIO
WriteSeq_r3
        Push    "r4,lr"
        MRS     r4, CPSR
        ORR     lr, r4, #I32_bit
        MSR     CPSR_c, lr
        STRB    r0, [r3, #VGASeqIndex]
        STRB    r1, [r3, #VGASeqData]
 [ DebugModule
        BREG    r0, "WrSeq: = "
        BREG    r1, ", "
 ]
        MSR     CPSR_c, r4
        Pull    "r4,pc"

ReadSeq
        LDR     r3, PVIO
ReadSeq_r3
        Push    "r4,lr"
        MRS     r4, CPSR
        ORR     lr, r4, #I32_bit
        MSR     CPSR_c, lr
        STRB    r0, [r3, #VGASeqIndex]
        LDRB    r1, [r3, #VGASeqData]
 [ DebugModule
        BREG    r0, "RdSeq: = "
        BREG    r1, ", "
 ]
        MSR     CPSR_c, r4
        Pull    "r4,pc"


WriteGr
        LDR     r3, PVIO
WriteGr_r3
        Push    "r4,lr"
        MRS     r4, CPSR
        ORR     lr, r4, #I32_bit
        MSR     CPSR_c, lr
        STRB    r0, [r3, #VGAGraphIndex]
        STRB    r1, [r3, #VGAGraphData]
 [ DebugModule
        BREG    r0, "WrGrap: = "
        BREG    r1, ", "
 ]
        MSR     CPSR_c, r4
        Pull    "r4,pc"

WriteAttr2
        LDR     r3, PCIO2
        B       WriteAttrCommon
WriteAttr
        LDRB    r3, CurrentHead
        TST     r3, #1
        LDRNE   r3, PCIO2
        LDREQ   r3, PCIO
WriteAttrCommon
        Push    "r4,lr"
        MRS     r4, CPSR
        ORR     lr, r4, #I32_bit
        MSR     CPSR_c, lr
        LDRB    lr, [r3, #VGAInStat1]            ; ensure Attr in addr mode
        TST     r0, #&20
        ORREQ   r0, r0, #&20                     ; dis -allow any palette mods
        STRB    r0, [r3, #VGAAttrIndex]
        STRB    r1, [r3, #VGAAttrDataW]
 [ DebugModule
        BREG    r0, "WrAttr: = "
        BREG    r1, ", "
 ]
        BICEQ   r0, r0, #&20                     ; re-enable if it was disabled
        MSR     CPSR_c, r4
        Pull    "r4,pc"



WriteMiscOut
        LDR     r3, PVIO
        STRB    r0, [r3, #VGAMiscOutW]
 [ DebugModule
        BREG    r0, "WrMiscOut: = "
 ]
        MOV     pc, lr

EnablePalette
        LDRB    r3, CurrentHead
        TST     r3, #1
        LDRNE   r3, PCIO2
        LDREQ   r3, PCIO
        LDRB    r0, [r3, #VGAInStat1]
        MOV     r0, #&00
        STRB    r0, [r3, #VGAAttrIndex]
        MOV     pc, lr

DisablePalette
        LDRB    r3, CurrentHead
        TST     r3, #1
        LDRNE   r3, PCIO2
        LDREQ   r3, PCIO
        LDRB    r0, [r3, #VGAInStat1]
        MOV     r0, #&20
        STRB    r0, [r3, #VGAAttrIndex]
        MOV     pc, lr

VGAUnlock
        Push    "r4,lr"
        MRS     r4, CPSR
        ORR     lr, r4, #I32_bit
        MSR     CPSR_c, lr
        LDRB    r3, CurrentHead
        TST     r3, #1
        LDRNE   r3, PCIO2
        LDREQ   r3, PCIO
        MOV     r0, #&11
        STRB    r0, [r3, #VGACRTCIndex]
        LDRB    r0, [r3, #VGACRTCData]
        BIC     r0, r0, #&80
        STRB    r0, [r3, #VGACRTCData]
        MSR     CPSR_c, r4
        Pull    "r4,pc"


NVUnlock
        MOV     r0, #NVCRTCX_LOCK
        MOV     r1, #&57
        B       WriteCRTC

; in R0 = offset from start of VRAM
;    (seems to have effective range of 32MB)
SetStartAddress
        Push    "r0,r1,r3,r4,r5,lr"
        LDRB    lr, CurrentHead
        TST     lr, #1
        STREQ   r0, StartAddress01        ; remember actual base head 0
        STRNE   r0, StartAddress11        ; remember actual base head 1
        LDREQ   r5, hLineOffset0
        LDRNE   r5, hLineOffset1
 [ DebugModule
   DREG r5,hLineOffset
 ]
        ADD     lr,r0,r5,lsl#2
        LDREQ   r5, hHalfStart0
        LDRNE   r5, hHalfStart1
;        ADD     lr,lr,r5,lsl #4
        STREQ   lr, StartAddress02        ; alt frame offset
        STRNE   lr, StartAddress12        ; alt frame offset
        B       rssa
ReSetStartAddress                        ; used with interlace
        Push    "r0,r1,r3,r4,r5,lr"
 [ DebugModule
   DREG r0
 ]
rssa    MRS     r5, CPSR                 ; needs to be aware of which head...
        ORR     lr, r5, #I32_bit
        MSR     CPSR_c, lr
        MOV     r4, r0
        MOV     r1, r0, LSR #2
        MOV     r0, #NVCRTCX_FBSTADDL
        BL      WriteCRTC
        MOV     r1, r4, LSR #10
        MOV     r0, #NVCRTCX_FBSTADDH
        BL      WriteCRTC_r3
        MOV     r0, #NVCRTCX_REPAINT0
        BL      ReadCRTC_r3
        AND     r0, r4, #&1F:SHL:18
        BIC     r1, r1, #&1F
        ORR     r1, r1, r0, LSR #18
        STRB    r1, [r3, #VGACRTCData]
        MOV     r0, #NVCRTCX_HEB
        BL      ReadCRTC_r3
        AND     r0, r4, #&60:SHL:18
        BIC     r1, r1, #&60
        ORR     r1, r1, r0, LSR #18
        STRB    r1, [r3, #VGACRTCData]
        MOV     r0, #NVATBX_HORPIXPAN
        AND     r1, r4, #3
        MOV     r1, r1, LSL #1
        BL      WriteAttr
        MSR     CPSR_c, r5
        Pull    "r0,r1,r3,r4,r5,pc"


; Out: r0-r2 undefined

InitialiseCardAddresses
        Push    "lr"

; Initialise pointers to register blocks
        LDR     r0, MMIO
        ADD     r1, r0, #&710000
        STR     r1, PRAMIN
        ADD     r1, r1, #&00F800
        STR     r1, CURSOR                  ; address of an internal cursor buffer .. beware addressing..
        ADD     r1, r0, #&600000
        ADD     r2, r1, #&000100
        STR     r2, VBLANK                  ; int status
        ADD     r2, r1, #&000140
        STR     r2, VBLANKENABLE            ; int enable
        ADD     r1, r1, #&001000
        ADD     r2, r1, #VGAHead2Offset
        STR     r1, PCIO
        STR     r2, PCIO2
        ADD     r1, r0, #&680000
        ADD     r2, r1, #VGAHead2Offset
        STR     r1, PRAMDAC
        STR     r2, PRAMDAC2
        ADD     r1, r1, #&001000
        ADD     r2, r1, #VGAHead2Offset
        STR     r1, PDIO
        STR     r2, PDIO2
        ADD     r1, r0, #&100000
        STR     r1, PFB
        ADD     r1, r0, #&400000
        STR     r1, PGRAPH
        ADD     r1, r0, #&800000
        STR     r1, Rop
        ADD     r2, r1, #&002000
        STR     r2, Clip
        ADD     r2, r1, #&004000
        STR     r2, Patt
        ADD     r2, r1, #&006000
        STR     r2, Blt
        ADD     r2, r1, #&008000
        STR     r2, Bitmap
        ADD     r2, r1, #&00A000
        STR     r2, Line
        ADD     r2, r1, #&00E000
        STR     r2, RenderAdd
        ADD     r1, r0, #&0C0000
        STR     r1, PVIO
        Pull    "pc"

InitialiseCard
        Push    "lr"
 [ :LNOT:NoPost
        BL      DoThePostThing

 ]
 [ POST_Only
        Pull    "pc"
 ]

; Check amount and speed of RAM
        IMPORT  |get_post_data|
;void get_post_data(void);
        mov     r0, r12
        BL      |get_post_data|

 [ DebugModule
        LDR     r0, CrystalFreqKHz
        DREG    r0, "Xtal freq = ",cc,Integer
        DLINE   "KHz"
        LDR     r0, RAMAmount
        MOV     r0, r0, LSR #20
        DREG    r0, "RAM size = ",cc,Integer
        DLINE   "MB"
 ]


 [ Set_Mode
; pixel_rate:78750
; h_timings:96,176,0,1024,0,16
; v_timings:3,28,0,768,0,1

; Now let's try a mode
        MOV     r0, #32
        STRB    r0, bpp
        MOV     r0, #0
        STRB    r0, is64k
        MOV     r0, #1024
        STR     r0, width
        STR     r0, hDisplay
        ADD     r0, r0, #16
        STR     r0, hStart
        ADD     r0, r0, #96
        STR     r0, hEnd
        ADD     r0, r0, #176
        STR     r0, hTotal

        MOV     r0, #768
        STR     r0, height
        STR     r0, vDisplay
        ADD     r0, r0, #1
        STR     r0, vStart
        ADD     r0, r0, #3
        STR     r0, vEnd
        ADD     r0, r0, #28
        STR     r0, vTotal

        LDR     r0, =78750
        STR     r0, dotClock
        MOV     r0, #0
        STRB    r0, syncPols

        BL      CalcStateExt

        BL      SetMode
 ]

;        BL      DoPoke

        MOV     r0, #0
        BL      SetStartAddress
        BL      EnableVSyncs

        Pull    "pc"
        LTORG


DisableCardLeaveVSyncs
        Push    "r0-r3,lr"
        BL      UnShadowBIOS
        MOV     r1, #0
        B       %FT10

DisableCard
        Push    "r0-r3,lr"
        MOV     r1, #3
10      BL      DoBlank
        BL      DisableVSyncs
;        LDR     r3, PMC
;        MOV     r0, #0
;        STR     r0, [r3, #&140]
;        LDR     r3, VBLANK
;        LDR     r0, [r3]
;        STR     r0, [r3]
;
;;        LDR     r3, VBLANKENABLE
;;        STR     r0, [r3]
;        ; ???
        Pull    "r0-r3,pc"

DisableVSyncs
        Push    "r0-r3,lr"
        MOV     r0, #0
        LDR     r3, MMIO
        STR     r0, [r3, #&140]
        LDR     r3, VBLANK
        LDR     r2, VBLANKENABLE
        STR     r0, [r3]
        LDR     r1, PCIIrqsEnabled
        BIC     r1, r1, #1
        STR     r1, PCIIrqsEnabled
        STR     r0, [r2]
        Pull    "r0-r3,pc"


SetModeFromVIDCList
        Push    "r0-r7,lr"

        LDR     r1, [r0, #VIDCList3_PixelDepth]
        CMP     r1, #4
        MOVLO   r1, #8
        MOVEQ   r1, #16
        MOVHI   r1, #32
        STRB    r1, bpp
 [ DebugModule
        DLINE   "Pixel depth  : "
        DREG    r1, " "
 ]

        MOV     r6, #0
        STRB    r6, is64k
        ldrb    r7, CurrentHead
        STR     r6, LineExtraBytes
        TST     r7, #1
        STREQB  r6, interlacestate0             ; remember in R6 too
        STRNEB  r6, interlacestate1             ; remember in R6 too
        STR     r6, CursordoubleScan
; now check the control_list
        ADD     r3, r0, #VIDCList3_ControlList
2       LDR     r1, [r3], #4
        CMN     r1, #1
        BEQ     %ft1
        LDR     r6, [r3], #4

 [ DebugModule
        DLINE   "CLPair: "
        DREG    r1, " "
        DREG    r6, ", "
 ]
        TEQ     r1, #ControlList_ModeFlags
        LDREQB  r1, bpp
        TEQEQ   r1, #16
        ASSERT  ModeFlag_64k < 256
        ANDEQ   r6, r6, #ModeFlag_64k
        STREQB  r6, is64k
        BEQ     %bt2
        TEQ     r1, #ControlList_ExtraBytes
        MOVEQ   r6, r6, lsl #21               ; effectively and &7ff
        MOVEQ   r6, r6, lsr #21               ;
        STREQ   r6, LineExtraBytes
        TEQ     r1, #ControlList_Interlaced
        BNE     %bt2
        AND     r6,r6,#1
        TST     r7, #1
        STREQB  r6, interlacestate0             ; remember in R6 too
        STRNEB  r6, interlacestate1             ; remember in R6 too
;        STR     r6,CursordoubleScan
        B       %bt2
1
        TST     r7, #1
        LDREQB  r6, interlacestate0             ; remember in R6 too
        LDRNEB  r6, interlacestate1             ; remember in R6 too
 [ DebugModule
        BREG    r6,"Interlace    : "
 ]

        LDR     r1, [r0, #VIDCList3_HorizDisplaySize]
        STR     r1, width
        STR     r1, hDisplay
 [ DebugModule
        DLINE   "H disp size  : "
        DREG    r1, " "
 ]
        LDR     r2, [r0, #VIDCList3_HorizRightBorder]
        LDR     r3, [r0, #VIDCList3_HorizFrontPorch]
 [ DebugModule
        DLINE   "H rt border  : "
        DREG    r2, " "
        DLINE   "H front porch: "
        DREG    r3, " "
 ]
        ADD     r1, r1, r2
        ADD     r1, r1, r3
        STR     r1, hStart
        LDR     r2, [r0, #VIDCList3_HorizSyncWidth]
 [ DebugModule
        DLINE   "H Sync width : "
        DREG    r2, " "
 ]
        ADD     r1, r1, r2
        STR     r1, hEnd
        LDR     r2, [r0, #VIDCList3_HorizBackPorch]
        LDR     r3, [r0, #VIDCList3_HorizLeftBorder]
 [ DebugModule
        DLINE   "H back porch : "
        DREG    r2, " "
        DLINE   "H left border: "
        DREG    r3, " "
 ]
        ADD     r1, r1, r2
        ADD     r1, r1, r3
        STR     r1, hTotal

        LDR     r1, [r0, #VIDCList3_VertiDisplaySize]
        TST     r6,#1
        ADDNE   r1,r1,r1
        STR     r1, height
        STR     r1, vDisplay
 [ DebugModule
        DLINE   "V disp size  : "
        DREG    r1, " "
 ]
        SUB     r2, r1, #1
        STR     r2, VWindLimit
 [ DebugModule
        DLINE   "VWLimit      : "
        DREG    r2, " "
 ]
        LDR     r2, [r0, #VIDCList3_VertiBottomBorder]
        LDR     r3, [r0, #VIDCList3_VertiFrontPorch]
        TST     r6,#1
        ADDNE   r2,r2,r2
        ADDNE   r3,r3,r3
 [ DebugModule
        DLINE   "V bot border : "
        DREG    r2, " "
        DLINE   "V front porch: "
        DREG    r3, " "
 ]
        ADD     r1, r1, r2
        ADD     r1, r1, r3
        STR     r1, vStart
        LDR     r2, [r0, #VIDCList3_VertiSyncWidth]
        TST     r6,#1
        ADDNE   r2,r2,r2
 [ DebugModule
        DLINE   "V Sync width : "
        DREG    r2, " "
 ]
        ADD     r1, r1, r2
        STR     r1, vEnd
        LDR     r2, [r0, #VIDCList3_VertiBackPorch]
        LDR     r3, [r0, #VIDCList3_VertiTopBorder]
        TST     r6,#1
        ADDNE   r2,r2,r2
        ADDNE   r3,r3,r3
 [ DebugModule
        DLINE   "V back porch : "
        DREG    r2, " "
        DLINE   "V top border : "
        DREG    r3, " "
 ]
        ADD     r1, r1, r2
        ADD     r1, r1, r3
        STR     r1, vTotal

        LDR     r1, [r0, #VIDCList3_PixelRate]
        STR     r1, dotClock
 [ DebugModule
        DLINE   "dot clock    : "
        DREG    r1, " "
 ]

        LDR     r1, [r0, #VIDCList3_SyncPol]
 [ DebugModule
        DLINE   "Sync Pols    : "
        DREG    r1, " "
 ]
        AND     r1, r1, #3
        MOV     r1, r1, LSL #6
        STRB    r1, syncPols

        BL      CalcStateExt
        BL      SetMode
        Pull    "r0-r7,pc"

; veneer to replace C routine
;/* compute optimum m,n,p values */
;/* all frequencies in KHz */
;void nv_find_MNP( uint32 clkwanted,                        /* required frequency                  */
;                  uint32 vco_min, uint32 vco_max,          /* VCO min/max frequency               */
;                  uint32 discr_low, uint32 discr_high,     /* PLL discriminator min/max frequency */
;                  uint8 m_max, uint8 m_min,                /* Max and min M */
;                  uint8 p_max, uint8 p_min,                /* Max and min P */
;                  uint8 second_scaler, uint32 fref,        /* 2nd scaler value if not 0           */
;                  uint32 *clockgot, uint8 *m_ans,
;                  uint8 *n_ans, uint8 *p_ans)              /* answers          */
         EXPORT   |nv_find_MNP2|
nv_find_MNP2
         Push    "r0-r12,lr"
         add     lr,sp,#(14*4)
         ldmia   lr!,{r4-r10}            ; rest of input data
         Push    "lr"
 [ DebugModule
        DREG    r0, " r0 = ",cc,Integer
        DREG    r1, " r1 = ",cc,Integer
        DREG    r2, " r2 = ",cc,Integer
        DREG    r3, " r3= ",,Integer
        DREG    r4, " r4 = ",cc,Integer
        DREG    r5, " r5 = ",cc,Integer
        DREG    r6, " r6 = ",cc,Integer
        DREG    r7, " r7= ",,Integer
        DREG    r8, " r8= ",cc,Integer
        DREG    r9, " r9 = ",cc,Integer
        DREG    r10, " r10 = ",,LongWord
 ]
         orr     r5, r6, r5, lsl #8           ; lo and hi m
         mov     lr,#0
32       tst     r8, #1
         moveq   r8,r8,lsr #1
         addeq   lr,lr,#1
         beq     %bt32
         orr     r5, r5, lr, lsl #16          ; lo p, as power of 2
         mov     lr,#0
33       tst     r7, #1
         moveq   r7,r7,lsr #1
         addeq   lr,lr,#1
         beq     %bt33
         orr     r5, r5, lr, lsl #24          ; hi p, as power of 2
         mov     r6, r9
         mov     r7, r10

;   str     r7, CrystalFreqKHz

 [ DebugModule
        DREG    r0, "want clk = ",cc,Integer
        DREG    r1, " r1 = ",cc,Integer
        DREG    r2, " r2 = ",cc,Integer
        DREG    r3, " r3 = ",cc,Integer
        DREG    r4, " r4 = ",cc,Integer
        DREG    r5, " r5 = ",cc,LongWord
        DREG    r6, " r6 = ",cc,Integer
        DREG    r7, " r7 = ",,Integer
 ]
         bl      CalcVClock1
         Pull    "lr"
         ldmia   lr,{r4-r7}            ; answer pointers
         str     r0,[r4]
         strb    r1,[r5]
         mov     r1,r1,lsr #8
         strb    r1,[r6]
         mov     r1,r1,lsr #8
         strb    r1,[r7]
         Pull    "r0-r12,pc"

; in: r0 = desired clock (kHz)
;     r1 = min vco (kHz)
;     r2 = max vco (kHz)
;     r3 = min discr freq (kHz)
;     r4 = max discr freq (kHz)
;     r5 = min M +
;          max M <<8
;          min P <<16
;          max P <<24
;     r6 = second pll scale factor, or 0 if none
;     r7 = reference clock
; out: r0 = actual clock (kHz)
;      r1 = M + N<<8 + P<<16
        EXPORT  |CalcVClock1|
CalcVClock1 ROUT
        Push    "r0-r12,lr"
Wanted  RN      0
Result  RN      0
lowM    RN      1
MNP     RN      1
highM   RN      2
DeltOld RN      3
Vco     RN      4
XFreq   RN      5
M       RN      6
N       RN      7
P       RN      8
DeltNew RN      9
highP   RN      10
tmp     RN      11
StackXtra *     (4*4)
MinVco   *      (4*1) + StackXtra
MaxVco   *      (4*2) + StackXtra
MinDiscr *      (4*3) + StackXtra
MaxDiscr *      (4*4) + StackXtra
Scale2   *      (4*6) + StackXtra
reffrq   *      (4*7) + StackXtra
; 0  extra stack space to allow temp store of best {Vco,M,N,P}
        sub     sp, sp, #StackXtra
; 1  initialise registers
        and     lowM, r5, #&ff
        and     highM, r5, #&ff00
        mov     highM, highM, lsr #8
        and     P, r5, #&ff0000
        mov     P, P, lsr #16
        mov     highP, r5, lsr #24
        ldr     XFreq, [sp, #reffrq]
        mov     DeltOld, #-1

; 2 clamp vco requested within vco range hi
        ldr     N, [sp, #MaxVco]
 [ DebugModule
   DLINE
   DREG Wanted, "Wanted: ",,Integer
   DREG N,      "VcoMax: ",,Integer
 ]
        cmp     Wanted, N
        movhi   Wanted, N

; 2 clamp vco requested within vco range lo
        ldr     N, [sp, #MinVco]
        mov     N, N, lsr highP
 [ DebugModule
   DLINE
   DREG Wanted, "Wanted: ",,Integer
   DREG N,      "VcoMin: ",,Integer
 ]
        cmp     Wanted, N
        movlo   Wanted, N

; 3 Loop for all possible values of P
Ploop   mov     Vco, Wanted, lsl P

; 3a check this Vco would be in range hi
        ldr     tmp, [sp, #MaxVco]
 [ DebugModule
   DLINE
   DREG Vco,    "Vco   : ",,Integer
   DREG Wanted, "Wanted: ",,Integer
   DREG P,      "P     : ",,Integer
   DREG tmp,    "VcoMax: ",,Integer
 ]
        cmp     Vco, tmp
        bhi     Pnext

; 3a check this Vco would be in range lo
        ldr     tmp, [sp, #MinVco]
 [ DebugModule
   DREG tmp,    "VcoMin: ",,Integer
 ]
        cmp     Vco, tmp
        blo     Pnext

; 3b allow for second pll scale factor
        ldr     tmp, [sp, #Scale2]
        teq     tmp, #0
        movne   Vco, Vco, lsr tmp       ; scale it

; 3c loop for all possible values of M
        mov     M, lowM
; [ DebugModule
;   DREG M,    "M     : ",,Integer
; ]

; 3d check this would result in PLL discriminator input that is in range
Mloop
        ldr     XFreq, [sp, #reffrq]
        mov     N, XFreq
        DivRem  lr, N, M, tmp           ; lr := XFreq/M, tmp corrupt
        ldr     tmp, [sp, #MinDiscr]
; [ DebugModule
;   DREG lr,    "discin: ",,Integer
;   DREG tmp,    "Mindisc ",,Integer
; ]
        cmp     lr, tmp
        blo     Mnext

        ldr     tmp, [sp, #MaxDiscr]
        cmp     lr, tmp
; [ DebugModule
;   DREG tmp,    "Maxdisc ",,Integer
; ]
        bhi     Mnext

; 4 compute N
        mul     N, Vco, M               ; Vco * M
        add     lr, N, XFreq, LSR #1    ; + XFreq/2
        DivRem  N, lr, XFreq, tmp       ; / XFreq
; [ DebugModule
;   DREG N,    "N     : ",,Integer
; ]

; 5 is N in valid range?
        teq     N, #0
        beq     Mnext                   ; n = 0
        cmp     N, #255                 ; range is 1 to 255 ..
        bhi     Mnext                   ; n was too large

; 6 compute resultant frequency
        mul     r12, XFreq, N           ; XFreq * N
        add     r12, r12, M, LSR #1     ; + M/2
        DivRem  lr, r12, M, tmp         ; / M
        mov     tmp, #1
        movs    tmp, tmp, lsl P
        moveq   tmp, #1
        add     lr, lr, tmp, LSR #1     ; + P/2
        DivRem  r12, lr, tmp, XFreq     ; / P

; 7 scale wanted clock if needed
        ldr     lr, [sp, #Scale2]       ; .. vco scale factor
        teq     lr, #0
        moveq   tmp, Wanted
        beq     Dl
        DivRem  tmp, Wanted, lr, DeltNew; DeltNew corrupted
Dl

; 8 compute abs (resultant clock - scaled vco) and remember settings if better
        mov     tmp, tmp, lsl P
; [ DebugModule
;   DREG r12,    "Fcalc: ",,Integer
;   DREG tmp,    "Wantd: ",,Integer
; ]
        cmp     tmp, R12
        subhi   DeltNew, tmp, R12
        rsblo   DeltNew, tmp, R12
; [ DebugModule
;   DREG DeltNew,    "Deltnew: ",,Integer
;   DREG DeltOld,    "Deltold: ",,Integer
; ]
        CMP     DeltNew, DeltOld
        stmloia sp, {Vco,M,N,P}
        movlo   DeltOld, DeltNew

Mnext   add     M, M, #1
        cmp     M, highM
        bls     Mloop

Pnext   add     P, P, #1
        cmp     P, #highP
        bls     Ploop

; 9 done the best we can. Retrieve best values
        ldr     lr, [sp, #Scale2]     ; .. vco scale factor
        ldmia   sp!, {Result,MNP,N,P,highP,tmp} ; (and recover stack space)
; 10 compensate for extra pll scale factor
        teq     lr, #0                ; valid scale factor
        movne   highP, Result
        mulne   Result, highP, lr     ; scale vco up if needed
        mov     Result, Result, LSR P ; and allow for P
; 11 merge M, N, P
        orr     MNP, MNP, N, LSL #8
        orr     MNP, MNP, P, LSL #16
;
        cmp     DeltOld, #-1          ; anything found?
        moveq   Result, #0            ; no.. flag error
 [ DebugModule
   DLINE
   DREG Result, "Returning: VCO = ",cc,Integer
   DREG MNP   , " PNM = ",,LongWord
   DLINE
 ]
        Pull    "r2-r12,pc"           ; r0-r1 stripped earlier






                        ^       0
sim_data_pclk_khz       #       4
sim_data_mclk_khz       #       4
sim_data_nvclk_khz      #       4
sim_data_memory_type    #       4
sim_data_memory_width   #       4
sim_data_mem_page_miss  #       1
sim_data_mem_latency    #       1
sim_data_enable_video   #       1
sim_data_gr_during_vid  #       1
sim_data_pix_bpp        #       1
sim_data_mem_aligned    #       1
sim_data_enable_mp      #       1
                        #       1
sim_data_sz             #       0

                        ^       0
fifo_info_graphics_lwm  #       4
fifo_info_video_lwm     #       4
fifo_info_graphics_burst_size # 4
fifo_info_video_burst_size #    4
fifo_info_valid         #       4
fifo_info_sz            #       0

CalcArbitration ROUT
; in: r0 -> fifo_info block
;     r1 -> sim_data block
; out: fifo_info filled in according to sim_data
        Push    "r0-r3,r12,lr"
        ; Call the C routine (eurch)
        BL      nv10CalcArbitration
        Pull    "r0-r3,r12,pc"

        LTORG

        GET     FromC.s

        LTORG

; in: r0 = VClk
;     r1 = bpp (8,16,32)
; out: fifo_burst and fifo_lwm filled in

UpdateArbitrationSettings ROUT
        Push    "r0-r8,lr"
        SUB     sp, sp, #fifo_info_sz + sim_data_sz
;        LDR     r3, PRAMDAC
        LDRB    r3, CurrentHead
        TST     r3, #1
        LDREQ   r3, PRAMDAC
        LDRNE   r3, PRAMDAC2
        LDR     r2, [r3, #&504]         ; r2 = MEM PLL pll
 [ DebugModule
        DREG    r2, " PNM found = ",cc,LongWord
 ]
        AND     M, r2, #&FF
        MOV     N, r2, LSR #8
        AND     N, N, #&FF
        MOV     P, r2, LSR #16
        AND     P, P, #&F
        LDR     lr, CrystalFreqKHz
        MUL     lr, N, lr
        DivRem  r2, lr, M, r4
        MOV     lr, r2, LSR P
 [ DebugModule
        DREG    lr, "MCLK = ",,Integer
 ]
        STR     lr, [sp, #sim_data_mclk_khz]
        LDR     r2, [r3, #&500]         ; r2 = CORE PLL pll
 [ DebugModule
        DREG    r2, "PNM found = ",cc,LongWord
 ]
        AND     M, r2, #&FF
        MOV     N, r2, LSR #8
        AND     N, N, #&FF
        MOV     P, r2, LSR #16
        AND     P, P, #&F
        LDR     lr, CrystalFreqKHz
        MUL     lr, N, lr
        DivRem  r2, lr, M, r4
        MOV     lr, r2, LSR P
 [ DebugModule
        DREG    lr, "NVCLK = ",,Integer
 ]
        STR     lr, [sp, #sim_data_nvclk_khz]
        LDR     r3, PFB
        LDR     r2, [r3, #&204]                   ;NV32_PFB_CONFIG_1
        STRB    r1, [sp, #sim_data_pix_bpp]
        MOV     lr, #0
        STRB    lr, [sp, #sim_data_enable_video]
        STRB    lr, [sp, #sim_data_enable_mp]
        STRB    lr, [sp, #sim_data_gr_during_vid]
        AND     lr, r2, #&F
        STRB    lr, [sp, #sim_data_mem_latency]
        MOV     lr, r2, LSR #4
        AND     lr, lr, #&F
        ADD     lr, lr, r2, LSR #31
        STRB    lr, [sp, #sim_data_mem_page_miss]
        STR     r0, [sp, #sim_data_pclk_khz]
        LDR     lr, [r3, #&200]                  ;NV32_PFB_CONFIG_0
        AND     lr, lr, #1
        STR     lr, [sp, #sim_data_memory_type]
        ADD     r3, r3, #&1000                   ;NV32_NVSTRAPINFO2
        LDR     lr, [r3]
        TST     lr, #&10
        MOVNE   lr, #128
        MOVEQ   lr, #64
        STR     lr, [sp, #sim_data_memory_width]
        MOV     lr, #1
        STRB    lr, [sp, #sim_data_mem_aligned]
        ADD     r0, sp, #sim_data_sz
        MOV     r1, sp
        BL      CalcArbitration
        LDR     r1, [r0, #fifo_info_valid]
        TEQ     r1, #0
        BEQ     %FT90
        LDR     r1, [r0, #fifo_info_graphics_burst_size]
        MOV     r1, r1, LSR #4
        MOV     r2, #0
60      MOVS    r1, r1, LSR #1
        ADDNE   r2, r2, #1
        BNE     %BT60
        LDR     r3, [r0, #fifo_info_graphics_lwm]
        MOV     r3, r3, LSR #3
        STRB    r2, fifo_burst
        STRB    r3, fifo_lwm
 [ DebugModule
        DREG    r2,"fifo_burst="
        DREG    r3,"fifo_lwm="
 ]
90
        ADD     sp, sp, #fifo_info_sz + sim_data_sz
        Pull    "r0-r8,pc"

 [ :LNOT:NoPost
DoThePostThing
        Push    "r0-r12,lr"
;        MRS     r4, CPSR
;        ORR     lr, r4, #I32_bit
;        MSR     CPSR_c, lr
;        Push    "r4"
        LDR     r3, PCIHandle
        MOV     r0, #&4c
        MOV     r2, #4
        MOV     r1, #0                 ; force PCI (not AGP) mode
        SWI     XPCI_ConfigurationWrite

        MOV     r0, #0
        MOV     r1, #&1                ; FB  space physical address
        SWI     XPCI_HardwareAddress

        STR     r4, FBLogicalAddr      ; FB logical permanently mapped in
        MOV     r0, r12
;uint8* PokeHandles(void* si)
        IMPORT  |PokeHandles|
        BL      |PokeHandles|       ; find where to put the ROM copy
        MOV     r1, r0
        LDR     r0, MMIO
        LDR     r2, PCIHandle
 [ DebugModule
        DLINE     "about to copy ROM "
 ]
; void CopyRom(uint32 RegBase, uint8* copyaddr, uint32 PCIHandle);
        BL      CopyRom

 [ DebugModule
        DLINE     "ROMcopied "
 ]
        ldmfd   r13,{r0-r12,lr}
        MOV     r11, #0
        mov     r0, r12
        IMPORT  |nv_general_powerup|
        BL      |nv_general_powerup|

;; select 1 == true puts analogue of primary head on dvii connector
;; select 0 == false puts analogue of primary head on vga connector
;        ldmfd   r13,{r0-r12,lr}
;        MOV     r11, #0
;;        MOV     r1, #1                       ; turn on ext dvi driver
;;        MOV     r0, #NVCRTCX_0x59
;;        BL      WriteCRTC
;;        MOV     r1, #1
;;        MOV     r0, #NVCRTCX_0x59
;;        BL      WriteCRTC2
;        mov r0, #0
;        mov     r1, r12
;        IMPORT  |nv_general_output_select|
;        BL      |nv_general_output_select|
;
;; head select .. rest of driver needs to be 'selected head' sensitive too
;        ldmfd   r13,{r0-r12,lr}
;        MOV     r11, #0
;        mov r0, #00
;        mov     r1, r12
;        IMPORT  |nv_general_head_select|
;        BL      |nv_general_head_select|
;

 [ DebugModule
        DLINE    "Post done "
 ]
;        ldmfd   r13,{r0-r12,lr}
;        MOV     r11, #0
;        LDR     a1, MMIO
;        LDR     a2, card_type
;        ADR     a3, card_post
;        BL      PostDevice
        Pull    "r0-r12,pc"

; uint32 RdCfg(uint8 add, uint32 c_pcihandle)
        EXPORT  |RdCfg|
RdCfg   stmfd   r13!, {r1-r3,lr}
        MOV     r3, r1
        MOV     r2, #4
        SWI     XPCI_ConfigurationRead
        MOVVC   r0, r1
        LDMFD   r13!, {r1-r3,pc}
; void WrCfg(uint8 add, uint32 c_pcihandle, uint32 value)
        EXPORT  |WrCfg|
WrCfg   stmfd   r13!, {r0-r3,lr}
        MOV     r3, r1
        MOV     r1, r2
        MOV     r2, #4
        SWI     XPCI_ConfigurationWrite
        LDMFD   r13!, {r0-r3,pc}

        EXPORT  |CopyRom|
; void CopyRom(uint32 RegBase, uint8* copyaddr, uint32 PCIHandle);
CopyRom Push    "r0-r3,lr"
        MOV     r3, r2                ; PCIHandle
        BL      UnShadowBIOS          ; in case
        MOV     r0, #&30
        MOV     r2, #4
        SWI     XPCI_ConfigurationRead; get rom map address
        ORR     r1, r1, #1            ; set map in bit
        SWI     XPCI_ConfigurationWrite
        MOV     r0, #1:SHL:31
        MOV     r1, #&100             ; rom space physical address
        SWI     XPCI_HardwareAddress
        MOV     r0, #14
        ORR     r0, r0, #&100         ; bufferable
 [ DebugModule
        DREG    r1, "copy ROM0 "
 ]
        SWI     XOS_Memory            ; map in 1MB phys addr R1 (logical -> R2)
 [ DebugModule
        DLINE     "copy ROM1 "
 ]
        Push    "r3"

        LDR     r1, [sp,#(4*1)+(4*1)] ; copyaddr
        MOV     r0, #0
 [ DebugModule
        DREG    r1, "copy dest ROMr1 "
        DREG    r2, "copy src  ROMr2 "
 ]
10      LDR     r3, [r2, r0]
        STR     r3, [r1, r0]
        ADD     r0, r0, #4
        CMP     r0, #&10000
        BLT     %bt10
        MOV     r0, #15
        Pull    "r1"
        SWI     XOS_Memory            ; release the mapped in rom space
 [ DebugModule
        DLINE     "copy ROM2 "
 ]

        LDR     r3, [sp,#(4*1)+(4*1)] ; PCIHandle
 [ DebugModule
        DREG    r3, "copy ROM2 "
 ]
        MOV     r0, #&30
        MOV     r2, #4
        SWI     XPCI_ConfigurationRead; get rom map address
        BIC     r1, r1, #1            ; clr map in bit
        SWI     XPCI_ConfigurationWrite
        LDR     r0, [sp]
        ADD     r1,r0,#&1000
        LDR     r0,[r1,#&850]
        MOV     r2,#1                 ; shadow the BIOS
        ORR     r0,r0,r2
        STR     r0,[r1,#&850]!
        Pull    "r0-r3,pc"
 ]
UnShadowBIOS
        Push    "r0-r2,lr"
        LDR     r0, MMIO
        ADD     r1,r0,#&1000
        LDR     r0,[r1,#&850]
        MVN     r2,#1
        AND     r0,r0,r2
        STR     r0,[r1,#&850]!
        Pull    "r0-r2,pc"


        EXPORT  |MicroDelay|
        EXPORT  |Delay|
MicroDelay ROUT
        Push    "r0-r3,r8,r9,lr"
        MOV     lr, #1
        B       %FT10
Delay
        Push    "r0-r3,r8,r9,lr"
        LDR     lr, =1000
10
        MOV     r8, #0
        MOV     r9, #EntryNo_HAL_CounterDelay
        MUL     r0, lr, r0
        SWI     XOS_Hardware
        Pull    "r0-r3,r8,r9,pc"


; in: must have already set up
;     bpp, width, height
;     hDisplay, hStart, hEnd, hTotal
;     vDisplay, vStart, vEnd, vTotal
;     CursordoubleScan, dotClock
CalcStateExt
        Push    "r0-r8,lr"
        LDRB    r8, CurrentHead
        LDR     r0, dotClock
 [ DebugModule
        DREG    r0, "Desired clock = ",,Integer
 ]
        MOV     r5, #14<<8              ; determine max M  (not NV28)
        ORR     r5, r5, #7              ; set min M
;        ORR     r5, r5, #0 <<16         ; set min P
        ORR     r5, r5, #32 <<24        ; set max P
        TEQ     r1, #NV36
        LDREQ   r3, =3200               ; min discrim freq NV36
        LDRNE   r3, =1000               ; min discrim freq otherwise
        LDREQ   r4, =6400               ; max discrim freq
        LDRNE   r4, =2000               ; max discrim freq
        LDR     r1, PixVcoMin
        LDR     r2, PixVcoMax
        LDRB    r6, pllScaleFactor
        LDR     r7, CrystalFreqKHz
        BL      CalcVClock1
 [ DebugModule
        DREG    r0, "Actual clock = ",,Integer
        DREG    r1, "PNM=",cc,LongWord
 ]

        STR     r1, vpll

        LDRB    r1, bpp
        MOV     r4, r1, LSR #3          ; r4 = pixelDepth

;        MOV     r1, r4, LSL #3
        BL      UpdateArbitrationSettings

        MOV     r0, #0
        STRB    r0, cursor0
        STR     r0, cursor2
        LDR     lr, CursordoubleScan
        MOV     r0, #&FC
        TEQ     lr, #0
        ORRNE   r0, r0, #2
;        ORR   r0, r0, #2
        STRB    r0, cursor1
        LDRB    r0, DualHead
        teq     r0, #0
        LDRNE   r0, =&10000700
        LDREQ   r0, =&30000f00
        STR     r0, pllsel
        LDR     r3, PFB
        LDR     r0, [r3, #&200]            ; NV32_PFB_CONFIG_0
        STR     r0, config
        LDRB    lr, bpp
        LDR     r0, =&00100100
        TEQ     lr, #8
        ORRNE   r0, r0, #&30       ; indirect mode via pallette if 16 or 32bpp
        LDRB    lr, is64k
        TEQ     lr, #0
        ORRNE   r0, r0, #&1000     ; enable 16bpp 565 mode
        STR     r0, general
        LDR     r0, hDisplay
        CMP     r0, #1280
        MOVLO   r0, #4
        MOVHS   r0, #0
        STRB    r0, repaint1

        LDR     r0, hStart
        MOV     r0, r0, LSR #3
        MOV     r0, r0, LSL #1
        LDR     lr, hTotal
        MOV     lr, lr, LSR #3
        SUB     lr, lr, #5
        CMP     r0, lr
        ADD     lr, lr, #5
        SUBGT   lr, r0, lr
        ADDLE   lr, r0, lr
        MOV     lr, lr, LSR #1
        tst     r8, #1
        STREQ   lr, hHalfStart0
        STRNE   lr, hHalfStart1

        LDR     lr, hTotal
        MOV     lr, lr, LSR #3
        SUB     lr, lr, #1
        AND     lr, lr, #&40
        MOV     r0, lr, LSR #2
        LDR     lr, vDisplay
        SUB     lr, lr, #1
        AND     lr, lr, #&400
        ORR     r0, r0, lr, LSR #7
        LDR     lr, vStart
        SUB     lr, lr, #1
        AND     lr, lr, #&400
        ORR     r0, r0, lr, LSR #8
        LDR     lr, vDisplay ; ???? End???
        SUB     lr, lr, #1
        AND     lr, lr, #&400
        ORR     r0, r0, lr, LSR #9
        LDR     lr, vTotal
        SUB     lr, lr, #2
        AND     lr, lr, #&400
        ORR     r0, r0, lr, LSR #10
        STRB    r0, screen

        LDR     r0, width
        LDR     lr, LineExtraBytes
        MLA     r0, r4, r0 ,lr
        TST     r8, #1
        LDREQB  r2, interlacestate0
        LDRNEB  r2, interlacestate1
        TST     r2, #1
        ADDNE   r0, r0, r0              ; double line offset if interlace
        STR     r0, pitch0
        STR     r0, pitch1
        STR     r0, pitch2
        STR     r0, pitch3
        MOV     r0, r0, LSR #3          ; nvidia needs pitch/8
        tst     r8, #1
        STREQ   r0, hLineOffset0
        STRNE   r0, hLineOffset1
        AND     r0, r0, #&700
        MOV     r0, r0, LSR #3
        STRB    r0, repaint0

        LDR     lr, hTotal
        MOV     lr, lr, LSR #3
        SUB     lr, lr, #5
        AND     r0, lr, #&100
        MOV     r0, r0, LSR #8
        LDR     r1, hDisplay
        MOV     r1, r1, LSR #3
        SUB     r1, r1, #1
        AND     r1, r1, #&100
        ORR     r0, r0, r1, LSR #7
        ORR     r0, r0, r1, LSR #6
        LDR     r1, hStart
        MOV     r1, r1, LSR #3
        SUB     r1, r1, #1
        AND     r1, r1, #&100
        ORR     r0, r0, r1, LSR #5

; interlace half field start has a top bit at CR2D bit 4 .. but as it is
; set to 1/2 hTotal, and hTotal has only 1 hi bit, we'll leave it 0 here
        TST     r8, #1
        LDREQB  r1, interlacestate0
        LDRNEB  r1, interlacestate1
        TST     r1, #1
        beq     %ft01
        tst     r8, #1
        LDREQ   lr, hHalfStart0
        LDRNE   lr, hHalfStart1
        AND     lr,lr,#&100
        ORR     r0,r0,lr,LSR #4

01      STRB    r0, horiz

        CMP     r4, #2               ; r4 = bpp (8,16,32) >> 3 i.e. 1,2,4
        MOVHI   r0, #3
        MOVLS   r0, r4
        STRB    r0, pixel

        MOV     r0, #0
        STR     r0, offset0
        STR     r0, offset1
        STR     r0, offset2
        STR     r0, offset3


        Pull    "r0-r8,pc"

        LTORG

; Corrupts r0-r3,lr
        MACRO
        LoadFixedAddr $register,$name,$suffix
        ADRL    r0, Table$name$suffix
 [ Table$name$suffix._end - Table$name$suffix < &400
        ADD     r1, r0, #Table$name$suffix._end - Table$name$suffix
 |
        ADRL    r1, Table$name$suffix._end
 ]
        LDR     r2, MMIO
10      LDMIA   r0!, {r3}
        TEQ     r0, r1
        STR     $register, [r2, r3]
        BNE     %BT10
        MEND

; Corrupts r0-r3,lr
        MACRO
        LoadFixedState $name,$suffix
        ADRL    r0, Table$name$suffix
 [ Table$name$suffix._end - Table$name$suffix < &400
        ADD     r1, r0, #Table$name$suffix._end - Table$name$suffix
 |
        ADRL    r1, Table$name$suffix._end
 ]
        LDR     r2, MMIO
10      LDMIA   r0!, {r3, lr}
        TEQ     r0, r1
        STR     lr, [r2, r3]
        BNE     %BT10
        MEND

PowerCycleEngine
        Push    "r0-r4,lr"
        ADRL    r4, TablePMC
        LDR     r2, MMIO
        LDMIA   r4!, {r3, lr}
        STR     lr, [r2, r3]
        MOV     r0, #1                ; 1ms delay
        BL      Delay
        LDMIA   r4!, {r3, lr}
        STR     lr, [r2, r3]
        Pull    "r0-r4,pc"


SetMode
        Push    "r0-r6,lr"
        BL      DisableVSyncs            ; go 'offline' for now
 [ DebugModule
        DLINE   "SetMode"
 ]

        BL      VGAUnlock
        BL      NVUnlock

 [ DebugModule
        DLINE   "Unlocked"
 ]
        LDRB    r6, CurrentHead          ; get current head state
        LDRB    r0, syncPols
        ORR     r0, r0, #&2D
        BL      WriteMiscOut

        LDR     r3, PVIO
        MOV     r0, #1
        STRB    r0, [r3, #VGAEnable]


        MOV     r0, #NVSEQX_RESET
        MOV     r1, #0
        BL      WriteSeq

 [ DebugModule
        DLINE   "Writing sequencer"
 ]

        MOV     r0, #NVSEQX_RESET
        MOV     r1, #1
        BL      WriteSeq
        MOV     r0, #NVSEQX_RESET
        MOV     r1, #3
        BL      WriteSeq
        MOV     r0, #NVSEQX_CLKMODE
        MOV     r1, #&01
        BL      WriteSeq
        MOV     r0, #2
        MOV     r1, #&0F
        BL      WriteSeq
        MOV     r0, #3
        MOV     r1, #0
        BL      WriteSeq
        MOV     r0, #NVSEQX_MEMMODE
        MOV     r1, #&0E
        BL      WriteSeq

 [ DebugModule
        DLINE   "Writing CRTC"
 ]

        MOV     r0, #NVCRTCX_HTOTAL
        LDR     r1, hTotal
        MOV     r1, r1, LSR #3
        SUB     r1, r1, #5
        BL      WriteCRTC

        TST     r6, #1
        LDREQB  r0, interlacestate0
        LDRNEB  r0, interlacestate1
        TST     r0,#1
        MOVEQ   r1,#&ff              ; interlace off
        beq     %ft01
        tst     r6, #1
        LDREQB  r1,hHalfStart0
        LDRNEB  r1,hHalfStart1
01      MOV     r0, #NVCRTCX_INTERLACE
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_HDISPE
        LDR     r1, hDisplay
        MOV     r1, r1, LSR #3
        SUB     r1, r1, #1
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_HBLANKS
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_HBLANKE
        LDR     r1, hTotal
        MOV     r1, r1, LSR #3
        SUB     r2, r1, #1
        AND     r1, r2, #&1F    ; r2 holds hblank end
        ORR     r1, r1, #&80
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_HSYNCS
        LDR     r1, hStart
        MOV     r1, r1, LSR #3
        SUB     r1, r1, #1
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_HSYNCE
        AND     r1, r2, #&20    ; recover bit 5 of hblank end
        MOV     r1, r1, LSL #2
        LDR     r2, hEnd
        MOV     r2, r2, LSR #3
        SUB     r2, r2, #1
        AND     r2, r2, #&1F
        ORR     r1, r1, r2
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_VTOTAL
        LDR     r1, vTotal
        SUB     r1, r1, #2
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_OVERFLOW
        LDR     lr, vDisplay
        SUB     lr, lr, #1
        AND     r2, lr, #&100
        AND     r3, lr, #&200
        MOV     r1, r2, LSR #7          ; vdisplay bit 8 => bit 1
        ORR     r1, r1, r2, LSR #5      ; vdisplay bit 8 => bit 3
        ORR     r1, r1, r3, LSR #3      ; vdisplay bit 9 => bit 6
        LDR     lr, vTotal
        SUB     lr, lr, #2
        AND     r2, lr, #&100
        AND     r3, lr, #&200
        ORR     r1, r1, r2, LSR #8      ; vtotal bit 8 => bit 0
        ORR     r1, r1, r3, LSR #4      ; vtotal bit 9 => bit 5
        LDR     lr, vStart
        SUB     lr, lr, #1
        AND     r2, lr, #&100
        AND     r3, lr, #&200
        ORR     r1, r1, r2, LSR #6      ; vstart bit 8 => bit 2
        ORR     r1, r1, r3, LSR #2      ; vstart bit 9 => bit 7
        ORR     r1, r1, #&10
        BL      WriteCRTC

        MOV     r0, #NVCRTCX_MAXSCLIN
        LDR     lr, vDisplay
        SUB     lr, lr, #1
        AND     r3, lr, #&200
        MOV     r1, r3, LSR #4
        ORR     r1, r1, #&40
        LDR     lr, CursordoubleScan
        TEQ     lr, #0
        ORRNE   r1, r1, #&80
        BL      WriteCRTC

        MOV     r0, #NVCRTCX_VSYNCS
        LDR     r1, vStart
        SUB     r1, r1, #1
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_VSYNCE
        LDR     r1, vEnd
        SUB     r1, r1, #1
        AND     r1, r1, #&0F
        ORR     r1, r1, #&20
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_VDISPE
        LDR     r1, vDisplay
        SUB     r1, r1, #1
        BL      WriteCRTC_r3

        tst     r6, #1
        LDREQB  r1,hLineOffset0
        LDRNEB  r1,hLineOffset1
        MOV     r0, #NVCRTCX_PITCHL
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_VBLANKS
        LDR     r1, vDisplay
        SUB     r1, r1, #1
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_VBLANKE
        LDR     r1, vTotal
        SUB     r1, r1, #1
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_MODECTL
        MOV     r1, #&E3
        BL      WriteCRTC_r3

        MOV     r0, #NVCRTCX_LINECOMP
        MOV     r1, #&FF
        BL      WriteCRTC_r3

 [ DebugModule
        DLINE   "Writing Graphics"
 ]

        MOV     r0, #0
        MOV     r1, #0
        BL      WriteGr
        MOV     r0, #NVGRPHX_ENSETRESET
        MOV     r1, #0
        BL      WriteGr
        MOV     r0, #2
        MOV     r1, #0
        BL      WriteGr
        MOV     r0, #NVGRPHX_DATAROTATE
        MOV     r1, #0x0
        BL      WriteGr
        MOV     r0, #NVGRPHX_READMAPSEL
        MOV     r1, #0
        BL      WriteGr
        MOV     r0, #NVGRPHX_MODE
        MOV     r1, #&40
        BL      WriteGr
        MOV     r0, #NVGRPHX_MISC
        MOV     r1, #&05
        BL      WriteGr
        MOV     r0, #7
        MOV     r1, #&0F
        BL      WriteGr
        MOV     r0, #NVGRPHX_BITMASK
        MOV     r1, #&FF
        BL      WriteGr

 [ DebugModule
        DLINE   "Writing Attributes"
 ]

        MOV     r0, #0
30      MOV     r1, r0
        BL      WriteAttr                      ; clear bottom 16 ATTR regs
        ADD     r0, r0, #1
        CMP     r0, #16
        BLO     %BT30

        ; r0 = 16 = NVATBX_MODECTL
        MOV     r1, #&41
        BL      WriteAttr
        MOV     r0, #NVATBX_COLPLANE_EN
        MOV     r1, #&0F
        BL      WriteAttr
        MOV     r0, #NVATBX_HORPIXPAN
        MOV     r1, #&00
        BL      WriteAttr
        MOV     r0, #NVATBX_COLSEL
        MOV     r1, #&00
        BL      WriteAttr

        LDRB    r0, bpp
        TEQ     r0, #8
        BEQ     %FT45

 [ DebugModule
        DLINE   "Writing palette"
 ]

        BL      EnablePalette

;        LDR     r3, PDIO
        LDRB    r3, CurrentHead
        TST     r3, #1
        LDREQ   r3, PDIO
        LDRNE   r3, PDIO2
        MOV     r1, #&FF
        STRB    r1, [r3, #VGADACMask]

        MOV     r1, #0
        STRB    r1, [r3, #VGADACWriteAddr]
        MOV     lr, #0
40      STRB    lr, [r3, #VGADACData]
        STRB    lr, [r3, #VGADACData]
        STRB    lr, [r3, #VGADACData]
        ADD     lr, lr, #1
        CMP     lr, #256
        BLO     %BT40

        BL      DisablePalette

45
 [ DebugModule
        DLINE    "Writing extra NVidia stuff"
 ]

        BL      PowerCycleEngine
        LoadFixedState PTIMER
        LoadFixedState PFIFO

        LDR     r1, PRAMIN                  ; clear the PRAMIN hash table
        MOV     r2, #255
        MOV     r0, #0
46      STR     r0, [r1, r2, LSL #2]
        SUBS    r2, r2, #1
        BGE     %bt46

        LDR     r2, psCardArch
        CMP     r2, #NV40A
        BGE     %ft461

        LoadFixedState PRAMIN1_nv10
        LoadFixedState PRAMIN2_nv10
        B       %ft462
461
        LoadFixedState PRAMIN1_nv40
        LoadFixedState PRAMIN2_nv40
462
        LoadFixedState PGRAPH

        LDR     r2, psCardArch
        LDRB    r0, bpp
        TEQ     r0, #16
        BEQ     %FT15
        TEQ     r0, #32
        BEQ     %FT32

8       CMP     r2, #NV30A
        BGE     %ft830
        LoadFixedState NV10,_8BPP
        B       %FT35
830     CMP     r2, #NV40A
        BGE     %ft840
        LoadFixedState NV30,_8BPP
        B       %FT35
840
        LoadFixedState NV40,_8BPP
        B       %FT35

15      LDRB    r14, is64k
        TEQ     r14, #0
        BNE     %FT16
        CMP     r2, #NV30A
        BGE     %ft1530
        LoadFixedState NV10,_15BPP
        B       %FT35
1530
        LoadFixedState NV30,_15BPP
        B       %FT35

16      CMP     r2, #NV04A
        BEQ     %FT1604
        CMP     r2, #NV30A
        BGE     %FT1630
        LoadFixedState NV10,_16BPP
        B       %FT35
1604
        LoadFixedState NV04A,_16BPP
        B       %FT35
1630
        LoadFixedState NV30,_16BPP
        B       %FT35                

32      CMP     r2, #NV30A
        BGE     %ft3230
        LoadFixedState NV10,_32BPP
        B       %FT35
3230
        LoadFixedState NV30,_32BPP

35
        LDR     r4, FrameBufferSize      ; set up all that needs to know ram top
        SUB     r4, r4, #1
        LoadFixedAddr R4, RAMLIMIT
        LDR     r2, psCardArch
        CMP     r2, #NV20A
        BLT     %ft41
        LDR     r2, psCardType
        CMP     r2, #NV40
        BLE     %ft33
        TEQ     r2, #NV45
        BEQ     %ft33
        LoadFixedAddr R4, RAMLIMIT_nv40
        B       %ft41
33      CMP     r2, #NV40
        BGE     %ft34
        LoadFixedAddr R4, RAMLIMIT_nv20
34
        LoadFixedAddr R4, RAMLIMIT_nv45
41

        LDR     r2, psCardArch
        CMP     r2, #NV30A
        BLT     %ft42
        LDR     r3, PGRAPH
        LDR     r2, [r3, #NVACC_DEBUG3-&400000]
        ORR     r2, r2, #1
        STR     r2, [r3, #NVACC_DEBUG3-&400000]
        LDR     r2, [r3, #NVACC_NV25_WHAT1-&400000]
        ORR     r2, r2, #&00040000
        STR     r2, [r3, #NVACC_NV25_WHAT1-&400000]

42
        LDR     r3, PGRAPH
        LDR     r0, psCardArch
        CMP     r0, #NV20A
        bge     %ft421

        LDR     r0, offset0                        ;2D destination buffer offset
        STR     r0, [r3, #NVACC_OFFSET0-&400000]   ; (location of active screen in FB)
        LDR     r0, offset1                        ; 2D source buffer offset
        STR     r0, [r3, #NVACC_OFFSET1-&400000]
        LDR     r0, offset2                        ; 3D color buffer offset
        STR     r0, [r3, #NVACC_OFFSET2-&400000]
        LDR     r0, offset3                        ; 3D depth buffer offset
        STR     r0, [r3, #NVACC_OFFSET2-&400000]
        LDR     r0, pitch0                         ; 2D destination buffer pitch
        STR     r0, [r3, #NVACC_PITCH0-&400000]
        LDR     r0, pitch1                         ; 2D source buffer pitch
        STR     r0, [r3, #NVACC_PITCH1-&400000]
        LDR     r0, pitch2                         ; 3D color buffer pitch
        STR     r0, [r3, #NVACC_PITCH2-&400000]
        LDR     r0, pitch3                         ; 3D depth buffer pitch
        STR     r0, [r3, #NVACC_PITCH3-&400000]
        STR     r0, [r3, #NVACC_PITCH4-&400000]
        b       %ft422
421     cmp     r0, #NV40A                                           ; at least nv20 arch
        beq     %ft423
424
        LDR     r0, offset0                        ;2D destination buffer offset
        STR     r0, [r3, #NVACC_NV20_OFFSET0-&400000]   ; (location of active screen in FB)
        LDR     r0, offset1                        ; 2D source buffer offset
        STR     r0, [r3, #NVACC_NV20_OFFSET1-&400000]
        LDR     r0, offset2                        ; 3D color buffer offset
        STR     r0, [r3, #NVACC_NV20_OFFSET2-&400000]
        LDR     r0, offset3                        ; 3D depth buffer offset
        STR     r0, [r3, #NVACC_NV20_OFFSET2-&400000]
        LDR     r0, pitch0                         ; 2D destination buffer pitch
        STR     r0, [r3, #NVACC_NV20_PITCH0-&400000]
        LDR     r0, pitch1                         ; 2D source buffer pitch
        STR     r0, [r3, #NVACC_NV20_PITCH1-&400000]
        LDR     r0, pitch2                         ; 3D color buffer pitch
        STR     r0, [r3, #NVACC_NV20_PITCH2-&400000]
        LDR     r0, pitch3                         ; 3D depth buffer pitch
        STR     r0, [r3, #NVACC_NV20_PITCH3-&400000]

        b       %ft422
423     ldr     r0, psCardType
        teq     r0, #NV40
        teqne   r0, #NV45
        beq     %bt424             ; use NV20 regs
        LDR     r0, offset0                        ;2D destination buffer offset
        STR     r0, [r3, #NVACC_NV40P_OFFSET0-&400000]   ; (location of active screen in FB)
        LDR     r0, offset1                        ; 2D source buffer offset
        STR     r0, [r3, #NVACC_NV40P_OFFSET1-&400000]
        LDR     r0, pitch0                         ; 2D destination buffer pitch
        STR     r0, [r3, #NVACC_NV40P_PITCH0-&400000]
        LDR     r0, pitch1                         ; 2D source buffer pitch
        STR     r0, [r3, #NVACC_NV40P_PITCH1-&400000]



422     LDR     r2, MMIO
        ADD     r2, r2, #&8000         ; point to NV10_BES
        MOV     r1, #1
        STR     r1, [r2, #NVBES_NV10_GENCTRL-&8000]
        MOV     r1, #0
        STR     r1, [r2, #NVBES_NV10_INTE-&8000]
        STR     r1, [r2, #NVBES_NV10_0OFFSET-&8000]
        STR     r1, [r2, #NVBES_NV10_1OFFSET-&8000]

        LDR     r4, PGRAPH                  ; copy from NVACC_NV10_TIL0AD (engine tile regs dest)
        LDR     r5, PFB                     ; to NVACC_NV10_FBTIL0AD  (engine tile registers)
        ADD     r4, r4, #&B00               ; for all 32 regs
        ADD     r5, r5, #&240
        MOV     lr, #&80
10      LDR     r0, [r4], #4
        SUBS    lr, lr, #4
        STR     r0, [r5], #4
        BNE     %BT10

; corrupts r0 .. Presumes R3 = PGRAPH
        MACRO
        PipeWriteAdd $value
        MOV     r0, #$value
        STR     r0, [R3, #NVACC_NV10_PIPEADR-&400000]
        MEND

; corrupts r0,r1 .. Presumes R3 = PGRAPH
        MACRO
        PipeWriteDat $value, $count
        MOV     r0, #$value
        MOV     r1, #$count
1       STR     r0, [R3, #NVACC_NV10_PIPEDAT-&400000]
        SUBS    r1, r1, #1
        BGT     %BT1
        MEND

        LDR     r3, PGRAPH                      ;  setup (clear) pipe
        MOV     r0, #&10000000                  ; set eyetype to local, lightning is off
        STR     r0, [r3, #NVACC_NV10_XFMOD0-&400000]
        MOV     r0, #0                          ;disable all lights
        STR     r0, [r3, #NVACC_NV10_XFMOD1-&400000]
        PipeWriteAdd &40
        PipeWriteDat 8, 1
        PipeWriteAdd &200
        PipeWriteDat 0, 3*16
        PipeWriteAdd &40
        PipeWriteDat 0, 1
        ldr     r2, psCardType
        teq     r2, #NV43
        BEQ     %ft23                    ; following would hang NV43
        PipeWriteAdd &800
        PipeWriteDat 0, 16*16
23
        MOV     r1, #&30000000          ; turn lightning on
        STR     r0, [r3, #NVACC_NV10_XFMOD0-&400000]
        MOV     r0, #4                  ; set light 1 to infinite type, other lights remain off
        STR     r0, [r3, #NVACC_NV10_XFMOD1-&400000]
        PipeWriteAdd &6400
        PipeWriteDat 0, 59*4
        PipeWriteAdd &6800
        PipeWriteDat 0, 47*4
        PipeWriteAdd &6C00
        PipeWriteDat 0, 3*4
        PipeWriteAdd &7000
        PipeWriteDat 0, 19*4
        PipeWriteAdd &7400
        PipeWriteDat 0, 12*4
        PipeWriteAdd &7800
        PipeWriteDat 0, 12*4
        PipeWriteAdd &4400
        PipeWriteDat 0, 8*4
        PipeWriteAdd &0000
        PipeWriteDat 0, 16
        PipeWriteAdd &0040
        PipeWriteDat 0, 4

        LoadFixedState FIFO
        ldr     r2, psCardType
        cmp     r2, #NV40
        bge     %ft27
        LoadFixedState FIFO,_n40
27
        LoadFixedState PGRAPH,_accel



 [ DebugModule
        DLINE   "Writing extra CRTC"
 ]

        MOV     r0, #NVCRTCX_REPAINT0
        LDRB    r1, repaint0
        BL      WriteCRTC
        MOV     r0, #NVCRTCX_REPAINT1
        LDRB    r1, repaint1
        BL      WriteCRTC_r3
        MOV     r0, #NVCRTCX_LSR
        LDRB    r1, screen
        BL      WriteCRTC_r3
        MOV     r0, #NVCRTCX_PIXEL
        LDRB    r1, pixel
        BL      WriteCRTC_r3
        MOV     r0, #NVCRTCX_HEB
        LDRB    r1, horiz
        BL      WriteCRTC_r3
        MOV     r0, #NVCRTCX_FIFO
        LDRB    r1, fifo_burst
        BL      WriteCRTC_r3
        MOV     r0, #NVCRTCX_FIFO_LWM
        LDRB    r1, fifo_lwm
        BL      WriteCRTC_r3
        MOV     r0, #NVCRTCX_CURCTL1
        LDRB    r1, cursor0
        BL      WriteCRTC_r3
        MOV     r0, #NVCRTCX_CURCTL0
        LDRB    r1, cursor1
        BL      WriteCRTC_r3


        LDRB    r3, CurrentHead
        TST     r3, #1
        LDR     r0, PRAMDAC
        MOVEQ   r3, r0
        LDRNE   r3, PRAMDAC2
        LDR     r1, cursor2
        STR     r1, [r3, #NVDAC_CURPOS-&680000]
        LDR     r1, vpll
        STREQ   r1, [r3, #NVDAC_PIXPLLC-&680000]         ; NVDAC_PIXPLLC
        STRNE   r1, [r0, #NVDAC2_PIXPLLC-&680000]        ; NVDAC2_PIXPLLC
        LDR     r1, pllsel
        STR     r1, [r3, #NVDAC_PLLSEL-&680000]
        LDR     r1, general
        LDR     r0, [r3, #NVDAC_GENCTRL-&680000]
        ldr     lr, =NVDAC_GENCTRL_Mask
        AND     r0, r0, lr
        ORR     r1, r1, r0
;        LDRB    r0, bpp
;        CMP     r0, #16
        ORR     r1, r1,#NVDAC_GENCTRL_RBSwapBit ; force colour plane swap if card will
        STR     r1, [r3, #NVDAC_GENCTRL-&680000]
        ; Use our configuration to work out whether we should be swapping or
        ; not.
        ;
        ; Config_Swap8bpp indicates whether we should swap our palette data,
        ; while Config_Swap16bpp and Config_Swap32bpp indicate whether RISC OS
        ; should swap its pixel data. Considering that we always force RBSwapBit
        ; on if the card supports it, and by default tell RISC OS to swap
        ; 16bpp modes if RBSwapBit=1, we end up with the following
        ; configurations for whether palette + cursor data should be swapped:
        ;
        ; RBSwapBit  bpp    -> Result
        ; 0          8         Swap if Config_Swap8bpp
        ; 0          16        Swap if Config_Swap16bpp EOR Config_Alt16bpp
        ; 0          32        Swap if Config_Swap32bpp
        ; 1          8         Swap if !Config_Swap8bpp
        ; 1          16        Swap if Config_Swap16bpp EOR Config_Alt16bpp
        ; 1          32        Swap if !Config_Swap32bpp
        LDR     r1, [r3, #NVDAC_GENCTRL-&680000] ; read back to find out whether RBSwapBit supported by card
        TST     r1, #NVDAC_GENCTRL_RBSwapBit
        LDRB    r3, Config
        EORNE   r3, r3, #Config_Swap8bpp+Config_Swap32bpp
        TST     r3, #Config_Alt16bpp
        EORNE   r3, r3, #Config_Swap16bpp
        LDRB    r1, bpp
        ASSERT  Config_Swap8bpp = 2
        ASSERT  Config_Swap16bpp = 4
        ASSERT  Config_Swap32bpp = 8
        AND     r1, r3, r1, LSR #2
        STRB    r1, RBSwapMode        

        LDR     r1, Rop
        LDRH    r1, [r1, #FifoFree]
        STR     r1, FifoEmptyCount
        MOV     r1, #0
        STR     r1, FifoFreeCount
        STR     r1, IsSolid
        MOV     r1, #-1
        STR     r1, currentRop

;        LDR     r3, PCRTC
;        ldr r1,=&810
;        add r3,r3,r1
;        ldr r1,=&02000100 ;select 32x32 pixel, 16bit color cursorbitmap, no doublescan
;                          ; bit 100 set .. use the bit map
;                          ; bit &02  .. 00 .. no height, 01 16 height
;                          ;             02 32 height     03 48 height(?)
;        str  r1, [r3]
        BL      EnableVSyncs           ; reenable again
        Pull    "r0-r6,pc"

; In: R0=0 => unblank, 1 => blank
;     R1 = DPMS state (if blanking)
SetBlankState
        TEQ     r0, #0
        BNE     DoBlank
DoUnblank
        Push    "r0-r3,lr"
        PHPSEI  r2
        LDRB    r0, BlankState
        TST     r0, #1
        BIC     r0, r0, #1
        STRB    r0, BlankState
        BEQ     %ft1

        MOV     r0, #NVSEQX_RESET ; synchronous reset
        MOV     r1, #1            ; set (if we were in blank)
        BL      WriteSeq

;        MOV     r0, #NVSEQX_RESET
;        MOV     r1, #0
;        BL      WriteSeq
;        MOV     r0, #NVSEQX_RESET
;        MOV     r1, #1
;        BL      WriteSeq
;        MOV     r0, #NVSEQX_RESET
;        MOV     r1, #3
;        BL      WriteSeq
;        MOV     r0, #NVSEQX_CLKMODE
;        MOV     r1, #&01
;        BL      WriteSeq
;        MOV     r0, #2
;        MOV     r1, #&0F
;        BL      WriteSeq
;        MOV     r0, #3
;        MOV     r1, #0
;        BL      WriteSeq
;        MOV     r0, #NVSEQX_MEMMODE
;        MOV     r1, #&0E
;        BL      WriteSeq


1       MOV     r0, #NVSEQX_CLKMODE
        BL      ReadSeq
        BIC     r1, r1, #&20      ; clock mode bit
        BL      WriteSeq_r3
        MOV     r0, #NVSEQX_RESET ; synchronous reset
        MOV     r1, #3            ; clear (blank may have set it)
        BL      WriteSeq
        MOV     r0, #NVCRTCX_REPAINT1
        LDRB    r1, repaint1
        BL      WriteCRTC
        PLP     r2
        Pull    "r0-r3,pc"

        MOV     r0, #NVSEQX_RESET
        MOV     r1, #0
        BL      WriteSeq
        MOV     r0, #NVSEQX_RESET
        MOV     r1, #1
        BL      WriteSeq
        MOV     r0, #NVSEQX_RESET
        MOV     r1, #3
        BL      WriteSeq
        MOV     r0, #NVSEQX_CLKMODE
        MOV     r1, #&01
        BL      WriteSeq
        MOV     r0, #2
        MOV     r1, #&0F
        BL      WriteSeq
        MOV     r0, #3
        MOV     r1, #0
        BL      WriteSeq
        MOV     r0, #NVSEQX_MEMMODE
        MOV     r1, #&0E
        BL      WriteSeq


DoBlank
        Push    "r0-r3,lr"
        PHPSEI  r2
        LDRB    r0, BlankState
        ORR     r0, r0, #1
        STRB    r0, BlankState
        MOV     r0, #NVCRTCX_REPAINT1
        LDRB    lr, repaint1
        TST     r1, #1            ; check dpms bits
        ORRNE   lr, lr, #&80
        TST     r1, #2
        ORRNE   lr, lr, #&40
        MOV     r1, lr
        BL      WriteCRTC
        MOV     r0, #NVSEQX_RESET ; synchronous reset
        MOV     r1, #1            ; set
        BL      WriteSeq
        MOV     r0, #NVSEQX_CLKMODE; clock mode
        BL      ReadSeq
        ORR     r1, r1, #&20
        BL      WriteSeq_r3
        PLP     r2
        Pull    "r0-r3,pc"

; R0 = 0(off) or 1(on)
; R1 = head 0 or 1
DoSetInterlace
        Push    "r0-r3,lr"
        AND     r0,r0,#1
        tst     r1, #1
        STREQB  r0, interlacestate0
        STRNEB  r0, interlacestate1
        Pull    "r0-r3,pc"

SelectHead
        Push    "r0-r3,lr"
        AND     r0,r0,#1
        STRB    r0, CurrentHead
        IMPORT  |set_crtc_owner|
        MOV     r1, r12
        BL      set_crtc_owner
        Pull    "r0-r3,pc"


; DoI2COp
;      r0 = b0-15 offset within IIC device to start at
;           b16-23 base IICAddress
;           b24-31 zero
;      r1 = buffer to read from/write to
;      r2 = pointer to number of bytes to transfer
;      r3 = head (extracted from R4 in GraphicsV.s)
; Out:
;      r0 = IICStatus return code
;      r1 = advanced by transferred bytes
;      r2 = number of bytes *not* transferred
DoI2COp
        Push    "r0-r8, lr"
        PHPSEI  r8
 [ DebugModule
        DREG    r0,"Op    ="
        DREG    r1,"Buffer="
        DREG    r2,"Count ="
        DREG    r3,"Head  ="
 ]
        MRS     lr, CPSR
        ORR     lr, lr, #SVC32_mode
        MSR     CPSR_c, lr
        BL      VGAUnlock
        BL      NVUnlock

        LDR     r3, PCIO
        LDR     r5, [sp, #3*4]    ; recover head number (0 | 1)
        CMP     r5, #1
        MOVCC   r5, r3
        ADDCS   r5, r3, #VGAHead2Offset ; R5 is I/O address to use, corrected for head

        LDR     r6, [sp, #1*4]    ; buffer address
        LDR     r7, [sp, #2*4]    ; count

        LDR     r0, [sp, #0*4]
        TST     r0, #1:SHL:16     ; check RnW bit (disallowing writes at present)
        BNE     I2CRead
        MOV     r0, #IICStatus_Error
10
        PLP     r8
        ADD     sp,sp,#4
        Pull    "r1-r8, pc"

; r0 = combined offset and IIC address
; r5 = PCI I/O address
; r6 = data buffer
; r7 = count
I2CRead ROUT
        CMP     r7, #0
        BEQ     %FT15           ; Nowt to do
        TST     r0, #&FF00
        BNE     %FT20           ; Input passed end
05
        AND     r3, r0, #255
 [ DebugModule
        DREG    r5, "IO addr="
        DREG    r6, "Buffer ="
        DREG    r7, "Count  ="
 ]
        BL      iicsendstart
        MOV     r4, r0, LSR #16
        BIC     r4, r4, #1      ; About to write the offset
        BL      iicbyteout
        BL      iicgetack
        TEQ     r4, #0
        BNE     %FT15
        MOV     r4, r3          ; Offset
        BL      iicbyteout
        BL      iicgetack
        TEQ     r4, #0
        BNE     %FT15

        BL      iicsendstart
        MOV     r4, r0, LSR #16 ; Read transaction
        BL      iicbyteout
        BL      iicgetack
        TEQ     r4, #0
        BNE     %FT15
10
        BL      iicbytein
        STRB    r4, [r6], #1
 [ DebugModule
        DREG    r4, "byte  ="
 ]
        SUBS    r7, r7, #1
        BEQ     %FT15           ; End of transfer
        BL      iicsendack      ; Autoincrement address
        B       %BT10
15
        MOV     r1, r6
        MOV     r2, r7
        MOVEQ   r0, #IICStatus_Completed
        MOVNE   r0, #IICStatus_NoACK
        BL      iicsendstop     ; End transaction

        PLP     r8
        ADD     sp,sp,#12
        Pull    "r3-r8,pc"

20
        ; EDID allows accesses to offsets >= 256 by first writing to the segment
        ; pointer
        AND     r4, r0, #&fe0000
        TEQ     r4, #&a00000
        BNE     %BT15
        BL      iicsendstart
        MOV     r4, #&60        ; Segment pointer addr
        BL      iicbyteout
        BL      iicgetack
        TEQ     r4, #0
        BNE     %BT15
        MOV     r4, r0, LSR #8
        BL      iicbyteout
        BL      iicgetack
        TEQ     r4, #0
        BNE     %BT15
        B       %BT05


; Send an ACK condition
; R5 is I/O address to use, corrected for head
iicsendack
        Push    "r0-r3,lr"
        MOV     r1,#0
        BL      setscl          ; SDA  -000
        MOV     r1,#0           ; SCL  0010
        BL      setsda
        MOV     R0,#10
        BL      MicroDelay
        MOV     r1,#1
        BL      setscl
        MOV     R0,#10
        BL      MicroDelay
        MOV     r1,#0
        BL      setscl
        MOV     R0,#10
        BL      MicroDelay
        Pull    "r0-r3,pc"

; Send a Start condition
; R5 is I/O address to use, corrected for head
iicsendstart
        Push    "r0-r3,lr"
        MOV     r1,#1
        BL      setsda          ; SDA  1100
        MOV     r1,#1           ; SCL  -110
        BL      setscl
        MOV     R0,#10
        BL      MicroDelay
        MOV     r1,#0
        BL      setsda
        MOV     R0,#10
        BL      MicroDelay
        MOV     r1,#0
        BL      setscl
        MOV     R0,#10
        BL      MicroDelay
        Pull    "r0-r3,pc"

; Send a Stop condition
; R5 is I/O address to use, corrected for head
iicsendstop
        Push    "r0-r3,lr"
        MOV     r1,#0
        BL      setsda          ; SDA  001
        MOV     r1,#1           ; SCL  -11
        BL      setscl
        MOV     R0,#10
        BL      MicroDelay
        MOV     r1,#1
        BL      setsda
        MOV     R0,#50
        BL      MicroDelay
        Pull    "r0-r3,pc"

; Get an ACK to R4 .. Successful if R4=0
; R5 is I/O address to use, corrected for head
iicgetack
        Push    "r0-r3,lr"
        MOV     r1,#1
        BL      setsda
        MOV     R0,#10
        BL      MicroDelay
        MOV     r1,#1
        BL      setscl
        MOV     R0,#10
        BL      MicroDelay
        BL      getsda
        AND     r4,r1, #1
        MOV     r1,#0
        BL      setscl
        MOV     R0,#10
        BL      MicroDelay
 [ DebugModule
        DREG    r4,"rdack="
 ]
        Pull    "r0-r3,pc"

; send byte in R4
;
; R5 is I/O address to use, corrected for head
iicbyteout  ROUT
        Push    "r0-r3,lr"
        MOV     r3,#7
1       MOV     r1,r4,lsr r3
        AND     r1,r1,#1
 [ DebugModule
        BREG    r1,"   wrb="
 ]
        BL      setsda
        MOV     R0,#10
        BL      MicroDelay
        MOV     r1,#1
        BL      setscl
        MOV     R0,#10
        BL      MicroDelay
        MOV     r1,#0
        BL      setscl
        MOV     R0,#10
        BL      MicroDelay
        SUBS    r3,r3,#1
        BGE     %bt1
        Pull    "r0-r3,pc"

; return byte read in R4
;
; R5 is I/O address to use, corrected for head
iicbytein  ROUT
        Push    "r0-r3,lr"
        MOV     r1,#1
        BL      setsda          ; release SDA so the slave can drive it
        MOV     r4,#0
        MOV     R0,#10
        BL      MicroDelay
        MOV     r3,#8
1       MOV     r1,#1
        BL      setscl
        MOV     R0,#10
        BL      MicroDelay
        BL      getsda
        ORR     r4,r1,r4,lsl #1
        MOV     r1,#0
        BL      setscl
        MOV     R0,#10
        BL      MicroDelay
        SUBS    r3,r3,#1
        BGT     %bt1
 [ DebugModule
        BREG    r4,"..rdb="
 ]
        Pull    "r0-r3,pc"

; get SDA bit to r1
; R5 is I/O address to use, corrected for head
getsda
        Push    "r0,r2-r3,lr"
        MOV     r0,#&3e
        BL      HdReadCRTC
        ANDS    r1,r1,#8
        MOVNE   r1,#1
        Pull    "r0,r2-r3,pc"

; scl state in r1
; R5 is I/O address to use, corrected for head
setscl
        Push    "r0-r3,lr"
        MOV     r0,#&3f
        BL      HdReadCRTC
        AND     r1,r1,#&d0
        LDR     lr, [sp,#4]
        TEQ     lr,#0
        ORRNE   r1,r1,#&20
        ORR     r1,r1,#1
        BL      HdWriteCRTC
        Pull    "r0-r3,pc"

; sda state in r1
; R5 is I/O address to use, corrected for head
setsda
        Push    "r0-r3,lr"
        MOV     r0,#&3f
        BL      HdReadCRTC
        AND     r1,r1,#&e0
        LDR     lr, [sp,#4]
        TEQ     lr,#0
        ORRNE   r1,r1,#&10
        ORR     r1,r1,#1
        BL      HdWriteCRTC
        Pull    "r0-r3,pc"

; R0 = register
; R5 is I/O address to use, corrected for head
; R1 = data
HdWriteCRTC
        Push    "r4,lr"
        MRS     r4, CPSR
        ORR     lr, r4, #I32_bit
        MSR     CPSR_c, lr
        STRB    r0, [r5, #VGACRTCIndex]
        STRB    r1, [r5, #VGACRTCData]
        MSR     CPSR_c, r4
        Pull    "r4,pc"

; R0 = register
; R5 is I/O address to use, corrected for head
; return R1 = data
HdReadCRTC
        Push    "r4,lr"
        MRS     r4, CPSR
        ORR     lr, r4, #I32_bit
        MSR     CPSR_c, lr
        STRB    r0, [r5, #VGACRTCIndex]
        LDRB    r1, [r5, #VGACRTCData]
        MSR     CPSR_c, r4
        Pull    "r4,pc"

        END
