/* Copyright 2008 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*  Power-on sequences for nVidia GeForce cards
 *  cards supported:
 *  GeForce2 MX440
 *  TypeGE2_0: Initial MSI card .. subsytemID:&83411462
 *  TypeGE2_1: not used (??)
 *  TypeGE2_2: BIOSword&34 = &A2C11080   Creative .. and default
 *                           &C35B10B0   defaulted: xfx card  
 *                           &C48B10B0   defaulted: circle fan card big rom 
 *                           &C54510B0   defaulted: circle fan card small rom  
 *  TypeGE2_3: BIOSword&34 = &CA2D10B0   xfx lo profile
 *  TypeGE2_4: BIOSword&34 = &C68110B0   xfx lo profile ddr
 *  TypeGE2_5: BIOSword&34 = &C39B10B0   jaton lo profile
 *  TypeGE2_6: BIOSword&34 = &C4A11080   jaton lo profile type 2
 *  ~~~~~~
 *  TypeGE4_0: Initial support for GeForce4 MSI card
 *
 *  last update 30/10/2004 JB
 */

#include <stdint.h>
#include "math.h"

#ifdef CDEBUG
#include <stdio.h>
#include <stdarg.h>
//#include <printf.h>
#endif

typedef uint8_t  U008;
typedef uint16_t U016;
typedef uint32_t U032;
typedef int      BOOL;

/*Keep these in sync with whats in s.nVidiaHW */
/*GeForce 2 types and default config values (-1 = ignore) */
/* (bit 31 set to write the register) ..*/
#define TypeGE2_0  0
#define GE2_0_DefConf 0x80000443                               
#define TypeGE2_1  1
#define GE2_1_DefConf -1
#define TypeGE2_2  2
#define GE2_2_DefConf 0x80000cdb
#define TypeGE2_3  3
#define GE2_3_DefConf 0x80000def
#define TypeGE2_4  4
#define GE2_4_DefConf 0x80000cef
#define TypeGE2_5  5
#define GE2_5_DefConf 0x800084db
#define TypeGE2_6  6
#define GE2_6_DefConf 0x800084ef
/*GeForce4 types */
#define TypeGE4_0  7
#define GE4_0_DefConf 0x800094af

#ifdef CDEBUG
#define XDebugIt_WriteC  0x6ba82
extern void PReg(unsigned int );
extern void PStr(char* );
extern void PChar(char);
#define PrReg(a) PReg(a)
#define PrStr(a) PStr(a)
#define PrChar(a) PChar(a)
#else
#define PrReg(a)
#define PrStr(a)
#define PrChar(a)
#endif  


#define REG_RD32(a)    (*(volatile U032 *) (MMIO + (a)))
#define REG_WR32(a,v) (*(volatile U032 *) (MMIO + (a)) = (v))
#define REG_RD08(a)    (*(volatile U008 *) (MMIO + (a)))
#define REG_WR08(a,v) (*(volatile U008 *) (MMIO + (a)) = (v))

#define IRQ_Off(a)    {                                \
                       int b,c;                        \
                       __asm                           \
                       {                               \
                         MRS     c, CPSR;              \
                         ORR     b, c, 1<<7;           \
                         MSR     CPSR_c, b;            \
                         STR     c,[a];                \
                       }                               \
                      }                           
                                                          

#define IRQ_On(a)    {                                 \
                       int b,c;                        \
                       __asm                           \
                       {                               \
                         MRS     c, CPSR;              \
                         MVN     b, 1<<7;              \
                         AND     b, a, b;              \
                         ORR     b, c, b;              \
                         MSR     CPSR_c, b;            \
                       }                               \
                     }                     
 
#define FALSE 0
#define TRUE 1

#define DDR_RAM 1
#define RamType 0   // Define board ram type as SDR


typedef struct
{
    U008 nM;
    U008 nN;
    U008 nP;
} PostClockParameters;

extern void Delay(int ms);

unsigned int CalcMNP( U032 Clock, U032 CrystalFreq, PostClockParameters *clockParameters );
void InitReg( U032 MMIO, U032 addr, U032 mask, U032 set );
void DvReadPort( U032 MMIO, U032 addr, U032 index, U008 *pValue );
void DvWritePort( U032 MMIO, U032 addr, U032 index, U008 value );
void programNVClk( U032 MMIO, U032 MhzX100, U032 CrystalFreq, int card_type);
void programMClk( U032 MMIO, U032 MhzX100, U032 CrystalFreq, int card_type );
void IOWrite( U032 MMIO, U032 addr, U032 index, U008 mask, U008 data );
int getCRTCIndex(U032 MMIO);
void PostDevice (U032 MMIO, int card_type, U032* card_post);
//int IRQ_Off(void);
//void IRQ_On(int enable);




void InitReg( U032 MMIO, U032 addr, U032 mask, U032 set )
{
    U032 value;
    int enable;
    PrStr("\nIR:");
    PrReg(addr);PrReg(mask);PrReg(set);
    IRQ_Off(&enable);
    value = REG_RD32(addr);
    value = (value & mask) | set;
    REG_WR32(addr, value);
    IRQ_On(enable);
    PrStr("\nRegInit:");
    PrReg(addr);PrReg(mask);PrReg(set);PrReg(value);
}

void DvReadPort( U032 MMIO, U032 addr, U032 index, U008 *pValue )
{
    U032 prevIndex;
    int enable;
    IRQ_Off(&enable);

    prevIndex = REG_RD08(addr);
    REG_WR08(addr, index);
    *pValue = REG_RD08(addr + 1);
    REG_WR08(addr, prevIndex);
    IRQ_On(enable);
    PrStr("\nDVRd:");
    PrReg(addr);PrReg(index);PrReg(*pValue);
}

void DvWritePort( U032 MMIO, U032 addr, U032 index, U008 value )
{
    U008 temp;
    int enable;
    IRQ_Off(&enable);

    temp = REG_RD08(addr);
    REG_WR08(addr, index);
    REG_WR08(addr + 1, value);
    REG_WR08(addr, temp);
    IRQ_On(enable);
    PrStr("\nDVWr:");
    PrReg(addr);PrReg(index);PrReg(value);
}

unsigned int CalcMNP
(
    U032     Clock,
    U032     CrystalFreq,
    PostClockParameters *clockParameters
)
{
    U016  crystalFreq;
    U032  vclk;
    U016  vclkClosest = 0;
    U016  deltaOld;
    U016  bestM = 0;
    U016  bestP = 0;
    U016  bestN = 0;
    U016  lowM;
    U016  highM;
    U016  lowP, highP;
    U032  hiVclk1, hiVclk2, hiVclk3;
    U032  FminVco, FmaxVco;
    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032  lwv, lwv2;
    U016  lwvs, vclks;
    U016  t;
    vclk = (U032)(Clock * 10);     // Make KHz
    deltaOld = 0xFFFF;
    hiVclk1 = 150000;
    hiVclk2 = 200000;
    hiVclk3 = 340000;
    lowP    = 0;
    highP   = 4;
    FminVco = 200000;
    FmaxVco = 400000;
    // Apply any adjusts needed to FminVco/FmaxVco.
    //
    // 1). Make sure vclk is not so low that we'll miss the whole VCO range.
    //     Adjust FminVco to hit with the highest P (post divide).
    //
    if ((vclk << highP) < FminVco)
        FminVco = vclk << highP;
    //
    // 2). Also, check if two consecutive P values would cause us to miss
    //     the whole VCO range, where the first P is beneath FminVco and
    //     the next P is above FmaxVco.
    //
    for (powerP = lowP; powerP < highP; powerP++)
    {
        lwv = vclk << powerP;
        if ((lwv < FminVco) && ((lwv << 1) > FmaxVco))
        {
            // adjust FminVco or FmaxVco, whichever is closer
            if ((FminVco - lwv) < ((lwv << 1) - FmaxVco))
                FminVco = lwv;
            else
                FmaxVco = (lwv << 1);
        }
    }
    //
    // 3). Let a high vclk set the upper bound.
    //
    if (vclk > FmaxVco)
        FmaxVco = vclk;
    //
    // Determine the current crystal frequency
    //
    if (CrystalFreq == 14318180)
    {
        // 14.3Khz
        crystalFreq = 14318;
        lowM = 1;
        //
        // NV11 needs four highM buckets due to
        // induced jitter into the PLL's
        //
        if (vclk > hiVclk3)
            highM = 2;
        else if (vclk > hiVclk2)
            highM = 4;
        else if (vclk > hiVclk1)
            highM = 6;
        else
            highM = 14;
    } else if (CrystalFreq == 27000000) {
        // 27.0 MHz
        crystalFreq = 27000;
        lowM = 1;
        //
        // NV11 needs four highM buckets due to
        // induced jitter into the PLL's
        //
        if (vclk > hiVclk3)
            highM = 2;
        else if (vclk > hiVclk2)
            highM = 4;
        else if (vclk > hiVclk1)
            highM = 6;
        else
            highM = 14;
    }
    else
    {
        // 13.5Khz
        crystalFreq = 13500;
        lowM = 1;
        //
        // NV11 needs four highM buckets due to
        // induced jitter into the PLL's
        //
        if (vclk > hiVclk3)
            highM = 2;
        else if (vclk > hiVclk2)
            highM = 4;
        else if (vclk > hiVclk1)
            highM = 6;
        else
            highM = 13;
    }
    //
    // P Loop
    //
    for (powerP = lowP; powerP <= highP; powerP++) // Init Power of P
    {
        // M Loop
        for (m = lowM; m <= highM; m++)
        {
            lwv = vclk << powerP;   // vclk * P
            // Compare with internal range of DAC
            if ((lwv >= FminVco) && (lwv <= FmaxVco))
            {
                lwv *= (U032)m;    // vclk * P * M
                // Add crystal Frequency /2 - will round better
                lwv += (crystalFreq >> 1);
                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);
                if (n > 0xFF)
                    break;
                lwv *= crystalFreq; // N * crystal
                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2
                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P
                i = m;
                j = m;
                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M
                lwv2 = lwv;          // Save a copy
                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta
                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);
                if (lwvs < vclks)
                {
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }
                lwvs -= vclks;      // ABS(Freq-Vclk);
                //
                // If this is an NV5 or better, allow the higher PCLK settings to use a lower M
                // if the error is small enough.  Just looking for the lowest overall error
                // may result in an M that is too high, possibly introducing PLL jitter.
                //
                //
                // If VCLK > 250MHz and error is less than 0.2, drop out
                //
                if (vclk > hiVclk1)
                {
                    if (lwvs == 0) // zero error; rare, but would cause exception
                    {
                        clockParameters->nP = powerP;
                        clockParameters->nM = m;
                        clockParameters->nN = n;
                        lwv2 /= 10;
                        return ((U016)(lwv2 & 0xFFFF));
                    }
                    else if ((vclk/lwvs) > 200) // ok, now safe to div by lwvs (it's not zero)
                    {
                        clockParameters->nP = powerP;
                        clockParameters->nM = m;
                        clockParameters->nN = n;
                        lwv2 /= 10;
                        return ((U016)(lwv2 & 0xFFFF));
                    }
                }
                if (lwvs < deltaOld) // go to closest match with M < highM
                {
                    // Closer match
                    deltaOld = lwvs;
                    bestP = powerP;
                    bestM = m;
                    bestN = n;
                    lwv2 /= 10;
                    vclkClosest = (U016)(lwv2 & 0xFFFF);
                }
            }
        }
    }
    //
    // Return the results
    //
    clockParameters->nM = bestM;
    clockParameters->nN = bestN;
    clockParameters->nP = bestP;
    return (vclkClosest);
}

void programNVClk( U032 MMIO, U032 MhzX100, U032 CrystalFreq, int card_type )
{
    U032 mOld, nOld, pOld;
    PostClockParameters cp;
    U032 mnNew, mnpNew;
    U032 coeff, data;
    int Loops;
    BOOL IsPllLocked, IsPllSlowed;

    CalcMNP( MhzX100, CrystalFreq, &cp );

    if (card_type != TypeGE2_4)
    {
      /* Get current core slowdown value */
      IsPllSlowed = REG_RD32(0x00001084);
      IsPllSlowed = (IsPllSlowed >> 0x0000001d) & 0x00000003;
      /* slowdown the core */
      data = REG_RD32(0x00001084);
      data = (data & 0x9fffffff) | 0x00000000;
      REG_WR32(0x00001084, data);
    }
    /* Retrieve Current coefficients */
    coeff = REG_RD32(0x00680500);
    mOld = (coeff >> 0x00000000) & 0x000000ff;
    nOld = (coeff >> 0x00000008) & 0x000000ff;
    pOld = (coeff >> 0x00000010) & 0x00000007;

    if (card_type != TypeGE2_4)
    {
      /* Restore core slowdown value */
      data = REG_RD32(0x00001084);
      data = (data & 0x9fffffff) | ((IsPllSlowed & 0x00000003) << 0x0000001d);
      REG_WR32(0x00001084, data);
    }
    
    /* If p decreases then be careful */
    if (cp.nP < pOld)
    {
        /* Write M and N first */
        mnNew = ((cp.nM & 0x000000ff) << 0x00000000) | ((cp.nN & 0x000000ff) << 0x00000008) | ((pOld & 0x00000007) << 0x00000010);
        REG_WR32(0x00680500, mnNew);

        /* Wait until PLL is locked */
        IsPllLocked = FALSE;
        for (Loops = 100; Loops; --Loops)
        {
            if (((REG_RD32(0x00680514) >> 0x0000001d) & 0x00000001) == 0x00000001)
            {
                /* Check again to make sure */
                if (((REG_RD32(0x00680514) >> 0x0000001d) & 0x00000001) == 0x00000001)
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }
            Delay(2/*1*/); // Delay 1ms
        }
    }

    /* Now Write the final value */
    mnpNew = ((cp.nM & 0x000000ff) << 0x00000000) | ((cp.nN & 0x000000ff) << 0x00000008) | ((cp.nP & 0x00000007) << 0x00000010);
    REG_WR32(0x00680500, mnpNew);
}

void programMClk( U032 MMIO, U032 MhzX100, U032 CrystalFreq, int card_type )
{
    PostClockParameters cp;
    U032 mnpNew;
    U032 data32;

    CalcMNP( MhzX100, CrystalFreq, &cp );

    /* Now Write the final value */
    if( card_type != TypeGE2_4 )
    {
      mnpNew = ((cp.nM & 0x000000ff) << 0x00000000) | ((cp.nN & 0x000000ff) << 0x00000008) | ((cp.nP & 0x00000007) << 0x00000010);
      REG_WR32(0x00680504, mnpNew);
      Delay(10/*1*/); // Delay 1ms
    }
    else                                
    {
      if ((REG_RD32(0x00680510) >> 0x0000000c) & 0x00000007 & 0x00000001 || 
         ((REG_RD32(0x00001584) >> 0x00000004) & 0x0000000f) == 0x00000003)
      {
          return;
      }
  
      {
          U032 pwrctrl_1 = 0;
          U032 maskValue = 0;
          U032 newValue = 0;
          maskValue = ~( 0x0000000f << 0x00000004 );
  
          newValue = 0x00000010;
  
          pwrctrl_1 = REG_RD32(0x00001584);
          pwrctrl_1 &= maskValue;
          pwrctrl_1 |= newValue;
          REG_WR32(0x00001584, pwrctrl_1);
          /* Now Write the final value */
          mnpNew = ((cp.nM & 0x000000ff) << 0x00000000) | ((cp.nN & 0x000000ff) << 0x00000008) | ((cp.nP & 0x00000007) << 0x00000010);
          REG_WR32(0x00680504, mnpNew);
          Delay(10); // Delay 10ms
          newValue = 0x00000000;
        
          pwrctrl_1 = REG_RD32(0x00001584);
          pwrctrl_1 &= maskValue;
          pwrctrl_1 |= newValue;
          REG_WR32(0x00001584, pwrctrl_1);
      }
    }


    if (RamType == DDR_RAM)
    {
        data32 = REG_RD32(0x001002c0);
        data32 = (data32 & 0xfffffeff) | 0x00000000;
        REG_WR32(0x001002c0, data32);
        Delay(2/*1*/); // Delay 1ms
        data32 = REG_RD32(0x001002c0);
        data32 = (data32 & 0xfffffeff) | 0x00000100;
        REG_WR32(0x001002c0, data32);
        Delay(2/*1*/); // Delay 1ms
        data32 = REG_RD32(0x001002c0);
        data32 = (data32 & 0xfffffeff) | 0x00000000;
        REG_WR32(0x001002c0, data32);
        Delay(2/*1*/); // Delay 1ms
        data32 = REG_RD32(0x001002c0);
        data32 = (data32 & 0xfffffeff) | 0x00000100;
        REG_WR32(0x001002c0, data32);
        Delay(2/*1*/); // Delay 1ms
    }
}

void IOWrite( U032 MMIO, U032 addr, U032 index, U008 mask, U008 data )
{
    U008 value08;

    DvReadPort( MMIO, addr, index, &value08 );
    value08 = (value08 & mask) | data;
    DvWritePort( MMIO, addr, index, value08 );
}

int getCRTCIndex(U032 MMIO)
{
    U008 cr44 = 0;
    int enable;
    IRQ_Off(&enable);

    REG_WR08(0x006013d4, 0x44);
    cr44 = REG_RD08(0x006013d5);
    IRQ_On(enable);

    if ((cr44 & 0x3) == 0x3)
    {
        return 0x2000;
    }
    else
    {
        return 0x0;
    }
}

void PostDevice (U032 MMIO, int card_type, U032* card_post)
{
    U008 lock;
    U008 freqIndex;
    U008 value08;
    U008 data08;
    U032 data32;
    U032 doubleFlag;
    U032 srcValue;
    U032 tempValue;
    U032 saveValue;
    U032 word32;
    U032 dwCrystal;
    U032 CrystalFreq;
    int enable;
    IRQ_Off(&enable);

//      force PCI mode whatever.. AGPCMD is 0x4c
//	CFGW(NVCFG_AGPCMD, 0x00000000);   /* force to PCI mode */
//
    
/*
 * Enable VGA subsystem
 */
    PrStr("\nrd1854:");
    data32 = REG_RD32(0x00001854);
    PrReg(data32);
    data32 = (data32 & 0xfffffffe) | 0x00000001;
    REG_WR32(0x00001854, data32);
    
/*
 * Unlock Extended CRTC registers
 */
    PrStr("\nUnLock:");
    REG_WR08(0x006013d4, 0x1f);
    data08 = REG_RD08(0x006013d5);
    PrReg(data08);
    switch (data08)
    {
        case 0x03:
            lock = 0x57;
            break;
        case 0x01:
            lock = 0x75;
            break;
        case 0x00:
        default:
            lock = 0x99;
            break;
    }
    PrReg(lock);
    REG_WR08(0x006013d4, 0x1f);
    REG_WR08(0x006013d5, 0x57);
    data08 = REG_RD08(0x006013d5); // flush it

/*
 * put in known state to board config status register
 * this is to overcome 'pyjamas' issue seen from time to time
 */
    /* table of default config values for the card configuration *
     * register. arranged in numerically ascending order         */
    static const U032 ConfigTable[8] = { GE2_0_DefConf,
                                         GE2_1_DefConf,
                                         GE2_2_DefConf,
                                         GE2_3_DefConf,
                                         GE2_4_DefConf,
                                         GE2_5_DefConf,
                                         GE2_6_DefConf,
                                         GE4_0_DefConf
                                       };
    PrStr("\nHardware reg read:");                                   
    data32=REG_RD32(0x00101000); /* remember it in case debug needed */
    *card_post=data32;
    PrReg(data32);
       
    if(data32= ConfigTable[card_type], data32!=-1)REG_WR32(0x00101000,data32);

/*
 * Determine the crystal frequency
 */
    PrStr("\n XtalFrq:");
    dwCrystal = REG_RD32(0x00101000);
    PrReg(dwCrystal);
    dwCrystal = (dwCrystal >> 0x00000006) & 0x00000001;
    if (dwCrystal & 0x00000002)
        CrystalFreq = 27000000;
    else if (dwCrystal == 0x00000000)
        CrystalFreq = 13500000;
    else if (dwCrystal == 0x00000001)
        CrystalFreq = 14318180;
    PrReg(CrystalFreq);

/*   go to GeForce2 script if there
 *
 *
 */
    if(card_type != TypeGE4_0)  //  == GeForce4 script
    {
/*
 * Process Script # 5
 *
 * Process Script # 0
 */
/*
 * INIT_RESET
 */
    /* Save and toggle the AGP command register (don't disturb the FW enable) */
    saveValue = REG_RD32(0x0000184c);
    REG_WR32(0x0000184c, saveValue & 0xfffffcff);
    /* turn engines off */
    REG_WR32(0x00000200, 0x03000000);
    /* turn engines on */
    REG_WR32(0x00000200, 0x03110110);
    /* restore AGP command register */
    REG_WR32(0x0000184c, saveValue);

    /* set access to the ROM thru instance mem */
    data32 = REG_RD32(0x00001850);
    data32 = (data32 & 0xfffffffe) | 0x00000000;
    REG_WR32(0x00001850, data32);
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00101000, 0xffffffff,
             card_type == TypeGE2_0 ? 0x80000000 : 0x80000800 );
/*
 * Process Script # 1
 */
/*
 * INIT_CONDITION
 */
/*
 * INIT_ZM_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, 0x00, 0x01 );
/*
 * INIT_NOT
 */
/*
 * INIT_ZM_INDEX_IO
 */
/*
 * INIT_RESUME
 */
/*
 * INIT_COPY
 */
    srcValue = REG_RD32(0x00101000);
    srcValue <<= 0x00000002;
    tempValue = srcValue & 0x000000f0;
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    value08 = (value08 & 0x0f) | tempValue; //FIXFIX
    DvWritePort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, value08 );
/*
 * Process Script # 2
 */
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000035, 0xfd, 0x01 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, 0xf7, 0x08 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00000200, 0x00000000, 0x03010111 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x000c03c4, 0x00000001, 0xff, 0x20 );
/*
 * INIT_PLL
 */
    /* Program NVClock */
    programNVClk( MMIO, 10000, CrystalFreq, card_type );
/*
 * INIT_PLL
 */
    /* Program MClock */
    programMClk( MMIO, 8300, CrystalFreq, card_type );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x000010b0, 0x0fffffff, 0xc0000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x000010b4, 0xffffffff, 0x00000000 );
/*
 * INIT_NV_REG
 */
    if ( (card_type == TypeGE2_3) || (card_type == TypeGE2_4) )
        InitReg( MMIO, 0x000010b8, 0x00000000, 0x88880000 );
    else
    if (card_type == TypeGE2_6 )
        InitReg( MMIO, 0x000010b8, 0xffffffff, 0x00960000 );
    else
        InitReg( MMIO, 0x000010b8, 0xffffffff, 0x00000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x000010bc, 0xfffffff0, 0x00000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x000010cc, 0xffffffff, 0x00000000 );
/*
 * INIT_NV_REG
 */
    if ( (card_type == TypeGE2_3) || (card_type == TypeGE2_4) )
        InitReg( MMIO, 0x000010d4, 0xf0ffffff, 0x0c000000 );
    else
        InitReg( MMIO, 0x000010d4, 0xffffffff, 0x00000000 );
/*
 * INIT_ZM_REG
 */
    if (card_type == TypeGE2_6)
      InitReg( MMIO, 0x000010d8, 0x00000000, 0x77777777 );
    else  
      InitReg( MMIO, 0x000010d8, 0x00000000, 0x88888888 );
/*

 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x0068050c, 0x00000000, 0x00000700 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x0068050c, 0x00000000, 0x00000500 );
/*
 * Process Script # 3
 */
/*
 * INIT_IO_RESTRICT_PLL
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &freqIndex );
    freqIndex = (freqIndex & 0xf0) >> 0x00000004;
    doubleFlag = 0;
    if (freqIndex < 16)
    {
        static const U016 freqTable[7][16] = {
            {0x4e20, 0x445c, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x37dc, 0x2ee0, 0x37dc, 0x3a98, 0x3a98, 0x4e20, 0x37dc, 0x4e20, 0x37dc, },
            {0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, },
            {0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x2ee0, 0x37dc, 0x4e20, 0x3a98, 0x4e20, 0x37dc, 0x4e20, 0x37dc, },
            {0x445c, 0x4e20, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x37dc, 0x2ee0, 0x37dc, 0x4e20, 0x4e20, 0x4e20, 0x37dc, 0x4e20, 0x37dc, },
            {0x445c, 0x4e20, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x37dc, 0x2ee0, 0x37dc, 0x4e20, 0x4e20, 0x4e20, 0x37dc, 0x4e20, 0x37dc, },
            {0x445c, 0x445c, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x37dc, 0x2ee0, 0x37dc, 0x445c, 0x3a98, 0x4e20, 0x37dc, 0x4e20, 0x37dc, },
            {0x445c, 0x445c, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x37dc, 0x2ee0, 0x37dc, 0x4e20, 0x445c, 0x4e20, 0x37dc, 0x4e20, 0x37dc, }
        };
        U032 freq = freqTable[card_type][freqIndex];
        freq = (doubleFlag) ? freq * 2 : freq;
        /* Program NVClock */
        programNVClk( MMIO, freq, CrystalFreq, card_type );
    }
/*
 * INIT_IO_RESTRICT_PLL
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &freqIndex );
    freqIndex = (freqIndex & 0xf0) >> 0x00000004;
    doubleFlag = 0;
// no doubleFlag for Jatong (TypeGE2_5) JWB
    if ( (card_type == TypeGE2_3)
      || (card_type == TypeGE2_4)
      || (card_type == TypeGE2_6) ) doubleFlag = 1;
      
    if (freqIndex < 16)
    {
        static const U016 freqTable[7][16] = {
            {0x4e20, 0x40d8, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x40d8, 0x36b0, 0x40d8, 0x37dc, 0x37dc, 0x40d8, 0x40d8, 0x40d8, 0x477c, },
            {0x37dc, 0x37dc, 0x37dc, 0x37dc, 0x37dc, 0x37dc, 0x37dc, 0x37dc, 0x37dc, 0x37dc, 0x37dc, 0x37dc, 0x37dc, 0x37dc, 0x37dc, 0x37dc, },
            {0x34bc, 0x34bc, 0x34bc, 0x34bc, 0x34bc, 0x34bc, 0x34bc, 0x34bc, 0x36b0, 0x40d8, 0x40d8, 0x37dc, 0x40d8, 0x40d8, 0x40d8, 0x40d8, },
            {0x40d8, 0x8214, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x40d8, 0x36b0, 0x40d8, 0x37dc, 0x37dc, 0x40d8, 0x40d8, 0x40d8, 0x40d8, },
            {0x40d8, 0x8214, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x40d8, 0x36b0, 0x40d8, 0x37dc, 0x37dc, 0x40d8, 0x40d8, 0x40d8, 0x40d8, },
            {0x40d8, 0x40d8, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x40d8, 0x36b0, 0x40d8, 0x40d8, 0x37dc, 0x40d8, 0x40d8, 0x40d8, 0x40d8, },
            {0x40d8, 0x40d8, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x2ee0, 0x40d8, 0x36b0, 0x40d8, 0x37dc, 0x40d8, 0x40d8, 0x40d8, 0x40d8, 0x40d8, }
            };
        U032 freq = freqTable[card_type][freqIndex];
        freq = (doubleFlag) ? freq * 2 : freq;
        /* Program MClock */
        programMClk( MMIO, freq, CrystalFreq, card_type );
    }
/*
 * Process Script # 4
 */
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00000200, 0x00000000, 0x03110111 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x000010e0, 0x00000000, 0x80800080 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x000010e4, 0x00000000, 0x00808080 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00001084, 0x00000000, 0x00005748 );
/*
 * Process Script # 5
 */
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x000c03c4, 0x00000001, 0xff, 0x20 );
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable44419[16] =         {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x07070707, 0x07070707, 0x07070707, 0x04040404, 0x07070707, 0x07070707, 0x07070707, 0x07070707, 0x07070707, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable44419[value08];
            REG_WR32(0x00001080, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable44494[16] =         {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable44494[value08];
            REG_WR32(0x00100210, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable44569[16] =         {0x08b11110, 0x08c11110, 0x08b01110, 0x08b01110, 0x08a01110, 0x08911110, 0x09c11110, 0x08b11001, 0x08b11101, 0x08b11101, 0x08c11001, 0x08a11101, 0x08a11101, 0x08c11001, 0x08a11111, 0x08c11101, };
        static const U032 dataTable44919[16] =         {0x08b11110, 0x08c11110, 0x08c11110, 0x08b01110, 0x08a01110, 0x08911110, 0x09c11110, 0x08b11001, 0x08b11101, 0x08b11101, 0x08c11001, 0x08a11101, 0x08a11101, 0x08c11001, 0x08a11111, 0x08c11101, };
        static const U032 dataTable45359[16] =         {0x08b11110, 0x08c11110, 0x08b01110, 0x08b01110, 0x08a01110, 0x08911110, 0x09c11110, 0x08b11001, 0x08b11101, 0x08b11101, 0x08c11001, 0x09c10001, 0x08a11101, 0x08c11001, 0x08a11111, 0x08c11101, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = (card_type == TypeGE2_6 ? dataTable45359 :
                      card_type == TypeGE2_4 ? dataTable45359 :
                      card_type == TypeGE2_3 ? dataTable45359 :
                      card_type == TypeGE2_2 ? dataTable44919 :
                                       dataTable44569)[value08];
            /* KJB change */
            if (card_type == TypeGE2_0)
                word32 &=~ 0x00001000;
// include type 5 (jatong) in this masking JWB
            else if (card_type == TypeGE2_1 || card_type == TypeGE2_2 || card_type == TypeGE2_5)
                word32 &=~ 0x00001010;
            REG_WR32(0x00100200, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable[7][16] = {
            {0x43070a0a, 0x43070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x34070d0b, 0x34070d0b, 0x34070d0b, 0x33060b09, 0x34070d0b, 0x34070d0b, 0x44070e0c, 0x34070d0b, 0x34070d0b, },
            {0x43070a0a, 0x43070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x34070d0b, 0x34070d0b, 0x34070d0b, 0x33070c0a, 0x34070d0b, 0x34070d0b, 0x33070a0c, 0x34070d0b, 0x34070d0b, },
            {0x44090c0c, 0x43070a0a, 0x44090c0c, 0x44090c0c, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x34070d0b, 0x34070d0b, 0x34070d0b, 0x33070c0a, 0x34070d0b, 0x34070d0b, 0x33070a0c, 0x34070d0b, 0x34070d0b, },
            {0x43070a0a, 0x43070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x34070d0b, 0x34070d0b, 0x34070d0b, 0x33070c0a, 0x44070c0c, 0x34070d0b, 0x33070a0c, 0x34070d0b, 0x34070d0b, },
            {0x43070a0a, 0x43070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x34070d0b, 0x34070d0b, 0x34070d0b, 0x33070c0a, 0x44070c0c, 0x34070d0b, 0x33070a0c, 0x34070d0b, 0x34070d0b, },
            {0x43070a0a, 0x43070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x34070d0b, 0x34070d0b, 0x34070d0b, 0x33070c0a, 0x34070d0b, 0x34070d0b, 0x33070a0c, 0x34070d0b, 0x34070d0b, },
            {0x43070a0a, 0x43070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x33070a0a, 0x34070d0b, 0x34070d0b, 0x34070d0b, 0x33070c0a, 0x44080d0c, 0x34070d0b, 0x33070a0c, 0x34070d0b, 0x34070d0b, }
        };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable[card_type][value08];
            REG_WR32(0x00100220, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable44719[16] =         {0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02442160, 0x02442160, 0x02442160, 0x02431150, 0x02432160, 0x02432160, 0x02331150, 0x02432160, 0x02442160, };
        static const U032 dataTable45395[16] =         {0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02442160, 0x02442160, 0x02442160, 0x02431150, 0x02432160, 0x02432160, 0x02432350, 0x02432160, 0x02442160, };
        static const U032 dataTable45509[16] =         {0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02442160, 0x02442160, 0x02442160, 0x02441150, 0x02442160, 0x02432160, 0x02432350, 0x02432160, 0x02442160, };
        static const U032 dataTable45599[16] =         {0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02211150, 0x02442160, 0x02442160, 0x02442160, 0x03542152, 0x03542152, 0x02432160, 0x02432350, 0x02432160, 0x02442160, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = (card_type == TypeGE2_6 ? dataTable45599 :
                      card_type == TypeGE2_4 ? dataTable45509 :
                      card_type == TypeGE2_3 ? dataTable45509 :
                      card_type == TypeGE2_0 ? dataTable44719 :
                                       dataTable45395)[value08];
            REG_WR32(0x00100224, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable44794[16] =         {0x000009ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000004ff, 0x000004ff, 0x000004ff, 0x0000089f, 0x000009ff, 0x000009ff, 0x000004ff, 0x000009ff, 0x0000027f, };
        static const U032 dataTable45470[16] =         {0x000009ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000004ff, 0x000004ff, 0x000004ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000004ff, 0x000009ff, 0x0000027f, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = (card_type == 0 ? dataTable44794 : dataTable45470)[value08];
            REG_WR32(0x00100228, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable44869[16] =         {0x11020044, 0x11020044, 0x11020044, 0x11020044, 0x11020044, 0x11020044, 0x11020044, 0x11220033, 0x11220033, 0x11220033, 0x11220033, 0x11220033, 0x11220033, 0x11220033, 0x11220033, 0x11220033, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable44869[value08];
            REG_WR32(0x000010c4, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable44944[16] =         {0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, 0x033783f0, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable44944[value08];
            REG_WR32(0x000010c8, word32);
        }
    }
/*
 * INIT_IO_FLAG_CONDITION
 */
/*
 * INIT_MACRO
 */
    if ( (card_type != TypeGE2_3) && (card_type != TypeGE2_4) && (card_type != TypeGE2_5) )
        REG_WR32(0x001002d4, 0x00000001);
/*
 * INIT_RESUME
 */
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable45024[16] =         {0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable45024[value08];
            REG_WR32(0x00100218, word32);
        }
    }
/*
 * INIT_IO_FLAG_CONDITION
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_NOT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x0010021c, 0x00000001);
/*
 * INIT_MACRO
 */
    if ( (card_type == TypeGE2_3) || (card_type == TypeGE2_4) )
        REG_WR32(0x001002d4, 0x00000001);
/*
 * INIT_IO_RESTRICT_PROG
 */
  if ( (card_type == TypeGE2_3) || (card_type == TypeGE2_4) )
  {
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable45898[16] =        {0xffffffff, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000002, 0x00000000, };
        static const U032 dataTable[16] =             {0xffffffff, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000001, 0x00000003, 0x00000000, 0x00000002, 0x00000000, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = (card_type == TypeGE2_5)?dataTable[value08]:dataTable45898[value08];
            REG_WR32(0x001002c4, word32);
        }
    }
  }
/*
 * INIT_RESUME
 */
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable45184[16] =         {0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000131, 0x00000131, 0x00000131, 0x00000131, 0x00000131, 0x00000031, 0x00000031, 0x00000031, 0x00000031, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable45184[value08];
            REG_WR32(0x001002c0, word32);
        }
    }
/*
 * INIT_IO_FLAG_CONDITION
 */
 if ( (card_type != TypeGE2_3) && (card_type != TypeGE2_4) && (card_type != TypeGE2_5) && (card_type != TypeGE2_6) )
 {
/*
 * INIT_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d0, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d0, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d0, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d0, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d0, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d0, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d0, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d0, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d4, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d4, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d4, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_NOT
 */
 } else { /* card_type == TypeGE2_3 || card_type == TypeGE2_4 || card_type == TypeGE2_5 || card_type == TypeGE2_6 */
/*
 * INIT_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d4, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d0, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d0, 0x00000001);
/*
 * INIT_END_REPEAT
 */
 }
/*
 * INIT_RESUME
 */
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable45283[16] =         {0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000031, 0x00000031, 0x00000031, 0x00000131, 0x00000131, 0x00000131, 0x00000031, 0x00000131, 0x00000031, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable45283[value08];
            REG_WR32(0x001002c0, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable45358[16] =         {0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable45358[value08];
            REG_WR32(0x00100210, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable45433[16] =         {0x00000000, 0x1c000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02000000, 0x02000000, 0x02000000, 0x02000000, 0x02000000, 0x02000000, 0x02000000, 0x02000000, 0x02000000, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable45433[value08];
            REG_WR32(0x000010d4, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        static const U032 dataTable45508[16] =         {0x00020000, 0x00020000, 0x00020000, 0x00020000, 0x00020000, 0x00020000, 0x00020000, 0x00020000, 0x00020000, 0x00020000, 0x00020000, 0x00020000, 0x00020000, 0x00020000, 0x00020000, 0x00020000, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable45508[value08];
            REG_WR32(0x00100080, word32);
        }
    }
/*
 * Process Script # 6
 */
/*
 * INIT_COMPUTE_MEM
 */
//    init_COMPUTE_Memory(MMIO);
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x000c03c4, 0x00000001, 0xdf, 0x00 );
/*
 * INIT_PLL
 */
    /* Program PClock */
    {
        U032 mOld, nOld, pOld;
        PostClockParameters cp;
        U032 mnNew, mnpNew;
        U032 coeff;
        int Loops;
        BOOL IsPllLocked;

//        CalcMNP( CrystalFreq, 3600, &cp );
        CalcMNP( 3600, CrystalFreq, &cp );

        /* Retrieve Current coefficients */
        coeff = REG_RD32(0x00680508);
        mOld = (coeff >> 0x00000000) & 0x000000ff;
        nOld = (coeff >> 0x00000008) & 0x000000ff;
        pOld = (coeff >> 0x00000010) & 0x00000007;
        /* If p decreates then be careful */
        if (cp.nP < pOld)
        {
            /* Write M and N first */
            mnNew = ((cp.nM & 0x000000ff) << 0x00000000) | ((cp.nN & 0x000000ff) << 0x00000008) | ((cp.nP & 0x00000007) << 0x00000010);
            REG_WR32(0x00680508, mnNew);
            /* Wait until PLL is locked */
            IsPllLocked = FALSE;
            for (Loops = 100; Loops; --Loops)
            {
                if (((REG_RD32(0x00680514) >> 0x0000001f) & 0x00000001) == 0x00000001)
                {
                    /* Check again to make sure */
                    if (((REG_RD32(0x00680514) >> 0x0000001f) & 0x00000001) == 0x00000001)
                    {
                        IsPllLocked = TRUE;
                        break;
                    }
                }
                Delay(1); // Delay 1ms
            }
        }
        /* Now Write the final value */
        mnpNew = ((cp.nM & 0x000000ff) << 0x00000000) | ((cp.nN & 0x000000ff) << 0x00000008) | ((cp.nP & 0x00000007) << 0x00000010);
        REG_WR32(0x00680508, mnpNew);
    }
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00001088, 0x00000000, 0x000011f0 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x0000108c, 0x00000000, 0x000000d1 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00680880, 0xdfffffff, card_type == TypeGE2_4 ? 0x30000000 :card_type == TypeGE2_3 ? 0x30000000 : 0x10000000 );
  if ( (card_type == TypeGE2_3) || (card_type == TypeGE2_4) )
  {
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00682880, 0x01101111, 0x20000000 );
/*
 * INIT_TIME
 */
    Delay(15);
  }
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00680610, 0x00000000, 0x00000000 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00682610, 0x00000000, 0x00000000 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000038, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000001a, 0x00, 0x3f );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000028, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000033, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000021, 0x00, 0xfa );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000002b, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000002c, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003a, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003b, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000004a, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000004b, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000004c, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000044, 0x00, 0x03 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000002b, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000002c, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003a, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003b, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000004a, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000004b, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000004c, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000044, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000052, 0x00, 0x04 );
/*
 * Process Script # 7
 */
 if ( (card_type == TypeGE2_3) ||  (card_type == TypeGE2_4) )
 {
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x001002c0, 0x00000000, 0x00000030 );
 }

   }
    else
    {        // GeForce4 script
#define DelayUs Delay    
/*
 * Process Script # 0
 */
/*
 * INIT_RESET
 */
    /* Save and toggle the AGP command register (don't disturb the FW enable) */
    saveValue = REG_RD32(0x0000184c);
    REG_WR32(0x0000184c, saveValue & 0xfffffcff);
    /* turn engines off */
    REG_WR32(0x00000200, 0x03000000);
    /* turn engines on */
    REG_WR32(0x00000200, 0x17111112);
    /* restore AGP command register */
    REG_WR32(0x0000184c, saveValue);
    /* set access to the ROM thru instance mem */
    data32 = REG_RD32(0x00001850);
    data32 = (data32 & 0xfffffffe) | 0x00000000;
    REG_WR32(0x00001850, data32);
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00101000, 0xfffffdff, 0x80000400 );
/*
 * INIT_CONDITION
 */
/*
 * INIT_ZM_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, 0x00, 0x01 );
/*
 * INIT_NOT
 */
/*
 * INIT_ZM_INDEX_IO
 */
/*
 * INIT_RESUME
 */
/*
 * INIT_COPY
 */
    srcValue = REG_RD32(0x00101000);
    srcValue <<= 0x00000002;
    tempValue = srcValue & 0x000000f0;
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    value08 = (value08 & 0x0f) | tempValue; //FIXFIX
    DvWritePort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, value08 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000035, 0xfd, 0x01 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, 0xf7, 0x08 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00000200, 0x00000000, 0x17011113 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x000c03c4, 0x00000001, 0xff, 0x20 );
/*
 * INIT_PLL
 */
    /* Program NVClock */
    programNVClk( MMIO, 10000, CrystalFreq, card_type );
/*
 * INIT_IO_FLAG_CONDITION
 */
/*
 * INIT_PLL
 */
/*
 * INIT_NOT
 */
/*
 * INIT_NV_REG
 */
/*
 * INIT_PLL
 */
    /* Program MClock */
    programMClk( MMIO, 32000, CrystalFreq, card_type );
/*
 * INIT_RESUME
 */
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x000010b0, 0x0000000f, 0x0413021a );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x000010b4, 0x00000000, 0xee000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x000010b8, 0x00000000, 0x01013131 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x000010bc, 0x0000000f, 0xff010000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x000010cc, 0x00000000, 0x00000022 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x000010d4, 0xff00000f, 0x00000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00001580, 0xfffffeff, 0x00000000 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x000010e8, 0x00000000, 0x00011103 );
/*
 * INIT_TIME
 */
    DelayUs(/*2*/1);
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x0068050c, 0x00000000, 0x00000700 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x0068050c, 0x00000000, 0x00000500 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00000140, 0x00000000, 0x00000000 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00000200, 0x00000000, 0x17111113 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x000010e0, 0x00000000, 0x80808080 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x000010e4, 0x00000000, 0x00808080 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00001084, 0x00000000, 0x00205749 );
/*
 * Process Script # 1
 */
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x001002e0, 0x00000000, 0x00000000 );
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable54878[16] =         {0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable54878[value08];
            REG_WR32(0x00100210, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable54953[16] =         {0x08b10010, 0x08c10011, 0x08c10011, 0x08c10011, 0x08c10011, 0x08c10011, 0x09c10010, 0x08b10011, 0x08b11011, 0x08b10011, 0x08c10001, 0x09c10001, 0x08c10011, 0x08c10011, 0x08c10011, 0x08c11011, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable54953[value08];
            REG_WR32(0x00100200, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable55028[16] =         {0x44090c0c, 0x33070a0a, 0x44090c0c, 0x44090c0c, 0x44090c0c, 0x44090c0c, 0x44090c0c, 0x550a110f, 0x44080e0c, 0x44080e0c, 0x44090c0c, 0x44080d0c, 0x44090c0c, 0x42080e0c, 0x44090c0c, 0x44080e0c, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable55028[value08];
            REG_WR32(0x00100220, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable55103[16] =         {0x03322260, 0x02302261, 0x03322260, 0x03322260, 0x03322260, 0x03322260, 0x03322260, 0x04452152, 0x02442152, 0x02442152, 0x03322260, 0x03542152, 0x03322260, 0x04452152, 0x03322260, 0x02442152, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable55103[value08];
            REG_WR32(0x00100224, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable55178[16] =         {0x000009ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000009ff, 0x000005ff, 0x0000043f, 0x0000043f, 0x000009ff, 0x000005ff, 0x000009ff, 0x000005ff, 0x000009ff, 0x0000043f, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable55178[value08];
            REG_WR32(0x00100228, word32);
        }
    }
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x000010c4, 0x00000000, 0x3333a2a2 );
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable55262[16] =         {0x66676199, 0x66676199, 0x66676199, 0x66676199, 0x66676199, 0x66676199, 0x66676199, 0x66676199, 0x66676199, 0x66676199, 0x66676199, 0x66676199, 0x66676199, 0x66676199, 0x66676199, 0x66676199, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable55262[value08];
            REG_WR32(0x000010c8, word32);
        }
    }
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00001214, 0x00000000, 0x88888888 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00001210, 0x00000000, 0x00000000 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x0000122c, 0x00000000, 0xffffffff );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x0000123c, 0x00000000, 0xffffffff );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00001234, 0x00000000, 0x44444444 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00001240, 0x00000000, 0xf2f2f2f2 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00001248, 0x00000000, 0xaaaaaaaa );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00001244, 0x00000000, 0xffffffff );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00001230, 0x00000000, 0xffffffff );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00001238, 0x00000000, 0x33333333 );
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable55427[16] =         {0xf0000100, 0xf0000100, 0xf0000100, 0xf0000100, 0xf0000100, 0xf0000100, 0xf0000100, 0xf0000001, 0xf0000000, 0xf0000000, 0xf0000000, 0x30010001, 0xf0000000, 0xf0000001, 0xf0000000, 0xf0000000, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable55427[value08];
            REG_WR32(0x00001218, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable55502[16] =         {0x00007777, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable55502[value08];
            REG_WR32(0x000010d8, word32);
        }
    }
/*
 * INIT_IO_FLAG_CONDITION
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_RESUME
 */
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00100218, 0x00000000, 0x00000100 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x0010021c, 0x00000000, 0x00000001 );
/*
 * INIT_TIME
 */
    DelayUs(/*200*/1);
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable55603[16] =         {0x00000101, 0x00000101, 0x00000101, 0x00000101, 0x00000101, 0x00000101, 0x00000101, 0x00000101, 0x00000101, 0x00000101, 0x00000101, 0x00000101, 0x00000101, 0x00000101, 0x00000101, 0x00000101, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable55603[value08];
            REG_WR32(0x00100218, word32);
        }
    }
/*
 * INIT_TIME
 */
    DelayUs(/*2*/1);
/*
 * INIT_IO_FLAG_CONDITION
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_NOT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x0010021c, 0x00000001);
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d4, 0x00000001);
/*
 * INIT_TIME
 */
    DelayUs(2/*000*/);
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable55693[16] =         {0xffffffff, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000042, 0x00000002, 0x00000002, 0x00000000, 0x00010002, 0x00000003, 0x00000042, 0x00000002, 0x00000002, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable55693[value08];
            REG_WR32(0x001002c4, word32);
        }
    }
/*
 * INIT_TIME
 */
    DelayUs(2/*000*/);
/*
 * INIT_RESUME
 */
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable55772[16] =         {0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000031, 0x00000131, 0x00000131, 0x00000131, 0x00000131, 0x00000031, 0x00000031, 0x00000031, 0x00000131, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable55772[value08];
            REG_WR32(0x001002c0, word32);
        }
    }
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002c0, 0xfffffeff, 0x00000100 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002c0, 0xfffffeff, 0x00000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002c0, 0xfffffeff, 0x00000100 );
/*
 * INIT_TIME
 */
    DelayUs(2/*000*/);
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d4, 0x00000001);
/*
 * INIT_TIME
 */
    DelayUs(2/*000*/);
/*
 * INIT_IO_FLAG_CONDITION
 */
/*
 * INIT_REPEAT
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_REPEAT
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_NOT
 */
/*
 * INIT_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d4, 0x00000001);
/*
 * INIT_END_REPEAT
 */
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d0, 0x00000001);
/*
 * INIT_TIME
 */
    DelayUs(2/*000*/);
/*
 * INIT_MACRO
 */
    REG_WR32(0x001002d0, 0x00000001);
/*
 * INIT_TIME
 */
    DelayUs(2/*000*/);
/*
 * INIT_RESUME
 */
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable55923[16] =         {0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000131, 0x00000031, 0x00000031, 0x00000030, 0x00000131, 0x00000030, 0x00000131, 0x00000030, 0x00000031, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable55923[value08];
            REG_WR32(0x001002c0, word32);
        }
    }
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002c0, 0xfffffeff, 0x00000100 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002c0, 0xfffffeff, 0x00000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002c0, 0xfffffeff, 0x00000100 );
/*
 * INIT_TIME
 */
    DelayUs(2/*000*/);
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable56040[16] =         {0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable56040[value08];
            REG_WR32(0x00100210, word32);
        }
    }
/*
 * INIT_IO_RESTRICT_PROG
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &value08 );
    {
        unsigned int dataTable56115[16] =         {0x00000000, 0x1c000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0c000000, 0x02000000, 0x02000000, 0x02000000, 0x02000000, 0x02000000, 0x02000000, 0x02000000, 0x02000000, 0x02000000, };
        value08 = (value08 & 0xf0) >> 0x00000004;
        if (value08 < 16)
        {
            word32 = dataTable56115[value08];
            REG_WR32(0x000010d4, word32);
        }
    }
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00100080, 0x00000000, 0x00020000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00100218, 0xfffffeff, 0x00000000 );
/*
 * Process Script # 2
 */
/*
 * INIT_COMPUTE_MEM
 */
//    init_COMPUTE_Memory(MMIO);
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00001088, 0x00000000, 0x000011f0 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x0000108c, 0x00000000, 0x000000d1 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00001098, 0xffffffff, 0x00040000 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000038, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000001a, 0x00, 0xbf );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000028, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000033, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000021, 0x00, 0xfa );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000002b, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000002c, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003a, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003b, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000004a, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000004b, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000004c, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000043, 0x00, 0x01 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000044, 0x00, 0x03 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000021, 0x00, 0xfa );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000002b, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000002c, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003a, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003b, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000004a, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000004b, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000004c, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000043, 0x00, 0x01 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000044, 0x00, 0x00 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x00000052, 0x00, 0x04 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x0060081c, 0xffcfffff, 0x80100000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x0060281c, 0xffcfffcc, 0x00200022 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00001864, 0xfffffffc, 0x00000000 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00680404, 0x00000000, 0x00000000 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x00100090, 0x00000000, 0xefffcfe0 );
/*
 * INIT_ZM_REG
 */
    InitReg( MMIO, 0x0010022c, 0x00000000, 0x00000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x0068052c, 0xfffffeff, 0x00000001 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x0068252c, 0xffffffff, 0x00000101 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00680528, 0xffffffff, 0x40000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00001584, 0xfff00000, 0x00000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002c0, 0xfffffeff, 0x00000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002c0, 0xffffffff, 0x00000100 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002e0, 0xffffffff, 0x00000001 );
/*
 * INIT_INDEX_ADDRESS_LATCHED
 */
    {
        U032    word32, data32;
        U008 dataTable[][2] = {{0x3a, 0x80}, {0x2f, 0xff}, };
        for ( word32 = 0; word32 < 2; word32++)
        {
            REG_WR32(0x006808b4, dataTable[word32][1]);
            data32 = REG_RD32(0x006808b0);
            data32 &= 0x00000000;
            data32 |= 0x00000000;
            data32 |= dataTable[word32][0];
            REG_WR32(0x006808b0, data32);
        }
    }
/*
 * INIT_INDEX_ADDRESS_LATCHED
 */
    {
        U032    word32, data32;
        U008 dataTable[][2] = {{0x3a, 0x81}, };
        for ( word32 = 0; word32 < 1; word32++)
        {
            REG_WR32(0x006808bc, dataTable[word32][1]);
            data32 = REG_RD32(0x006808b8);
            data32 &= 0x00000000;
            data32 |= 0x00000000;
            data32 |= dataTable[word32][0];
            REG_WR32(0x006808b8, data32);
        }
    }
/*
 * INIT_INDEX_ADDRESS_LATCHED
 */
    {
        U032    word32, data32;
        U008 dataTable[][2] = {{0x2f, 0xff}, };
        for ( word32 = 0; word32 < 1; word32++)
        {
            REG_WR32(0x006828b4, dataTable[word32][1]);
            data32 = REG_RD32(0x006828b0);
            data32 &= 0x00000000;
            data32 |= 0x00000000;
            data32 |= dataTable[word32][0];
            REG_WR32(0x006828b0, data32);
        }
    }
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00680880, 0xcfffffff, 0x30000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x00682880, 0xcfffffff, 0x30000000 );
/*
 * INIT_TIME
 */
    DelayUs(15/*000*/);
/*
 * Process Script # 3
 */
/*
 * INIT_IO_RESTRICT_PLL
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &freqIndex );
    freqIndex = (freqIndex & 0xf0) >> 0x00000004;
    doubleFlag = 0;
    if (freqIndex < 16)
    {
        unsigned short freqTable56218[16] = {0x4e20, 0x61a8, 0x4e20, 0x4e20, 0x4e20, 0x4e20, 0x61a8, 0x4e20, 0x6978, 0x4e20, 0x61a8, 0x61a8, 0x4e20, 0x4e20, 0x4e20, 0x6978, };
        unsigned int freq = freqTable56218[freqIndex];
        freq = (doubleFlag) ? freq * 2 : freq;
        /* Program NVClock */
        programNVClk( MMIO, freq, CrystalFreq, card_type );
    }
/*
 * INIT_IO_RESTRICT_PLL
 */
    DvReadPort( MMIO, 0x006013d4 + getCRTCIndex(MMIO), 0x0000003c, &freqIndex );
    freqIndex = (freqIndex & 0xf0) >> 0x00000004;
    doubleFlag = 0;
    doubleFlag = 1;
    if (freqIndex < 16)
    {
        unsigned short freqTable56262[16] = {0x2710, 0x8214, 0x2710, 0x2710, 0x2710, 0x2710, 0x40d8, 0x36b0, 0x36b0, 0x36b0, 0x40d8, 0x40d8, 0x2710, 0x36b0, 0x2710, 0x36b0, };
        unsigned int freq = freqTable56262[freqIndex];
        freq = (doubleFlag) ? freq * 2 : freq;
        /* Program MClock */
        programMClk( MMIO, freq, CrystalFreq, card_type );
    }
/*
 * Process Script # 4
 */
/*
 * INIT_IO_FLAG_CONDITION
 */
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002c4, 0xffffffff, 0x00000002 );
/*
 * INIT_TIME
 */
    DelayUs(64/*000*/);
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002c0, 0xfffffeff, 0x00000000 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002c0, 0xffffffff, 0x00000100 );
/*
 * INIT_NV_REG
 */
    InitReg( MMIO, 0x001002c0, 0xfffffeff, 0x00000000 );
/*
 * INIT_INDEX_IO
 */
    IOWrite( MMIO, 0x000c03c4, 0x00000001, 0xdf, 0x00 );
/*
 * INIT_RESUME
 */
    }
/*
 * Process Script # 8
 */
/*
 * Lock Extended CRTC registers
 */
    REG_WR08(0x006013d4, 0x1f);
    REG_WR08(0x006013d5, lock);
/*
 * Enable shadowing of BIOS
 */
    data32 = REG_RD32(0x00001850);
    data32 = (data32 & 0xfffffffe) | 0x00000001;
    REG_WR32(0x00001850, data32);
    IRQ_On(enable);

}

