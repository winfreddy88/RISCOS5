;
; Copyright (c) 2012, RISC OS Open Ltd
; Copyright (c) 2012, Adrian Lees
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;
; With many thanks to Broadcom Europe Ltd for releasing the source code to
; its Linux drivers, thus making this port possible.
;


        [ :LNOT: :DEF: BCM2835_Hdr
        GBLL BCM2835_Hdr

          ; Debugging in the serial port (HAL_DebugTX, HAL_DebugRX)
          GBLL    Debug
Debug     SETL    {FALSE}

          ; Debug messages from the HAL itself
          GBLL    HALDebug
HALDebug  SETL    {FALSE} :LAND: Debug

          ; Enable JTAG support
          ;
          ; This reconfigures GPIO22-27 into alt4 mode, which maps the ARM JTAG
          ; signals to the following pins on the 40-pin GPIO header that's
          ; found on the B+ and later models:
          ;
          ; GPIO22  ARM_TRST  pin 15
          ; GPIO23  ARM_RTCK  pin 16
          ; GPIO24  ARM_TDO   pin 18
          ; GPIO25  ARM_TCK   pin 22
          ; GPIO26  ARM_TDI   pin 37
          ; GPIO27  ARM_TMS   pin 13
          ;
          ; If you want to debug an older board then you'll have to adjust the
          ; code accordingly (n.b. revision 1 boards for Pi 1B only have ARM_TDI
          ; available via the camera header, which will be awkward to get
          ; access to)
          ;
          ; As a precaution, this setting will also disable registration of the
          ; GPIO HAL device
          GBLL    JTAG
JTAG      SETL    {FALSE}

; RPi ARM11 registers

; 4Gbytes of address space.
; 00000000-0000001F reserved for exception vectors
; FFFFE000-FFFFFFFF allocated to control registers

; Bus memory map, for direct DMA access to devices
; 7e000000-7effffff I/O peripherals for DMA access
; c0000000-???????? SDRAM physical for DMA

; Our physical memory map:
; 00000000-???????? SDRAM  upper bound set at boot
; 20000000-20ffffff IO_Base for peripherals
; 3fffffff          top of physical memory space

; Address window 0 is set to 4K and points to a single page of HAL workspace for the messaging
; unit.


;ROM_Base        *       &00000000
IO_Base_BCM2835     *   &20000000
IO_Base_BCM2836     *   &3F000000           ; it moves in Pi 2
IO_Size         *       &01000000
RAM_Base        *       &00000000           ; try off bottom
Boot_RAM_Base   *       &00000000
DMA_RAM_Base    *       &C0000000           ; base physical address of ram for DMA purposes
GPU_UnCached    *       &c0000000           ; GPU mempry mapping uncached
GPU_L2Conly     *       &80000000           ; GPU L2 Cached (only)
GPU_L2CnonAl    *       &40000000           ; GPU L2 cached non allocating coherent
GPU_L1L2Cac     *       &00000000           ; both L1 and L2 cached GPU side
GPU_CacheMask   *       &c0000000

; Exit CC if ARM11, CS if A7/A53
        MACRO
$label  CPUDetect $reg
$label  MRC     p15, 0, $reg, c0, c0, 0  ; read Main ID Register
        AND     $reg, $reg, #&FF00
        CMP     $reg, #&C000             ; xxxxB76x for ARM1176, xxxxC07x for Cortex-A7
        MEND

; Acquire/release the HAL spinlock
; This is mainly for quad-core devices, but will work with ARMv6 too
        MACRO
        AcquireSpinlock ; Corrupts ip, NZ, stashes old PSR on stack
        MRS     ip, CPSR
        Push    "ip"
        ADD     sb, sb, #:INDEX:Spinlock
        CPSID   if
10
        LDREX   ip, [sb]
        TEQ     ip, #0
        WFENE
        STREXEQ ip, sb, [sb]
        TEQEQ   ip, #0
        BNE     %BT10
        MCR     p15, 0, ip, c7, c10, 5  ; a.k.a DoMemBarrier, but ip already 0
        SUB     sb, sb, #:INDEX:Spinlock
        MEND

        MACRO
        ReleaseSpinlock ; Corrupts ip
        MOV     ip, #0
        MCR     p15, 0, ip, c7, c10, 5  ; a.k.a DoMemBarrier, but ip already 0
        STR     ip, Spinlock            ; Clear spinlock before barrier
        MCR     p15, 0, ip, c7, c10, 4  ; a.k.a DataSyncBarrier, but ip already 0
        SEV
        Pull    "ip"
        MSR     CPSR_c, ip
        MEND

;
; Timer details
;
TIMER_RATE      *       1000000            ; 1MHz

                GBLA    NumTimers
NumTimers       SETA    0

        MACRO
        DeclareTimer    $phys
TimerPhysFromLog$NumTimers      *       $phys
NumTimers                       SETA    NumTimers + 1
        MEND

; List of physical timers (excluding those already used by VideoCore)
; in the order we use them for logical timers
        DeclareTimer 1
        DeclareTimer 3

; An assembly-time variable for looping over all logical timers, since
; the available timers might vary with version of start.elf
        GBLA    Timer


;
; Mailbox
;
; There are two mailboxes; we write to mailbox 1 and read from mailbox 0
;
MB_Base        *       &0000b800     ; offset from IO space start
MB_DBell0      *       &40           ; doorbell 0 (VCHIQ VC -> ARM)
MB_DBell1      *       &44           ; doorbell 1
MB_DBell2      *       &48           ; doorbell 2 (VCHIQ ARM -> VC)
MB_DBell3      *       &4c           ; doorbell 3
MB_ChRd        *       &80           ; normal read - offset from MB_Base
MB_ChWr        *       &a0           ; normal write
MB_ChRWTop     *       &8c           ; 4 word read or write
MB_Pol         *       &90           ; NonPOP read
MB_Snd         *       &94           ; sender read (bottom 2 bits)
MB_Sta         *       &98           ; status read
MB_Cnf         *       &9c           ; config r/w
;
; mailbox register bits
;
; MB_Sta
MB_Sta_Full    *       &80000000     ; mailbox full
MB_Sta_Empty   *       &40000000     ; mailbox empty
MB_Sta_Level   *       &000000ff     ; mailbox content count
; MB_Cnf
MB_Cnf_HDIrqEn *       &00000001     ; mailbox has-data irq enable
MB_Cnf_HSIrqEn *       &00000002     ; mailbox has-space irq enable
MB_Cnf_OpIrqEn *       &00000004     ; mailbox Opp irq en
MB_Cnf_MBClr   *       &00000008     ; write 1 then 0 to clear mailbox
MB_Cnf_HDIrq   *       &00000010     ; mailbox has-data irq pending
MB_Cnf_HSIrq   *       &00000020     ; mailbox has-space irq pending
MB_Cnf_OpIrq   *       &00000040     ; mailbox Opp irq pending
; these flags are reset on any write to this register
MB_Cnf_ErNone  *       &00000100     ; none read error
MB_Cnf_ErWFull *       &00000200     ; Write to full mailbox
MB_Cnf_ErREmty *       &00000400     ; read from empty mailbox

; mem barrier operation; ensures all explicit mem operations completed before
; instruction exits.
; (value 4 is all instructions, value 5 is just mem instructions)
; zeroes $r
        MACRO
$label  DataSyncBarrier $r, $cond
$label  MOV$cond $r, #0
      [ {UAL}
        MCR$cond p15, #0, $r, c7, c10, #4
      |
        MCR$cond p15, 0, $r, c7, c10,4
      ]
        MEND
        MACRO
$label  DoMemBarrier $r, $cond
$label  MOV$cond $r, #0
      [ {UAL}
        MCR$cond p15, #0, $r, c7, c10, #5
      |
        MCR$cond p15, 0, $r, c7, c10,5
      ]
        MEND

        MACRO
$label  FlushDataCacheV6 $tmp
$label  MOV     $tmp, #0
        MCR     p15, 0, $tmp, c7, c14, 0        ; clean and invalidate entire data cache
        MEND

        MACRO
$label  FlushDataCacheV7 $clidr, $loc, $level, $ccsidr, $linelen, $way, $wayshift, $set, $tmp
$label  MRC     p15, 1, $clidr, c0, c0, 1       ; read CLIDR
        ANDS    $loc, $clidr, #&07000000
        MOV     $loc, $loc, LSR #23             ; extract level of coherence * 2
        BEQ     %F99                            ; nothing to do if loc = 0
        MOV     $level, #0                      ; cache level * 2
10      ADD     $tmp, $level, $level, LSR #1    ; cache level * 3
        MOV     $tmp, $clidr, LSR $tmp
        AND     $tmp, $tmp, #7
        CMP     $tmp, #2
        BLT     %FT40                           ; no cache or only instruction cache at this level
        MCR     p15, 2, $level, c0, c0, 0       ; write CSSELR
        ISB                                     ; sync the change to the CCSIDR
        MRC     p15, 1, $ccsidr, c0, c0, 0      ; read current CCSIDR
        AND     $linelen, $ccsidr, #7           ; extract the line length field
        ADD     $linelen, $linelen, #4          ; add 4 for the line length offset (log2 16 bytes)
        UBFX    $way, $ccsidr, #3, #10          ; associativity aka number of ways
        CLZ     $wayshift, $way
20      UBFX    $set, $ccsidr, #13, #15         ; number of sets
30      ORR     $tmp, $level, $way, LSL $wayshift
        ORR     $tmp, $tmp, $set, LSL $linelen
        MCR     p15, 0, $tmp, c7, c14, 2        ; data cache clean and invalidate by set/way
        SUBS    $set, $set, #1
        BGE     %BT30
        SUBS    $way, $way, #1
        BGE     %BT20
        DSB                                     ; Cortex-A7 errata 814220: DSB required when changing cache levels when using set/way operations. This also counts as our end-of-maintenance DSB.
40      ADD     $level, $level, #2
        CMP     $level, $loc
        BLT     %BT10
99
        MEND

        MACRO
$label  FlushDataCache
$label  CPUDetect lr
        BCS     %FA07
        FlushDataCacheV6 lr
        B       %FT99
07      STMFD   r13!, {r4-r9}
        FlushDataCacheV7 r2,r3,r4,r5,r6,r7,r8,r9,lr
        LDMFD   r13!, {r4-r9}
99
        MEND
      
        MACRO
$label  FlushDataCacheRange $startaddr,$endaddr,$cond
$label  BIC$cond $startaddr, $startaddr, #&1f
        BIC$cond $endaddr,   $endaddr,   #&1f
      [ {UAL}
        MCRR$cond p15, #0, $endaddr, $startaddr, c14
      |
        MCRR$cond p15, 0, $endaddr, $startaddr, c14
      ]
        MEND

; Board revision values (pre Pi 2), enumerated scheme
; Ref: https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md
BoardRevision_AorB256_First  * &2          ; } Either an A or B
BoardRevision_AorB256_Last   * &9          ; } various manufacturers
BoardRevision_AorB512_First  * &D          ; } Either an A or B
BoardRevision_AorB512_Last   * &F          ; } various manufacturers
BoardRevision_AorB_First     * &2          ; } Either an A or B, 256MB or 512MB
BoardRevision_AorB_Last      * &F          ; } and various manufacturers
BoardRevision_BPlus_Sony     * &10         ; Significant board revisions
BoardRevision_Compute_Sony   * &11
BoardRevision_APlus_Sony     * &12
BoardRevision_BPlus_Embest   * &13
BoardRevision_Compute_Embest * &14
BoardRevision_APlus_Embest   * &15

; Board revision values (Pi 2 and later), bitfield scheme
BoardRevision_User_Shift    *  24
BoardRevision_User_Mask     * 255 :SHL: BoardRevision_User_Shift
BoardRevision_Warranty      *   1 :SHL: 25 ; if set, warranty void (Pi 2 and later)
BoardRevision_WarrantyOld   *   1 :SHL: 24 ; if set, warranty void (pre Pi 2)
BoardRevision_NewScheme     *   1 :SHL: 23 ; if set, indicates the following are in use
BoardRevision_Mem_Shift     *  20
BoardRevision_Mem_Mask      *   7 :SHL: BoardRevision_Mem_Shift
BoardRevision_Mem_256M      *   0 :SHL: BoardRevision_Mem_Shift
BoardRevision_Mem_512M      *   1 :SHL: BoardRevision_Mem_Shift
BoardRevision_Mem_1G        *   2 :SHL: BoardRevision_Mem_Shift
BoardRevision_Manuf_Shift   *  16
BoardRevision_Manuf_Mask    *  15 :SHL: BoardRevision_Manuf_Shift
BoardRevision_Manuf_Sony    *   0 :SHL: BoardRevision_Manuf_Shift
BoardRevision_Manuf_Egoman  *   1 :SHL: BoardRevision_Manuf_Shift
BoardRevision_Manuf_Embest  *   2 :SHL: BoardRevision_Manuf_Shift
BoardRevision_Manuf_SonyJP  *   3 :SHL: BoardRevision_Manuf_Shift
BoardRevision_Manuf_Embest2 *   4 :SHL: BoardRevision_Manuf_Shift
BoardRevision_Proc_Shift    *  12
BoardRevision_Proc_Mask     *  15 :SHL: BoardRevision_Proc_Shift
BoardRevision_Proc_2835     *   0 :SHL: BoardRevision_Proc_Shift
BoardRevision_Proc_2836     *   1 :SHL: BoardRevision_Proc_Shift
BoardRevision_Proc_2837     *   2 :SHL: BoardRevision_Proc_Shift
BoardRevision_Model_Shift   *   4
BoardRevision_Model_Mask    * 255 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_A       *   0 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_B       *   1 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_APlus   *   2 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_BPlus   *   3 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_B2      *   4 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_Compute *   6 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_B3      *   8 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_Zero    *   9 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_Compute3 * 10 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_ZeroW   *  12 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_B3Plus  *  13 :SHL: BoardRevision_Model_Shift
BoardRevision_Model_A3Plus  *  14 :SHL: BoardRevision_Model_Shift
BoardRevision_Rev_Shift     *   0
BoardRevision_Rev_Mask      *  15 :SHL: BoardRevision_Rev_Shift

; GPIO register set
GPIO_Base    *        &00200000      ; base offset of GPIO regs
GPFSel0      *        &0             ; function sel 0
GPFSel1      *        &4             ; function sel 1
GPFSel2      *        &8             ; function sel 2
GPFSel3      *        &c             ; function sel 3
GPFSel4      *        &10            ; function sel 4
GPFSel5      *        &14            ; function sel 5
GPSet0       *        &1c            ; GPIO Set 0
GPSet1       *        &20            ; GPIO Set 1
GPClr0       *        &28            ; GPIO Clear 0
GPClr1       *        &2c            ; GPIO Clear 1
GPLev0       *        &34            ; GPIO Level 0
GPLev1       *        &38            ; GPIO Level 1
GPPEDS0      *        &40            ; GPIO Pin Event Detect Status 0
GPPEDS1      *        &44            ; GPIO Pin Event Detect Status 1
GPREDE0      *        &4c            ; GPIO rising edge detect enable 0
GPREDE1      *        &50            ; GPIO rising edge detect enable 1
GPFEDE0      *        &58            ; GPIO falling edge detect enable 0
GPFEDE1      *        &5c            ; GPIO falling edge detect enable 1
GPHIDE0      *        &64            ; GPIO High detect enable 0
GPHIDE1      *        &68            ; GPIO High detect enable 1
GPLODE0      *        &70            ; GPIO Low detect enable 0
GPLODE1      *        &74            ; GPIO Low detect enable 1
GPAREDE0     *        &7c            ; GPIO Async rising edge detect enable 0
GPAREDE1     *        &80            ; GPIO Async rising edge detect enable 1
GPAFEDE0     *        &88            ; GPIO Async falling edge detect enable 0
GPAFEDE1     *        &8c            ; GPIO Async falling edge detect enable 1
GPPUPDEN     *        &94            ; GPIO PullUp PullDown Enable
GPPUDCK0     *        &98            ; GPIO PullUp PullDown Clock 0
GPPUDCK1     *        &9c            ; GPIO PullUp PullDown Clock 1

; Auxio peripherals
; MiniUart uses TXD1 and RXD1
; txd1 is GPIO14 alt 5  (010)
; rxd1 is GPIO15 alt 5
; rts1 is GPIO17 alt 5
AUXIO_Base   *        &00215000      ; base of auxio regs
AUXIRQ       *        &0             ; IRQ status
AUXEnables   *        &4             ; AUX enables
AUXMUIO      *        &40            ; MiniUart IO data
AUXMUIER     *        &44            ; MU int enable
AUXMUIIR     *        &48            ; MU int identify
AUXMULCR     *        &4c            ; MU Line Control
AUXMUMCR     *        &50            ; MU Modem Control
AUXMULSR     *        &54            ; MU Line Status
AUXMUMSR     *        &58            ; MU Control Status
AUXMUSCRATCH *        &5c            ; MU Scratch reg
AUXMUCNTL    *        &60            ; MU extra control
AUXMUSTAT    *        &64            ; MU extra status
AUXMUBAUD    *        &68            ; MU Baud rate

AUXSPI0      *        &80            ; Aux SPI0 (aka SPI1) base
AUXSPI1      *        &C0            ; Aux SPI1 (aka SPI2) base
AUXSPICNTL0  *        &0             ; Aux API control 0
AUXSPICNTL1  *        &4             ; Aux SPI control 1
AUXSPISTAT   *        &8             ; Aux API status
AUXSPIIO     *        &10            ; Aux API data
AUXSPIPEEK   *        &14            ; Aux SPI PEEK


; UART TXD0 RXD0
; txd0 is GPIO14 alt 0  (100)
; rxd0 is GPIO15 alt 0
UART_Base    *        &00201000      ; base of uart regs
UART1_offset *        &00004000      ; offset to base of uart1 regs
                                     ; mini uart (above)
UARTDR       *        &0             ; data reg
UARTRSRECR   *        &4             ;
UARTFLAG     *        &18            ;
UARTIBRD     *        &24            ; int baud reg
UARTFBRD     *        &28            ; fract baud reg
UARTLCRH     *        &2c            ; Line Control
UARTCR       *        &30            ; Control Reg
UARTIFLS     *        &34            ; Int FIFO Level
UARTIMSC     *        &38            ; Int Mask set clear
UARTRIS      *        &3c            ; raw int status
UARTMIS      *        &40            ; masked int status
UARTICR      *        &44            ; irq clr
UARTDMACR    *        &40            ; DMA Control
UARTITCR     *        &80            ; test control
UARTITIP     *        &84            ; integr test ip
UARTITOP     *        &88            ; integ test op
UARTTDR      *        &8c            ; test data reg

; GPU System Timer
Timer_Base   *        &00003000      ; base of system timer regs
ST_CS        *        &00            ; control/status
ST_CLO       *        &04            ; counter low
ST_CHI       *        &08            ; counter high
ST_C0        *        &0C            ; compare 0
ST_C1        *        &10            ; compare 1
ST_C2        *        &14            ; compare 2
ST_C3        *        &18            ; compare 3

; ARM Timer
ARM_Timer_Base *      &0000b400      ; base of ARM timer regs

; DMA registers
DMA_Base     *        &00007000

; DMA_CH_Count *        13 ; Allegedly 16 channels, but can only get IRQs from 13 of them?
DMA_CH_Count *        12 ; Was 13, but firmware bug is incorrectly reporting that ch 12 is available

; Message-based parallel host interface
MPHI_Base    *        &00006000

; Power management
PM_Base      *        &00100000      ; power management
PM_Password  *        &5a000000      ; for writes to be accepted
PM_GNRIC     *        &00
PM_AUDIO     *        &04
PM_STATUS    *        &18
PM_RSTC      *        &1c            ; reset control reg
PM_RSTS      *        &20            ; reset status reg
PM_WDOG      *        &24            ; watchdog control reg
; register bits
PM_RSTC_DRCFG_MASK *   &00000003
PM_RSTC_WRCFG_MASK *   &00000030
PM_RSTC_WRCFG_FULLRST * &00000020
PM_RSTC_SRCFG_MASK *   &00000300
PM_RSTC_QRCFG_MASK *   &00003000
PM_RSTC_FRCFG_MASK *   &00030000
PM_RSTC_HRCFG_MASK *   &00300000
PM_RSTS_HADDRQ     *   1:SHL:0
PM_RSTS_HADDRF     *   1:SHL:1
PM_RSTS_HADDRH     *   1:SHL:2
PM_RSTS_HADWRQ     *   1:SHL:4
PM_RSTS_HADWRF     *   1:SHL:5
PM_RSTS_HADWRH     *   1:SHL:6
PM_RSTS_HADSRQ     *   1:SHL:8
PM_RSTS_HADSRF     *   1:SHL:9
PM_RSTS_HADSRH     *   1:SHL:10
PM_RSTS_HADPOR     *   1:SHL:12
PM_WDOG_TIME_MASK  *   &000fffff
;
;
USB_Base     *        &00980000      ; USB
ISP_Base     *        &00a00000      ; ISP
;
; Interrupt handling
;
IRQ_Base           *  &0000B200
IRQ_PENDB          *  &00            ; read: pending basic interrupts (devices 64-95)
IRQ_PEND1          *  &04            ; read: pending interrupts 1 (GPU IRQs 0-31, devices 0-31)
IRQ_PEND2          *  &08            ; read: pending interrupts 2 (GPU IRQs 32-63, devices 32-63)
IRQ_FIQCTL         *  &0C            ; FIQ control register
IRQ_EN1            *  &10            ; read: enabled interrupts 1;     write: bits to OR into enabled interrupts 1
IRQ_EN2            *  &14            ; read: enabled interrupts 2;     write: bits to OR into enabled interrupts 2
IRQ_ENB            *  &18            ; read: enabled basic interrupts; write: bits to OR into enabled basic interrupts
IRQ_DIS1           *  &1C            ; read: enabled interrupts 1;     write: bits to BIC from enabled interrupts 1
IRQ_DIS2           *  &20            ; read: enabled interrupts 2;     write: bits to BIC from enabled interrupts 2
IRQ_DISB           *  &24            ; read: enabled basic interrupts; write: bits to BIC from enabled basic interrupts

; Raspberry Pi interrupt sources.
; Because the pending and enable registers are listed in different orders, there are 2 logical ways to map these onto
; device numbers. However, matching the order of the enable registers has the following advantages:
; * the same device numbers can be used in the FIQ control register without modification
; * the GPU timer interrupts end up with the lowest priority - desirable since we run our counter from them

; devices in register 1  - start at 0
iDev_GPU_Timer0     *     0    ; not on list in datasheet
iDev_GPU_Timer1     *     1    ; not on list in datasheet
iDev_GPU_Timer2     *     2    ; not on list in datasheet
iDev_GPU_Timer3     *     3    ; not on list in datasheet
iDev_GPU_Codec0     *     4    ; not on list in datasheet
iDev_GPU_Codec1     *     5    ; not on list in datasheet
iDev_GPU_Codec2     *     6    ; not on list in datasheet
iDev_GPU_VCJPEG     *     7    ; not on list in datasheet
iDev_GPU_ISP        *     8    ; not on list in datasheet
iDev_GPU_VCUSB      *     9    ; not on list in datasheet
iDev_GPU_VC3D       *     10   ; not on list in datasheet
iDev_GPU_Transp     *     11   ; not on list in datasheet
iDev_GPU_MCSync0    *     12   ; not on list in datasheet
iDev_GPU_MCSync1    *     13   ; not on list in datasheet
iDev_GPU_MCSync2    *     14   ; not on list in datasheet
iDev_GPU_MCSync3    *     15   ; not on list in datasheet
iDev_GPU_DMA0       *     16   ; not on list in datasheet
iDev_GPU_DMA1       *     17   ; not on list in datasheet
iDev_GPU_VCDMA2     *     18   ; not on list in datasheet
iDev_GPU_VCDMA3     *     19   ; not on list in datasheet
iDev_GPU_DMA4       *     20   ; not on list in datasheet
iDev_GPU_DMA5       *     21   ; not on list in datasheet
iDev_GPU_DMA6       *     22   ; not on list in datasheet
iDev_GPU_DMA7       *     23   ; not on list in datasheet
iDev_GPU_DMA8       *     24   ; not on list in datasheet
iDev_GPU_DMA9       *     25   ; not on list in datasheet
iDev_GPU_DMA10      *     26   ; not on list in datasheet
iDev_GPU_DMA11      *     27   ; not on list in datasheet
iDev_GPU_DMA12      *     28   ; not on list in datasheet
iDev_GPU_AuxInt     *     29
iDev_GPU_ARM        *     30   ; not on list in datasheet
iDev_GPU_VPUDMA     *     31   ; not on list in datasheet
; devices in register 2  - start at 32
iDev_GPU_HostPort   *     32   ; not on list in datasheet
iDev_GPU_VidScale   *     33   ; not on list in datasheet
iDev_GPU_CCP2TX     *     34   ; not on list in datasheet
iDev_GPU_SDC        *     35   ; not on list in datasheet
iDev_GPU_DSI0       *     36   ; not on list in datasheet
iDev_GPU_AVE        *     37   ; not on list in datasheet
iDev_GPU_Cam0       *     38   ; not on list in datasheet
iDev_GPU_Cam1       *     39   ; not on list in datasheet
iDev_GPU_HDMI0      *     40   ; not on list in datasheet
iDev_GPU_HDMI1      *     41   ; not on list in datasheet
iDev_GPU_PixVal1    *     42   ; not on list in datasheet
iDev_GPU_I2CSPISlv  *     43
iDev_GPU_DSI1       *     44   ; not on list in datasheet
iDev_GPU_PWA0       *     45
iDev_GPU_PWA1       *     46
iDev_GPU_CPR        *     47   ; not on list in datasheet
iDev_GPU_SMI        *     48
iDev_GPU_GPIO0      *     49
iDev_GPU_GPIO1      *     50
iDev_GPU_GPIO2      *     51
iDev_GPU_GPIO3      *     52
iDev_GPU_I2C        *     53
iDev_GPU_SPI        *     54
iDev_GPU_PCM        *     55
iDev_GPU_SDIO       *     56   ; not on list in datasheet
iDev_GPU_Uart       *     57
iDev_GPU_SlimBus    *     58   ; not on list in datasheet
iDev_GPU_Vec        *     59   ; not on list in datasheet
iDev_GPU_CPG        *     60   ; not on list in datasheet
iDev_GPU_RNG        *     61   ; not on list in datasheet
iDev_GPU_VCSDIO     *     62   ; not on list in datasheet
iDev_GPU_AVSPMON    *     63   ; not on list in datasheet
iDev_ARM_Timer      *     64+0
iDev_ARM_Mbx        *     64+1
iDev_ARM_DBell0     *     64+2
iDev_ARM_DBell1     *     64+3
iDev_ARM_GPU0Hlt    *     64+4
iDev_ARM_GPU1Hlt    *     64+5
iDev_ARM_IllegAcs1  *     64+6
iDev_ARM_IllegAcs0  *     64+7
; Notice that bits 8-31 of the pending basic interrupts cannot be masked. This causes the RISC OS kernel problems,
; because the default action for an unhandled interrupt is to mask it, and if masking doesn't work, we end up with an
; infinite loop. You *could* map these device numbers back to bits in the disable interrupts 1/2 registers, but it's
; not a simple mapping and the same bits appear in the pending interrupts 1/2 registers as well, so they're arguably
; not much use. Is the saving of one or two reads of the pending interrupt registers worth the complexity? I don't know.
; It's also worth noting that these device numbers are not valid for use as FIQs. So for now, I recommend you don't use
; these devices - use the equivalents in the GPU interrupt registers instead.
iDev_ARM_MiscGPU1   *     64+8    ; OR of GPU IRQs 0-31 excluding those listed below
iDev_ARM_MiscGPU2   *     64+9    ; OR of GPU IRQs 32-63 excluding those listed below
iDev_ARM_VCJPEG     *     64+10   ; copy of GPU IRQ 7
iDev_ARM_VCUSB      *     64+11   ; copy of GPU IRQ 9
iDev_ARM_VC3D       *     64+12   ; copy of GPU IRQ 10
iDev_ARM_VCDMA2     *     64+13   ; copy of GPU IRQ 18
iDev_ARM_VCDMA3     *     64+14   ; copy of GPU IRQ 19
iDev_ARM_I2C        *     64+15   ; copy of GPU IRQ 53
iDev_ARM_SPI        *     64+16   ; copy of GPU IRQ 54
iDev_ARM_PCM        *     64+17   ; copy of GPU IRQ 55
iDev_ARM_SDIO       *     64+18   ; copy of GPU IRQ 56
iDev_ARM_Uart       *     64+19   ; copy of GPU IRQ 57
iDev_ARM_VCSDIO     *     64+20   ; copy of GPU IRQ 62

iDev_ARM11_Max      *     64+21

; Extra interrupt sources for QA7
; These are all core-specific interrupts
; Note that the original interrupts (0 - iDev_ARM11_Max) can only be routed to
; one core at a time (although IRQ and FIQ can be routed differently if we
; desire). If iDev_QA7_GPU is firing, it indicates that we are the owner of the
; GPU interrupts and should check its status registers to determine the source.
iDev_QA7_Base       *     iDev_ARM11_Max
                    ^     iDev_QA7_Base
iDev_QA7_CNTPSIRQ   #     4 ; Core-specific
iDev_QA7_CNTPNSIRQ  #     4 ; Core-specific
iDev_QA7_CNTPHPIRQ  #     4 ; Core-specific
iDev_QA7_CNTPVIRQ   #     4 ; Core-specific
iDev_QA7_MBox0      #     4 ; Core-specific
iDev_QA7_MBox1      #     4 ; Core-specific
iDev_QA7_MBox2      #     4 ; Core-specific
iDev_QA7_MBox3      #     4 ; Core-specific
iDev_QA7_GPU        #     4 ; Each of IRQ+FIQ can only be assigned to one core at a time
iDev_QA7_PMU        #     4 ; Core-specific
iDev_QA7_AXI        #     4 ; Can only be IRQ of core 0
iDev_QA7_LocalTimer #     4 ; Can only be assigned to one core (as either IRQ or FIQ)

iDev_QA7_Max        #     0

;IIC0 (BSC0, i.e. Broadcom Serial Controller 0)
IIC_Base0           *     &00205000  ; base of IIC0
;IIC1 (BCS1, i.e. Broadcom Serial Controller 1)
IIC_Base1           *     &00804000
IIC_C               *     &00        ; Control
IIC_S               *     &04        ; Status
IIC_DLEN            *     &08        ; Data Length
IIC_A               *     &0C        ; Slave Address
IIC_FIFO            *     &10        ; Data FIFO
IIC_DIV             *     &14        ; Clock Divider
IIC_DEL             *     &18        ; Data Delay
IIC_CLKT            *     &1C        ; Clock Stretch Timeout

; ARM control registers for quad core chips (BCM2836, BCM2837, etc.)
; ref: https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2836/QA7_rev3.4.pdf
QA7_BASE              * &40000000
QA7_CONTROL               * &0000
QA7_CORE_TIMER_PRESCALE   * &0008
QA7_GPU_INT_ROUTING       * &000C
QA7_PMU_INT_ROUT_SET      * &0010
QA7_PMU_INT_ROUT_CLR      * &0014
QA7_CORE_TIMER_LSW        * &001C
QA7_CORE_TIMER_MSW        * &0020
QA7_LOCAL_INT_ROUTING     * &0024
QA7_AXI_OUTSTANDING_CNT   * &002C
QA7_AXI_OUTSTANDING_IRQ   * &0030
QA7_LOCAL_TIMER_CTRL_STAT * &0034
QA7_LOCAL_TIMER_WRFLAGS   * &0038
QA7_CORE0_TIMER_INT_CTRL  * &0040
QA7_CORE1_TIMER_INT_CTRL  * &0044
QA7_CORE2_TIMER_INT_CTRL  * &0048
QA7_CORE3_TIMER_INT_CTRL  * &004C
QA7_CORE0_MBOX_INT_CTRL   * &0050
QA7_CORE1_MBOX_INT_CTRL   * &0054
QA7_CORE2_MBOX_INT_CTRL   * &0058
QA7_CORE3_MBOX_INT_CTRL   * &005C
QA7_CORE0_IRQ_SOURCE      * &0060
QA7_CORE1_IRQ_SOURCE      * &0064
QA7_CORE2_IRQ_SOURCE      * &0068
QA7_CORE3_IRQ_SOURCE      * &006C
QA7_CORE0_FIQ_SOURCE      * &0070
QA7_CORE1_FIQ_SOURCE      * &0074
QA7_CORE2_FIQ_SOURCE      * &0078
QA7_CORE3_FIQ_SOURCE      * &007C
QA7_CORE0_MBOX0_SET       * &0080 ; Write to set bits in mailbox
QA7_CORE0_MBOX1_SET       * &0084
QA7_CORE0_MBOX2_SET       * &0088
QA7_CORE0_MBOX3_SET       * &008C
QA7_CORE1_MBOX0_SET       * &0090
QA7_CORE1_MBOX1_SET       * &0094
QA7_CORE1_MBOX2_SET       * &0098
QA7_CORE1_MBOX3_SET       * &009C
QA7_CORE2_MBOX0_SET       * &00A0
QA7_CORE2_MBOX1_SET       * &00A4
QA7_CORE2_MBOX2_SET       * &00A8
QA7_CORE2_MBOX3_SET       * &00AC
QA7_CORE3_MBOX0_SET       * &00B0
QA7_CORE3_MBOX1_SET       * &00B4
QA7_CORE3_MBOX2_SET       * &00B8
QA7_CORE3_MBOX3_SET       * &00BC
QA7_CORE0_MBOX0_RDCLR     * &00C0 ; Write to clear bits in mailbox
QA7_CORE0_MBOX1_RDCLR     * &00C4
QA7_CORE0_MBOX2_RDCLR     * &00C8
QA7_CORE0_MBOX3_RDCLR     * &00CC
QA7_CORE1_MBOX0_RDCLR     * &00D0
QA7_CORE1_MBOX1_RDCLR     * &00D4
QA7_CORE1_MBOX2_RDCLR     * &00D8
QA7_CORE1_MBOX3_RDCLR     * &00DC
QA7_CORE2_MBOX0_RDCLR     * &00E0
QA7_CORE2_MBOX1_RDCLR     * &00E4
QA7_CORE2_MBOX2_RDCLR     * &00E8
QA7_CORE2_MBOX3_RDCLR     * &00EC
QA7_CORE3_MBOX0_RDCLR     * &00F0
QA7_CORE3_MBOX1_RDCLR     * &00F4
QA7_CORE3_MBOX2_RDCLR     * &00F8
QA7_CORE3_MBOX3_RDCLR     * &00FC
QA7_SIZE                  * &40000

        ]
                END
