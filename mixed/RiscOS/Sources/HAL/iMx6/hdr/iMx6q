; Copyright 2017 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        [       :LNOT: :DEF: __HAL_iMx6_HDR__
        GBLL    __HAL_iMx6_HDR__

        GET     Hdr.iMx6qMemMap
        GET     hdr.iMx6qReg
        GET     hdr.iMx6qIOMux
        GET     hdr.iMx6qIRQs
        GET     Hdr:iMx6qMemMap

                GBLL    HALDebug
HALDebug        SETL    {FALSE};

; switch to configure relevant changes for CuBox
  [ :LNOT::DEF: CuBox
                GBLL CuBox
CuBox           SETL {FALSE}
  ]

        ; Debugging in the serial port (UART 2)
                GBLL    Debug
Debug           SETL    {FALSE};{TRUE};
        ; this depends on the Debug definition above
        GET     hdr.iMx6qboard

        ; Boot timings using the 32KHz timer
                GBLL    DebugTiming
DebugTiming     SETL    Debug :LAND: {FALSE}

        ; Should the I cache be off when the MMU is
                GBLL    CacheOff
CacheOff        SETL    {FALSE}

        ; Whether we clear RAM or let the OS do it
        ; SDMA is fairly slow (about 110MB/s bandwidth), it's better to let the
        ; OS clear RAM using the CPU once the caches are enabled (about 600MB/s)
                GBLL    ClearRAM
ClearRAM        SETL    {FALSE}

; IVT offset from start of SD media
IVTMediaAddress *       0x400
; size we round this loader up to  (need to ensure it is on 4k boundary
IVTLoaderSize   *       0x1000

; Support PCIe space?
                GBLL    PCIeSpace
PCIeSpace       SETL    {FALSE}


IO_Base         *       &02000000
IO_Size         *       &01000000


RAM_Base        *       &10000000           ; try off bottom
Boot_RAM_Base   *       &10000000

; IOMUX pad settings
IOMuxPadUartIn  * (  (HYS_ENABLED <<16)    \
                   + (PUS_100KOHM_PU <<14) \
                   + (PUE_PULL <<13)       \
                   + (PKE_ENABLED <<12)    \
                   + (ODE_DISABLED <<11)   \
                   + (SPD_100MHZ <<6)      \
                   + (DSE_DISABLED <<3)    \
                   + (SRE_FAST)            \
                  )

IOMuxPadUartOut * (  (HYS_ENABLED <<16)    \
                   + (PUS_100KOHM_PU <<14) \
                   + (PUE_PULL <<13)       \
                   + (PKE_ENABLED <<12)    \
                   + (ODE_DISABLED <<11)   \
                   + (SPD_100MHZ <<6)      \
                   + (DSE_40OHM <<3)       \
                   + (SRE_FAST)            \
                  )

IOMuxPadI2C   * (  (HYS_ENABLED <<16)       \
                   + (PUS_22KOHM_PU <<14)   \
                   + (PUE_PULL <<13)        \
                   + (PKE_ENABLED <<12)     \
                   + (ODE_ENABLED <<11)     \
                   + (SPD_50MHZ <<6)        \
                   + (DSE_40OHM <<3)        \
                   + (SRE_FAST)             \
                  )

IOMuxPadDDC   * (  (HYS_ENABLED <<16)       \
                   + (PUS_22KOHM_PU <<14)  \
                   + (PUE_PULL <<13)        \
                   + (PKE_DISABLED <<12)     \
                   + (ODE_ENABLED <<11)     \
                   + (SPD_50MHZ <<6)        \
                   + (DSE_40OHM <<3)        \
                   + (SRE_SLOW)             \
                  )

IOMuxPadUSBHC   * (  (HYS_ENABLED <<16)     \
                   + (PUS_47KOHM_PU <<14)   \
                   + (PUE_PULL <<13)        \
                   + (PKE_DISABLED <<12)    \
                   + (ODE_DISABLED <<11)    \
                   + (SPD_50MHZ <<6)        \
                   + (DSE_80OHM <<3)        \
                   + (SRE_FAST)             \
                  )

IOMuxPadUSDHC   * (  (HYS_ENABLED <<16)     \
                   + (PUS_100KOHM_PU <<14)  \
                   + (PUE_PULL <<13)        \
                   + (PKE_ENABLED <<12)     \
                   + (ODE_DISABLED <<11)    \
                   + (SPD_100MHZ <<6)       \
                   + (DSE_40OHM <<3)        \
                   + (SRE_SLOW)             \
                  )
;&160b1
IOMuxPadEnet    * (  (HYS_ENABLED <<16)       \
                   + (PUS_100KOHM_PU <<14)     \
                   + (PUE_PULL <<13)          \
                   + (PKE_DISABLED <<12)       \
                   + (ODE_DISABLED <<11)      \
                   + (SPD_100MHZ <<6)         \
                   + (DSE_40OHM <<3)          \
                   + (SRE_SLOW)               \
                  )

IOMuxPadRGMII    * (  (HYS_ENABLED <<16)       \
                   + (PUS_100KOHM_PU <<14)     \
                   + (PUE_PULL <<13)          \
                   + (PKE_ENABLED <<12)       \
                   + (DSE_40OHM <<3)          \
                  )

IOMuxPadSPI     * (  (HYS_ENABLED <<16)       \
                   + (PUS_100KOHM_PU <<14)     \
                   + (PUE_PULL <<13)          \
                   + (PKE_ENABLED <<12)       \
                   + (DSE_40OHM <<3)          \
                  )
IOMuxHDMICEC    * (  (HYS_ENABLED <<16)       \
                   + (PUS_22KOHM_PU <<14)     \
                   + (PUE_PULL <<13)          \
                   + (PKE_ENABLED <<12)       \
                   + (SPD_100MHZ <<6)         \
                   + (DSE_40OHM <<3)          \
                  )

; Phy drive values
IOMuxENETMDIO      * &1b8b0
IOMuxENETMDC       * &1b0b0
IOMuxENETPhyRST    * &130b0
IOMuxENETPhyIrq    * &1b0b0
IOMuxENETPD        * &13030
IOMuxENETPU        * &1b030
IOMuxENETRefClk    * &0a0b1
IOMuxENETRefClkOut * &4001b0b0
IOMuxENETHiZPU     * &03000







        MACRO
$label  DebugChar $temp1,$temp2,$char
    [ Debug
$label  LDR     $temp1,[sb, #:INDEX:DebugUART]
        MOV     $temp2,#$char
        STRB    $temp2,[$temp1, #UART_UTXD_OFFSET]
    ]
        MEND

        MACRO
$label  DebugTX $str
    [ Debug
$label  BL      DebugHALPrint
        =       "$str", 13, 10, 0
        ALIGN
    ]
        MEND

        MACRO
$label  DebugTXS $str
    [ Debug
$label  BL      DebugHALPrint
        =       "$str ", 0
        ALIGN
    ]
        MEND

        MACRO
$label  DebugCR
    [ Debug
$label  BL      DebugHALPrint
        =       13,10, 0
        ALIGN
    ]
        MEND

        MACRO
$label   DebugReg $reg, $str
    [ Debug
$label   Push   "$reg"
     [ "$str" <> ""
       DebugTXS $str
     ]
        BL     DebugHALPrintReg
        DebugCR
    ]
        MEND

        MACRO
$label   DebugRegNCR $reg, $str
    [ Debug
$label   Push   "$reg"
     [ "$str" <> ""
       DebugTXS $str
     ]
        BL     DebugHALPrintReg
    ]
        MEND

        MACRO
$label  DebugRegByte $reg, $str
    [ Debug
$label  Push   "$reg"
     [ "$str" <> ""
        BL     DebugHALPrint
        =      "$str",0
        ALIGN
     ]
        BL     DebugHALPrintByte
    ]
        MEND

        MACRO
$label  DebugTime $temp,$str
    [ DebugTiming
$label  LDR     $temp,L4_32KTIMER_Log
        LDR     $temp,[$temp,#16] ; REG_32KSYNCNT_CR
        DebugReg $temp, "$str"
    ]
        MEND

        MACRO
$label  DebugTimeNoMMU $temp,$str
    [ DebugTiming
$label  LDR     $temp,=L4_32KTIMER
        LDR     $temp,[$temp,#16]
        DebugReg $temp, "$str"
    ]
        MEND

; Acquire/release the HAL spinlock
        MACRO
        AcquireSpinlock $temp ; Corrupts $temp, NZ, stashes old PSR on stack
        MRS     $temp, CPSR
        Push    "$temp"
        ADD     sb, sb, #:INDEX:Spinlock
        CPSID   if
10
        LDREX   $temp, [sb]
        TEQ     $temp, #0
        WFENE
        STREXEQ $temp, sb, [sb]
        TEQEQ   $temp, #0
        BNE     %BT10
        DMB
        SUB     sb, sb, #:INDEX:Spinlock
        MEND

        MACRO
        ReleaseSpinlock $temp ; Corrupts $temp
        MOV     $temp, #0
        DMB
        STR     $temp, Spinlock         ; Clear spinlock before barrier
        DSB
        SEV
        Pull    "$temp"
        MSR     CPSR_c, $temp
        MEND

        ] ; __HAL_iMx6_HDR__

        END
