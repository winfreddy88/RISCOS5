/* Copyright 2005 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    CLI.c                                             */
/*          (C) 2005 Tematic                                  */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Star command implementations.                     */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 18-Aug-2005 (ADH): Created.                       */
/**************************************************************/

#include <string.h>

#include "CLI.h"
#include "Effect.h"
#include "SWI.h"

/**************************************************************/
/* cli_fade()                                                 */
/*                                                            */
/* Implement *ScreenFXFade.                                   */
/*                                                            */
/* Parameters:  Pointer to the command string.                */
/*                                                            */
/* Re-entrancy: Function is not re-entrant.                   */
/*                                                            */
/* Threading:   Function is not thread-safe.                  */
/**************************************************************/

_kernel_oserror * cli_fade(const char * args)
{
  uint32_t         argbuf[64];
  _kernel_swi_regs r;
  char             i[4];

  dprintf(("CLI",
           "cli_fade: Called with '%s'\n",

           TOSTR(args)));

  /* Parse the argument list */

  PRISMLIB_RETERR(_swix(OS_ReadArgs,
                        _INR(0,3),

                        "block/S,escape/S,/EA,/EA,/EA",
                        args,
                        argbuf,
                        sizeof(argbuf)));

  /* Pick out the bits and pieces from the returned data */

  if (argbuf[0] != 0) r.r[0]  = SCREENFX_FADE_BLOCK;
  else                r.r[0]  = 0;

  if (argbuf[1] != 0) r.r[0] |= SCREENFX_FADE_ALLOWESCAPE;

  /* The checks are "should never happen" candidates */

  if (argbuf[2] == 0) r.r[1] = 0;
  else
  {
    /* argbuf[2] points to a 5 byte block, with one byte of type
     * information and 4 bytes of value. The value pointer is byte
     * aligned, so we can't just dereference it directly.
     */

    memcpy(i, (((char *) argbuf[2]) + 1), 4);
    r.r[1] = *((int *) i);
  }

  if (argbuf[3] == 0) r.r[2] = -1; /* (To give &FFFFFFFF) */
  else
  {
    memcpy(i, (((char *) argbuf[3]) + 1), 4);
    r.r[2] = *((int *) i);
  }

  if (argbuf[4] == 0) r.r[3] = 0;
  else
  {
    memcpy(i, (((char *) argbuf[4]) + 1), 4);
    r.r[3] = *((int *) i);
  }

  dprintf(("CLI", "cli_fade: Exiting through swi_fade()...\n"));
  return swi_fade(&r);
}

/**************************************************************/
/* cli_crossfade()                                            */
/*                                                            */
/* Implement *ScreenFXCrossFade.                              */
/*                                                            */
/* Parameters:  Pointer to the command string.                */
/*                                                            */
/* Re-entrancy: Function is not re-entrant.                   */
/*                                                            */
/* Threading:   Function is not thread-safe.                  */
/**************************************************************/

_kernel_oserror * cli_crossfade(const char * args)
{
  uint32_t         argbuf[64];
  _kernel_swi_regs r;
  char             i[4];

  dprintf(("CLI",
           "cli_crossfade: Called with '%s'\n",

           TOSTR(args)));

  /* Parse the argument list */

  PRISMLIB_RETERR(_swix(OS_ReadArgs,
                        _INR(0,3),

                        "block/S,escape/S,low/S,/EA",
                        args,
                        argbuf,
                        sizeof(argbuf)));

  /* Pick out the bits and pieces from the returned data */

  if (argbuf[0] != 0) r.r[0]  = SCREENFX_CROSSFADE_BLOCK;
  else                r.r[0]  = 0;

  if (argbuf[1] != 0) r.r[0] |= SCREENFX_CROSSFADE_ALLOWESCAPE;
  if (argbuf[2] != 0) r.r[0] |= SCREENFX_CROSSFADE_TOLOWER;

  /* The checks are "should never happen" candidates */

  if (argbuf[3] == 0) r.r[1] = 0;
  else
  {
    /* argbuf[2] points to a 5 byte block, with one byte of type
     * information and 4 bytes of value. The value pointer is byte
     * aligned, so we can't just dereference it directly.
     */

    memcpy(i, (((char *) argbuf[3]) + 1), 4);
    r.r[1] = *((int *) i);
  }

  dprintf(("CLI", "cli_crossfade: Exiting through swi_crossfade()...\n"));
  return swi_crossfade(&r);
}

/**************************************************************/
/* cli_cancel()                                               */
/*                                                            */
/* Implement *ScreenFXCancel.                                 */
/*                                                            */
/* Parameters:  Pointer to the command string.                */
/*                                                            */
/* Re-entrancy: Function is not re-entrant.                   */
/*                                                            */
/* Threading:   Function is not thread-safe.                  */
/**************************************************************/

_kernel_oserror * cli_cancel(const char * args)
{
  (void) args;

  dprintf(("CLI",
           "cli_cancel: Called with '%s'\n",

           TOSTR(args)));

  dprintf(("CLI", "cli_cancel: Exiting through swi_cancel()...\n"));
  return swi_cancel(NULL);
}

/**************************************************************/
/* cli_reset()                                                */
/*                                                            */
/* Implement *ScreenFXReset.                                  */
/*                                                            */
/* Parameters:  Pointer to the command string.                */
/*                                                            */
/* Re-entrancy: Function is not re-entrant.                   */
/*                                                            */
/* Threading:   Function is not thread-safe.                  */
/**************************************************************/

_kernel_oserror * cli_reset(const char * args)
{
  (void) args;

  dprintf(("CLI",
           "cli_reset: Called with '%s'\n",

           TOSTR(args)));

  dprintf(("CLI", "cli_reset: Exiting through swi_reset()...\n"));
  return swi_reset(NULL);
}

/**************************************************************/
/* cli_status()                                               */
/*                                                            */
/* Implement *ScreenFXStatus.                                 */
/*                                                            */
/* Parameters:  Pointer to the command string.                */
/*                                                            */
/* Re-entrancy: Function is not re-entrant.                   */
/*                                                            */
/* Threading:   Function is not thread-safe.                  */
/**************************************************************/

_kernel_oserror * cli_status(const char * args)
{
  const char * buf;
  size_t       len;
  size_t       width;
  uint32_t     now;
  int32_t      run_for;

  (void) args;

  dprintf(("CLI",
           "cli_status: Called with '%s'\n",

           TOSTR(args)));

  /* Module information and "status:" suffix */

  printf(Module_Title " " Module_HelpVersion);

  buf = NULL;
  PRISMLIB_RETERR(prismlib_read_message("StatusSuffix", &buf, &len));

  /* Length limit is used as we're using MessageTrans_Lookup
   * (via PRISMLib) in its "give us the buffer" mode, so the
   * string is terminated by LF rather than NUL.
   */

  printf("%.*s\n\n", len, buf);

  /* Find the column width */

  buf = NULL;
  PRISMLIB_RETERR(prismlib_read_message("StatusColumnWidth", &buf, &len));

  /* The following relies on a NUL terminator hard-coded in
   * the Messages file.
   */

  width = atoi(buf);

  /* Left endpoint */

  buf = NULL;
  PRISMLIB_RETERR(prismlib_read_message("StatusRGBSLeft", &buf, &len));

  printf("%.*s", len, buf);
  while (len++ < width) fputc(' ', stdout);

  printf("&%08X\n", effect_pack(current_r[0],
                                current_g[0],
                                current_b[0],
                                current_s[0]));

  /* Right endpoint */

  buf = NULL;
  PRISMLIB_RETERR(prismlib_read_message("StatusRGBSRight", &buf, &len));

  printf("%.*s", len, buf);
  while (len++ < width) fputc(' ', stdout);

  printf("&%08X\n", effect_pack(current_r[255],
                                current_g[255],
                                current_b[255],
                                current_s[255]));

  /* Fade in progress? */

  buf = NULL;
  PRISMLIB_RETERR(prismlib_read_message("StatusFading", &buf, &len));

  printf("%.*s", len, buf);
  while (len++ < width) fputc(' ', stdout);

  buf = NULL;

  if (fade_running != screenfx_effect_type_NONE)
  {
    PRISMLIB_RETERR(prismlib_read_message("Yes", &buf, &len));
    printf("%d (%.*s)\n", fade_running, len, buf);
  }
  else
  {
    PRISMLIB_RETERR(prismlib_read_message("No", &buf, &len));
    printf("%d (%.*s)\n", fade_running, len, buf);
  }

  /* Time to completion */

  buf = NULL;
  PRISMLIB_RETERR(prismlib_read_message("StatusCompletion", &buf, &len));

  printf("%.*s", len, buf);
  while (len++ < width) fputc(' ', stdout);

  buf = NULL;
  PRISMLIB_RETERR(prismlib_read_message("StatusCentiseconds", &buf, &len));

  /* Read the current time */

  PRISMLIB_RETERR(_swix(OS_ReadMonotonicTime,
                        _OUT(0),

                        &now));

  /* Work out how long the fade has been running */

  run_for = now - fade_start_at;

  /* Bound the result */

  if      (run_for < 0)             run_for = 0;
  else if (run_for > fade_duration) run_for = fade_duration;

  printf("%u%.*s\n", fade_duration - run_for, len, buf);

  /* All done */

  dprintf(("CLI", "cli_status: Successful\n"));
  return NULL;
}

/* End of file */
