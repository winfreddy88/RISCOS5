/* Copyright 2005 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Module.c                                          */
/*          (C) 2005 Tematic                                  */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Module mechanisms for ScreenFX.                   */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 18-Aug-2005 (ADH): Created.                       */
/**************************************************************/

#include <string.h>
#include <Global/Services.h> /* Has to come before Global.h as, unlike Global.h, Global/Services.h doesn't check for existing definitions - so it may try to redefine items */

#include "Global.h"

#include "CLI.h"
#include "Effect.h"
#include "SWI.h"

#include "Module.h"

/* This macro, when defined, includes the code for the two debugging *-commands
 * You need to enable the commands in the CMHG header file too.
 */

#if CMHG_VERSION < 516
  #define CMHG_CONST
#else
  #define CMHG_CONST const
#endif

/* Declare in RAM builds the resources accessor function, which
 * returns a pointer to a resource file block for ResourceFS.
 * It is automatically generated by resgen in one of the shared
 * Makefile components (at the time of writing, the relevant
 * file is "RiscOS/Sources/Video/PRISM/PRISM/CommonMF").
 */

#ifndef ROM
  extern int resmess_ResourcesFiles(void);
#endif

/* In RAM builds, define a private copy of errno if asked to do so */

#ifndef ROM
  #ifdef DEFINE_ERRNO
    int __errno;
  #endif
#endif

/* Private word, set up in module_initialise */

void * module_pw;

/**************************************************************/
/* module_initialise()                                        */
/*                                                            */
/* Startup code, usual initialisation entry point stuff.      */
/*                                                            */
/* Note that this module does not attempt to patch around a   */
/* faulty realloc() and so won't work on RISC OS 3.1.         */
/*                                                            */
/* Parameters: As normal for a CMHG initialisation function.  */
/**************************************************************/

_kernel_oserror * module_initialise(CMHG_CONST char * cmd_fail, int podule_base, void * pw)
{
  _kernel_oserror * e;

  module_pw = pw;

  (void) cmd_fail;
  (void) podule_base;

  /* Earlier CMHGs won't call atexit() handlers if we return an
   * error here. Could work around it but since there is a fixed
   * version available, insist on that.
   */

  #if CMHG_VERSION < 530
    #error You need CMHG 5.30 or later to build ScreenFX.
  #endif

  /* Get DebugLib up and running */

  #ifdef TRACE
    {
      debug_device dev = FILE_OUTPUT;

      debug_initialise(Module_Title, "ADFS::4.$." Module_Title "Debug", NULL);
      debug_atexit();
      debug_set_screen_cornering(FALSE);
      debug_set_unbuffered_files(TRUE);
      debug_set_device(dev);
    }
  #endif

  dprintf(("Module", "module_initialise: Hello!\n"));

  /* Sort out the Messages file */

  #ifndef ROM_MODULE

    e = _swix(ResourceFS_RegisterFiles,
              _IN(0),

              resmess_ResourcesFiles());

    if (e != NULL)
    {
      dprintf(("Module", "module_initialise: Failed to register ResourceFS files\n"));
      return e;
    }

  #endif

  if (getenv(Module_Title "$Path"))
  {
    e = prismlib_open_messages(Module_Title ":Messages");
  }
  else
  {
    e = prismlib_open_messages(Module_MessagesFile);
  }

  if (e != NULL)
  {
    dprintf(("Module", "module_initialise: Failed to open messages file\n"));

    #ifndef ROM_MODULE

      (void) _swix(ResourceFS_DeregisterFiles,
                   _IN(0),

                   resmess_ResourcesFiles());

    #endif

    return e;
  }

  /* Program the assumed initial values of the SRGB tables */

  for (uint32_t i = 0; i < 256; i++) starting_r[i] = i;

  memcpy(starting_g, starting_r, 256);
  memcpy(starting_b, starting_r, 256);
  memcpy(starting_s, starting_r, 256);

  memcpy(current_r,  starting_r, 256);
  memcpy(current_g,  starting_r, 256);
  memcpy(current_b,  starting_r, 256);
  memcpy(current_s,  starting_r, 256);

  /* Finished */

  dprintf(("Module", "module_initialise: Successful\n"));
  return NULL;
}

/**************************************************************/
/* module_finalise()                                          */
/*                                                            */
/* Tidy everything up on shutdown.                            */
/**************************************************************/

_kernel_oserror * module_finalise(int fatal, int podule, void * pw)
{
  (void) fatal;
  (void) podule;
  (void) pw;

  dprintf(("Module", "module_finalise: Called\n"));

  /* Shut down any running effects and reset the tables */

  PRISMLIB_RETERR(effect_cancel(false));
  PRISMLIB_RETERR(effect_reset());

  /* Close the messages file */

  (void) prismlib_close_messages();

  #ifndef ROM_MODULE

    (void) _swix(ResourceFS_DeregisterFiles,
                 _IN(0),

                 resmess_ResourcesFiles());

  #endif

  /* Finished */

  dprintf(("Module", "module_finalise: Goodbye!\n"));
  return NULL;
}

/**************************************************************/
/* module_swi_handler()                                       */
/*                                                            */
/* Simple SWI dispatch table.                                 */
/*                                                            */
/* Parameters: As normal for a CMHG SWI handler.              */
/**************************************************************/

_kernel_oserror * module_swi_handler(int swi_no, _kernel_swi_regs * r, void * pw)
{
  (void) pw;
  (void) r;

  dprintf(("Module",
           "module_swi_handler: Called for SWI &%08X\n",

           swi_no + ScreenFX_00));

  switch (swi_no)
  {
    /* Reserved or unknown SWIs */

    default:
      return error_BAD_SWI;

    /* Main interface */

    case ScreenFX_Fade      - ScreenFX_00:
      return swi_fade(r);

    case ScreenFX_Cancel    - ScreenFX_00:
      return swi_cancel(r);

    case ScreenFX_Reset     - ScreenFX_00:
      return swi_reset(r);

    case ScreenFX_Status    - ScreenFX_00:
      return swi_status(r);

    case ScreenFX_CrossFade - ScreenFX_00:
      return swi_crossfade(r);
  }
}

/**************************************************************/
/* module_cli_handler()                                       */
/*                                                            */
/* Simple *-command handler.                                  */
/*                                                            */
/* Parameters: As normal for a CMHG *-command handler.        */
/**************************************************************/

_kernel_oserror * module_cli_handler(CMHG_CONST char * a, int ac, int cmd_no, void * pw)
{
  (void) ac;
  (void) pw;

  switch (cmd_no)
  {
    case CMD_ScreenFXFade:
      return cli_fade((const char *) a);

    case CMD_ScreenFXCrossFade:
      return cli_crossfade((const char *) a);

    case CMD_ScreenFXCancel:
      return cli_cancel((const char *) a);

    case CMD_ScreenFXReset:
      return cli_reset((const char *) a);

    case CMD_ScreenFXStatus:
      return cli_status((const char *) a);

    /* Should never happen... */

    default:
      return NULL;
  }
}

/**************************************************************/
/* module_event_handler()                                     */
/*                                                            */
/* Handle a EventV events 4 (VSync) and 6 (Escape).           */
/*                                                            */
/* Parameters: As normal for a CMHG event handler.            */
/**************************************************************/

int module_event_handler(_kernel_swi_regs * r, void * pw)
{
  (void) pw;
  (void) r;

  switch (r->r[0])
  {
    case Event_VSync:
    {
      switch (fade_running)
      {
        case screenfx_effect_type_FADE:      effect_process_fade();      break;
        case screenfx_effect_type_CROSSFADE: effect_process_crossfade(); break;
      }
    }
    break;

    case Event_Escape:
    {
      if (fade_running != screenfx_effect_type_NONE)
      {
        effect_cancel(true);

        /* Clear the current escape condition */

        _swix(OS_Byte,
              _IN(0),

              OsByte_ClearEscape);
      }
    }
    break;
  }

  return 1; /* Don't claim event */
}
