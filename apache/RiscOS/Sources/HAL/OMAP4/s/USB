; Copyright 2011 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.omap4430
        GET     hdr.StaticWS
        GET     hdr.Timers
        GET     hdr.PRCM
        GET     hdr.USB
        GET     hdr.GPIO
        GET     hdr.omap4_reg

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  USB_Init

        EXPORT  HAL_USBControllerInfo

        IMPORT  HAL_CounterDelay
        IMPORT  GPIOx_SetAsOutput
        IMPORT  GPIOx_SetOutput


; GPIO pins for USB
GPIO_HUB_NRESET *       62
GPIO_HUB_POWER  *       1

OHCI_IRQ        *       OMAP44XX_IRQ_HSUSB_OHCI
EHCI_IRQ        *       OMAP44XX_IRQ_HSUSB_EHCI
MUSB_IRQ        *       OMAP44XX_IRQ_HSUSB_OTG

USB_Init
        Push    "lr"
        ; Initialise USB
        ; This code is roughly the same as omap4_ehci_init() in the linux sources
        ; remark: there is no need to configure pins GPIO_HUB_POWER + GPIO_HUB_NRESET
        ;         because it is already done by U-Boot (it uses USB itself)

        ; disable the power to the usb hub prior to init
        MOV     a1, #GPIO_HUB_POWER
        MOV     a2, #0
        BL      GPIOx_SetAsOutput

        ; reset phy+hub
        MOV     a1, #GPIO_HUB_NRESET
        MOV     a2, #0
        BL      GPIOx_SetAsOutput
        MOV     a1, #GPIO_HUB_NRESET
        MOV     a2, #1
        BL      GPIOx_SetOutput

        ; usb_ehci_init()
        ; initialise port 1 in EHCI_HCD_OMAP_MODE_PHY
        ; setup_4430ehci_io_mux()
        LDR     a1, L4_Core_Log
        LDR     a2, =(L4_SYSCTRL_PADCONF_CORE - L4_Core)
        ADD     a1, a2, a1
        LDR     a2, =0x010C010C
        LDR     a3, =0x0004
        STRH    a2, [a1, #0xC2]         ; USBB1_ULPIPHY_CLK (I)
        STRH    a3, [a1, #0xC4]         ; USBB1_ULPIPHY_STP (O)
        STRH    a2, [a1, #0xC6]         ; USBB1_ULPIPHY_DIR (I)
        STR     a2, [a1, #0xC8]         ; USBB1_ULPIPHY_NXT (I) + USBB1_ULPIPHY_DAT0 (IO)
        STR     a2, [a1, #0xCC]         ; USBB1_ULPIPHY_DAT2 (IO) + USBB1_ULPIPHY_DAT1 (IO)
        STR     a2, [a1, #0xD0]         ; USBB1_ULPIPHY_DAT4 (IO) + USBB1_ULPIPHY_DAT3 (IO)
        STR     a2, [a1, #0xD4]         ; USBB1_ULPIPHY_DAT6 (IO) + USBB1_ULPIPHY_DAT5 (IO)
        STRH    a2, [a1, #0xD8]         ; USBB1_ULPIPHY_DAT7 (IO)

        ; enable power to hub
        MOV     a1, #GPIO_HUB_POWER
        MOV     a2, #1
        BL      GPIOx_SetOutput

        ; Enable USBHOST TLL clocks
        LDR     a1, L4_ClockMan2_Log
        ADD     a1, a1, #L3INIT_CM2
        MOV     a2, #1
        STR     a2, [a1, #CM_L3INIT_HSUSBTLL_CLKCTRL]

        ; Enable external PHY clock for port 1
        LDR     a2, [a1, #CM_L3INIT_HSUSBHOST_CLKCTRL]
        ORR     a2, a2, #(3 << 24)      ; == (CLKSEL_UTMI_P2 | CLKSEL_UTMI_P1)
        BIC     a2, a2, #3
        ORR     a2, a2, #2              ; enable module
        STR     a2, [a1, #CM_L3INIT_HSUSBHOST_CLKCTRL]

        ; TLL soft reset
        LDR     a1, L4_USBTLL_Log
        MOV     a2, #2          ; SOFTRESET
        STR     a2, [a1, #USBTLL_SYSCONFIG]
5
        LDR     a2, [a1, #USBTLL_SYSSTATUS]
        TST     a2, #1          ; RESETDONE
        BEQ     %BT5

        ; Now configure UHH
        ; no auto-idle/standby (TODO - why?)
        LDR     a1, L4_USB_Host_Log
        LDR     a2, =((1 << 4) + (1 << 2))
        STR     a2, [a1, #UHH_SYSCONFIG]
        ; Configure for UPLI TTL mode port1 + port2
        ; P2: ULPI PHY, P1: ULPI PHY, INCR4/8/16 bursts enabled
        LDR     a2, =((0 << 18) + (0 << 16) + (1 << 4) + (1 << 3) + (1 << 2))
        STR     a2, [a1, #UHH_HOSTCONFIG]

        ; Success!


10
        Pull    "pc"

        ; a1 = interface #
        ; a2 = usbinfo ptr
        ; a3 = sizeof(usbinfo)
        ; Return sizeof(usbinfo) or 0 for no more devices
        ; If supplied size isn't large enough, only the controller type will be filled in
HAL_USBControllerInfo
        CMP     a1, #1
        MOVHI   a1, #0
        MOVHI   pc, lr
        BEQ     %FT10
        ; Fill in the usbinfo struct
        MOV     a1, #HALUSBControllerType_EHCI
        STR     a1, [a2, #HALUSBControllerInfo_Type]
        CMP     a3, #HALUSBControllerInfo_SizeOf
        MOV     a1, #HALUSBControllerInfo_SizeOf
        MOVLO   pc, lr
        ; EHCI did seem to work OK without forcing 32bit register access,
        ; but it is technically needed so I'll leave it set.
        MOV     a4, #HALUSBControllerFlag_32bit_Regs
        STR     a4, [a2, #HALUSBControllerInfo_Flags]
        LDR     a4, L4_USB_Host_Log
        ADD     a4, a4, #EHCI_BASE
        STR     a4, [a2, #HALUSBControllerInfo_HW]
        MOV     a4, #EHCI_IRQ
        STR     a4, [a2, #HALUSBControllerInfo_DevNo]
        MOV     pc, lr
10
        MOV     a1, #HALUSBControllerType_MUSBMHDRC
        STR     a1, [a2, #HALUSBControllerInfo_Type]
        CMP     a3, #HALUSBControllerInfo_SizeOf
        MOV     a1, #HALUSBControllerInfo_SizeOf
        MOVLO   pc, lr
        MOV     a4, #0
        STR     a4, [a2, #HALUSBControllerInfo_Flags]
        LDR     a4, L4_USB_OTG_Log
        STR     a4, [a2, #HALUSBControllerInfo_HW]
        MOV     a4, #MUSB_IRQ
        STR     a4, [a2, #HALUSBControllerInfo_DevNo]
        MOV     pc, lr

        END
