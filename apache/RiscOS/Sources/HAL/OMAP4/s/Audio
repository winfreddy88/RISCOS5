; Copyright 2011 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries
        GET     Hdr:HALDevice
        GET     Hdr:AudioDevice
        GET     Hdr:MixerDevice
        GET     Hdr:Proc

        GET     hdr.omap4430
        GET     hdr.StaticWS
        GET     hdr.PRCM
        GET     hdr.GPIO

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  Audio_Init

        IMPORT  TPSRead
        IMPORT  TPSWrite

        IMPORT  memcpy
        IMPORT  HAL_IRQClear
        IMPORT  HAL_CounterDelay
        IMPORT  GPIOx_SetAsOutput

; A brief rundown of OMAP4 HAL audio support:
; Audio in/out is typically provided via the TWL6040 companion chip.
; Two interfaces are used to link the audio subsystem to the OMAP: I2C is used to program the
; audio subsystem, and PDM is used to transmit & receive data (using the McPDM module on the
; OMAP side).
; Both the TWL6040 and the OMAP are capable of acting as either the master or slave across the
; PDM link, so to keep things simple this implementation has the TWL6040 acting as master and
; the OMAP acting as slave.
; Finally, to keep the McPDM buffer full, the SDMA module of the OMAP is used

; This means that, on the software side, audio is provided by the following network of
; components:
;
;                             HAL I2C driver
;                                   |
;                           RISC OS I2C driver
;                           |                |
;                HAL mixer device  <->  HAL audio device
;                       |                     |
;             SoundControl module  <->  SoundDMA module
;                                             |
;                                       DMAManager module
;                                             |
;                                       HAL DMA device
;
; (Note - there's also a small amount of communication between the HAL DMA device and the HAL
; audio device, to allow for the correct setting of the FIFO threshold/DMA packet size)

; With regards to the actual sound I/O features TWL6040 makes available:
; Audio output:
;   Headset
;   Handsfree
;   Vibrator
;   Auxiliary
;   Earphone
; Audio input:
;   Mic left input (Main mic | HS mic | AUX/FM left input)
;   Mic right input (Main mic | HS mic | AUX/FM right input)
;   Line In

; The Phoenix codec (TWL6040) renders samples at 88.2 kHz and 96 kHz.
; Handsfree speakers and other paths work at 96 kHz, but headphone has 2 modes:
;   Low power mode (88.2 and 96 kHz)
;   High performance mode (96 kHz only)

; There are 8 digital input channels on TWL6040 that can be used for rendering audio out
; to 9 different analogue outputs. There are 5 McPDM channels (DL0 - DL4), an I2C channel
; and 2 auxiliary inputs that can be used for FM radio (AFM0/AFM1). Audio from these
; inputs can be routed to the various analogue outputs as per following table:

; Output port   DL0     DL1     DL2     DL3     DL4     I2C or frame(3) AFM0    AFM1
; Earphone      X(1)
; Left Headset  X                                                       X
; Right Headset X       X                                                       X
; Left HF                       X                                       X
; Right HF                      X       X                                       X
; Left Aux                      X(2)                                    X
; Right Aux                     X(2)    X(2)                                    X
; Left Vibr.                                    X       X
; Right Vibr.                                   X       X
; (1) This path cannot be concurrent of L/R headset paths
; (2) These paths can be concurrent but not independent of L/R handsfree paths
; (3) The frame line can be used for register write in command mode

; TWL6040 has the following 5 analogue input channels that can be used for encoding audio.
; Uplink audio from TWL6040 to the OMAP Audio BackEnd (ABE) can be transferred over
; 2 McPDM channles (UL0 and UL1) or via 2 auxiliary ports, AFM0 and AFM1, which are often
; used for FM radio audio. The possible mappings of these inputs to uplink channels in to
; the OMAP ABE are as follows:

; Input port            UL0     UL1     AFM0    AFM1
; Main Microphone, MMIC X
; Sub Microphone, SMIC          X
; Headset Micro, HSMIC  X       X
; Left Aux/FM radio     X               X
; Right Aux/FM radio            X               X

; So, in summary.....
; * Since RISC OS only produces one stream of stereo data, we can assign one DAC/amplifier pair
;   (HSL/HSR, to keep the voice path free for the future?) to playing the data generated by
;   the OS
; * There are only two ADCs, so you can only really sample from one stereo source at a time
;   (or two mono)
; * The plethora of outputs can select their mix from RISC OS sound data & the ADC data at will
; * In any case, RISC OS doesn't really have an API for sound recording (or setting the
;   recording source), so we could just ignore all the inputs entirely until that gets
;   rectified (although for most OMAP devices which RISC OS is targeting, it's likely that the
;   stereo "auxiliary" input will be the one providing all the input data, so an API to select
;   the recording source isn't entirely necessary)

; As for mapping inputs & outputs to those currently supported by the HAL mixer API:
; TWL6040                         HAL mixer category
; Headset left/right              HEADPHONES
; Earphone                        SPEAKER
; Hands-free left/right           LINE_OUT
; Auxiliary left/right            AUX_OUT
;
; Headset mic                     MIC
; Handset main mic                AUX_IN
; Handset sub mic                 none?
; Digital mic 0                   none?
; Digital mic 1                   none?
; Stereo FM/aux input             LINE_IN


; For all pandaboards the TWL6040 is connected to the OMAP4 via I2C1 & McPDM.
;
; The OMAP4430 Pandaboard provides a stacked audio connector, which provides two 3.5 mm audio
; jack connections. The upper jack on this stacked connector (J16A) is connected to the
; Headset Microphone Plus and Minus inputs of the TWL6040 Audio Companion IC. The lower jack on
; this stacked connector (J16B) is connected to the Headset Left and Right outputs of the
; TWL6040 Audio Companion IC. For expansion purposes the left and right Hands-Free speaker
; outputs of the TWL6040 are connected to the Expansion Connector J6 [Pin 13,14,15,16].
;
; The OMAP4460 Pandaboard ES provides a stacked audio connector, which provides two 3.5 mm audio
; jack connections. The upper jack on this stacked connector (J16A) is connected to the
; FM Audio Left and Right inputs of the TWL6040 Audio Companion IC (AFML/AFMR). The lower jack
; on this stacked connector (J16B) is connected to the Headset Left and Right outputs of the
; TWL6040 Audio Companion IC. For expansion purposes the left Hands-Free speaker
; outputs of the TWL6040 are connected to the Expansion Connector J6 [Pin 13,15].
;


; Flag to enable gobs of debug output
                GBLL    AudioDebug
AudioDebug      SETL    {FALSE}
;AudioDebug     SETL    {TRUE}


; GPIO pin for activating power to TWL6040 audio chip
AUDIO_POWER_PIN         *       127
AUDIO_POWER_DELAY       *       (50*1024)       ; ~51 ms

; interrupt mask for use with McPDM downlink channel
MCPDM_IRQ_DN_MASK       *       (MCPDM_IRQ_DN_EMPTY + MCPDM_IRQ_DN_FULL)

; flag for using only supported sample rates
                GBLL    AllSampleRates
AllSampleRates  SETL    {FALSE}

; flag to enable mono to stereo switching for headset
; ATM just for testing: it doubles the playrate because the right channel gets the same value
;                       as the left channel
; ToDo: how to map lower sample rates to the supported ones (88.2 | 96 kHz)?
                GBLL    Mono2Stereo
Mono2Stereo     SETL    {TRUE} :LAND: AllSampleRates

; McPDM downlink channel mask
MCPDM_DL_CHANNELS       *       (MCPDM_CTRL_PDM_DN1_EN + MCPDM_CTRL_PDM_DN2_EN)

; special gain values for marking OFF state
HS_GAIN_OFF             *       &F0
HF_GAIN_OFF             *       &1F


Audio_Init
        Push    "v1-v4,lr"
  [ AudioDebug
        DebugTX "Audio_Init"
  ]
        ADRL    v1, AudioWS
        MOV     a1, v1
        ADR     a2, AudioTemplate
        MOV     a3, #Audio_DeviceSize
        BL      memcpy
        STR     sb, [v1, #:INDEX:AudioWorkspace]
        ; Get McPDM logical address
        LDR     v2, L4_ABE_Log
        ADD     v2, v2, #(L4_McPDM - L4_ABE)
        STR     v2, [v1, #:INDEX:AudioRegs]
  [ AudioDebug
        DebugReg v2, "McPDM @ "
  ]

        ; Configure all PADs for McPDM and AUDIOPWRON pin
        LDR     a1, L4_Core_Log
        LDR     a2, =(L4_SYSCTRL_PADCONF_CORE - L4_Core)
        ADD     a1, a2, a1
        ADD     a1, a1, #0x100          ; add common offset
        MOV     a2, #0x03               ; output: Mode 3 (GPIO)
        STRH    a2, [a1, #0x020]        ; GPIO_127 at offset 0x120
        LDR     a2, =0x01080108         ; inputs: IEN + PTD + Mode 0
        LDR     a3, =0x0118             ; input:  IEN + PTU + Mode 0
        STRH    a2, [a1, #0x0006]       ; ABE_PDM_UL_DATA
        STRH    a2, [a1, #0x0008]       ; ABE_PDM_DL_DATA
        STRH    a3, [a1, #0x000A]       ; ABE_PDM_FRAME
        STR     a2, [a1, #0x000C]       ; ABE_PDM_LB_CLK + ABE_CLKS

        ; Before we go any further, enable module McPDM
        LDR     a1, L4_ClockMan_Log
        ADD     a1, a1, #CKGEN_CM1
        LDR     a2, [a1, #CM_CLKSEL_ABE]
        ORR     a2, a2, #(1 << 8)       ; PAD_CLOCKS_GATE
        STR     a2, [a1, #CM_CLKSEL_ABE]
        ADD     a1, a1, #(ABE_CM1 - CKGEN_CM1)
        MOV     a2, #2          ; enable module
        STR     a2, [a1, #CM1_ABE_PDM_CLKCTRL]
        LDR     a2, [a1, #CM1_ABE_CLKSTCTRL]
        BIC     a2, a2, #3      ; NO SLEEP
        STR     a2, [a1, #CM1_ABE_CLKSTCTRL]

        ; turn on the power for external audio chip (TWL6040)
        MOV     a1, #AUDIO_POWER_PIN
        MOV     a2, #1
        BL      GPIOx_SetAsOutput
        ; wait a bit
        LDR     a1, =AUDIO_POWER_DELAY
        BL      HAL_CounterDelay

        ; Set McPDM to reset state
        ; Perform full reset, in fact
        MOV     a1, #MCPDM_SYSCONFIG_SOFTRESET
        STR     a1, [v2, #MCPDM_SYSCONFIG]
10
        LDR     a1, [v2, #MCPDM_SYSCONFIG]
        TST     a1, #MCPDM_SYSCONFIG_SOFTRESET
        BNE     %BT10

        ; Set smart idle mode. No auto-idle available! :(
        MOV     a1, #MCPDM_SYSCONFIG_IDLEMODE_SMART
        STR     a1, [v2, #MCPDM_SYSCONFIG]
        MOV     v3, v2                          ; save ptr to PcPDM for later


        ; Now resume HAL device setup...

        ADD     v2, v1, #Audio_DeviceSize
        MOV     a1, v2
        ADR     a2, MixerTemplate
        MOV     a3, #Mixer_DeviceSize
        BL      memcpy

        ; Fill in pointers to each other
        STR     v1, [v2, #HALDevice_MixerCtrlr]
        STR     v2, [v1, #HALDevice_AudioMixer]

        LDRB    a1, [sb, #BoardConfig_MixerChans]
        STRB    a1, [v2, #:INDEX:MixerDisableFlags]
        ; Unavailable channels, and input channels, start muted
        ORR     a1, a1, #((1<<MixerChannel_HeadsetMic) + (1<<MixerChannel_AuxInput) + (1<<MixerChannel_MainMic))
        ADD     a2, v2, #:INDEX:MixerSettings
10      AND     a3, a1, #1
        MOVS    a1, a1, LSR #1
        STR     a3, [a2], #8
        BNE     %BT10

        ; Register devices
        MOV     a2, v1
        MOV     a1, #0
        CallOS  OS_AddDevice
        MOV     a2, v2
        MOV     a1, #0
        CallOS  OS_AddDevice


        ; allow registers to be accessed by i2c (only I2C, in fast mode)
        ; twl6040_write(codec, TWL6040_REG_ACCCTL, cache[TWL6040_REG_ACCCTL]);
        MOV     v4, v1                  ; save workspace ptr for later
        ADD     a2, v4, #:INDEX: AudioChipCache
        MOV     a4, #TWL6040_REG_ACCCTL
        ADD     a2, a2, a4
        MOV     a3, #(TWL6040_I2CSEL + TWL6040_INTCLRMODE + TWL6040_I2CMODE_FM)
        STRB    a3, [a2]
        MOV     a1, #TWL6040_IIC*2
        MOV     a3, #1
        LDR     v1, OSentries+4*OS_IICOpV
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #IICStatus_Completed
        BEQ     %FT10
        DebugTX "Audio_Init: TWL6040_ACCCTL access failed!"
10
  ]

        ; now read all regs into our reg cache
        ADD     a2, v4, #:INDEX: AudioChipCache ; address our reg cache
        MOV     a4, #TWL6040_REG_ASICID
        ADD     a2, a2, a4                      ; start with first valid register
        MOV     a1, #TWL6040_IIC*2
        MOV     a3, #(TWL6040_REG_STATUS + 1 - TWL6040_REG_ASICID)
        LDR     v1, OSentries+4*OS_IICOpV
        BL      TPSRead
  [ AudioDebug
        CMP     a1, #IICStatus_Completed
        BEQ     %FT20
        DebugTX "Audio_Init: read of TWL6040 regs failed!"
20
  ]

        ; extract offsets from TWL6040_REG_HSOTRIM register and set McPDM offsets
        ADD     a2, v4, #:INDEX: AudioChipCache
        MOV     a4, #TWL6040_REG_HSOTRIM
        LDRB    a3, [a2, a4]
        MOV     a2, a3, LSR #4          ; extract HSF part
        AND     a3, a3, #TWL6040_HSLO   ; isolate HSL part
        CMP     a3, #7
        SUBHI   a3, a3, #16             ; sign correction
        AND     a3, a3, #0x1F           ; mask valid offset bits
        CMP     a2, #7
        SUBHI   a2, a2, #16             ; sign correction
        AND     a2, a2, #0x1F           ; mask valid offset bits
        MOV     a3, a3, LSL #1          ; shift into DN_OFST_RX1 field
        MOV     a2, a2, LSL #9          ; shift into DN_OFST_RX2 field
        ORR     a3, a3, #MCPDM_DN_OFFSET_DN_OFST_RX1_EN
        ORR     a2, a2, #MCPDM_DN_OFFSET_DN_OFST_RX2_EN
        ORR     a2, a3, a2
        STR     a2, [v3, #MCPDM_DN_OFFSET]
        ; configure downlink threshold (differentiate between OMAP4460 and OMAP4430)
        LDR     a1, L4_Core_Log
        ADD     a1, a1, #(L4_SYSCTRL_GENERAL_CORE - L4_Core)
        LDR     a2, [a1, #CONTROL_ID_CODE]
        UBFX    a1, a2, #12, #16        ; HAWKEYE field
        MOV     v1, #HAWKEYE_OMAP4460_ES10
        CMP     a1, v1
        MOVEQ   a2, #(8 - 1)
        MOVNE   a2, #1
        STR     a2, [v3, #MCPDM_FIFO_CTRL_DN]
        ; remember usable FIFO size
        MOVEQ   a2, #8
        MOVNE   a2, #16
        ADD     a3, v4, #:INDEX: AudioDMASize
        STRB    a2, [a3]

30

  [ AudioDebug
        DebugTX "Audio_Init done"
  ]
        Pull    "v1-v4,pc"




; Sample rate table
; The first 'reserved' byte is used to store the value that needs programming into the
; TWL6040 LPPLLCTL register, the second byte is used for 'mono --> stereo' flag (HSMN2ST)
; 'mono' means: R channel gets same value as L channel (==> double sample rate)

        GBLA    numrate
numrate SETA    0

        MACRO
$lab    cdf     $freq, $per, $m, $mode  ; CD-derived rate ($freq in Hz, since all integral)
$lab    DCD     $freq*1024              ; frequency value as reported by Sound_SampleRate
        DCB     $per                    ; period as reported via Sound_Configure
        DCB     $mode                   ; 0=TWL6040_LPLLFIN not set, sysclk=19200000
                                        ; 1=TWL6040_LPLLFIN     set, sysclk=17640000
        DCB     $m                      ; 1=HSMN2ST active, 0=HSMN2ST not active
        DCB     0                       ; padding to 8 bytes
numrate SETA    numrate+1
        MEND

        ASSERT  AudioRateTableSize = 8

; short forms for mode
MODE_1920       *       (TWL6040_LPLLENA + 0)
MODE_1764       *       (TWL6040_LPLLENA + TWL6040_LPLLFIN)

ratetab
  [ AllSampleRates
        cdf     8000, 125, 1, MODE_1920         ;  8kHz     (125us)  AC97/6
        cdf     11025, 91, 1, MODE_1764         ; 11.025kHz (~91 us) CD/4
        cdf     16000, 63, 1, MODE_1920         ; 16kHz     (~63 us) AC97/3
        cdf     22050, 45, 1, MODE_1764         ; 22.05kHz  (~45 us) CD/2
        cdf     32000, 31, 1, MODE_1920         ; 32kHz     (~31 us) AC97*2/3
  ] ; AllSampleRates
  [ {FALSE} ; these are not natively supported
        cdf     44100, 23, 1, MODE_1764         ; 44.1kHz   (~23 us) CD/1
        cdf     48000, 21, 1, MODE_1920         ; 48kHz     (~21 us) AC97/1
  ]
        cdf     88200, 11, 0, MODE_1764         ; 88.2kHz   (~11 us) CD*2
        cdf     96000, 10, 0, MODE_1920         ; 96kHz     (~10 us) AC97*2

; Audio controller HAL device

AudioTemplate
        DCW     HALDeviceType_Audio + HALDeviceAudio_AudC
        DCW     HALDeviceID_AudC_TWL6040
        DCD     HALDeviceBus_Ser + HALDeviceSerBus_IIC
        DCD     2:SHL:16        ; API version 2.0
        DCD     AudioDesc
        DCD     0               ; Address - N/A
        %       12              ; Reserved
        DCD     AudioActivate
        DCD     AudioDeactivate
        DCD     AudioReset
        DCD     AudioSleep
        DCD     AUDIO_IRQ       ; Device
        DCD     0               ; TestIRQ cannot be called
        %       8
        DCD     0               ; Filled in during init
        DCD     1               ; Output channels (supported so far)
        DCD     0               ; Input channels (supported so far)
        ASSERT  (.-AudioTemplate) = HALDevice_Audio_Size
        ; DMA channel parameters
        DCD     0               ; flags
        DCD     AUDIO_DMA_CHAN + 1              ; logical channel
        DCD     0                               ; 'cycle speed'
        DCD     2                               ; transfer unit size: 16 bit (2 byte)
        DCD     L4_McPDM + MCPDM_DN_DATA + 2    ; *physical* address to send data to
                                                ; use upper half word only (left aligned 24 bit)
        ; Enable/disable/IRQ routines
        DCD     PreEnable
        DCD     PostEnable
        DCD     PreDisable
        DCD     PostDisable
        DCD     IRQHandle
        DCD     numrate         ; Number of sample rates
        DCD     ratetab         ; Sample rate table
        DCD     AudioSetRate    ; SetRate function
        ; extra fields for API 2.0
        DCD     0               ; AudioCustomDMAEnable
        DCD     AudioFlag_StereoReverse       ; map R-L to L-R
        DCD     0               ; AudioMinBuffSize
        DCD     0               ; AudioBuffAlign
        ASSERT  (. - AudioTemplate) = HALDevice_Audio_Size_2
        DCD     0               ; AudioRegs: filled in during init
        DCD     0               ; AudioWorkspace: filled in during init
        DCB     0               ; AudioMode
        DCB     0               ; AudioMono
        DCB     0               ; AudioDMASize
        DCB     0               ; AudioChannels
        %       48              ; AudioChipCache
        ALIGN

        ASSERT  (. - AudioTemplate) = Audio_DeviceSize

; Mixer HAL device

MixerTemplate
        DCW     HALDeviceType_Audio + HALDeviceAudio_Mixer
        DCW     HALDeviceID_Mixer_TWL6040
        DCD     HALDeviceBus_Ser + HALDeviceSerBus_IIC
        DCD     1               ; API version
        DCD     MixerDesc
        DCD     0               ; Address - N/A
        %       12              ; Reserved
        DCD     MixerActivate
        DCD     MixerDeactivate
        DCD     MixerReset
        DCD     MixerSleep
        DCD     -1              ; Device
        DCD     0               ; TestIRQ cannot be called
        %       8
        DCD     0               ; Filled in during init
        DCD     MixerChannels
        DCD     MixerGetFeatures
        DCD     MixerSetMix
        DCD     MixerGetMix
        DCD     MixerGetMixLimits
        ASSERT  (.-MixerTemplate) = HALDevice_Mixer_Size + 4
        ; Default settings will be filled in during init
        DCD     0, 0
        DCD     0, 0
        DCD     0, 0
        DCD     0, 0
        DCD     0, 0
        DCD     0, 0
        DCD     0, 0
        DCD     0, 0
        DCW     HS_GAIN_OFF     ; MixerHeadsetGain
        DCW     0               ; MixerEarphoneGain
        DCW     0               ; MixerHandsFreeGain
        DCW     0               ; MixerAuxOutputGain
        DCW     &1B             ; MixerSystemGain
        %       2
        ASSERT  (.-MixerTemplate) = Mixer_DeviceSize

AudioDesc
        =       "TWL6040-compatible audio controller", 0

MixerDesc
        =       "TWL6040-compatible audio mixer", 0
        ALIGN

AudioActivate
        ; TODO - Fix this!
        ; SoundDMA is higher up the module chain than SoundControl
        ; Which means we need the audio controller to do the mixer init, otherwise stuff might
        ; not work properly
        Entry   "v1,sb", 4
        ; Turn off codec, program mix params
        LDR     v1, [a1, #HALDevice_AudioMixer]
        ADD     v1, v1, #(:INDEX:MixerSettings)+8*MixerChannels
        MOV     a2, #MixerChannels-1
        LDR     sb, AudioWorkspace
  [ AudioDebug
        DebugTX "AudioActivate: Setting defaults"
  ]
        ADR     a3, ratetab
  [ AllSampleRates
        LDRB    a4, [a3, #(6*8+6)]
        LDRB    a3, [a3, #(6*8+5)]      ; use 48 kHz rate
  |
        LDRB    a4, [a3, #(1*8+6)]
        LDRB    a3, [a3, #(1*8+5)]      ; use 96 kHz rate
  ] ; AllSampleRates
        STRB    a4, AudioMono
        CMP     a4, #0
        MOVNE   a4, #(MCPDM_CTRL_PDM_DN1_EN)
        MOVEQ   a4, #(MCPDM_CTRL_PDM_DN1_EN + MCPDM_CTRL_PDM_DN2_EN)
        STRB    a4, AudioChannels
        STRB    a3, AudioMode
        BL      SetCodecMode
10      LDMDB   v1!,{a3-a4}
        BL      ReallySetMix
        SUBS    a2, a2, #1
        BGE     %BT10
        ; Finished!
        MOV     a1, #1
        EXIT

AudioDeactivate
        MOV     pc, lr

AudioReset
        MOV     pc, lr

AudioSleep
        MOV     a1, #0
        MOV     pc, lr

SetCodecMode
        ; Reprogram TWL6040_REG_LPPLLCTL from softcopy
        ; Assumes a1=audio device ptr, sb=HAL workspace
        Entry   "a1-a4,v1"

        ADR     a2, AudioMode
        MOV     a1, #TWL6040_IIC*2
        MOV     a3, #1
        MOV     a4, #TWL6040_REG_LPPLLCTL
        LDR     v1, OSentries+4*OS_IICOpV
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #IICStatus_Completed
        EXIT    EQ
        DebugTX "SetCodecMode: TPS write failed!"
  ]
        EXIT

PreEnable
        ; a2 = DMA buffer length
        ; Use the buffer length to calculate a DMA packet size that fits in the FIFO.
        ; McPDM has at most 16 FIFO entries; 1 entry contains 2 channels (stereo)
        ; packet size is handled in element numbers
        LDR     a3, AudioWorkspace
        LDRB    a4, AudioMono
        CMP     a4, #0
        LDRB    a4, AudioDMASize
        MOVEQ   a4, a4, LSL #1  ; double it for stereo
        STR     a4, [a3, #:INDEX: DMAPktSz_Audio]
        MOV     pc, lr

PostEnable
        ; a2 = DMA buffer length
        ; This function is a mix of two things:
        ; The McPDM instance is initialised first, to allow the DMA to prefill the TX FIFO.
        ; The TWL6040 is then initialised afterwards.
        Entry   "v1-v2,sb"
        LDR     sb, AudioWorkspace
  [ AudioDebug
        DebugTX "PostEnable"
  ]
        Push    "a1"
        LDR     v1, AudioRegs
        LDRB    v2, AudioChannels

        ; set McPDM Downlink path to reset state
        ; omap_mcpdm_reset_playback(1)
        LDR     a1, [v1, #MCPDM_CTRL]
        ORR     a1, a1, #MCPDM_CTRL_SW_DN_RST
        STR     a1, [v1, #MCPDM_CTRL]

        ; omap_mcpdm_playback_open()
        ; clear any outstanding interrupt causes
        MOV     a1, #-1
        STR     a1, [v1, #MCPDM_IRQSTATUS]
        ; enable irq request generation
        MOV     a1, #MCPDM_IRQ_DN_MASK
        STR     a1, [v1, #MCPDM_IRQENABLE_SET]
        ; enable DMA request generation
        MOV     a1, #MCPDM_DMA_DN
        STR     a1, [v1, #MCPDM_DMAENABLE_SET]
        ; set PDM out format
;       LDR     a1, [v1, #MCPDM_CTRL]
;       BIC     a1, a1, #MCPDM_CTRL_PDMOUTFORMAT        ; left justified
;       STR     a1, [v1, #MCPDM_CTRL]

        ; release McPDM Downlink path from reset state
        ; omap_mcpdm_reset_playback(0)
        ; omap_mcpdm_start()
        ; enable playback channel
        LDR     a1, [v1, #MCPDM_CTRL]
        BIC     a1, a1, #MCPDM_CTRL_SW_DN_RST
        ORR     a1, a1, #MCPDM_CTRL_WD_EN
        ORR     a1, a1, v2                              ; activate our channels
        STR     a1, [v1, #MCPDM_CTRL]

        Pull    "a1"

        ; enable headset (if needed)
        LDRB    a3, AudioMono
        LDR     a1, [a1, #HALDevice_AudioMixer]
        LDR     a2, MixerSettings+MixerChannel_HeadsetOut*8
        TST     a2, #MixerMixFlag_Mute
        BLEQ    UpdateHeadset

        EXIT

PreDisable
        ; Disable the TWL6040, and then McPDM
        ; This should avoid unwanted underflow IRQs
        Entry   "v1,sb"
        LDR     sb, AudioWorkspace
  [ AudioDebug
        DebugTX "PreDisable"
  ]

        ; Disable headset output if required
        LDR     v1, [a1, #HALDevice_AudioMixer]
        LDR     a2, [v1, #:INDEX:MixerSettings+MixerChannel_HeadsetOut*8]
        ANDS    a2, a2, #MixerMixFlag_Mute
        BNE     %FT30
        MOV     a2, #HS_GAIN_OFF        ; mark it as OFF
        STRH    a2, [v1, #:INDEX:MixerHeadsetGain]
        Push    "a1"
        LDRB    a2, AudioMono
        CMP     a2, #0
        ADRNEL  a2, HeadsetDisableSequenceM
        ADREQL  a2, HeadsetDisableSequenceS
        MOV     a3, #1
        LDR     v1, OSentries+4*OS_IICOpV
10
        LDRB    a4, [a2],#1
        MOV     a1, #TWL6040_IIC*2
        CMP     a4, #0
        BEQ     %FT20
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #IICStatus_Completed
        BEQ     %FT15
        DebugReg a4,"PreDisable: Write failed, reg="
15
  ]
        ADD     a2, a2, #1
        B       %BT10
20
        Pull    "a1"
30

        ; omap_mcpdm_stop()
        ; disable playback channel
        LDR     a2, AudioRegs
        LDR     a3, [a2, #MCPDM_CTRL]
        BIC     a3, a3, #MCPDM_DL_CHANNELS
        STR     a3, [a2, #MCPDM_CTRL]

        ; omap_mcpdm_playback_close()
        ; disable IRQ request generation
        MOV     a3, #MCPDM_IRQ_DN_MASK
        STR     a3, [a2, #MCPDM_IRQENABLE_CLR]
        ; disable DMA request generation
        MOV     a3, #MCPDM_DMA_DN
        STR     a3, [a2, #MCPDM_DMAENABLE_CLR]

        EXIT

PostDisable
        MOV     pc, lr

IRQHandle
  [ AudioDebug
        Push    "sb,lr"
        LDR     sb, AudioWorkspace
        LDR     a2, AudioRegs
        LDR     a2, [a2, #MCPDM_IRQSTATUS]
        DebugReg a2,"IRQHandle: IRQSTATUS="
        Pull    "sb,lr"
  ]
  [ {FALSE} ;{TRUE}
        ; Just clear the IRQ and ask for an audio reset
        LDR     a3, AudioRegs
        MVN     a2, #0
        ; Make sure we don't get bothered about this again - we can't guarantee when the OS
        ; will get round to resetting the audio, and could potentially get stuck in a loop
        ; if we allow the IRQ to keep firing
        STR     a2, [a3, #MCPDM_IRQENABLE_CLR]
        STR     a2, [a3, #MCPDM_IRQSTATUS]      ; clear all possible causes
        MOV     a1, #AudioIRQHandle_RequestReset
        MOV     pc, lr
  |
        ; restart the PDM channels and go on
        LDR     a3, AudioRegs
        LDR     a2, [a3, #MCPDM_IRQSTATUS]
        STR     a2, [a3, #MCPDM_IRQSTATUS]      ; clear interrupt causes
        LDR     a2, [a3, #MCPDM_CTRL]
        BIC     a2, a2, #MCPDM_DL_CHANNELS
        ORR     a2, a2, #MCPDM_CTRL_SW_DN_RST   ; reset downlink path
        STR     a2, [a3, #MCPDM_CTRL]
        BIC     a2, a2, #MCPDM_CTRL_SW_DN_RST   ; release reset
        STR     a2, [a3, #MCPDM_CTRL]
        ; prepare some data in FIFO (to avoid underflow)
        MOV     a2, #0
        STR     a2, [a3, #MCPDM_DN_DATA]
        STR     a2, [a3, #MCPDM_DN_DATA]
        LDR     a2, [a3, #MCPDM_CTRL]
        LDRB    a1, AudioChannels
        ORR     a2, a2, a1                      ; reenable channels
        STR     a2, [a3, #MCPDM_CTRL]
        MOV     a1, #AudioIRQHandle_NOP
        MOV     pc, lr
  ]

AudioSetRate
        ; a2 = sample rate index (0-based)
        Entry   "sb"
        LDR     sb, AudioWorkspace
  [ AudioDebug
        DebugReg a2, "AudioSetRate: "
  ]
        ; Reload TWL6040_REG_LPPLLCTL with the required value
        ADRL    a3, ratetab
        ASSERT  AudioRateTableSize = 8
        ADD     a3, a3, a2, LSL #3
        LDRB    a4, [a3, #6]
        LDRB    a3, [a3, #5]
        STRB    a4, AudioMono
        CMP     a4, #0
        MOVNE   a4, #(MCPDM_CTRL_PDM_DN1_EN)
        MOVEQ   a4, #(MCPDM_CTRL_PDM_DN1_EN + MCPDM_CTRL_PDM_DN2_EN)
        STRB    a4, AudioChannels
        STRB    a3, AudioMode
        BL      SetCodecMode
        EXIT

MixerActivate
        MOV     a1, #1

MixerDeactivate
        MOV     pc, lr

MixerReset
        Entry   "v1,sb", 4
        ; program default mix params
        ADR     v1, MixerSettings+8*MixerChannels
        LDR     a1, [a1, #HALDevice_MixerCtrlr]
        MOV     a2, #MixerChannels-1
        LDR     sb, AudioWorkspace
  [ AudioDebug
        DebugTX "MixerReset: Setting defaults"
  ]
10      LDMDB   v1!,{a3-a4}
        BL      ReallySetMix
        SUBS    a2, a2, #1
        BGE     %BT10
        EXIT

MixerSleep
        ; TODO?
        MOV     a1, #0
        MOV     pc, lr

MixerGetFeatures
        ; Check if this channel is disabled and needs the 'fixed' flag
        MOV     a4, #1
        LDRB    a3, MixerDisableFlags
        TST     a3, a4, LSL a2
        ADR     a1, MixerFeaturesTab
        LDR     a1, [a1, a2, LSL #2]
        ORRNE   a1, a1, #MixerFeaturesFlag_Fixed
        MOV     pc, lr

MixerFeaturesTab
        ; Stereo headset output
        DCW     0
        DCW     MixerCategory_Headphones
        ; Mono earphone output
        DCW     MixerFeaturesFlag_DefaultMute
        DCW     MixerCategory_Speaker
        ; Stereo hands-free output
        DCW     MixerFeaturesFlag_DefaultMute
        DCW     MixerCategory_LineOut
        ; Stereo FM/aux output
        DCW     MixerFeaturesFlag_DefaultMute
        DCW     MixerCategory_AuxOut
        ; System audio
        DCW     0
        DCW     MixerCategory_System
        ; Stereo headset mic
        DCW     MixerFeaturesFlag_Mono :OR: MixerFeaturesFlag_DefaultMute
        DCW     MixerCategory_Mic
        ; Stereo FM/aux input
        DCW     MixerFeaturesFlag_DefaultMute
        DCW     MixerCategory_LineIn
        ; Mono main mic
        DCW     MixerFeaturesFlag_Mono :OR: MixerFeaturesFlag_DefaultMute
        DCW     MixerCategory_AuxIn

; MixerDevice API v0.1
MixerGetMixLimits
        ADR     a1, MixerLimitsTab
        ADD     a1, a1, a2, LSL #3
        ADD     a1, a1, a2, LSL #2
        LDMIA   a1, {a1, a2, a4}
        STMIA   a3, {a1, a2, a4}
        MOV     pc, lr

MixerLimitsTab
        ; Stereo headset output
        DCD     -30*16
        DCD     0
        DCD     2*16
        ; Mono speaker output
        DCD     -24*16
        DCD     6*16
        DCD     2*16
        ; Stereo hands-free output
        DCD     -52*16
        DCD     6*16
        DCD     2*16
        ; Stereo FM/aux output
        DCD     -52*16
        DCD     6*16
        DCD     2*16
        ; System audio
        DCD     -18*16
        DCD     24*16
        DCD     6*16
        ; Stereo headset mic
        DCD     6*16
        DCD     30*16
        DCD     6*16
        ; Stereo FM/aux input
        DCD     6*16
        DCD     30*16
        DCD     6*16
        ; Mono main mic
        DCD     6*16
        DCD     30*16
        DCD     6*16

MixerSetMix
        ; a1 = mixer device
        ; a2 = channel
        ; a3 = mute flag
        ; a4 = gain, in dB*16
        Entry   "v1"
        ; Double-check that we aren't being asked to program a disabled channel
        ; Although ReallySetMix will do another check, we must check here to make sure we don't
        ; update the stored settings (particularly the headset settings, which UpdateHeadset
        ; treats as gospel)
        MOV     ip, #1
        LDRB    v1, MixerDisableFlags
        TST     v1, ip, LSL a2
        EXIT    NE
        ADR     v1, MixerSettings
        ADD     v1, v1, a2, LSL #3
        LDMIA   v1, {ip, lr}
        TEQ     a3, ip
        TEQEQ   a4, lr
        STMNEIA v1, {a3, a4}
        LDRNE   a1, [a1, #HALDevice_MixerCtrlr]
        BLNE    ReallySetMix
        EXIT

ReallySetMix
        ; a1 = *audio* device
        ; a2-a4 as above
        ; Preserves all regs
        ; Channel gain & mute control can't easily be abstracted, need to do it on a
        ; case-by-case basis :(
        ; Common code to get ready for IIC transfers
        Entry   "a1-a4,v1-v5,sb,v7"
        LDR     sb, AudioWorkspace
  [ AudioDebug
        DebugTX "ReallySetMix:"
        DebugReg a2,"Channel="
        DebugReg a3,"Mute="
        DebugReg a4,"Gain="
  ]
        ; Triple-check that we aren't being asked to program a disabled channel
        ; (ReallySetMix gets called unconditionally in a few places; easier to just check for
        ; invalid channels here rather than in every place it gets called from)
        LDRB    v5, [sb, #BoardConfig_MixerChans]
        MOV     v2, #1
        TST     v5, v2, LSL a2
        EXIT    NE
        LDR     v5, [a1, #HALDevice_AudioMixer]
        MOV     v2, a3
;       LDRB    v4, AudioMode
        LDRB    v4, AudioMono
        ADD     v7, v5, #:INDEX: MixerSettings+4
        LDR     v1, OSentries+4*OS_IICOpV
        MOV     a1, #TWL6040_IIC*2
        ADD     v7, v7, a2, LSL #3
        ADR     a3, SetMixTab
        MOV     v3, a4
        LDR     pc, [a3, a2, LSL #2]
        ; Following code entered with:
        ; a1, v1 ready for TPSRead/TPSWrite
        ; v2 = mute flag
        ; v3 = gain
        ; v4 = current AudioMono setting
        ; v5 = mixer device
        ; sb = HAL WS
        ; v7 = gain writeback ptr
SetMixTab
        DCD     SetMixHeadsetOut
        DCD     SetMixEarphone
        DCD     SetMixHandsFree
        DCD     SetMixAuxOutput
        DCD     SetMixSystem
        DCD     SetMixHeadsetMic
        DCD     SetMixAuxInput
        DCD     SetMixMainMic

SetMixHeadsetOut ; HS_* regs
        ; Go through to UpdateHeadset
        MOV     a3, v4
        MOV     a1, v5
        BL      UpdateHeadset
        EXIT

SetMixEarphone ; TWL6040 has no predriver regs ==> use earphone instead
        ; Calculate EARGAIN: 0x0 == 6 dB, 0x1 == 4 dB, 0x2 == 2 dB ... 0xF == -24dB
        TST     v2, #MixerMixFlag_Mute
        MOVNE   v4, #0                  ; disable everything
        BNE     %FT10
        ; limit gain to allowed range
        CMP     v3, #-24*16
        LDRLT   v3, =(-24*16)
        CMP     v3, #6*16
        MOVGT   v3, #6*16
        ; calculate gain value
        MOV     lr, v3, ASR #(4+1)      ; div by step width (2 dB)
        RSB     v4, lr, #3              ; negate at zero point
        MOV     v4, v4, LSL #1          ; shift into EARGAIN position
        STR     v3, [v7]                ; remember used gain value
        ORR     v4, v4, #TWL6040_EARENA ; enable it
10
        ADD     a2, v5, #:INDEX:MixerEarphoneGain
        LDRH    ip, [a2]
        CMP     ip, v4
        EXIT    EQ
        STRH    v4, [a2]
        MOV     a3, #1
        MOV     a4, #TWL6040_REG_EARCTL
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #0
        EXIT    EQ
        DebugTX "SetMixEarphone: TPS write failed!"
  ]
        EXIT

SetMixHandsFree ; HF* regs
        ; Go through to UpdateHandsFree
        MOV     a1, v5
        BL      UpdateHandsFree
        EXIT


SetMixAuxOutput
        ; Aux Output path has no separate control registers in TWL6040
        ; it is internally connected to handsfree path
        B       SetMixHandsFree

SetMixSystem
        ; there is no such thing for output in TWL6040
        ; there is only a general LINEGAIN for input paths
        ; Calculate LINEGAIN (L|R): 0x0 == -18 dB, 0x1 == -12 dB, ... 0x7 == +24 dB
        ; range mapping: [-18 dB .. +24 dB]
        ; mapping: fScale = (1 / 6) = 0.166.. ~ 2370 [ * 2^14]
        ; "/ 6" for step width of 6 dB
        TST     v2, #MixerMixFlag_Mute
        MOVNE   v4, #0                  ; disable everything
        BNE     %FT10
        ; limit gain to allowed range
        CMP     v3, #-18*16
        LDRLT   v3, =(-18*16)
        CMP     v3, #24*16
        MOVGT   v3, #24*16
        STR     v3, [v7]                ; remember used gain value
        ; calculate scaled gain value
        CMP     v3, #0
        ADDGT   v3, v3, #1              ; compensate for rounding errors
        MOV     a3, #2370               ; == fScale
        MUL     a3, v3, a3
        MOV     a3, a3, ASR #(14+4)     ; div by (16 * 2^14)
        ADD     a3, a3, #3              ; add 0 dB offset
        AND     v4, a3, #TWL6040_LINEGAINL      ; only relevant bits
        ORR     v4, v4, v4, LSL #3      ; fold into LINEGAINR
10
        ADD     a2, v5, #:INDEX:MixerSystemGain
        LDRH    ip, [a2]
        CMP     ip, v4
        EXIT    EQ
        MOV     a3, #1
        STRH    v4, [a2]
        MOV     a4, #TWL6040_REG_LINEGAIN
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #0
        EXIT    EQ
        DebugTX "SetMixSystem: TPS write failed!"
  ]
        EXIT

SetMixHeadsetMic ; TODO - Implement!
SetMixAuxInput ; TODO - Implement!
SetMixMainMic ; TODO - Implement!
        EXIT

MixerGetMix
        ADR     a1, MixerSettings
        ADD     a1, a1, a2, LSL #3
        LDMIA   a1, {a1, a2}
        MOV     pc, lr

UpdateHeadset
        ; This performs the steps necessary to enable/disable the headset output
        ; Input:
        ; a1 = mixer device
        ; a3 = AudioMono flag
        ; sb = HAL workspace
        Entry   "a1-a4,v1", 12

        ; Get mixer settings for headset
        ADR     ip, MixerSettings+MixerChannel_HeadsetOut*8
        LDMIA   ip, {a4,v1}     ; a4 = mute flag, v1 = gain
        TST     a4, #MixerMixFlag_Mute
        BEQ     %FT02
        CMP     a3, #0
        ADRNE   a2, HeadsetDisableSequenceM ; Muted, so disable it
        ADREQ   a2, HeadsetDisableSequenceS ; Muted, so disable it
        MOV     ip, #0
        B       %FT05
02
        ; limit gain to allowed range
        CMP     v1, #-30*16
        LDRLT   v1, =(-30*16)
        CMP     v1, #0
        MOVGT   v1, #0
        ; Calculate HSGAIN: 0x0 == 0 dB, 0x1 == -2 dB, ... 0xF == -30dB
        MOV     a2, v1, ASR #(4+1)      ; div by step width (2 dB)
        RSB     ip, a2, #0              ; negate
        ORR     ip, ip, ip, LSL #4      ; fold it into HSGAINR
        ; Copy enable sequence to stack so we can modify it with the correct gain
        CMP     a3, #0
        ADRNE   a3, HeadsetEnableSequenceM
        ADREQ   a3, HeadsetEnableSequenceS
        MOV     a2, sp
        LDRH    v1, MixerHeadsetGain
        CMP     v1, #HS_GAIN_OFF        ; Is the headset currently turned off?
        LDMIA   a3, {a3,a4,v1}
        ORR     a4, a4, ip, LSL #8      ; Set correct gain
        STMEQIA a2, {a3,a4,v1}          ; Full programming sequence if headset off
        MOVNE   a4, a4, LSL #16         ; If headset on, only change HSGAIN
        MOVNE   a4, a4, LSR #16
        STRNE   a4, [a2]
05
        ; a2 = sequence to program
        ; ip = HSGAIN value
        LDRH    v1, MixerHeadsetGain
  [ AudioDebug
        DebugReg ip,"UpdateHeadset: New="
        DebugReg v1,"Old="
  ]
        CMP     v1, ip
        EXIT    EQ              ; Avoid reprogramming identical values
        STRH    ip, MixerHeadsetGain
        MOV     a3, #1
        LDR     v1, OSentries+4*OS_IICOpV
10
        LDRB    a4, [a2],#1
        MOV     a1, #TWL6040_IIC*2
        CMP     a4, #0
        EXIT    EQ
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #IICStatus_Completed
        BEQ     %FT15
        DebugReg a4,"UpdateHeadset: Write failed, reg="
15
  ]
        ADD     a2, a2, #1
        B       %BT10

HeadsetEnableSequenceM
        DCB     TWL6040_REG_HSLCTL, &2B ; DAC ON
        DCB     TWL6040_REG_HSRCTL, &AB ; DAC ON + HSMN2ST
        DCB     TWL6040_REG_HSGAIN, 0   ; this gets filled in above
        DCB     TWL6040_REG_HSLCTL, &2F ; DAC + Driver ON
        DCB     TWL6040_REG_HSRCTL, &AF ; DAC + Driver ON + HSMN2ST
        DCB     0       ; Terminator
        ALIGN

HeadsetEnableSequenceS
        DCB     TWL6040_REG_HSLCTL, &2B ; DAC ON
        DCB     TWL6040_REG_HSRCTL, &2B ; DAC ON
        DCB     TWL6040_REG_HSGAIN, 0   ; this gets filled in above
        DCB     TWL6040_REG_HSLCTL, &2F ; DAC + Driver ON
        DCB     TWL6040_REG_HSRCTL, &2F ; DAC + Driver ON
        DCB     0       ; Terminator
        ALIGN

HeadsetDisableSequenceM
        DCB     TWL6040_REG_HSLCTL, &2B ; DAC ON
        DCB     TWL6040_REG_HSRCTL, &AB ; DAC ON + HSMN2ST
        DCB     TWL6040_REG_HSGAIN, HS_GAIN_OFF ; special value for marking OFF
        DCB     0       ; Terminator
        ALIGN

HeadsetDisableSequenceS
        DCB     TWL6040_REG_HSLCTL, &2B ; DAC ON
        DCB     TWL6040_REG_HSRCTL, &2B ; DAC ON
        DCB     TWL6040_REG_HSGAIN, HS_GAIN_OFF ; special value for marking OFF
        DCB     0       ; Terminator
        ALIGN


UpdateHandsFree
        ; This performs the steps necessary to enable/disable the hands-free output
        ; Input:
        ; a1 = mixer device
        ; sb = HAL workspace
        Entry   "a1-a4,v1", 16

        ; Get mixer settings for headset
        ADR     ip, MixerSettings+MixerChannel_HandsFree*8
        LDMIA   ip, {a4,v1}     ; a4 = mute flag, v1 = gain
        TST     a4, #MixerMixFlag_Mute
        ADRNE   a2, HandsFreeDisableSequence ; Muted, so disable it
        MOVNE   ip, #0
        BNE     %FT05
        ; gain is in HFLGAIN and HFRGAIN each with the following values:
        ; 0x00 == 6 dB, 0x01 == 4 dB, 0x02 == 2 dB, 0x03 == 0 dB, 0x04 == -2 dB,
        ; ... 0x1C == -50 dB, 0x1D == -52 dB  (0x1E and 0x1F not valid)
        ; limit gain to allowed range
        CMP     v1, #-52*16
        LDRLT   v1, =(-52*16)
        CMP     v1, #6*16
        MOVGT   v1, #6*16
        ; calculate gain value
        MOV     a3, v1, ASR #(4+1)      ; div by step width (2 dB)
        RSB     ip, a3, #3              ; negate at zero point
        ; Copy enable sequence to stack so we can modify it with the correct gain
        ADR     a3, HandsFreeEnableSequence
        MOV     a2, sp
        LDRH    v1, MixerHandsFreeGain
        CMP     v1, #HF_GAIN_OFF        ; Is the hands-free currently turned off?
        LDMIA   a3, {a3,a4,v1}
        ORR     a4, a4, ip, LSL #8      ; Set correct gain HFLGAIN
        ORR     a4, a4, ip, LSL #24     ; Set correct gain HFRGAIN
        STMEQIA a2, {a3,a4,v1}          ; Full programming sequence if hands-free off
        STRNE   a4, [a2]                ; If hands-free on, only change HFxGAIN
        MOV     a4, #0                  ; terminate sequence with 0
        STRNE   a4, [a2, #4]
        STREQ   a4, [a2, #3*4]
05
        ; a2 = sequence to program
        ; ip = HFxGAIN value
        LDRH    v1, MixerHandsFreeGain
  [ AudioDebug
        DebugReg ip,"UpdateHandsFree: New="
        DebugReg v1,"Old="
  ]
        CMP     v1, ip
        EXIT    EQ              ; Avoid reprogramming identical values
        STRH    ip, MixerHandsFreeGain
        MOV     a3, #1
        LDR     v1, OSentries+4*OS_IICOpV
10
        LDRB    a4, [a2],#1
        MOV     a1, #TWL6040_IIC*2
        CMP     a4, #0
        EXIT    EQ
        BL      TPSWrite
  [ AudioDebug
        CMP     a1, #IICStatus_Completed
        BEQ     %FT15
        DebugReg a4,"UpdateHandsFree: Write failed, reg="
15
  ]
        ADD     a2, a2, #1
        B       %BT10

HandsFreeEnableSequence
        DCB     TWL6040_REG_HFLCTL, &07 ; DAC ON
  [ Mono2Stereo
        DCB     TWL6040_REG_HFRCTL, &27 ; DAC ON + HFMN2ST
  |
        DCB     TWL6040_REG_HFRCTL, &07 ; DAC ON
  ] ; Mono2Stereo
        DCB     TWL6040_REG_HFLGAIN, 0  ; this gets filled in above
        DCB     TWL6040_REG_HFRGAIN, 0  ; this gets filled in above
        DCB     TWL6040_REG_HFLCTL, &17 ; DAC + Driver ON
  [ Mono2Stereo
        DCB     TWL6040_REG_HFRCTL, &37 ; DAC + Driver ON + HFMN2ST
  |
        DCB     TWL6040_REG_HFRCTL, &17 ; DAC + Driver ON
  ] ; Mono2Stereo
        DCB     0       ; Terminator
        ALIGN

HandsFreeDisableSequence
        DCB     TWL6040_REG_HFLCTL, &07 ; DAC ON
  [ Mono2Stereo
        DCB     TWL6040_REG_HFRCTL, &27 ; DAC ON + HFMN2ST
  |
        DCB     TWL6040_REG_HFRCTL, &07 ; DAC ON
  ] ; Mono2Stereo
        DCB     TWL6040_REG_HFLGAIN, &1D        ; nearly mute
        DCB     TWL6040_REG_HFRGAIN, &1D        ; nearly mute
        DCB     0       ; Terminator
        ALIGN


        END
