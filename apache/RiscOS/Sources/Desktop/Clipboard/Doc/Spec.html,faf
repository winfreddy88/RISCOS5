<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD><TITLE>Drag and Drop Protocol</TITLE></HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">
<BASEFONT SIZE=2>
<P ALIGN=CENTER>
<B><FONT SIZE="+4">Drag-and-Drop Functional Specification</FONT></B>
<DIV ALIGN=CENTER>
<TABLE CELLPADDING=5>
<TR><TD ALIGN=RIGHT WIDTH=108><TT>Document Ref:</TT>
<TD WIDTH=243><FONT SIZE="+1">1309,419/FS</FONT>
<TR><TD ALIGN=RIGHT><TT>Project:</TT>
<TD><FONT SIZE="+1">Shared Source RISC OS release (formerly Ursula and Java 1.2)</FONT>
<TR><TD ALIGN=RIGHT><TT>Revision:</TT>
<TD><FONT SIZE="+1">G *** DRAFT ***</FONT>
<TR><TD ALIGN=RIGHT><TT>Date:</TT>
<TD><FONT SIZE="+1">22 February 2015</FONT>
<TR><TD ALIGN=RIGHT><TT>Author(s):</TT>
<TD><FONT SIZE="+1">Ben Avison</FONT>
<TR><TD ALIGN=RIGHT><TT>Change:</TT>
<TD><FONT SIZE="+1">Finally finished integrating the Ursula review comments and 8 years' worth of mental notes, for initial release alongside shared source code</FONT>
</TABLE>
</DIV>
<P>
<B><FONT SIZE="+3">Contents:</FONT></B>
<DIV ALIGN=CENTER>
<TABLE CELLPADDING=5>
<TR><TD ALIGN=RIGHT WIDTH=29><FONT SIZE="+1">1.</FONT>
<TD WIDTH=237><FONT SIZE="+1">Overview</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">2.</FONT>
<TD><FONT SIZE="+1">Outstanding Issues</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">3.</FONT>
<TD><FONT SIZE="+1">Technical Background</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">4.</FONT>
<TD><FONT SIZE="+1">User Interface</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">5.</FONT>
<TD><FONT SIZE="+1">Programming Interface and Data Interchange</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">6.</FONT>
<TD><FONT SIZE="+1">Data Formats</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">7.</FONT>
<TD><FONT SIZE="+1">Dependencies</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">8.</FONT>
<TD><FONT SIZE="+1">Acceptance Test</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">9.</FONT>
<TD><FONT SIZE="+1">Non Compliances</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">10.</FONT>
<TD><FONT SIZE="+1">Development Test Strategy</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">11.</FONT>
<TD><FONT SIZE="+1">Product Organisation</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">12.</FONT>
<TD><FONT SIZE="+1">Future Enhancements</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">13.</FONT>
<TD><FONT SIZE="+1">Glossary</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">14.</FONT>
<TD><FONT SIZE="+1">References</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">15.</FONT>
<TD><FONT SIZE="+1">History</FONT>
<TR><TD ALIGN=RIGHT><FONT SIZE="+1">16.</FONT>
<TD><FONT SIZE="+1">Appendices</FONT>
</TABLE>
</DIV>
<P>
<B><FONT SIZE="+3">1. Overview</FONT></B>
<P>
<B><FONT SIZE="+1">1.1. This Document</FONT></B>
<P>
<FONT SIZE="+1">This document supersedes the cut-and-paste and drag-and-drop protocol application notes [1] and [2], and specifies the cut-and-paste / drag-and-drop abilities to be added to the Wimp, plus the Clipboard module that supports the Wimp (and whose facilities will also be of use to future applications intended to support the protocols).</FONT>
<P>
<FONT SIZE="+1">Key terms are defined and some familiar terms are also redefined more precisely in the glossary (&sect;13), and the reader is recommended to read this first.</FONT>
<P>
<FONT SIZE="+1">Where information is fundamentally new in this specification - non-obvious consequences of and clarifications and extensions to the existing protocol, the relevant section is underlined to bring attention to the fact.</FONT>
<P>
<FONT SIZE="+1">The document may be slightly weighted towards text-handling applications, but this is because the user interface is generally more complicated in such cases. It is expected that the reader be able to extrapolate meanings to apply to any possible fundamental type of data.</FONT>

<P>
<B><FONT SIZE="+1">1.2. Cut-and-Paste</FONT></B>
<P>
<FONT SIZE="+1">Global-clipboard-based or cut-and-paste data transfer involves data being removed or copied from any document in the desktop to a notional "clipboard", then pasted from the clipboard into the same document, or any other document in the desktop, whether managed by the same application or not. On the way, data translation is performed in such a way as to minimise the information loss about the data.</FONT>
<P>
<FONT SIZE="+1">This interface involves three operations, cut, copy and paste, which may be performed in any order. Any one data transfer will require at least two of these operations, in addition to the choice of the original selection and the destination point; the process is somewhat clumsy (and unintuitive, since the clipboard is hidden from view), so this is the least preferred technique of the two described in this document. However, it must still be provided, as it does allow some operations which cannot be achieved in any other way, and can perform other operations faster than by drag-and-drop.</FONT>

<P>
<B><FONT SIZE="+1">1.3. Drag-and-Drop</FONT></B>
<P>
<FONT SIZE="+1">Drag-and-drop is similar to cut-and-paste, but with the cut/copy performed by pressing a mouse button, and the paste by releasing the button at the destination. Full drag-and-drop compliance combines the features of conventional, simple drag-and-drop, as commonly used in Save dialogue boxes, with the data translation abilities of the global clipboard, and overcomes the abstract nature of the global clipboard by the displaying throughout the drag a bounding box, dithered sprite/object or representation of the insertion point.</FONT>
<P>
<FONT SIZE="+1">The user interface is simpler to use - consisting typically of two mouse drags (one to select and one to move or copy), with a requirement for at most one keypress (the Shift key swaps the meaning of copying and moving). However, the programming interface is more complicated, because continuously negotiated transferable data types, destination positioning and rendering of objects and pointers are required in addition to everything needed for cut-and-paste. This complexity is possibly responsible for the low implementation rate of the protocol to date.</FONT>

<P>
<B><FONT SIZE="+1">1.4. General</FONT></B>
<P>
<FONT SIZE="+1">The Clipboard module is primarily to enable cut-and-paste and drag-and-drop to be reliably implemented for writable icons, which are handled automatically by the Wimp. (The fundamental problem is that the established cut-and-paste and drag-and-drop systems are Wimp-message-based, and the Wimp itself is poorly equipped to send and receive messages.)</FONT>
<P>
<FONT SIZE="+1">However, the module is secondarily to handle the complex protocols on behalf of any application that chooses to do so - and in the process, producing a more uniform user interface. This is to be the preferred method of implementing the protocols in future, although in special cases, the tasks it performs can be split into four separate areas, any combination of which can be taken advantage of by the same application:</FONT>
<UL>
<LI><FONT SIZE="+1">clipboard management - supporting cut and copy operations</FONT>
<LI><FONT SIZE="+1">clipboard procurement - supporting paste operations</FONT>
<LI><FONT SIZE="+1">sending drag-and-drop data</FONT>
<LI><FONT SIZE="+1">receiving drag-and-drop data</FONT>
</UL>


<P>
<B><FONT SIZE="+3">2. Outstanding Issues</FONT></B>
<P>
<B><FONT SIZE="+1">2.1. Bounding Box Discrepancies</FONT></B>
<P>
<FONT SIZE="+1">It is possible that data may have different "real life" bounding boxes in different data types - for example, a DrawFile sprite object may be transformed and/or scaled, and thus have a different bounding box to the underlying sprite. Thus if a transformed sprite object were dragged from Draw to a sprite editor window, the bounding box would <I>not</I> represent the final position of the sprite.</FONT>

<P>
<B><FONT SIZE="+3">3. Technical Background</FONT></B>
<P>
<B><FONT SIZE="+1">3.1. This Document</FONT></B>
<P>
<FONT SIZE="+1">Some important pre-existing technical terms are rigorously defined in the context of cut-and-paste / drag-and-drop in the Glossary in &sect;13, along with some new terms introduced in this document.</FONT>
<P>
<FONT SIZE="+1">Where technical background information is relatively straightforward (no more than one or two short paragraphs), it is included alongside the appropriate part of &sect;4 or &sect;5, for ease of reference.</FONT>

<P>
<B><FONT SIZE="+1">3.2. Previous Documents</FONT></B>
<P>
<FONT SIZE="+1">Simple drag-and-drop operations, such as those employed by Save dialogue boxes, do not employ any inter-task negotiation during the drag, and use the plain DataSave/DataLoad protocol during the drop, as described in the Programmer's Reference Manual [3].</FONT>
<P>
<FONT SIZE="+1">The Style Guide [4] first indicates selection models, then describes an overview of cut-and-paste and drag-and-drop behaviour, before referring the reader to the relevant Support Group Application Notes [1] and [2].</FONT>

<P>
<B><FONT SIZE="+1">3.3 Previous Applications</FONT></B>
<P>
<FONT SIZE="+1">Old-style selection model / copy-and-move implementations are still in existence, especially so in the case of text editors, (e.g. Zap, StrongEd, SrcEdit) which have often followed Edit's example. Such schemes typically involve only three actions to perform an operation (select region, position caret, move/copy keypress) rather than the four (select region, cut/copy keypress, position caret, paste keypress), but have the disadvantage that they can present both a caret and a selection to the user at the same time, which is potentially confusing. Old behaviour will remain deprecated, but new cut-and-paste / drag-and-drop applications must be able to interact with tasks that use it.</FONT>
<P>
<FONT SIZE="+1">Other applications may support just cut-and-paste, or just drag-and-drop. Drag-and-drop will be the favoured technique in future, due to the simpler actions required (select region, drag region), but cut-and-paste must also be supported as well, to cater for cases when drag-and-drop cannot be used (e.g. when copying on to a menu tree).</FONT>
<P>
<FONT SIZE="+1">Some aspects (e.g. pointer shape, window) of applications already written to the application note guidelines (e.g. DataPower, EasiWriter/TechWriter) are already inconsistent, due to the lack of detail in the application notes. Applications will in future be encouraged to follow the more detailed specification herein.</FONT>


<P>
<B><FONT SIZE="+3">4. User Interface</FONT></B>
<P>
<B><FONT SIZE="+1">4.1. Selection</FONT></B>
<P>
<B><FONT SIZE="+1">4.1.1. Protocol</FONT></B>
<P>
<B>4.1.1.1. Rendering</B>
<P>
<U><FONT SIZE="+1">Selection is rendered either by a recolouring an object (with its photographic negative or otherwise) or by drawing a bounding box, typically in red, and optionally with one or more "handles" for resizing and/or rotating operations as appropriate:</FONT></U>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic4.gif" ALT="" ALIGN=MIDDLE HEIGHT=60 WIDTH=103 VSPACE=2><IMG SRC="Images/Pic6.gif" ALT="" ALIGN=MIDDLE HEIGHT=60 WIDTH=123 VSPACE=2><IMG SRC="Images/Pic5.gif" ALT="" ALIGN=MIDDLE HEIGHT=60 WIDTH=146 VSPACE=2><IMG SRC="Images/Pic7.gif" ALT="" ALIGN=MIDDLE HEIGHT=60 WIDTH=111 VSPACE=2></FONT>
<P>
<FONT SIZE="+1">It should be emphasised that a caret must never appear within the same window as a selection at any time, not even during the selecting drag. Placing a new caret or selection removes any caret or selection previously active in the same window. (The definition of a window for these purposes is a top-level window and its panes and all their child windows.)</FONT>
<P>
<FONT SIZE="+1"><U>However, if during (or immediately after) the selection process, the selection would have to be drawn with zero width (i.e. for text selections, when the two ends snap to the same character boundary), a caret must be displayed instead.</U> It is helpful to consider the caret as a zero-width selection; only one selection may be present within one window at a time, so the exclusivity of the caret and selection is an extension of this concept.</FONT>
<P>
<FONT SIZE="+1"><U>When either a caret or a selection is placed in a document, the window must gain the input focus.</U> This will happen automatically for a Wimp-drawn user caret, but in the case of application-drawn carets and selections, the application must position the Wimp caret in the window, but marked as invisible, in order to achieve the same effect. Simply changing the window border colour (as is possible in Wimps since RISC OS 4) is not acceptable.</FONT>
<P>
<FONT SIZE="+1">When a caret or selection is placed in a different drag-and-drop window, the old selection must be <U>redrawn as a shaded selection, not left as is or removed entirely</U>. The caret must be removed entirely <U>(or optionally redrawn as a shadow caret)</U>; if the application uses a Wimp-drawn user caret, the caret will be removed for it automatically. The LoseCaret and GainCaret events must not be used to determine when this is necessary, as the Wimp may "borrow" the caret temporarily while a menu is open. A Wimp message exists to indicate when removal or redraw of the caret and selection is necessary, and must be used in preference to the events (see &sect;5.1.1).</FONT>
<P>
<U><FONT SIZE="+1">Note that a selection may also be non-shaded but not have the input focus if an application not adhering to the cut-and-paste / drag-and-drop protocols had grabbed the Wimp caret (and therefore the input focus). Similarly, non-Wimp-drawn carets may be deprived of the input focus under similar circumstances while neither being removed, nor being replaced with a shadow caret.</FONT></U>

<P>
<B>4.1.1.2. Mouse Events</B>
<P>
<U><FONT SIZE="+1">Non-contiguous selections (just about everything except text and DTP documents) will continue to be handled as described in the Style Guide [4], with the proviso that clicking Select over an already-selected object must not deselect anything, as a Select click event always precedes the Select drag event which initiates a drag-and-drop operation. Appropriate action must also be taken to un-shade shaded selections when necessary.</FONT></U>
<P>
<FONT SIZE="+1">On the other hand, a more detailed behaviour for contiguous selections must be adhered to in future. In summary:</FONT>
<UL>
<LI><FONT SIZE="+1"><I>Select</I> click outside the selection (or when there is no selection, or at one end of a selection): position the caret at the pointer position, and flag the next <I>Select</I> drag as creating a selection.</FONT>
<LI><FONT SIZE="+1"><I>Select</I> click on a selection: <U>if the selection was shaded, un-shade it.</U> <U>Make sure the window has the input focus.</U> Flag the next <I>Select</I> drag as being a drag-and-drop drag.</FONT>
<LI><FONT SIZE="+1"><U><I>Select</I> click in a "dead" region of a window (e.g. in a page border): un-shade any selection or replace any shadow caret with the caret, if either exists. Make sure the window has the input focus. Optionally, flag the next <I>Select</I> drag as causing an window scroll operation (as Impression, TechWriter etc. do as present), but certainly not as starting a selection or drag-and-drop operation.</U></FONT>
<LI><FONT SIZE="+1"><I>Select</I> drag-start event: <U>remove the caret</U>, and set the selection from the old caret position to the current pointer position. Alternatively, start the drag-and-drop operation (see &sect;4.4.1). The exact meaning is determined by the flag that was set at the <I>Select</I> click stage.</FONT>
<LI><FONT SIZE="+1">During <I>Select</I> drag: if creating a selection, adjust the most recently touched end of the selection to the pointer position at regular intervals; <U>autoscroll the window if necessary, using the SWI Wimp_AutoScroll introduced in the RISC OS 4 Wimp.</U> For what to do during a drag-and-drop drag, see &sect;4.4.1.</FONT>
<LI><FONT SIZE="+1"><U><I>Select</I> double-click: select a word (as defined in the Style Guide), irrespective of whether the click is on an existing selection or not.</U></FONT>
<LI><FONT SIZE="+1"><U><I>Select</I> click-drag (button pressed, then released, then pressed again within the double-click limits, then held or moved according to the drag limits): equivalent to a normal selection-delimiting drag, except that the selection limits are rounded to word boundaries (excluding whitespace at either end).</U></FONT>
<LI><FONT SIZE="+1"><U><I>Adjust</I> click when there is no caret or selection: position the caret at the pointer position, unless there was a shadow caret, in which case, position the caret where the shadow caret was. Set a flag to indicate that there was no caret or selection before the <I>Adjust</I> click (the shadow caret doesn't count); do not rely on the fact that there is no selection displayed when the drag event is generated to flag this, as a zero-width selection may have been displayed as a caret instead.</U></FONT>
<LI><FONT SIZE="+1"><I>Adjust</I> click when there is a caret: <U>remove the caret</U>, and set the selection from the old caret position to the current pointer position.</FONT>
<LI><FONT SIZE="+1"><I>Adjust</I> click when there is a selection: grow or shrink the selection so that the <I>nearest end</I> of the selection moves to the pointer position. <U>(Remember to un-shade the selection and/or gain the input focus if necessary.)</U></FONT>
<LI><FONT SIZE="+1"><U><I>Adjust</I> click in a "dead" region of a window: the same as Select in these circumstances.</U></FONT>
<LI><FONT SIZE="+1"><I>Adjust</I> drag-start event: <U>unless there was no caret or selection before the preceding <I>Adjust</I> click,</U> adjust the most recently touched end of the selection to the pointer position.</FONT>
<LI><FONT SIZE="+1">During <I>Adjust</I> drag: <U>unless there was no caret or selection before the preceding <I>Adjust</I> click,</U> adjust the most recently touched end of the selection to the pointer position at regular intervals; <U>autoscroll the window if necessary, using SWI Wimp_AutoScroll.</U></FONT>
</UL>
<P>
<FONT SIZE="+1">Other operations (including <I>Adjust</I> double-clicks, higher-multiple-clicks and combinations with shifting keys) are left to the application to respond to as it sees fit - they might select a line of text, or select something in another layer, or whatever. Typically, higher-multiple clicks of <I>Select</I> will select progressively larger blocks of text. For single-line items such as writable icons, three clicks means select the entire line. Once the maximum number of clicks is reached, the next click is interpreted as for a single click, so for writable icons, a quadruple-click sets the position of the caret.</FONT>
<P>
<FONT SIZE="+1">In order to make selections over a larger area than can be displayed in a window, during selecting drags of contiguous selections and select box drags of non-contiguous selections, autoscrolling can be implemented. However, since there is rarely a meaning to making a selection spanning several windows, there is only one meaning to moving the pointer off the window, and so there must be no need for a pause over the autoscrolling zone to precede commencement of scrolling, as this would merely slow down the user's actions.</FONT>

<P>
<B><U>4.1.1.3. Keypresses</U></B>
<P>
<FONT SIZE="+1">There are some special keypresses relating to cut-and-paste that affect the selection. Obviously, these only apply to selections that have the input focus (and therefore never apply to a shaded selection). The keypresses are:</FONT>
<UL>
<LI><FONT SIZE="+1">Ctrl-Z: clear the selection (i.e. undraw the highlights), and place the caret (if appropriate) at the right-hand end of the old selection (or the left-hand end in a right-to-left language).</FONT>
<LI><FONT SIZE="+1">Ctrl-V or Insert: delete (not cut) the selected data, and place the caret (if appropriate) at the end of the newly inserted text.</FONT>
<LI><FONT SIZE="+1">Ctrl-X, Backspace or Delete: cut the selected data and place the caret (if appropriate) where the selection was.</FONT>
<LI><FONT SIZE="+1">Ctrl-K: delete (not cut) the selected data and place the caret (if appropriate) where the selection was.</FONT>
</UL>
<P>
<FONT SIZE="+1"><BR>
Then there are a number of special behaviours for textual regions:</FONT>
<UL>
<LI><FONT SIZE="+1">Left-arrow/up-arrow: clear the selection, and process the keypress as though the caret had been at the left of the selection.</FONT>
<LI><FONT SIZE="+1">Right-arrow/down-arrow: clear the selection, and process the keypress as though the caret had been at the right of the selection.</FONT>
<LI><FONT SIZE="+1">Any other repositioning keypresses (Home, Tab etc.) behave along similar lines, as appropriate to the application.</FONT>
<LI><FONT SIZE="+1">Any other keypresses that would normally insert one or more characters: perform a cut operation, then position the caret where the selection was, and process the keypress as normal.</FONT>
</UL>
<P>
<FONT SIZE="+1"><BR>
Any other keypresses must not affect the selection.</FONT>
<P>
<FONT SIZE="+1">During drags (both those that set a selection and those that copy or move one), no keypresses that would normally affect the selection must be acted upon.</FONT>

<P>
<B><U>4.1.1.4. Scope</U></B>
<P>
<FONT SIZE="+1">When a caret or selection is placed in the same window where one already exists, the old one is removed (not just re-rendered as a shaded selection). <U>In order for this to be consistent with the use of input focus colouring of windows, all carets and selections must be unique within a group of windows characterised thus: a top-level (non-nested) window, all its panes, and all windows nested within the window or one of its panes. If a task does its own selection handling but the window or one of its panes also uses writable icons, the task will need to monitor caret/selection updates to the writable icons in order to deselect its own selections.</U></FONT>
<P>
<FONT SIZE="+1">Carets and selections must not be preserved when a window is closed, deleted or iconized (check for Open_Window_Requests with handle-to-open-behind of -3 to detect iconization). The Wimp takes care of everything for Wimp-drawn carets, and automatically removes the input focus in any case. If a selection can be made in a dialogue box opened from a menu, then the task must  act as though the window were being closed when receiving Message_MenusDeleted, as tasks are not sent the usual Close_Window_Request for such windows.</FONT>
<P>
<FONT SIZE="+1">When the window is being closed or deleted, application-drawn carets and selections must be marked as absent, but when it the window is being iconized, carets and selections drawn by the application must be flagged as a shadow caret (if supported) or a shaded selection, respectively, ready for the next redraw request.</FONT>

<P>
<B><FONT SIZE="+1">4.1.2. Clipboard Module</FONT></B>
<P>
<FONT SIZE="+1">The Clipboard is not involved in the selection process.</FONT>

<P>
<B><FONT SIZE="+1">4.1.3. Writable Icons</FONT></B>
<P>
<FONT SIZE="+1">Up to one writable icon selection may exist in each window, and the selection will only be un-shaded if the window has the input focus.</FONT>

<P>
<B>4.1.3.1. Rendering</B>
<P>
<FONT SIZE="+1">Carets within writable icons will be Wimp colour 11 (red), irrespective of the background colour of the icon. This will be achieved by using (Wimp colour 11 EOR background colour), calculated in GCOL space, as the colour to EOR on to the icon.</FONT>
<P>
<FONT SIZE="+1">Selections and shaded selections will be drawn by switching the foreground and background colours, then fading them if appropriate. A gap of 4 OS units will be left before the top and bottom borders (if any) of the icon. Therefore, a typical writable icon will look like this in its three states:</FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic8.gif" ALT="" ALIGN=MIDDLE HEIGHT=140 WIDTH=182 VSPACE=2></FONT>
<P>
<FONT SIZE="+1">Using this method is better than EORing a block of colour, especially in the shaded selection case, where the anti-aliasing of the text is destroyed by an EOR operation. It also means that non-standard writable icons are catered for sensibly as well with no extra effort:</FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic9.gif" ALT="" ALIGN=MIDDLE HEIGHT=126 WIDTH=282 VSPACE=2></FONT>
<P>
<FONT SIZE="+1">In the past, during writable icon redraws caused by scrolling of the icon (caused, for example, by repositioning of the caret), there has been a certain amount of flicker, both of the text, and of the caret itself, especially for large writable icons. This will be exaggerated substantially if the same technique is used to draw selections; to reduce flicker in both cases, a new algorithm will be written to deal with icon updates following caret / selection / ghost caret changes, utilising block copies wherever possible.</FONT>

<P>
<B>4.1.3.2. Scrolling</B>
<P>
<FONT SIZE="+1">Icons where the text is less wide than the icon are relatively simple; the text has a fixed position, irrespective of caret and selection position. But it is likely that where the text is wider than the icon, occasions will arise where the user needs access to areas of the text string that are normally hidden, in order to set one or both ends of a selection. The matter is similar to the requirement for icon scrolling to position the ghost caret during a drag-and-drop selection (see &sect;4.4).</FONT>
<P>
<FONT SIZE="+1">So, while the user is delimiting a selection, or when a ghost caret is displayed in the icon, an autoscrolling scheme will be followed, directly analogous to that used for windows in Wimp_AutoScroll.</FONT>
<P>
<FONT SIZE="+1">Note in particular:</FONT>
<UL>
<LI><FONT SIZE="+1">The speed of scrolling is proportional to the distance the pointer has moved beyond the inside edge of the autoscrolling "pause" zone. This is because this scheme allows fine user control of both acceleration and deceleration.</FONT>
<LI><FONT SIZE="+1">When delimiting a selection, autoscrolling will start as soon as the pointer enters the "pause" zone - i.e. a pause time of zero is used. Conversely, to start autoscrolling during a drag-and-drop operation, the pointer must be held over the pause zone for the configured pause time. This matches the equivalent behaviour for autoscrolling of windows.</FONT>
<LI><FONT SIZE="+1">While document windows are generally of a comparable size, hence the similar pause zone widths, the size of writable icons can vary dramatically from icon to icon - compare, for example, a writable icon that is part of a numeric field, with the URL at the top of a web browser window. Scrolling speeds that would suit a small icon would be painfully slow for a very large one, and usable speeds for a large icon would scroll a small icon far too quickly. Therefore, the scrolling speed of a writable icon when the pointer is at one end will be proportional to its width. However, it is also desirable that the scrolling speed ramp up at the same rate, irrespective of icon size; these two constraints imply that a fixed proportion of the width of any icon needs to be allocated as the autoscroll pause zone - we will use 1/4 of the width at each end, as illustrated to scale below:</FONT>
</UL>
<P>
<FONT SIZE="+1"><IMG SRC="Images/Pic10.gif" ALT="" ALIGN=MIDDLE HEIGHT=344 WIDTH=575 VSPACE=2></FONT>
<P>
<FONT SIZE="+1">Below, the autoscrolling zone is cross-hatched; the autoscrolling pause zone is the intersection of the autoscrolling zone with the icon bounding box:</FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic22.gif" ALT="" ALIGN=MIDDLE HEIGHT=133 WIDTH=268 VSPACE=2></FONT>

<P>
<B>4.1.3.3. Mouse Events</B>
<P>
<FONT SIZE="+1">Mouse events in writable icons will follow the general behaviour, as specified in &sect;4.1.1.2, but with a couple of slight changes. The definition of a word will match that used for Shift-arrow navigation, i.e. treating both spaces and the '.' character as word delimiters.</FONT>
<P>
<FONT SIZE="+1">On the second click of a double click with Adjust, the selection established by the first Adjust click will be extended outwards at both ends to include complete words.</FONT>
<P>
<FONT SIZE="+1">Clicks with either Select or Adjust will not affect the text origin, unless they are setting the caret position (which will still be centred as far as possible, for consistency with old Wimps). Neither double-click operation will affect the text origin either, unless a scroll was caused by the first click of the two.</FONT>
<P>
<FONT SIZE="+1">During a drag, while the pointer is over the central zone between the autoscrolling zones, no scrolling occurs. The autoscrolling zones act just like those of windows. After each scroll step (<I>not</I> before), the selection end is determined by the closest character boundary to the pointer.</FONT>
<P>
<FONT SIZE="+1">When a drag starts, any movement of the text which was performed at the time of the click event is undone. This is necessary because otherwise we have introduced a relative movement between the text and the pointer which was not intended by the user, and the alternative (moving the pointer) is less in the style of the RISC OS user interface. Consider, for example, if the user clicks Select at the right hand end of an icon where there is a lot of text further to the right which is clipped out of view: if the user starts dragging to the left, but as a result of the initial click, the text had jumped quickly to the left of the pointer and so the user is now creating a selection to its right; worse still, if the pointer is still over the autoscrolling zone, the initial character may start scrolling off the left of the icon, leaving a large selection in the opposite direction to that intended by the user!</FONT>

<P>
<B>4.1.3.4. Keypresses</B>
<P>
<FONT SIZE="+1">These will in general be handled as in &sect;4.1.1.3. Note in particular:</FONT>
<UL>
<LI><FONT SIZE="+1">Only keypresses as specified in the validation string would normally insert characters, so any others (except Ctrl-X and its synonyms, of course) will not cut any selected text.</FONT>
<LI><FONT SIZE="+1">Whenever a keypress (including Ctrl-X and synonyms) causes the caret to be repositioned, a traditional, centred caret will be used.</FONT>
<LI><FONT SIZE="+1">When a paste is performed, and so an entirely new selection is set, the selection will be centred within the icon (unless it is wider than the icon, in which it will be right-aligned).</FONT>
</UL>

<P>
<B>4.1.3.5. Wimp Selections and Menus</B>
<P>
<FONT SIZE="+1">When the pointer moves over a writable menu item, or when a dialogue box containing writable icons is opened from a menu, the Wimp automatically places the caret in the menu item, or the first writable icon, respectively. The Wimp remembers the position of the caret before it does this, and then returns the caret to its old location afterwards.</FONT>
<P>
<FONT SIZE="+1">This behaviour will be extended to check for Wimp selections that have the input focus before the caret is placed. If the same selection still exists afterwards (i.e. a selection has not been made within the menu structure in the meantime), then the input focus will be returned to it.</FONT>
<P>
<FONT SIZE="+1">Note that selections cannot be made in writable menu items, as any clicks are considered as choices from the menu tree before being considered as requests to set the caret position, let alone setting a selection. Also note that drags cannot be made to an icon in a menu structure, as the click that starts the drag will close the menu structure before the drag begins!</FONT>
<P>
<FONT SIZE="+1">Cut and paste will work as specified for writable icons in dialogue boxes in menu trees, and pasting (but obviously not cut or copy) will work for writable menu items.</FONT>

<P>
<B>4.1.3.6. Password icons</B>
<P>
<FONT SIZE="+1">Cutting, copying and dragging from a password icon, or pasting or dragging into one, is not permitted for security reasons. To give the user some feedback, the Wimp issues a system beep if the user attempts to do so. Selecting text in a password icon is permitted, although the only action that can be performed on it is deletion.</FONT>

<P>
<B>4.1.3.7. Application-altered Indirected Data</B>
<P>
<FONT SIZE="+1">On occasions, the text of a writable icon is altered by code other than the Wimp's writable icon handling code (and as a prerequisite, the text data has to be indirected). A common example of this is the writable numeric range, where adjuster arrows may be used to alter the value inside the accompanying writable icon.</FONT>
<P>
<FONT SIZE="+1">Altering the data does not, in itself, cause any screen updates to be done; applications have to force a redraw of the icon for the new value to be displayed. During the redraw, the caret is redrawn, but only using the last work-area-origin-relative co-ordinates calculated the last time the caret was positioned. If the new data requires a different text origin, the caret will then appear incorrectly positioned. To cater for this, nearly if not all applications set the position of the caret again, as well as forcing a redraw of the icon.</FONT>
<P>
<FONT SIZE="+1">A similar situation could arise with selections (and even ghost carets) - but since no existing applications know about selections, they will not be able to cater for the "feature" in the API. For example, suppose the value 99 was selected in a centred numeric range, then the up-arrow was pressed; the result would be as below:</FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic1.gif" ALT="" ALIGN=MIDDLE HEIGHT=59 WIDTH=138 VSPACE=2></FONT>
<P>
<FONT SIZE="+1">To work around this, separate checksums will be kept for the text of the icon currently containing the selection and the ghost caret. Each time an icon is redrawn, a new checksum is calculated, and if the checksum has changed, the selection or ghost caret will be removed. This is because the change to the text has probably invalidated the selected text anyway.</FONT>
<P>
<FONT SIZE="+1">A variant on this approach will be used to fix the equivalent long-standing bug in the case of carets. One potential fix which we have to reject is to simply remove the caret when the text changes, because in many cases the application already has its own workaround whereby it reapplies the caret, so with each change of the text, the window's title bar would flicker due to losing and re-gaining the input focus. Instead, the Wimp will recalculate the caret position, assuming the same index into the string is required - unless the icon's numeric flag (icon flag bit 20) is set, in which the caret will be kept at the same index from the end of the string, to preserve the decimal place being edited. This way, future applications need not include the workaround at all.</FONT>

<P>
<B>4.1.3.8. Scope</B>
<P>
<FONT SIZE="+1">In addition to the rules in &sect;4.1.1.4., any combination of caret, ghost caret and selection must be removed when an icon is deleted. Also, when a menu is closed, any selection in a dialogue box linked to the menu must be removed (the caret already is removed in these cases).</FONT>
<P>
<FONT SIZE="+1">It will not be possible for any caret, selection or ghost caret to be placed in a writable icon that is shaded. If any caret, selection or ghost caret is present in a writable icon when it becomes shaded, they will be removed.</FONT>
<P>
<FONT SIZE="+1">The Wimp selection and both carets will be removed when the Wimp font is changed, but this will be the responsibility of the task that is changing the font - namely !Configure (or more precisely, a configure plug-in).</FONT>
<P>
<FONT SIZE="+1">If an icon is resized using Wimp_ResizeIcon, any of the caret, ghost caret and selection which are present in the icon will be marked absent (although no redrawing will occur immediately, because Wimp_ResizeIcon expects to be followed by a separate redraw operation anyway).</FONT>

<P>
<B>4.1.3.9. Draggable-Writable (Type 14) Icons</B>
<P>
<FONT SIZE="+1">Type 14 (draggable) writable icons are much rarer than standard, type 15 writable icons, and in the past, have only differed in that drag events are reported to the task. Some applications (such as Fresco) have taken advantage of these icons to implement a simpler form of drag-and-drop; such behaviour would be broken if the steps described above were employed for type 14 icons. Type 14 icons could also be a useful special case, where sub-units of the information in the icon have no meaning on their own, and where only the entire text can logically be dragged-and-dropped.</FONT>
<P>
<FONT SIZE="+1">Therefore, all of the rest of &sect;4.x.3 and &sect;5.x.3 (with the exception of developments specific to carets, such as the bugfix in &sect;4.1.3.7) will only apply to type 15 writable icons.</FONT>

<P>
<B><FONT SIZE="+1">4.2. Cut and Copy</FONT></B>
<P>
<B><FONT SIZE="+1">4.2.1. Protocol</FONT></B>
<P>
<FONT SIZE="+1">"Cut" and "Copy" menu options, if provided, must be placed as described in the Style Guide; the options must be shaded if there is currently no selection in the window.</FONT>
<P>
<FONT SIZE="+1"><U>A cut operation must be performed when the task receives a Ctrl-X, Backspace or Delete keypress (i.e. Wimp key codes &amp;008, &amp;018 and &amp;07F) </U>or when "Cut" is chosen from the menu. When <U>a keypress suitable for inserting data is received, or when data is dragged-and-dropped on to the selection's window</U>, or pasted when a selection is active, the selection must also be cut prior to performing the raw operation.</FONT>
<P>
<FONT SIZE="+1">A copy operation must be performed when "Copy" is chosen from the menu, <U>or when the task receives a Ctrl-C keypress (Wimp key code &amp;003) - but not when Wimp key code &amp;18B is received, because although it resulted from a press of the "Copy" key on the Archimedes, A30x0, A4000 and A5000, on all other machines it will be generated by the "End" key.</U></FONT>
<P>
<FONT SIZE="+1">Both cut and copy will cause a copy of the selected data to be placed on the clipboard overwriting any data already there. (See &sect;13 for a definition of clipboard in this context.) No attempt must be made to render the clipboard; it is a hidden, abstract entity. The data on the clipboard is of indeterminate data type; a data type to use for the transfer is negotiated between the clipboard owner and the pasting task at paste-time, and may involve either or both tasks performing data translation.</FONT>
<P>
<FONT SIZE="+1">The only difference between cut and copy is that the selected data must be removed from the main document in the case of a cut operation. <U>The selection remains unchanged in the case of a copy operation (i.e. it is not deselected).</U></FONT>
<P>
<U><FONT SIZE="+1">If the data cut or copied to the clipboard is of type text, the newlines (if any) must be represented by ASCII &amp;0A.</FONT></U>

<P>
<B><FONT SIZE="+1">4.2.2. Clipboard Module</FONT></B>
<P>
<FONT SIZE="+1">The use, or not, of the Clipboard module to handle cut and copy operations will not affect the cut or copy user interfaces, even though this entails some complication of the programming interface (see &sect;5.2.2).</FONT>

<P>
<B><FONT SIZE="+1">4.2.3. Writable Icons</FONT></B>
<P>
<FONT SIZE="+1">Keypresses will be honoured as described in &sect;4.2.1 - although individual icons don't and shouldn't have menus, so the description of performing cuts and copies via a menu is inappropriate. The data held in the writable icon will always be plain text, and the exported data can only be the same, so management of the clipboard can and will be delegated to the Clipboard (and as a consequence of this, a Message_ClaimEntity 4 will be issued by the Clipboard every time data is cut or copied to the clipboard from a writable icon, including those in menu structures).</FONT>

<P>
<B><FONT SIZE="+1">4.3. Paste</FONT></B>
<P>
<B><FONT SIZE="+1">4.3.1. Protocol</FONT></B>
<P>
<FONT SIZE="+1">A"Paste" menu option, if provided, must be placed as described in the Style Guide; the option <U>must</U> be shaded if there is no data on the clipboard suitable for pasting into the document, even though this may entail a slight delay before opening of the submenu while the application interrogates the current owner of the clipboard.</FONT>
<P>
<U><FONT SIZE="+1">The keypresses Ctrl-V and Insert (Wimp key codes &amp;016 and &amp;1CD) are both equivalent to choosing "Paste" from the menu.</FONT></U>
<P>
<FONT SIZE="+1">If there is a selection present in the window before the paste operation, it must be deleted before the paste takes place; swapping the clipboard contents and the selection would prevent the same data being pasted multiple times. The new data is inserted at the caret, or where the old selection was positioned, and the pasted data is automatically selected, so that the user can immediately cut it again, should it be so desired.</FONT>
<P>
<U><FONT SIZE="+1">If the data pasted from the clipboard is of type text, any instances of ASCII &amp;0A, &amp;0D, or both codes adjacently in either order must be treated equally, as a single newline.</FONT></U>

<P>
<B><FONT SIZE="+1">4.3.2. Clipboard Module</FONT></B>
<P>
<FONT SIZE="+1">The use, or not, of the Clipboard module to handle paste operations will not affect the paste user interface.</FONT>

<P>
<B><FONT SIZE="+1">4.3.3. Writable Icons</FONT></B>
<P>
<FONT SIZE="+1">Keypresses will be honoured as described in &sect;4.3.1 - although individual icons don't and shouldn't have menus, so the description of performing pastes via a menu is inappropriate. Handling the protocol for obtaining the pasted data will be delegated to the Clipboard.</FONT>
<P>
<FONT SIZE="+1">Pasted data must be available in text (data type &amp;FFF) form, or else the keypress will be ignored. Only text up to the first instance of ASCII &amp;00, &amp;0A or &amp;0D, or the length of the spare space in the data buffer (plus the length of any selection), will be considered; if this string contains other control characters, or characters forbidden by the validation string, the operation will be faulted with a beep. In this case, no characters are inserted and any pre-existing selection is neither deselected nor deleted.</FONT>

<P>
<B><FONT SIZE="+1">4.4. Drag</FONT></B>
<P>
<B><FONT SIZE="+1">4.4.1. Protocol</FONT></B>
<P>
<B>4.4.1.1. General</B>
<P>
<FONT SIZE="+1"><U>When the user starts a drag-and-drop drag (which will always be with the Select button, at least for text selections), the selection is not deselected.</U> When the drag ends, the new data is selected, <U>which means that, unless the drag was a move operation, or the destination is in the same window as the source, the old selection will subsequently be redrawn as a shaded selection.</U></FONT>
<P>
<FONT SIZE="+1">If, during any drag operation, the Escape key is pressed, the drag must be aborted. <U>Any other keypresses during a drag must be ignored</U> (except of course for the status of the Shift key at the beginning of the drag, which is responsible for exchanging the meanings of copy and move operations).</FONT>

<P>
<B><U>4.4.1.2. Pointers</U></B>
<P>
<FONT SIZE="+1">During a drag, the pointer shape is changed to the new standard alternative pointer shape ptr_drop; this must be used instead of the alternatives employed by DataPower, TechWriter and others. The new pointer shape will be added to the Wimp's RAM sprite pool by the Clipboard module, so that it is always available for tasks to use.</FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic11.gif" ALT="" ALIGN=MIDDLE HEIGHT=43 WIDTH=294 VSPACE=2></FONT>
<P>
<FONT SIZE="+1">The new pointer retains the styling of the default pointer, plus the handed-ness of it, while implying a lifting operation consistent with the drop shadows added by the DragASprite and DragAnObject modules, and yet is not completely dissimilar to the existing third party pointers.</FONT>
<P>
<FONT SIZE="+1">The ptr_drop pointer must remain in use throughout the drag operation, with the sole exception of during an autoscroll, when the Wimp's autoscroll pointers are used in preference - see &sect;4.4.1.5.</FONT>

<P>
<B>4.4.1.3. Dragboxes</B>
<P>
<FONT SIZE="+1">Linked to the pointer position, there will be at all times during the drag either a representation of the (potential) drop position, or of the original data, <U>but not both</U>. Which is used depends on both the sending and (potentially-) receiving tasks, and on the type of data being dragged: if the receiving task understands at least one of the the data types, it will draw the drop position; if not, the sending task is responsible for the representation of the original data.</FONT>
<P>
<FONT SIZE="+1">The representation of the original data, when required, can take the form of either a rotating-dash Wimp box of the same size as the original selection, <U>or of a DragASprite or DragAnObject rendering. As ever, if the CMOS indicates as such, a dragbox must be used instead of a DragASprite or DragAnObject drag. If a selection consisting of multiple, non-contiguous objects is to be represented without using a dragbox, the Wimp sprite "package" must be used, to match the Filer's behaviour.</U></FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic13.gif" ALT="" ALIGN=MIDDLE HEIGHT=70 WIDTH=90 VSPACE=2><IMG SRC="Images/Pic14.gif" ALT="" ALIGN=MIDDLE HEIGHT=70 WIDTH=90 VSPACE=2></FONT>
<P>
<FONT SIZE="+1">Whether a dragbox is to be used or not, the representation is (of course) updated automatically by the Wimp to follow the pointer. <U>The box, sprite or object must always keep the same position relative to the pointer's active point as the original bounding box did at the click that started the drag - except that in the special case of the "package" sprite, the sprite must always be centred over the pointer's active point.</U></FONT>

<P>
<B>4.4.1.4. Ghost Carets</B>
<P>
<FONT SIZE="+1">The representation of the drop position - known as the ghost caret - has two typical forms. When the pointer is over a primarily textual region, and the task understands at least one of the available data types, the ghost caret can be displayed as a grey I-beam, "snapped" to the nearest character boundary. When the pointer is over a layout-based region, a grey bounding box, scaled according to the zoom setting of the window, can be displayed, snapped to any grid, guidelines, frame boundaries etc. as appropriate. <U>The two are not necessarily mutually exclusive; a DTP package might, for example, want to display an I-beam when underneath a text drag, but a scaled bounding box when underneath a sprite drag.</U> If neither form is appropriate, and the application knows of no other appropriate rendering either, the sending task must be informed (or be allowed to continue) to display the dragbox, sprite or whatever.</FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic12.gif" ALT="" ALIGN=MIDDLE HEIGHT=70 WIDTH=90 VSPACE=2><IMG SRC="Images/Pic15.gif" ALT="" ALIGN=MIDDLE HEIGHT=70 WIDTH=90 VSPACE=2></FONT>
<P>
<FONT SIZE="+1">While the task that technically owns the drag continues to be the sending task, the receiving task is responsible for drawing any ghost caret. Therefore the ghost caret position is only updated at each pass through the underlying message protocol, approximately four times a second. In order to prevent the sending task's dragbox or sprite from coexisting with the ghost caret, and thus cluttering the target area to an unnecessary extent, provision is made in the protocol for the receiving task to request that the drag be <U>replaced with a "drag point" (type 7) drag</U> for as long as the receiving task is displaying a ghost caret.</FONT>
<P>
<U><FONT SIZE="+1">In textual documents, if during the drag, the pointer is positioned over the original selection, the ghost caret must not be displayed - the dragbox must be displayed instead. This is because dragging text inside itself has no meaning.</FONT></U>

<P>
<B>4.4.1.5. Scrolling</B>
<P>
<FONT SIZE="+1">During a drag, when the pointer is over a window that can scroll, autoscrolling must be turned on <U>using the SWI Wimp_AutoScroll. For more details of the effect of this SWI, see [5], but note that unless the pointer is held still near the edge of the window for a period, no scrolling will occur. Since determination of the pause zone is dependent upon positioning of panes etc., the activation and deactivation of Wimp_AutoScroll is the responsibility of the receiving task.</U></FONT>

<P>
<B><FONT SIZE="+1">4.4.2. Clipboard Module</FONT></B>
<P>
<FONT SIZE="+1">The use, or not, of the Clipboard module to handle drag operations will not affect the drag user interface.</FONT>

<P>
<B><FONT SIZE="+1">4.4.3. Writable Icons</FONT></B>
<P>
<FONT SIZE="+1">Drags from writable icons will use the ptr_drop pointer, and a rotating-dash dragbox matched in size to the selection. If the pointer has not moved since the click, the drag will initially look like this (with the dashes rotating):</FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic16.gif" ALT="" ALIGN=MIDDLE HEIGHT=93 WIDTH=220 VSPACE=2></FONT>
<P>
<FONT SIZE="+1">Drags to writable icons (including drags within the same icon) will use an I-beam ghost caret. The ghost-caret drawing facility of the Wimp will also be made available to applications, in order to ensure that all I-beam ghost carets are drawn to the same colour and design. The colour used will be the ColourTransed version of palette entry &amp;80808000 (50.2% grey) in order to attain maximum contrast when EORed over every possible colour.</FONT>
<P>
<FONT SIZE="+1">If the pointer is dragged over the autoscrolling zone (as defined in &sect;4.1.3.2), the icon will be scrolled in order to let the ghost caret be positioned in an out-of-sight part of the icon. This will happen even if the selection fills the icon (meaning that the ghost caret cannot be positioned anywhere in the icon) because there would be no visual clues as to why the autoscrolling was not occurring in this case.</FONT>
<P>
<FONT SIZE="+1">Window autoscrolling will not be initiated while the pointer is being dragged over a writable icon. However, if autoscrolling of the icon's window is already in progress and the pointer moves on to a writable icon, the ghost caret will not be placed in the writable icon.</FONT>

<P>
<B><FONT SIZE="+1">4.5. Drop</FONT></B>
<P>
<B><FONT SIZE="+1">4.5.1. Protocol</FONT></B>
<P>
<B>4.5.1.1. Sending</B>
<P>
<FONT SIZE="+1">When a drag-and-drop drag ends, the sending task attempts to transfer data to the task under the pointer, or if a drag-and-drop dialogue was in effect, to the receiving task (which can only be different from the task under the pointer if the receiving task is autoscrolling one of its windows). The data type actually transferred is negotiated between the sending and receiving tasks at the time of the drop; it may entail either or both tasks performing data translation.</FONT>
<P>
<FONT SIZE="+1">The decision whether to delete the original data when the drag ends (i.e. whether to copy or move the selection) is based upon the state of the Shift key <U>when the drag began</U>, and upon whether the pointer position at the end of the drag is in the same <U>window</U> as at the start, or not. Drags within a <U>window</U> move the data unless Shift is held down; drags between <U>windows</U> copy the data unless Shift is held down. Shift reverses the meaning of the drag, so within a <U>region</U>, the selection is copied, and between <U>regions</U>, the selection is moved.</FONT>
<P>
<FONT SIZE="+1">The destination task can also insist that the operation be a move irrespective of the above; this is to allow for trashcan applications. <U>Drags to non-drag-and-drop applications (including the Filer) are treated the same as drags to a different window.</U></FONT>
<P>
<FONT SIZE="+1"><U>In some circumstances, such as dropping data onto a directory viewer, the filename used in the data transfer protocols will become visible to the user. For these to be meaningful to the user, these filenames should follow the convention of concatenating the source of the data with the textual filetype, for example "IconText" or "PaintSprite".</U></FONT>
<P>
<U><FONT SIZE="+1">When generating data of type text that includes newline characters, you must use ASCII &amp;0A to terminate lines.</FONT></U>

<P>
<B>4.5.1.2. Receiving</B>
<P>
<FONT SIZE="+1">To the destination task, a drop will appear the same as a non-drag-and-drop DataSave (inter-application data transfer) operation, except that the Wimp message is subtly marked (by virtue of having a non-zero your_ref field) as having resulted from previous messaging (i.e. the drag-and-drop dialogue). Assuming the task doesn't reject the data as being unsuitable, this is sufficient for the task to know what to do with the data:</FONT>
<P>
<FONT SIZE="+1">If a drag-and-drop drop,</FONT>
<UL>
<LI><FONT SIZE="+1">If a ghost caret was being displayed, the insertion point is set to the last known ghost caret position.</FONT>
<LI><FONT SIZE="+1">Otherwise, the insertion point is set to the position specified in the message (i.e. the pointer position), snapped if necessary.</FONT>
</UL>
<P>
<FONT SIZE="+1"><BR>
<U>If a non-drag-and-drop drop,</U></FONT>
<UL>
<LI><U><FONT SIZE="+1">If a caret (shadow or not) or selection (shaded or not) is being displayed, the insertion point is set there.</FONT></U>
<LI><U><FONT SIZE="+1">Otherwise, the insertion point is set to the position specified in the message, snapped if necessary.</FONT></U>
</UL>
<P>
<FONT SIZE="+1"><BR>
<U>If the insertion point thus determined lies on a selection (shaded or not), the said selection must be cut to the clipboard. (This is the only circumstance in which the clipboard is affected by a drag-and-drop operation.)</U> The new data is inserted, and is then selected itself.</FONT>
<P>
<U><FONT SIZE="+1">If the insertion point lies on the source selection, no actions must be taken. The selection remains selected.</FONT></U>
<P>
<U><FONT SIZE="+1">Received text data must be correctly handled whether newlines (if any) are indicated using ASCII &amp;0A, &amp;0D, or both characters in either order.</FONT></U>

<P>
<B><FONT SIZE="+1">4.5.2. Clipboard Module</FONT></B>
<P>
<FONT SIZE="+1">The use, or not, of the Clipboard module to handle drop operations will not affect the drop user interface.</FONT>

<P>
<B><FONT SIZE="+1">4.5.3. Writable Icons</FONT></B>
<P>
<FONT SIZE="+1">The requirements for acceptance of dropped data are the same as for pasted data (see &sect;4.3.3).</FONT>
<P>
<FONT SIZE="+1">Text dragged from a writable icon is not terminated in any way - the "file" length determines the amount of text. The leafname used for icon-sourced text will be "IconText"; because the data transfer message handling will be delegated to the Clipboard, there will be no opportunity to change the leafname so as not to overwrite an existing file of the same name.</FONT>


<P>
<B><FONT SIZE="+3">5. Programming Interface and Data Interchange</FONT></B>
<P>
<FONT SIZE="+1">These two sections have been combined because any programming interfaces being specified are intimately connected to data interchange, and it makes no sense to discuss the programming interfaces before the data interchange they relate to.</FONT>

<P>
<B><FONT SIZE="+1">5.1. Selection</FONT></B>
<P>
<B><FONT SIZE="+1">5.1.1. Protocol</FONT></B>
<P>
<FONT SIZE="+1">Handling mouse and key events relating to and rendering of selections is the responsibility of the task. The task may use Wimp_SetCaretPosition to delegate drawing of the caret, but non-I-beam carets and selections need to be drawn during window update and redraw code. To give a window the input focus without displaying the Wimp caret (for example, when setting a selection), Wimp_SetCaretPosition must be called with R4 bit 25 set.</FONT>
<P>
<FONT SIZE="+1">Whenever a cut-and-paste / drag-and-drop task gains either the caret or the selection, it must broadcast the following event 17 Wimp message with both flag bits 0 and 1 set:</FONT>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=6 WIDTH=457><B><FONT SIZE="+1">Message_ClaimEntity (&amp;0000F)</FONT></B>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">This message is broadcast by a task claiming the cut-and-paste / drag-and-drop caret, selection or clipboard.</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+12</FONT>
<TD COLSPAN=4><FONT SIZE="+1">your_ref: 0</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+20</FONT>
<TD><FONT SIZE="+1">flags:</FONT>
<TD><FONT SIZE="+1">bit 0/1 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">caret or selection being claimed</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 2 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">clipboard being claimed (see &sect;5.2.1)</FONT>
<TR><TD>
<TD>
<TD>
<TD COLSPAN=3><FONT SIZE="+1">all other bits are reserved and must be clear</FONT>
</TABLE>
<P>
<FONT SIZE="+1">A task must determine if it is gaining, or merely repositioning the caret/selection by whether any other task has broadcast a Message_ClaimEntity with bits 0 or 1 set, since the last time the task in question broadcast such a message. Note in particular, this means that a task must not consider the caret to have been lost when the Wimp caret is grabbed by a non- cut-and-paste / drag-and-drop task.</FONT>
<P>
<FONT SIZE="+1">When a task receives Message_ClaimEntity with either one or both of bits 0 and 1 set, it must act as though both the caret and selection have been claimed - and therefore redraw any selection as a shaded selection, and either redraw the caret as a shadow caret, or remove the caret entirely (the latter will be done automatically if the task was using a Wimp-drawn user caret).</FONT>
<P>
<FONT SIZE="+1">Note that the Wimp does not issue this message when positioning either the caret or a selection within a menu structure.</FONT>

<P>
<B><FONT SIZE="+1">5.1.2. Clipboard Module</FONT></B>
<P>
<FONT SIZE="+1">The Clipboard is not involved in the selection process. However, any programs planning to rely entirely on the Clipboard to manage its cut-and-paste / drag-and-drop data transfer must still claim the caret and selection as described in &sect;5.1.1.</FONT>

<P>
<B><FONT SIZE="+1">5.1.3. Writable Icons</FONT></B>
<P>
<B>5.1.3.1. Wimp_SetCaretPosition API</B>
<P>
<FONT SIZE="+1">Wimp_SetCaretPosition will be extended to allow the following entities to be created:</FONT>
<UL>
<LI><FONT SIZE="+1">Carets in writable icons that are not necessarily centred when the text is wider than the icon.</FONT>
<LI><FONT SIZE="+1">"User" ghost carets - i.e. ghost carets not in an icon. *</FONT>
<LI><FONT SIZE="+1">Ghost carets in writable icons (not necessarily centred). (See &sect;5.4.3.)</FONT>
<LI><FONT SIZE="+1">Selections in writable icons, centred when the text is wider than the icon. *</FONT>
<LI><FONT SIZE="+1">Selections in writable icons, not necessarily centred when the text is wider than the icon.</FONT>
</UL>
<P>
<FONT SIZE="+1"><BR>
Those entities above marked with an asterisk will also be made available to tasks. Any calls using the API for the others will be ignored, unless called using the internal Wimp routine. Below is the complete new Wimp_SetCaretPosition API, including the existing functionality, in a more digestible form than in the RISC OS 3 PRM. This includes the calls for internal use only; although these are internally distinguished by flags bit 28 being set, as far as the outside world is concerned, both bits 28 and 29 remain "reserved, must be zero".</FONT>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=5 WIDTH=458><B><FONT SIZE="+1">Wimp_SetCaretPosition (SWI &amp;400D2)</FONT></B>
<TR><TD>
<TD COLSPAN=4><FONT SIZE="+1">Set up the data for a new caret, ghost caret or selection position, and redraw it there.</FONT>
<TR><TD COLSPAN=5><FONT SIZE="+1">   On entry</FONT>
<TR><TD>
<TD COLSPAN=4><FONT SIZE="+1">To remove the caret / ghost caret / selection:</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">-1</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R2    =</FONT>
<TD><FONT SIZE="+1">"TASK"   =&gt;</FONT>
<TD COLSPAN=2><FONT SIZE="+1">use bits 30 and 31 of R4 to determine which entity to remove, otherwise remove the caret</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R3    =</FONT>
<TD><FONT SIZE="+1">flags</FONT>
<TD COLSPAN=2><FONT SIZE="+1">bits other than 30 and 31 reserved, must be zero</FONT>
<TR><TD>
<TD COLSPAN=4><FONT SIZE="+1"><BR>
To set a user caret / user ghost caret:</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">-1</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R2    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">x-offset of caret / ghost caret, relative to work area origin</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R3    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">y-offset of caret / ghost caret, relative to work area origin</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R4    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">height of caret, and flags</FONT>
<TR><TD>
<TD COLSPAN=4><FONT SIZE="+1"><BR>
To set an icon caret, centred if possible, by known index into the string:</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">icon handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R4    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">-1</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R5    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">index of caret into string (must be &gt;= 0)</FONT>
<TR><TD>
<TD COLSPAN=4><FONT SIZE="+1">or alternatively, if you wish to override the default Y position, size or flags:</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">icon handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R3    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">y-offset of caret, relative to work area origin</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R4    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">height of caret, and flags (bits 28-31 all clear)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R5    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">index of caret into string (must be &gt;= 0)</FONT>
<TR><TD>
<TD COLSPAN=4><FONT SIZE="+1"><BR>
To set an icon caret, centred if possible, by approximate current position on screen (note that if positioning the caret there causes the icon to scroll, the final caret position may be very different to the specified position):</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">icon handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R2    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">current x-offset of desired position, relative to work area origin</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R3    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">current y-offset of desired position, relative to work area origin</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R5    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">-1</FONT>
<TR><TD>
<TD COLSPAN=4><FONT SIZE="+1"><BR>
To set an icon caret / icon ghost caret, not necessarily centred: *</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">icon handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R2    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">new value of caret scrollx</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R3    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">0 (reserved for future expansion)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R4    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">height of caret, and flags (bit 28 set, bit 30 set for ghost caret or clear for caret, bit 31 clear)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R5    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">index of caret into string (must be &gt;= 0)</FONT>
<TR><TD>
<TD COLSPAN=4><FONT SIZE="+1"><BR>
To set an icon selection, centred if possible (or if the selection is wider than the icon, right-aligned within the icon):</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">icon handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R4    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">flags (bit 28 clear, bit 30 clear, bit 31 set)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R5    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">index of lower boundary into string</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R6    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">index of upper boundary into string (no action is taken if R5 &gt;= R6)</FONT>
<TR><TD>
<TD COLSPAN=4><FONT SIZE="+1"><BR>
To set an icon selection, not necessarily centred: *</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">icon handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R2    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">new value of selection scrollx</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R3    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">0 (reserved for future expansion)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R4    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">flags (bit 28 set, bit 30 clear, bit 31 set)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R5    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">index of lower boundary into string</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R6    =</FONT>
<TD COLSPAN=3><FONT SIZE="+1">index of upper boundary into string (no action is taken if R5 &gt;= R6)</FONT>
<TR><TD>
<TD COLSPAN=4><FONT SIZE="+1"><BR>
Flag bits 30/31 determine which entity the call refers to, and also affect the other flag bit meanings:</FONT>
<TR><TD>
<TD><FONT SIZE="+1">Value</FONT>
<TD><FONT SIZE="+1">Entity</FONT>
<TD><FONT SIZE="+1">Bit(s)</FONT>
<TD><FONT SIZE="+1">Meaning (if one bit, then meaning when set)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">   0</FONT>
<TD><FONT SIZE="+1">Caret</FONT>
<TD><FONT SIZE="+1">0-15</FONT>
<TD><FONT SIZE="+1">height in OS units (0-65535)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">16-23</FONT>
<TD><FONT SIZE="+1">colour (bits 20-23 ignored if a Wimp colour number)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">24</FONT>
<TD><FONT SIZE="+1">use a Wimp-drawn caret rather than the Font Manager caret</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">25</FONT>
<TD><FONT SIZE="+1">do not draw the I-beam (caret is invisible)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">26</FONT>
<TD><FONT SIZE="+1">use bits 16-23 for colour (else defaults to colour 11)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">27</FONT>
<TD><FONT SIZE="+1">colour is a GCOL, otherwise a Wimp colour number</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">28</FONT>
<TD><FONT SIZE="+1">use both R2 and R5 to position the caret in an icon and override centring behaviour (internal use only, must be zero for external callers)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">29</FONT>
<TD><FONT SIZE="+1">reserved, must be zero</FONT>
<TR><TD>
<TD><FONT SIZE="+1">   1</FONT>
<TD><FONT SIZE="+1">Ghost caret</FONT>
<TD><FONT SIZE="+1">0-15</FONT>
<TD><FONT SIZE="+1">height in OS units (0-65535)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">16-23</FONT>
<TD><FONT SIZE="+1">not used; must be zero (palette entry &amp;80808000 always used)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">24</FONT>
<TD><FONT SIZE="+1">use a Wimp-drawn caret rather than the Font Manager caret</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">25-27</FONT>
<TD><FONT SIZE="+1">not used; must be zero (cannot be invisible, colour is fixed)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">28</FONT>
<TD><FONT SIZE="+1">use both R2 and R5 to position the ghost caret in an icon and override centring behaviour (internal use only, must be zero for external callers)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">29</FONT>
<TD><FONT SIZE="+1">reserved, must be zero</FONT>
<TR><TD>
<TD><FONT SIZE="+1">   2</FONT>
<TD><FONT SIZE="+1">Selection</FONT>
<TD><FONT SIZE="+1">0-25</FONT>
<TD><FONT SIZE="+1">not used; must be zero (height and colour determined by icon properties and bit 26)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">26</FONT>
<TD><FONT SIZE="+1">use shaded selection colour scheme (also implies that the window containing the selection should not be awarded the input focus as the result of this call)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">27</FONT>
<TD><FONT SIZE="+1">the window containing the selection should not be awarded the input focus, even if it is not shaded</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">28</FONT>
<TD><FONT SIZE="+1">use both R2 and R5/R6 to position the selection in an icon and override centring behaviour (internal use only, must be zero for external callers)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">29</FONT>
<TD><FONT SIZE="+1">reserved, must be zero</FONT>
<TR><TD>
<TD><FONT SIZE="+1">   3</FONT>
<TD><FONT SIZE="+1">Reserved</FONT>
<TD>
<TD>
<TR><TD COLSPAN=5><FONT SIZE="+1">   On exit</FONT>
<TR><TD>
<TD COLSPAN=4><FONT SIZE="+1">R0-R5 are preserved, except that if R0 was -1 and R2 was "TASK" on entry, then R2 is set to zero on exit.</FONT>
<TR><TD>
<TD COLSPAN=4><FONT SIZE="+1">The versions of the indexes into the string held internally, after an icon caret is positioned by index, will in future be restricted to the range { 0 &lt;= index &lt;= length } rather than just { index &gt;= 0 }. This is essentially a bugfix, and will affect the values returned by Wimp_GetCaretPosition.</FONT>
</TABLE>

<P>
<B>5.1.3.2. Wimp_GetCaretPosition API</B>
<P>
<FONT SIZE="+1">The complimentary SWI will be extended to allow for Wimp_SetCaretPosition's new functionality:</FONT>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=4 WIDTH=457><B><FONT SIZE="+1">Wimp_GetCaretPosition (SWI &amp;400D3)</FONT></B>
<TR><TD>
<TD COLSPAN=3><FONT SIZE="+1">Returns details of the state of the caret, ghost caret or writable icon selection.</FONT>
<TR><TD COLSPAN=4><FONT SIZE="+1">   On entry</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0    =</FONT>
<TD COLSPAN=2><FONT SIZE="+1">if R2 = "TASK", this is the entity to inspect (0 =&gt; caret, 1 =&gt; ghost caret, 2 =&gt; selection)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1  -&gt;</FONT>
<TD COLSPAN=2><FONT SIZE="+1">block to fill with entity state</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R2    =</FONT>
<TD><FONT SIZE="+1">"TASK"   =&gt;</FONT>
<TD><FONT SIZE="+1">fill block with state of entity specified by R0 and R3, else fill block with caret state</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R3    =</FONT>
<TD COLSPAN=2><FONT SIZE="+1">if R0 = 2 and R2 = "TASK", this is either the handle of the window to inspect, or -1 to inspect the window which currently has the input focus and therefore also the only un-shaded selection</FONT>
<TR><TD COLSPAN=4><FONT SIZE="+1">   On exit</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0</FONT>
<TD><FONT SIZE="+1">corrupted</FONT>
<TD>
<TR><TD>
<TD><FONT SIZE="+1">R1</FONT>
<TD><FONT SIZE="+1">preserved</FONT>
<TD>
<TR><TD>
<TD><FONT SIZE="+1">R2    =</FONT>
<TD COLSPAN=2><FONT SIZE="+1">0 if it was "TASK" on entry</FONT>
<TD>
<TR><TD>
<TD><FONT SIZE="+1">R3</FONT>
<TD><FONT SIZE="+1">preserved</FONT>
<TR><TD>
<TD COLSPAN=3><FONT SIZE="+1"><BR>
If the caret or ghost caret state is being returned, the block is filled as follows:</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+0</FONT>
<TD COLSPAN=2><FONT SIZE="+1">window handle (or -1 if there is no [ghost] caret)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+4</FONT>
<TD COLSPAN=2><FONT SIZE="+1">icon handle (or -1 if a user [ghost] caret)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+8</FONT>
<TD COLSPAN=2><FONT SIZE="+1">x-offset of [ghost] caret, relative to work area origin</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+12</FONT>
<TD COLSPAN=2><FONT SIZE="+1">y-offset of [ghost] caret, relative to work area origin</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+16</FONT>
<TD COLSPAN=2><FONT SIZE="+1">height of [ghost] caret and flags (bit 28 clear)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+20</FONT>
<TD COLSPAN=2><FONT SIZE="+1">index of [ghost] caret into string (undefined if a user [ghost] caret)</FONT>
<TR><TD>
<TD COLSPAN=3><FONT SIZE="+1"><BR>
If the selection state is being returned, the block is filled as follows:</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+0</FONT>
<TD COLSPAN=2><FONT SIZE="+1">window handle (or -1 if there is no writable icon selection)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+4</FONT>
<TD COLSPAN=2><FONT SIZE="+1">icon handle (&gt;= 0)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+8</FONT>
<TD COLSPAN=2><FONT SIZE="+1">x-offset of lower boundary of selection, relative to work area origin</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+12</FONT>
<TD COLSPAN=2><FONT SIZE="+1">width of selection</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+16</FONT>
<TD COLSPAN=2><FONT SIZE="+1">y-offset of selection, relative to work area origin</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+20</FONT>
<TD COLSPAN=2><FONT SIZE="+1">height of selection and flags (bit 28 clear)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+24</FONT>
<TD COLSPAN=2><FONT SIZE="+1">index of lower boundary into string</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+28</FONT>
<TD COLSPAN=2><FONT SIZE="+1">index of upper boundary into string</FONT>
</TABLE>

<P>
<B><FONT SIZE="+1">5.2. Cut and Copy</FONT></B>
<P>
<B><FONT SIZE="+1">5.2.1. Protocol</FONT></B>
<P>
<FONT SIZE="+1">When a cut or copy operation is requested of an application, it must copy the selected data to the clipboard. Under the raw protocol, each task is responsible for allocating (and deallocating) the memory necessary to store the clipboard. <U>The clipboard must hold the data in a form from which it can be translated to the maximum number of other data types, which usually means it must be held in the application's internal format.</U></FONT>
<P>
<FONT SIZE="+1">In order to ensure that only one clipboard is active globally at a time, it is necessary that when a cut or copy operation is performed, the cutting/copying task broadcasts a Message_ClaimEntity (see &sect;5.1.1) with bit 2 set. Accordingly, when a task receives such a message, it must deallocate the memory used to store its own clipboard (unless of course, its own clipboard was not in use). The message must not be sent if the same task already owned the clipboard.</FONT>

<P>
<B><FONT SIZE="+1">5.2.2. Clipboard Module</FONT></B>
<P>
<FONT SIZE="+1">One of the Clipboard's functions is to allocate and manage memory to store the clipboard data for any participating tasks, following a cut or copy operation.</FONT>
<P>
<FONT SIZE="+1">However, the Clipboard has no intrinsic knowledge of how to translate data between different formats, so it is essential that no task uses the Clipboard for this purpose if it is able to translate data on export. For example, none of Edit, Paint or Draw can exclusively use the Clipboard for clipboard storage - Edit could export Basic programs as a tokenised file, or as text; Paint can export both sprites and palettes; and Draw can export text, sprites, JPEGs and PostScript as well as DrawFiles.</FONT>
<P>
<FONT SIZE="+1">Despite this, the raw protocol messaging involved at the pasting stage is still not completely trivial, and so an alternative method will be provided, whereby the task is still responsible for storing the clipboard and translating the data when required, but the Clipboard handles all the associated Wimp messaging. This also allows some code sharing with the data-send end of the drop operation.</FONT>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=6 WIDTH=457><B><FONT SIZE="+1">SWI Clipboard_Put (&amp;4E000)</FONT></B>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">Puts data on the clipboard, or initiates the data-send of a drop (see &sect;5.4.2).</FONT>
<TR><TD COLSPAN=6><FONT SIZE="+1">On entry</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0   =</FONT>
<TD><FONT SIZE="+1">flags:</FONT>
<TD><FONT SIZE="+1">bit 0 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">clear the clipboard (must be used when the application exits, unless another task has since claimed the clipboard using a Message_ClaimEntity 4)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 1 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">do not store the data, just the data length (and the task handle) - when the data is required, the Clipboard will send the clipboard-owning task a Message_PutRequest stating the required data type, see &sect;5.3.2</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 2 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">R1 is a pointer to a data type list, otherwise R1 is the data type</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 31 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">flag reply messages as for the attention of the Wimp</FONT>
<TR><TD>
<TD>
<TD>
<TD COLSPAN=3><FONT SIZE="+1">all others are reserved and must be zero</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">depending on flags bit 2, either the data type (in bits 0-11), or a pointer to non-null list of data types that the task can translate the data to (in no particular order), terminated by -1</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R2   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">pointer to data (if flags bit 1 is clear)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R3   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">data length</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R4   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">pointer to proposed leafname of data, null-terminated</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R5   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">my_ref of Message_PutRequest which this is a reply to, or 0 if this isn't a reply</FONT>
<TR><TD COLSPAN=6><FONT SIZE="+1">On exit</FONT>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">R0-R5 preserved</FONT>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">The Clipboard broadcasts a Message_ClaimEntity 4 (unless the Clipboard owns the clipboard already), and takes a copy of the data, the leafname and the data type list, as appropriate. An error is generated if any of the pointers are invalid.</FONT>
</TABLE>
<P>
<FONT SIZE="+1">This SWI can be used for three main purposes:</FONT>
<OL>
<LI><FONT SIZE="+1">passing clipboard data to the Clipboard module to handle on the application's behalf</FONT>
<LI><FONT SIZE="+1">passing enough information about the clipboard to the Clipboard so it can advertise on our behalf (or <I>proxy</I>) and get back to the application if and when a paste operation happens</FONT>
<LI><FONT SIZE="+1">passing selection data to the Clipboard</FONT>
</OL>
<P>
<FONT SIZE="+1">The first and second cases can be initiated by the application, often in response to a Ctrl-C or Ctrl-X keypress. In this case, R5 will be 0. The first and third cases should be called in response to a Message_PutRequest, which is sent to the application by the Clipboard module if it called SWI Clipboard_Put (second case) or SWI Clipboard_StartDrag respectively, and a paste or drop operation (respectively) has been performed by the user.</FONT>
<P>
<FONT SIZE="+1">Deleting the data in the main document following a cut operation remains the task's responsibility. If a task is maintaining its own clipboard storage area, it must release the memory when it receives a Message_ClaimEntity 4 broadcast. When a task exits, if it is maintaining the clipboard, or if Clipboard is maintaining the clipboard for it, the task must call Clipboard_Put with flags bit 0 set, for consistency with applications that do everything themselves.</FONT>

<P>
<B><FONT SIZE="+1">5.2.3. Writable Icons</FONT></B>
<P>
<FONT SIZE="+1">The Wimp itself is not a Wimp task. One of the consequences of this is that it has no task handle, and is as such not well suited to handling Wimp messages. Because of this, it will make heavy use of the Clipboard.</FONT>
<P>
<FONT SIZE="+1">When the user types Ctrl-C or Ctrl-X in a writable icon, the Wimp will call Clipboard_Put with all flags clear and a data type of &amp;FFF. The data will not be terminated; only the data length word will determine the extent of the data.</FONT>

<P>
<B><FONT SIZE="+1">5.3. Paste</FONT></B>
<P>
<B><FONT SIZE="+1">5.3.1. Protocol</FONT></B>
<P>
<FONT SIZE="+1">The application must first check to see if it owns the clipboard, and use the data directly if so. If it does not own it, it must broadcast a Message_DataRequest <U>(message type 18)</U>:</FONT>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=6 WIDTH=457><B><FONT SIZE="+1">Message_DataRequest (&amp;00010)</FONT></B>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">This message is broadcast by a task when it wishes to paste data from a clipboard maintained by another task.</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+12</FONT>
<TD COLSPAN=4><FONT SIZE="+1">your_ref: 0</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+20</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+24</FONT>
<TD COLSPAN=4><FONT SIZE="+1">internal handle to indicate destination of data; <U>may be icon handle (see below)</U></FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+28</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination x co-ordinate</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+32</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination y co-ordinate</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+36</FONT>
<TD><FONT SIZE="+1">flags:</FONT>
<TD><FONT SIZE="+1">bit 2 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">send data from clipboard</FONT>
<TR><TD>
<TD>
<TD>
<TD COLSPAN=3><FONT SIZE="+1">all other bits are reserved and must be clear</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+40</FONT>
<TD COLSPAN=4><FONT SIZE="+1">list of data types in receiver's order of preference, terminated by -1 <U>(may be null)</U></FONT>
</TABLE>
<P>
<FONT SIZE="+1">Flags bit 2 must be set when the message is sent. If the message is received with flags bit 2 clear, the message must be ignored.</FONT>
<P>
<FONT SIZE="+1">If an application receiving the message owns the clipboard, it must choose the earliest data type in the list that it can provide, and if none are possible <U>(or the list is null)</U> it must provide the data in its original (native) format. It must reply using the normal Message_DataSave protocol. Bytes 20-35 of the DataSave block must be copied directly from the corresponding bytes of the Message_DataRequest block (despite the discrepancy between icon handle and internal handle), while the estimated size, data type and leafname must be filled appropriately. <U>The your_ref of the Message_DataSave must be the my_ref of the Message_DataRequest.</U></FONT>
<P>
<FONT SIZE="+1"><U>Be aware that if the Wimp sees an incoming DataSave with a valid icon handle at bytes 24-27 (i.e. less than the number of icons created in the windows), it will assume that it is a request to paste into that icon. Consequently, an application must be careful how it allocates its internal handles for use in this message. For example, it could use pointers into application space, which will be above &amp;8000 and therefore very unlikely to clash with an icon handle.</U></FONT>
<P>
<FONT SIZE="+1">When the task that initiated the paste receives the Message_DataSave, it must check the data type to ensure that it knows how to deal with it - it may be the clipboard owner's native format. If it cannot, it may back out of the transaction by ignoring the message. Otherwise, it must continue with the conventional DataSave protocol, preferably using memory data transfer.</FONT>
<P>
<FONT SIZE="+1">If an application needs to find out whether there is data available to paste, but does not actually want to receive the data (e.g. in order to determine whether a "Paste" menu option should be shaded), it must broadcast a Message_DataRequest as described above. If no task replies (i.e. the message bounces) then there is no clipboard data available. If a Message_DataSave is received, then the application must ignore it (i.e. fail to reply), which will cause the operation to be silently aborted by the other task. The data type field of the Message_DataSave can then be used to determine whether the data being offered by the other task is in a suitable format to be pasted.</FONT>

<P>
<B><FONT SIZE="+1">5.3.2. Clipboard Module</FONT></B>
<P>
<B>5.3.2.1. The Complete Paste Process</B>
<P>
<FONT SIZE="+1">During the paste process, the Clipboard behaves to conventional drag-and-drop tasks exactly like any other clipboard owner, and responds to Message_DataRequests as described above.</FONT>
<P>
<FONT SIZE="+1">It also provides an alternative interface to the pasting process, involving much less messaging. It involves SWI Clipboard_Get and the messages Message_PutRequest and Message_Paste. However, as before, if a task is managing its own clipboard, it must use the data directly in preference (although this will now only be in cases where the data can be translated on export).</FONT>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=6 WIDTH=457><B><FONT SIZE="+1">SWI Clipboard_Get (&amp;4E001)</FONT></B>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">Requests data from the clipboard, using the Clipboard as a proxy.</FONT>
<TR><TD COLSPAN=6><FONT SIZE="+1">On entry</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0   =</FONT>
<TD><FONT SIZE="+1">flags:</FONT>
<TD><FONT SIZE="+1">bit 31 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">flag reply messages as for the attention of the Wimp (this bit must only be set by the Wimp)</FONT>
<TR><TD>
<TD>
<TD>
<TD COLSPAN=3><FONT SIZE="+1">all others are reserved and must be clear</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R2   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination icon handle (-1 if none)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R3   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination x co-ordinate</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R4   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination y co-ordinate</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R5   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">pointer to list of data types that the task is interested in receiving, in order of preference, terminated by -1 (may be a null list if the native format is required)</FONT>
<TR><TD COLSPAN=6><FONT SIZE="+1">On exit</FONT>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">R0-R5 preserved</FONT>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">The Clipboard takes an internal copy of the data type list. If it owns the clipboard itself, it replies immediately with a Message_Paste. If a task has registered itself with the Clipboard using a bit-1-set SWI Clipboard_Put, the Clipboard sends a Message_PutRequest to the clipboard owner, and uses the data copied from the details in the following SWI Clipboard_Put to construct a Message_Paste. Alternatively, if a conventional drag-and-drop task owns the clipboard, the Clipboard will send a Message_DataRequest and handle all the Message_DataSave etc. messaging, before sending a Message_Paste to the pasting task, thus creating a uniform interface.</FONT>
</TABLE>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=6 WIDTH=457><B><FONT SIZE="+1">Message_PutRequest (&amp;4E000)</FONT></B>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">This message requests that clipboard or selection data be sent to the Clipboard.</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+12</FONT>
<TD COLSPAN=4><FONT SIZE="+1">your_ref: 0</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+20</FONT>
<TD><FONT SIZE="+1">flags:</FONT>
<TD><FONT SIZE="+1">bit 0</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">flags bit 0 to use in Clipboard_Put</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 1</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">flags bit 1 to use in Clipboard_Put</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 2</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">flags bit 2 to use in Clipboard_Put (note this also determines whether a single data type, or a data type list pointer is required in R3)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 3 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">send the clipboard (otherwise send the selection)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 4 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">delete the selection after sending the data</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 31 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">message is for the attention of the Wimp, other tasks must ignore it</FONT>
<TR><TD>
<TD>
<TD>
<TD COLSPAN=3><FONT SIZE="+1">all others are reserved and must be clear</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+24</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+28</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination icon handle (-1 if none)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+32</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination x co-ordinate</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+36</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination y co-ordinate</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+40</FONT>
<TD COLSPAN=4><FONT SIZE="+1">pointer to list of data types that the destination task is interested in receiving, in order of preference, terminated by -1 (may be a null list if the native format is required) - now held in the Clipboard's workspace</FONT>
</TABLE>
<P>
<FONT SIZE="+1">Message_PutRequest is sent exclusively by the Clipboard. Any task receiving the message must reply before the next Wimp_Poll using SWI Clipboard_Put with, preserving flags bit 0-2 and 31.</FONT>
<P>
<FONT SIZE="+1">The message is used both for providing the data in a paste operation (when data translation has to be delayed until paste-time) and in a drop operation, so care must be taken to send the data from either the internal clipboard or the selection, respectively. Bit 4 caters for move-drags (see &sect;5.4.2).</FONT>
<P>
<FONT SIZE="+1">The data type chosen must be the first one in the list that it can provide, or the native data type if none (or if the list is null). The data must be translated prior to calling Clipboard_Put (unless bit 2 is set), as it is at that stage that the Clipboard takes an internal copy of the data. The leafname must be built as described in &sect;4.5.1.1.</FONT>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=6 WIDTH=457><B><FONT SIZE="+1">Message_Paste (&amp;4E001)</FONT></B>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">This message informs the task being pasted to or dropped upon that the data is ready to be received.</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+12</FONT>
<TD COLSPAN=4><FONT SIZE="+1">your_ref: 0</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+20</FONT>
<TD><FONT SIZE="+1">flags:</FONT>
<TD><FONT SIZE="+1">bit 0 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">Clipboard couldn't find any clipboard after a Clipboard_Get call - take no further action</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 31 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">message is for the attention of the Wimp, other tasks must ignore it</FONT>
<TR><TD>
<TD>
<TD>
<TD COLSPAN=3><FONT SIZE="+1">all others are reserved and must be clear</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+24</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+28</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination icon handle (-1 if none) or internal handle if initiated by a Message_DataRequest</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+32</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination x co-ordinate</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+36</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination y co-ordinate</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+40</FONT>
<TD COLSPAN=4><FONT SIZE="+1">data type</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+44</FONT>
<TD COLSPAN=4><FONT SIZE="+1">pointer to data, or 0 if flag bit 0 set</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+48</FONT>
<TD COLSPAN=4><FONT SIZE="+1">data length</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+52</FONT>
<TD COLSPAN=4><FONT SIZE="+1">pointer to proposed leafname of data, null-terminated, or 0 if flag bit 0 set</FONT>
</TABLE>
<P>
<FONT SIZE="+1">This message is also sent exclusively by the Clipboard. The data type must first be checked for suitability, then the data must be copied before the next Wimp_Poll, as the Clipboard will free up the memory unless it was itself the owner of the clipboard (the task must not attempt to determine whether this is the case).</FONT>
<P>
<FONT SIZE="+1">Note that the Clipboard stores data in its own application slot, and this is where the pointer at R1+44 lies, so in order to copy the data, you must use Wimp_TransferBlock. The Clipboard's task handle (required by Wimp_TransferBlock) may be obtained from R1+4.</FONT>

<P>
<B>5.3.2.2. Interactions</B>
<P>
<FONT SIZE="+1">The five possible interactions during a paste operation are outlined below. The solid lines refer to the complete paste process, and the dotted lines refer to clipboard data type determination, as described in &sect;5.3.2.3. Lines are diagonal where a task switch is performed (i.e. for the sending of messages rather than the use of SWIs). Note that the "clipboard-owning task" is the task that most recently performed a cut or copy operation - strictly speaking, if the task is cooperating with the Clipboard, the Clipboard is the clipboard owner.</FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic17.gif" ALT="" ALIGN=MIDDLE HEIGHT=126 WIDTH=520 VSPACE=2><BR>
</FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic18.gif" ALT="" ALIGN=MIDDLE HEIGHT=154 WIDTH=520 VSPACE=2><BR>
</FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic19.gif" ALT="" ALIGN=MIDDLE HEIGHT=309 WIDTH=520 VSPACE=2><BR>
</FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic20.gif" ALT="" ALIGN=MIDDLE HEIGHT=253 WIDTH=520 VSPACE=2><BR>
</FONT>
<P ALIGN=CENTER>
<FONT SIZE="+1"><IMG SRC="Images/Pic21.gif" ALT="" ALIGN=MIDDLE HEIGHT=253 WIDTH=520 VSPACE=2></FONT>
<P>
<FONT SIZE="+1">In the fifth case, it is necessary for the Clipboard to ack the Message_DataRequest so that it doesn't bounce while the Message_PutRequest is delivered to the clipboard-owning task.</FONT>

<P>
<B>5.3.2.3. Clipboard Data Type Determination</B>
<P>
<FONT SIZE="+1">Since the Clipboard is responsible for performing the traditional data transfer protocol, tasks that use the Clipboard need another way in which to determine whether they can use the current clipboard data. This will be provided by the Clipboard using the SWI Clipboard_GetDataType and the message Message_DataTypeIs.</FONT>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=6 WIDTH=457><B><FONT SIZE="+1">SWI Clipboard_GetDataType (&amp;4E002)</FONT></B>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">Requests data type of the clipboard, using the Clipboard as a proxy.</FONT>
<TR><TD COLSPAN=6><FONT SIZE="+1">On entry</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0   =</FONT>
<TD><FONT SIZE="+1">flags:</FONT>
<TD><FONT SIZE="+1">bit 31 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">flag reply messages as for the attention of the Wimp (this bit must only be set by the Wimp, even though there are currently no plans for it to do so at present)</FONT>
<TR><TD>
<TD>
<TD>
<TD COLSPAN=3><FONT SIZE="+1">all others are reserved and must be clear</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R2   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination icon handle (-1 if none)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R3   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination x co-ordinate</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R4   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination y co-ordinate</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R5   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">pointer to list of data types that the task is interested in receiving, in order of preference, terminated by -1 (may be a null list if the native format is required)</FONT>
<TR><TD COLSPAN=6><FONT SIZE="+1">On exit</FONT>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">R0-R5 preserved</FONT>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">The Clipboard takes an internal copy of the data type list. If it owns the clipboard itself, it replies immediately with a Message_DataTypeIs. If a task has registered itself with the Clipboard using a bit-1-set SWI Clipboard_Put, the Clipboard sends a Message_PutRequest to the clipboard owner, and uses the (single) data type returned in the following SWI Clipboard_Put to construct a Message_DataTypeIs. Alternatively, if a conventional drag-and-drop task owns the clipboard, the Clipboard will send a Message_DataRequest, but fail to reply to the subsequent Message_DataSave; the data type from the Message_DataSave is used in the Message_DataTypeIs, thus creating a uniform interface.</FONT>
</TABLE>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=6 WIDTH=457><B><FONT SIZE="+1">Message_DataTypeIs (&amp;4E002)</FONT></B>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">This message informs a task of the data type of the clipboard (subject to the data type list passed to the preceding SWI Clipboard_GetDataType).</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+12</FONT>
<TD COLSPAN=4><FONT SIZE="+1">your_ref: 0</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+20</FONT>
<TD><FONT SIZE="+1">flags:</FONT>
<TD><FONT SIZE="+1">bit 0 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">Clipboard couldn't find any clipboard after a Clipboard_GetDataType call</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 31 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">message is for the attention of the Wimp, other tasks must ignore it</FONT>
<TR><TD>
<TD>
<TD>
<TD COLSPAN=3><FONT SIZE="+1">all others are reserved and must be clear</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+24</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination window handle</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+28</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination icon handle (-1 if none)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+32</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination x co-ordinate</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+36</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination y co-ordinate</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+40</FONT>
<TD COLSPAN=4><FONT SIZE="+1">data type</FONT>
</TABLE>

<P>
<B><FONT SIZE="+1">5.3.3. Writable Icons</FONT></B>
<P>
<FONT SIZE="+1">The Wimp will use the Clipboard to obtain data when it needs to be pasted. It will (effectively) install a temporary post-poll filter on the task owning the icon, in order to detect the flags-bit-31-set Message_Paste that follows a Clipboard_Get SWI call. The message event will not be claimed, so that a task can be kept informed about what is being done to its icons - but the task must not change the contents of the icon, because the Wimp will already have done so.</FONT>
<P>
<FONT SIZE="+1">Since the Wimp will only export text from writable icons, and as such will have used the bit-1-clear version of Clipboard_Put, it will not have to respond to Message_PutRequests (except as a result of a drag-and-drop, see &sect;5.4.2).</FONT>
<P>
<FONT SIZE="+1">The Wimp will not call Clipboard_GetDataType, so need not respond to Message_DataTypeIs.</FONT>

<P>
<B><FONT SIZE="+1">5.4. Drag and Drop</FONT></B>
<P>
<B><FONT SIZE="+1">5.4.1. Protocol</FONT></B>
<P>
<FONT SIZE="+1">During a traditional drag operation, no messaging takes place until the drop. However, during a drag-and-drop drag, a dialogue is set up between the dragging (sending) task and the potentially-receiving (claiming) task - which, in general, is the task owning the window under the pointer at any given time.</FONT>

<P>
<B>5.4.1.1. Responsibilities</B>
<P>
<FONT SIZE="+1">The sending task's responsibilities include:</FONT>
<UL>
<LI><FONT SIZE="+1">checking the status of the Shift key at the beginning of the drag</FONT>
<LI><FONT SIZE="+1">setting the pointer shape to <U>ptr_drop</U> at the beginning of the drag, resetting the pointer shape to <U>ptr_drop</U> when the claiming task has finished with using an alternative pointer shape, <U>and setting it back to ptr_default at the end of the drag</U></FONT>
<LI><FONT SIZE="+1">calling Wimp_DragBox, <U>DragASprite_Start/Stop or DragAnObject_Start/Stop,</U> as appropriate, at the beginning and end (abortion or completion) of the drag, and whenever the claiming task starts or stops requiring that the dragged object be removed from view (during such a period, a <U>type 7 Wimp_DragBox "dragpoint"</U> must be used instead)</FONT>
<LI><FONT SIZE="+1">contacting the claiming task every 0.25 seconds, stating the screen position and "real life" bounding box of the data and the data types in which it is available</FONT>
<LI><FONT SIZE="+1">initiating the drop when the drag ends</FONT>
<LI><FONT SIZE="+1">deleting the selected data after a successful drop if (drag was within the same window AND Shift was not held down) OR (drag was between windows <U>or to a type-15 writable icon in any window</U> AND Shift was held down) OR the destination is a trashcan application</FONT>
<LI><FONT SIZE="+1">aborting the drag (and informing the claiming task as such) when the user presses Escape (which means the sending task must retain the input focus throughout the drag)</FONT>
</UL>
<P>
<FONT SIZE="+1"><BR>
The claiming task's responsibilities include:</FONT>
<UL>
<LI><FONT SIZE="+1">updating the ghost caret according to the data passed from the sending task, provided at least one available data type can be used (and telling the sending task to remove the dragged object if a ghost caret is being displayed)</FONT>
<LI><FONT SIZE="+1">automatically scrolling the window <U>if the pointer is paused near the edge of a document window (and changing the pointer to reflect as such at the beginning of the autoscroll - changing it back at the end is the sending task's responsibility)</U></FONT>
<LI><FONT SIZE="+1">letting the sending task know its preferred ordering of data types, so that the sending task can work out which data type to send during the drop</FONT>
<LI><FONT SIZE="+1">letting the sending task know if it the claiming task is a trashcan (i.e. that the source data must be deleted)</FONT>
</UL>
<P>
<FONT SIZE="+1"><BR>
<U>A task must only claim the drag if it can do something useful with the handles and co-ordinates passed to it</U> - typically a response would be made when the pointer is over a text area or in the autoscrolling pause zone, but not when over a "dead" area like a page border, and not when over a writable icon (except that being over an autoscrolling pause zone takes precedence over being over a dead zone or icon).</FONT>
<P>
<FONT SIZE="+1">In practice, the claiming task can choose to continue to be involved in the dialogue, even when the pointer is no longer over one of its windows. This is to allow autoscrolling to continue, even when the pointer is dragged outside the window being autoscrolled (although this must not occur if the pointer has been moved smoothly over the window boundary without pausing over the window's autoscrolling activation zone). In fact, the default behaviour is for the dialogue to continue between the same two tasks, until the claiming task bows out by letting the sending task's message bounce. The claiming task, being the one handling the autoscrolling, is of course the one that knows best when this is necessary.</FONT>

<P>
<B>5.4.1.2. Messaging</B>
<P>
<FONT SIZE="+1">The sending task sends a Message_Dragging, and the claiming task replies with a Message_DragClaim, as follow:</FONT>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=6 WIDTH=457><B><FONT SIZE="+1">Message_Dragging (&amp;00011)</FONT></B>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">This message is sent by a sending task to a (prospective) claiming task at intervals of 0.25 second, carrying context-sensitive information about the drag.</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+12</FONT>
<TD COLSPAN=4><FONT SIZE="+1">your_ref: <U>my_ref of last Message_DragClaim (or 0 if there was no claimant last time, or if this is the first Message_Dragging)</U></FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+20</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination window handle (constructed from Wimp_GetPointerInfo)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+24</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination icon handle (constructed from Wimp_GetPointerInfo)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+28</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination x co-ordinate (constructed from Wimp_GetPointerInfo)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+32</FONT>
<TD COLSPAN=4><FONT SIZE="+1">destination y co-ordinate (constructed from Wimp_GetPointerInfo)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+36</FONT>
<TD><FONT SIZE="+1">flags:</FONT>
<TD><FONT SIZE="+1">bit 1 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">sending data from selection <U>(for information only, receiver must ignore)</U></FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 2 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">sending data from clipboard -<U> i.e. from a clipboard-displaying window (for information only, receiver must ignore)</U></FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 3 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">source data will be deleted <U>(for information only, and unfortunately is incorrect when generated by DataPower; receiver must ignore)</U></FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 4 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1"><U>drag is being aborted</U>, do not respond to this message</FONT>
<TR><TD>
<TD>
<TD>
<TD COLSPAN=3><FONT SIZE="+1">all other bits are reserved and must be clear</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+40</FONT>
<TD COLSPAN=4><FONT SIZE="+1">xmin, ymin, xmax, ymax (4 bytes each): bounding box of data, relative to pointer, measured in millipoints (1/72000th of an inch), <I>not</I> scaled according to the zoom factor(s) of the source window; xmin &gt; xmax means data has no bounding box, or bounding box is unknown</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+56</FONT>
<TD COLSPAN=4><FONT SIZE="+1">list of available data types <U>in no particular order</U>, terminated by -1 <U>(must not be null)</U></FONT>
</TABLE>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=6 WIDTH=457><B><FONT SIZE="+1">Message_DragClaim (&amp;00012)</FONT></B>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">This message is sent by a claiming task to the sending task in response to a Message_Dragging, carrying context-sensitive information about the drag. <U>It must only be issued if the claiming task is interested in at least one available data type.</U></FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+12</FONT>
<TD COLSPAN=4><FONT SIZE="+1">your_ref: my_ref of last Message_Dragging</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+20</FONT>
<TD><FONT SIZE="+1">flags:</FONT>
<TD><FONT SIZE="+1">bit 0 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">a pointer shape other than ptr_drop is in use</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 1 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">claiming task requires the absence of the Wimp dragbox / DragASprite sprite / DragAnObject object</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 3 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">claiming task is a trashcan application, so the source data must be deleted irrespective of Message_Dragging's flags bit 3 <U>(else deletion of the source data is determined by sending task)</U></FONT>
<TR><TD>
<TD>
<TD>
<TD COLSPAN=3><FONT SIZE="+1">all other bits are reserved and must be clear</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1+24</FONT>
<TD COLSPAN=4><FONT SIZE="+1">list of available data types in receiver's order of preference, terminated by -1 <U>(may be null)</U></FONT>
</TABLE>
<P>
<U><FONT SIZE="+1">Tasks are free to use internal routines to keep track of drags within or between windows that it owns, avoiding the performance overhead of all the messaging, as long as the user interface is indistinguishable from that which would result otherwise. Note in particular, that if the pointer is found to be over a type-15 writable icon, messaging must be turned back on as though the pointer was over a window owned by another task; this is so that the Wimp can collaborate in the dragging dialogue. Fortunately, the only application which currently uses this optimisation is Easi/TechWriter, where all the writable icons are in transient (or pseudo-transient) dialogue boxes, so this problem will never be visible, provided new implementations of drag-and-drop in applications follow these revised guidelines.</FONT></U>

<P>
<B>5.4.1.3. Use</B>
<P>
<FONT SIZE="+1">In event-driven terms, the sending and claiming tasks must follow the behaviour outlined below in order to implement every aspect of the protocol. Explanatory comments are italicised (and are all new in this specification).</FONT>
<P>
<FONT SIZE="+1">"Message type 17/18" means "use message type 17 unless drag_finished is 'true', when you must use message type 18". <I>This is an optimisation, because we're not interested if Message_Dragging bounces from a non-drag-and-drop task, until the end of the drag, when we will want to send the data by simple data transfer.</I></FONT>
<P>
<B><FONT SIZE="+1">Sending task:</FONT></B>
<UL>
<LI><FONT SIZE="+1">At <U>drag</U> start,</FONT>
<UL>
<LI><FONT SIZE="+1">enable null events every 0.25 seconds;</FONT>
<LI><FONT SIZE="+1">call Wimp_DragBox <U>(with a drag type of 5), DragASprite_Start or DragAnObject_Start as appropriate (remember to use the dragbox if CMOS states that dragged sprites/objects must not be used);</U></FONT>
<LI><U><FONT SIZE="+1">program pointer shape to ptr_drop;</FONT></U>
<LI><U><FONT SIZE="+1">set shift_pressed to indicate current status of the Shift keys;</FONT></U>
<LI><FONT SIZE="+1">set claimant to 'none' <I>(-1 is a suitable invalid task handle for this purpose)</I>;</FONT>
<LI><FONT SIZE="+1">set drag_finished to 'false';</FONT>
<LI><FONT SIZE="+1">set drag_aborted to 'false';</FONT>
<LI><FONT SIZE="+1">set lastref to 'none' <I>(0 is suitable for this purpose)</I>.</FONT>
</UL>
<LI><FONT SIZE="+1">At drag abort (when Escape pressed during a drag),</FONT>
<UL>
<LI><U><FONT SIZE="+1">disable null events;</FONT></U>
<LI><FONT SIZE="+1">call Wimp_DragBox -1, <U>DragASprite_Stop or DragAnObject_Stop as appropriate (or Wimp_DragBox -1 if old_dragclaim_flags has bit 1 set)</U>;</FONT>
<LI><U><FONT SIZE="+1">program pointer shape to ptr_default;</FONT></U>
<LI><FONT SIZE="+1">set drag_finished and drag_aborted to 'true';</FONT>
<LI><FONT SIZE="+1">proceed as for a null event...</FONT>
</UL>
<LI><FONT SIZE="+1">At drag end (when User_Drag_Box event is received),</FONT>
<UL>
<LI><U><FONT SIZE="+1">disable null events;</FONT></U>
<LI><U><FONT SIZE="+1">if necessary, call DragASprite_Stop or DragAnObject_Stop;</FONT></U>
<LI><U><FONT SIZE="+1">program pointer shape to ptr_default;</FONT></U>
<LI><FONT SIZE="+1">set drag_finished to 'true';</FONT>
<LI><FONT SIZE="+1">proceed as for a null event...</FONT>
</UL>
<LI><FONT SIZE="+1">At null events,</FONT>
<UL>
<LI><FONT SIZE="+1">construct Message_Dragging using data from Wimp_GetPointerInfo and the value of drag_aborted;</FONT>
<LI><FONT SIZE="+1">if claimant is 'none', send message type 17/18 to window owner with your_ref = 0;</FONT>
<LI><FONT SIZE="+1">else, send message type 18 to claimant with your_ref = lastref.</FONT>
</UL>
<LI><FONT SIZE="+1">When Message_DragClaim is received,</FONT>
<UL>
<LI><FONT SIZE="+1">if drag_finished is 'true',</FONT>
<UL>
<LI><I><FONT SIZE="+1">drag has ended successfully while a claim is in force</FONT></I>
<LI><FONT SIZE="+1">if drag_aborted is 'false' <I>(this comparison is not strictly necessary, since the claiming task is not supposed to reply when the drag is being aborted)</I>,</FONT>
<UL>
<LI><FONT SIZE="+1">initiate enhanced drop operation (send Message_DataSave to claimant, using first possible data type in the list, or the native data type if none are possible, and using your_ref = my_ref of the Message_DragClaim, then delete the source data if shift_pressed and the new window/icon handles (or the trashcan flag bit in Message_DragClaim) indicate as such.</FONT>
</UL>
</UL>
<LI><FONT SIZE="+1">else,</FONT>
<UL>
<LI><I><FONT SIZE="+1">drag is continuing AND (a claim is in force, or a claim is starting)</FONT></I>
<LI><U><FONT SIZE="+1">if lastref != 'none',</FONT></U>
<UL>
<LI><I><FONT SIZE="+1">claim is continuing, not just starting</FONT></I>
<LI><FONT SIZE="+1">if old_dragclaim_flags bit 0 is set, but the new Message_DragClaim flags bit 0 is clear, program the pointer shape to <U>ptr_drop</U>;</FONT>
<LI><U><FONT SIZE="+1">if old_dragclaim_flags bit 1 is set, but the new Message_DragClaim flags bit 1 is clear, call Wimp_DragBox (with a drag type of 5), DragASprite_Start or DragAnObject_Start as appropriate.</FONT></U>
<LI><U><FONT SIZE="+1">if old_dragclaim_flags bit 1 is clear, but the new Message_DragClaim flags bit 1 is set, call DragASprite_Stop or DragAnObject_Stop if necessary, then call Wimp_DragBox with a drag type of 7.</FONT></U>
</UL>
<LI><U><FONT SIZE="+1">else,</FONT></U>
<UL>
<LI><I><FONT SIZE="+1">claim is just starting</FONT></I>
<LI><U><FONT SIZE="+1">if Message_DragClaim flags bit 1 is set, call DragASprite_Stop or DragAnObject_Stop if necessary, then call Wimp_DragBox with a drag type of 7.</FONT></U>
</UL>
<LI><FONT SIZE="+1">set claimant to task handle in Message_DragClaim;</FONT>
<LI><FONT SIZE="+1">set lastref to my_ref of Message_DragClaim;</FONT>
<LI><U><FONT SIZE="+1">set old_dragclaim_flags to flags word from Message_DragClaim.</FONT></U>
</UL>
</UL>
<LI><FONT SIZE="+1">When Message_Dragging bounces,</FONT>
<UL>
<LI><FONT SIZE="+1">if claimant is not 'none',</FONT>
<UL>
<LI><I><FONT SIZE="+1">claimant is releasing claim (including when claimant doesn't reply because the drag is aborting)</FONT></I>
<LI><U><FONT SIZE="+1">if drag_finished is 'false',</FONT></U>
<UL>
<LI><FONT SIZE="+1">if old_dragclaim_flags bit 0 is set, program the pointer shape to <U>ptr_drop</U>;</FONT>
<LI><U><FONT SIZE="+1">if old_dragclaim_flags bit 1 is set, call Wimp_DragBox (with a drag type of 5), DragASprite_Start or DragAnObject_Start as appropriate.</FONT></U>
</UL>
<LI><FONT SIZE="+1">set claimant to 'none';</FONT>
<LI><U><FONT SIZE="+1">set lastref to 'none';</FONT></U>
<LI><FONT SIZE="+1">resend Message_Dragging as message type 17/18 to the window owner (preserving the flags, and with your_ref = 0).</FONT>
</UL>
<LI><FONT SIZE="+1">else,</FONT>
<UL>
<LI><I><FONT SIZE="+1">(no claimant is in effect AND drag has finished) OR the drag is aborting</FONT></I>
<LI><FONT SIZE="+1">if drag_finished is 'true' <I>(this comparison is not strictly necessary, since drag_aborted also implies drag_finished)</I>,</FONT>
<UL>
<LI><FONT SIZE="+1">if drag_aborted is 'false',</FONT>
<UL>
<LI><FONT SIZE="+1">initiate simple drop operation (send Message_DataSave to window owner, using native data type and your_ref = 0).</FONT>
</UL>
</UL>
</UL>
</UL>
</UL>
<P>
<B><FONT SIZE="+1"><BR>
Claiming task:</FONT></B>
<UL>
<LI><FONT SIZE="+1">At <U>initialisation</U>,</FONT>
<UL>
<LI><FONT SIZE="+1">set claiming to 'false'.</FONT>
</UL>
<LI><FONT SIZE="+1">When Message_Dragging is received,</FONT>
<UL>
<LI><FONT SIZE="+1">if claiming is 'false',</FONT>
<UL>
<LI><FONT SIZE="+1">if flags bit 4 is clear,</FONT>
<UL>
<LI><I><FONT SIZE="+1">start claim</FONT></I>
<LI><U><FONT SIZE="+1">set claiming to 'true' and autoscrolling to 'false';</FONT></U>
<LI><FONT SIZE="+1">if pointer is in the autoscroll pause zone,</FONT>
<UL>
<LI><U><FONT SIZE="+1">set pausing to 'true';</FONT></U>
<LI><U><FONT SIZE="+1">set old_pointer_x, old_pointer_y and old_pointer_time to the x and y from Message_Dragging and the current monotonic time;</FONT></U>
<LI><FONT SIZE="+1">program pointer to autoscroll-pause shape, <U>and set pointer_altered to 'true';</U></FONT>
</UL>
<LI><U><FONT SIZE="+1">else,</FONT></U>
<UL>
<LI><U><FONT SIZE="+1">set pausing to 'false' and pointer_altered to 'false';</FONT></U>
</UL>
<LI><FONT SIZE="+1"><U>if the data type is suitable,</U> draw the ghost caret (I-beam or bounding box) and <U>set ghost_caret to 'true', else set ghost_caret to 'false';</U></FONT>
<LI><FONT SIZE="+1">reply with Message_DragClaim (message type 17), <U>using pointer_altered and ghost_caret to determine the flags.</U></FONT>
</UL>
</UL>
<LI><FONT SIZE="+1">else,</FONT>
<UL>
<LI><FONT SIZE="+1">if flags bit 4 is clear AND (claiming task owns the window<U>/icon</U> handle in Message_Dragging OR autoscrolling is 'true'),</FONT>
<UL>
<LI><I><U><FONT SIZE="+1">update claim</FONT></U></I>
<LI><FONT SIZE="+1">if pausing is 'true',</FONT>
<UL>
<LI><FONT SIZE="+1">if current pointer x or y differs from old_pointer_x or old_pointer_y, set old_pointer_x, old_pointer_y and old_pointer_time to the current pointer x and y and monotonic time;</FONT>
<LI><FONT SIZE="+1">if pointer has left autoscroll pausing zone,</FONT>
<UL>
<LI><FONT SIZE="+1">set pausing and pointer_altered to 'false';</FONT>
</UL>
<LI><FONT SIZE="+1"> else,</FONT>
<UL>
<LI><FONT SIZE="+1">if (current monotonic time - old_pointer_time) &gt;= pause_time (typically 0.5 seconds), set autoscrolling to 'true' and pausing to 'false', and program the pointer to its autoscroll-active shape;</FONT>
</UL>
</UL>
<LI><FONT SIZE="+1">else if autoscrolling is 'false',</FONT>
<UL>
<LI><FONT SIZE="+1">if pointer is in the autoscroll pause zone,</FONT>
<UL>
<LI><FONT SIZE="+1">set pausing to 'true';</FONT>
<LI><FONT SIZE="+1">set old_pointer_x, old_pointer_y and old_pointer_time to the x and y from Message_Dragging and the current monotonic time;</FONT>
<LI><FONT SIZE="+1">program pointer to autoscroll-pause shape, and set pointer_altered to 'true';</FONT>
</UL>
<LI><FONT SIZE="+1">else,</FONT>
<UL>
<LI><FONT SIZE="+1">set pausing to 'false' and pointer_altered to 'false';</FONT>
</UL>
</UL>
<LI><FONT SIZE="+1">else (i.e. autoscrolling is 'true'),</FONT>
<UL>
<LI><FONT SIZE="+1">if pointer is over the window, but not in the autoscroll pause zone,</FONT>
<UL>
<LI><FONT SIZE="+1">set autoscrolling and pointer_altered to 'false';</FONT>
</UL>
<LI><FONT SIZE="+1">else,</FONT>
<UL>
<LI><FONT SIZE="+1">scroll the window by an amount proportional to the distance from the pointer to the inside edge of the autoscroll pause zone;</FONT>
<LI><FONT SIZE="+1">if the window cannot be scrolled any further in this direction (or can be scrolled in neither direction if a 2D scroll), set autoscrolling to 'false', set pausing to 'true' and program the pointer to its autoscroll-pausing shape;</FONT>
</UL>
</UL>
<LI><FONT SIZE="+1">if ghost_caret is 'true', update ghost caret - unless the work-area-relative position is unchanged, undraw the old ghost caret and draw the new ghost caret;</FONT>
<LI><FONT SIZE="+1">reply with Message_DragClaim (message type 17), using pointer_altered and ghost_caret to determine the flags.</FONT>
</UL>
<LI><FONT SIZE="+1">else,</FONT>
<UL>
<LI><I><FONT SIZE="+1">release claim</FONT></I>
<LI><FONT SIZE="+1">set claiming to 'false';</FONT>
<LI><FONT SIZE="+1"><U>if ghost_caret is 'true', </U>undraw the old ghost caret;</FONT>
<LI><FONT SIZE="+1">let Message_Dragging bounce (i.e. don't reply to it).</FONT>
</UL>
</UL>
</UL>
<LI><FONT SIZE="+1">When Message_DataSave is received,</FONT>
<UL>
<LI><FONT SIZE="+1">if you_ref != 0,</FONT>
<UL>
<LI><U><FONT SIZE="+1">if claiming is 'true',</FONT></U>
<UL>
<LI><I><FONT SIZE="+1">this was an enhanced (full drag-and-drop) drop - the claim was never released</FONT></I>
<LI><FONT SIZE="+1">set claiming to 'false';</FONT>
<LI><FONT SIZE="+1">if ghost_caret is 'true', undraw the old ghost caret;</FONT>
<LI><FONT SIZE="+1">import data to the last ghost caret position using conventional data transfer protocol (preferably using memory data transfer).</FONT>
</UL>
<LI><U><FONT SIZE="+1">else,</FONT></U>
<UL>
<LI><I><FONT SIZE="+1">this is part of the paste protocol</FONT></I>
<LI><U><FONT SIZE="+1">continue as for simple drop...</FONT></U>
</UL>
</UL>
<LI><FONT SIZE="+1">else,</FONT>
<UL>
<LI><I><FONT SIZE="+1">this was a simple drop</FONT></I>
<LI><FONT SIZE="+1">import data to position from Message_DataSave using conventional data transfer protocol (preferably using memory data transfer).</FONT>
</UL>
</UL>
</UL>

<P>
<B><FONT SIZE="+1">5.4.2. Clipboard Module</FONT></B>
<P>
<B>5.4.2.1. Use</B>
<P>
<FONT SIZE="+1">The Clipboard module, in conjunction with the SWI Wimp_AutoScroll, will reduce the coding required to implement drag-and-drop to the following, a great improvement on &sect;5.4.1.3. Note that, unlike the clipboard maintenance and paste protocols, the drag and drop protocols use one-to-one messages rather than broadcast messages, so the Clipboard needs to make use of filters in order to translate between the protocols. (An assumption has been made that the receiving task wishes to use an I-beam ghost caret - this does not have to be the case, but Wimp_SetCaretPosition's new facility for drawing ghost carets requires simpler but different code from that in &sect;5.4.1.3.)</FONT>
<P>
<B><FONT SIZE="+1">Sending task:</FONT></B>
<UL>
<LI><FONT SIZE="+1">At drag start,</FONT>
<UL>
<LI><FONT SIZE="+1">ensure sending window has the input focus;</FONT>
<LI><FONT SIZE="+1">call SWI Clipboard_StartDrag.</FONT>
</UL>
<LI><FONT SIZE="+1">When Message_PutRequest is received,</FONT>
<UL>
<LI><FONT SIZE="+1">if flags bits 3 and 31 are clear,</FONT>
<UL>
<LI><I><FONT SIZE="+1">this is a PutRequest for the selection, rather than the task-managed clipboard</FONT></I>
<LI><FONT SIZE="+1">translate selected data to the first possible data type in the list, or leave as the native data type if none are possible;</FONT>
<LI><FONT SIZE="+1">call Clipboard_Put to send the data;</FONT>
<LI><FONT SIZE="+1">if flags bit 4 of the Message_PutRequest was set, delete the selection.</FONT>
</UL>
</UL>
</UL>
<P>
<B><FONT SIZE="+1"><BR>
Claiming task:</FONT></B>
<UL>
<LI><FONT SIZE="+1">At initialisation,</FONT>
<UL>
<LI><FONT SIZE="+1">set claiming to 'false'.</FONT>
</UL>
<LI><FONT SIZE="+1">When Message_Dragging is received,</FONT>
<UL>
<LI><FONT SIZE="+1">if claiming is 'false',</FONT>
<UL>
<LI><FONT SIZE="+1">if flags bit 4 is clear,</FONT>
<UL>
<LI><I><FONT SIZE="+1">start claim</FONT></I>
<LI><FONT SIZE="+1">set claiming to 'true';</FONT>
<LI><FONT SIZE="+1">call Wimp_AutoScroll;</FONT>
<LI><FONT SIZE="+1">call Wimp_SetCaretPosition to position the ghost caret if at least one available data type is suitable;</FONT>
<LI><FONT SIZE="+1">reply with Message_DragClaim (message type 17), with flags bit 0 clear, and flags bit 1 set if a ghost caret is being displayed.</FONT>
</UL>
</UL>
<LI><FONT SIZE="+1">else,</FONT>
<UL>
<LI><FONT SIZE="+1">if flags bit 4 is clear AND (claiming task owns the window handle in Message_Dragging OR Wimp_AutoScroll indicates scrolling is in progress),</FONT>
<UL>
<LI><I><FONT SIZE="+1">update claim</FONT></I>
<LI><FONT SIZE="+1">call Wimp_SetCaretPosition to reposition the ghost caret if at least one available data type is suitable;</FONT>
<LI><FONT SIZE="+1">reply with Message_DragClaim (message type 17), with flags bit 0 clear, and flags bit 1 set if a ghost caret is being displayed.</FONT>
</UL>
<LI><FONT SIZE="+1">else,</FONT>
<UL>
<LI><I><FONT SIZE="+1">release claim</FONT></I>
<LI><FONT SIZE="+1">set claiming to 'false';</FONT>
<LI><FONT SIZE="+1">call Wimp_AutoScroll to deactivate autoscrolling;</FONT>
<LI><FONT SIZE="+1">call Wimp_SetCaretPosition -1 to remove the ghost caret;</FONT>
<LI><FONT SIZE="+1">let Message_Dragging bounce (i.e. don't reply to it).</FONT>
</UL>
</UL>
</UL>
<LI><FONT SIZE="+1">When Message_DataSave is received,</FONT>
<UL>
<LI><FONT SIZE="+1">if claiming is 'true',</FONT>
<UL>
<LI><I><FONT SIZE="+1">this was an enhanced (full drag-and-drop) drop - the claim was never released</FONT></I>
<LI><FONT SIZE="+1">set claiming to 'false';</FONT>
<LI><FONT SIZE="+1">call Wimp_AutoScroll to deactivate autoscrolling;</FONT>
<LI><FONT SIZE="+1">call Wimp_SetCaretPosition -1 to remove the ghost caret;</FONT>
<LI><FONT SIZE="+1">copy window handle, icon handle, x and y offsets from last Message_Dragging over the Message_DataSave block equivalents, and call Clipboard_CatchDrop.</FONT>
</UL>
<LI><FONT SIZE="+1">else,</FONT>
<UL>
<LI><I><FONT SIZE="+1">this was a simple drop</FONT></I>
<LI><FONT SIZE="+1">call Clipboard_CatchDrop.</FONT>
</UL>
</UL>
</UL>
</UL>
<P>
<FONT SIZE="+1"><BR>
</FONT>
<P>
<B>5.4.2.2. Messaging</B>
<P>
<FONT SIZE="+1">The details of the new SWIs introduced are:</FONT>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=6 WIDTH=457><B><FONT SIZE="+1">SWI Clipboard_StartDrag (&amp;4E003)</FONT></B>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">Starts a drag-and-drop drag, using the Clipboard as a proxy.</FONT>
<TR><TD COLSPAN=6><FONT SIZE="+1">On entry</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0   =</FONT>
<TD><FONT SIZE="+1">flags:</FONT>
<TD><FONT SIZE="+1">bit 1</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">as Message_Dragging (= sending from selection)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 2</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">as Message_Dragging (= sending from clipboard)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bits 14, 15</FONT>
<TD><FONT SIZE="+1">   0</FONT>
<TD><FONT SIZE="+1">=&gt;  use rotating-dash fixed-size Wimp dragbox</FONT>
<TR><TD>
<TD>
<TD>
<TD>
<TD><FONT SIZE="+1">   1</FONT>
<TD><FONT SIZE="+1">=&gt;  use DragASprite</FONT>
<TR><TD>
<TD>
<TD>
<TD>
<TD><FONT SIZE="+1">   2</FONT>
<TD><FONT SIZE="+1">=&gt;  use DragAnObject</FONT>
<TR><TD>
<TD>
<TD>
<TD>
<TD><FONT SIZE="+1">   3</FONT>
<TD><FONT SIZE="+1">=&gt;  reserved</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 16</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">as DragAnObject_Start, if applicable (R1 is a pointer to a routine rather than a SWI number)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 17</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">as DragAnObject_Start, if applicable (if bit 16 is set and bit 18 clear, enter routine with R10 below R13 - note this was previously misdocumented as the routine being entered in SVC mode rather than USR mode)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 18</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">as DragAnObject_Start, if applicable (if bit 16 is set and DragAnObject is version 0.09 or later, enter routine in USR mode rather than SVC mode)</FONT>
<TR><TD>
<TD>
<TD>
<TD><FONT SIZE="+1">bit 31 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">flag reply messages as for the attention of the Wimp (this bit must only be set by the Wimp)</FONT>
<TR><TD>
<TD>
<TD>
<TD COLSPAN=3><FONT SIZE="+1">all others are reserved and must be clear</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">sprite area or renderer (if DragASprite or DragAnObject, respectively)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R2   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">pointer to sprite name or register/parameter block (if DragASprite or DragAnObject, respectively)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R3   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">source window handle (used in combination with the Shift key state to determine when the source data needs deleting afterwards)</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R4   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">pointer to word-aligned block containing three bounding boxes, each made up of four 32-bit quantities held in the order xmin, ymin, xmax, ymax, where the minima are inclusive and the maxima are exclusive:</FONT>
<OL>
<LI><FONT SIZE="+1">bounding box to apply to the pointer, in OS units from the screen origin; if xmin &gt; max then the pointer is constrained to the screen</FONT>
<LI><FONT SIZE="+1">initial position of the dragbox/sprite/object being dragged, in OS units from the screen origin</FONT>
<LI><FONT SIZE="+1">"real" position and size of the data to use to render the ghost caret, in millipoints (1/72000ths of an inch) relative to the pointer; if xmin &gt; xmax then the size is unknown or undefined</FONT>
</OL>
<TR><TD>
<TD><FONT SIZE="+1">R5   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">data length, bytes</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R6   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">pointer to non-null list of data types that the task can translate the data to (in no particular order), terminated by -1</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R7   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">pointer to proposed leafname of data, null-terminated</FONT>
<TR><TD COLSPAN=6><FONT SIZE="+1">On exit</FONT>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">R0-R7 preserved</FONT>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">The Clipboard takes a copy of the data pointed to, and performs the actions described in &sect;5.4.1.3 (sending) on behalf of the task. In order to achieve this, it forces the required Wimp events to be unmasked using a pre-poll filter, then performs its main actions using a post-poll filter; it also calls Wimp_AddMessages, so it not necessary for the task to register interest in Message_DragClaim etc. at initialisation. During the drag, the task will not see any user_drag_box events, key_pressed events (except for Escape), or any DragClaim, RAMFetch, DataSaveAck or DataLoadAck messages. If null events were enabled in the poll mask before it was massaged by the pre-poll filter (and, if it was a call to Wimp_PollIdle, the required time has passed) they will also pass through to the task once the post-poll filter has done its work.</FONT>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">When the drag ends (successfully or not), the filters are removed. When the drag ends successfully, the task's cooperation is required in order to translate the data to the required data type; this is accomplished by the Clipboard sending it a Message_PutRequest with flags bit 3 clear, as described in &sect;5.3.2.1.</FONT>
</TABLE>
<P>
<TABLE CELLPADDING=5>
<TR><TD COLSPAN=6 WIDTH=457><B><FONT SIZE="+1">SWI Clipboard_CatchDrop (&amp;4E004)</FONT></B>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">Request the Clipboard to act as a proxy for data transfer during a drop.</FONT>
<TR><TD COLSPAN=6><FONT SIZE="+1">On entry</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R0   =</FONT>
<TD><FONT SIZE="+1">flags:</FONT>
<TD><FONT SIZE="+1">bit 31 set</FONT>
<TD><FONT SIZE="+1">=&gt;</FONT>
<TD><FONT SIZE="+1">flag reply messages as for the attention of the Wimp (this bit must only be set by the Wimp)</FONT>
<TR><TD>
<TD>
<TD>
<TD COLSPAN=3><FONT SIZE="+1">all others are reserved and must be clear</FONT>
<TR><TD>
<TD><FONT SIZE="+1">R1   =</FONT>
<TD COLSPAN=4><FONT SIZE="+1">pointer to DataSave message block (or DataLoad message block if initiated by the Filer) that needs replying to</FONT>
<TR><TD COLSPAN=6><FONT SIZE="+1">On exit</FONT>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">R0-R1 preserved</FONT>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">The Clipboard handles the data transfer for the task, trying memory data transfer first if possible. When the transfer is complete, the Clipboard sends a Message_Paste to the task that called this SWI, so as to appear identical to a paste operation.</FONT>
<TR><TD>
<TD COLSPAN=5><FONT SIZE="+1">It will also detect if it sent the DataSave message itself - in other words, if the sending task was using the Clipboard as a proxy too - if so, no further messaging will occur, and the Clipboard will simply use the pointer to its copy of the data made during Clipboard_Put in the Message_Paste.</FONT>
</TABLE>

<P>
<B><FONT SIZE="+1">5.4.3. Writable Icons</FONT></B>
<P>
<FONT SIZE="+1">The Wimp will handle drags to and from writable icons as in &sect;5.4.2.</FONT>
<P>
<FONT SIZE="+1">The Wimp will install an internal message filter in order to listen for Clipboard messages (Message_PutRequest and Message_Paste) with flags bit 31 set; these are handled by the Wimp and not passed on to the task. Similarly, it will intercept and not pass on Message_Dragging throughout any period when it is claiming the drag. However, some tasks (such as FrontEnd) do perform useful functions when they receive a Message_DataSave, so Message_DataSave is always passed through to the task, and the Wimp will only call Clipboard_CatchDrop at the Wimp_Poll following the delivery of Message_DataSave if the task didn't call Wimp_SendMessage, Wimp_UpdateWindow or Wimp_ForceRedraw.</FONT>
</UL>

<P>
<B><FONT SIZE="+3">6. Data Formats</FONT></B>
<P>
<FONT SIZE="+1">No new data formats are introduced.</FONT>

<P>
<B><FONT SIZE="+3">7. Dependencies</FONT></B>
<P>
<FONT SIZE="+1">The new Wimp provides facilities not available in earlier versions. Although the source release means that it is possible for applications that use them to require users of older Wimps to upgrade them, the authors may choose to implement them manually in cases where an older Wimp is detected. However, it is encouraged that the new Wimp facilities be utilised when possible, to accommodate future GUI changes, to allow system-wide configuration of autoscroll behaviour and so on.</FONT>
<P>
<FONT SIZE="+1">The Wimp will require the Clipboard to enable functioning of drag-and-drop to or from writable icons. Without it, selections will be able to be made, but no operations (other than deletion) can be performed on them, and no selections from other applications will be inserted when dropped on a writable icon.</FONT>

<P>
<B><FONT SIZE="+3">8. Acceptance Test</FONT></B>
<P>
<B><FONT SIZE="+1">8.1. Clipboard Module</FONT></B>
<P>
<B><FONT SIZE="+1">8.1.1. Compatibility</FONT></B>
<P>
<FONT SIZE="+1">The most advanced features of RISC OS that the Clipboard will make use of are Dynamic Areas and the DragAnObject module, both introduced at RISC OS 3.50. Provision may be made for further development work to be done to support versions back to RISC OS 3.10 (by using RMA rather than Dynamic Areas, and defaulting to rotating-dash boxes when a DragAnObject drag is requested), but for the purposes of the initial release, a modern OS may be assumed.</FONT>

<P>
<B><FONT SIZE="+1">8.1.2. Reliability/Robustness</FONT></B>
<P>
<FONT SIZE="+1">The module must be able to handle at least a thousand consecutive operations without crashing. Null-length data, extremely long data and data close in length to a multiple of the page size must not cause problems. Bad parameters (e.g. illegal sprite area pointers) must be handled as well as possible - in the example, a rotating-dash box must be used instead.</FONT>

<P>
<B><FONT SIZE="+1">8.1.3. Performance</FONT></B>
<P>
<FONT SIZE="+1">Performance will unfortunately continue to be slow in certain key situations - for example, when transferring data to a conventional task by memory data transfer, where the receiving task has specified too small a buffer. Memory transfer will be slower during drops, since the data is copied twice, once to the Clipboard's application slot, and once from it. The incidences of scrapfile transfer will however be reduced, resulting in speed gains.</FONT>

<P>
<B><FONT SIZE="+1">8.1.4. Memory Usage</FONT></B>
<P>
<FONT SIZE="+1">The module itself must not exceed 32kB in length. Stored global clipboard data and transient data (during a drop operation) are stored in the Clipboard's application slot so that the only size limits are those of the application slot size (not a big issue with modern memory maps) and the amount of physical RAM available. The application slot shall grow and shrink so that it is no larger than the combined size of the data stored, rounded up to the next page boundary. The RMA shall be used for general heap storage (linked lists etc.).</FONT>

<P>
<B><FONT SIZE="+1">8.2. Wimp Writable Icon Code</FONT></B>
<P>
<B><FONT SIZE="+1">8.2.1. Compatibility</FONT></B>
<P>
<FONT SIZE="+1">The writable icon code will function correctly for all tasks that follow the revised guidelines in &sect;5 and all tasks that do not support the drag-and-drop protocol, but it may lack complete functionality (although not to the extent of rendering it useless) for up to 10% of the writable icons in existing applications written to the old application note guidelines.</FONT>

<P>
<B><FONT SIZE="+1">8.2.2. Reliability/Robustness</FONT></B>
<P>
<FONT SIZE="+1">The writable icon cut-and-paste / drag-and-drop code must be at least as reliable as the Clipboard module.</FONT>

<P>
<B><FONT SIZE="+1">8.2.3. Performance</FONT></B>
<P>
<FONT SIZE="+1">Redraw of writable icons, especially when delimiting a selection with autoscrolling active, must not cause flicker. Data transfer operations must not be appreciably slower than the Clipboard routines that are actually doing the work.</FONT>

<P>
<B><FONT SIZE="+1">8.2.4. Memory Usage</FONT></B>
<P>
<FONT SIZE="+1">Writable icon data is usually held in application workspace, and will not increase in size by virtue of these enhancements. A negligible amount of extra module workspace will be required to hold the details of the Wimp selection and ghost caret, this should typically be no more than 32K.</FONT>

<P>
<B><FONT SIZE="+3">9. Non Compliances</FONT></B>
<P>
<FONT SIZE="+1">No attempt will be made to develop an selection-drawing algorithm that can cope with overlapping icons. The appearance of such icons after scrolling and redrawing is not defined.</FONT>

<P>
<B><FONT SIZE="+3">10. Development Test Strategy</FONT></B>
<P>
<FONT SIZE="+1">Test applications will be written to exercise the Clipboard SWIs.</FONT>
<P>
<FONT SIZE="+1">Drags to and from the existing drag-and-drop applications (e.g. DataPower, EasiWriter and TechWriter) work seamlessly. These applications will therefore be important testing tools. Also for testing purposes, a drag-and-drop trashcan application and simple clipboard-display application will be written.</FONT>
<P>
<FONT SIZE="+1">(Conventional data transfer (as for example, when dropping a selection on to a Filer window) is not expected to cause significant problems, as the protocol has been clearly defined for a long time, unlike the protocol in the application notes.)</FONT>
<P>
<FONT SIZE="+1">A test suite will be written to exercise the functions of the Clipboard through exercise of writable icons' cut-and-paste / drag-and-drop facilities. For example: setting of writable icon selections will be tested repeatedly, involving operations that change one or both ends of a selection (or neither) at the same time, both with and without the presence of a ghost caret. This will be done by direct calling of Wimp_SetCaretPosition. And text files of differing length, of differing line terminator and files that have been accidentally mistyped as text will be saved on to writable icons of differing validation strings, using conventional data transfer, pasting and dropping.</FONT>

<P>
<B><FONT SIZE="+3">11. Product Organisation</FONT></B>
<P>
<FONT SIZE="+1">This document, and the code it describes, form part of the Shared Source RISC OS release.</FONT>
<P>
<FONT SIZE="+1">The APIs and messages should ideally be included in a new version of the Programmer's Reference Manual. Use of the raw protocol rather than the Clipboard module will be deprecated.</FONT>
<P>
<FONT SIZE="+1">The Clipboard module can be softloaded, but must also be capable of being built into ROM.</FONT>

<P>
<B><FONT SIZE="+3">12. Future Enhancements</FONT></B>
<P>
<FONT SIZE="+1">None planned.</FONT>

<P>
<B><FONT SIZE="+3">13. Glossary</FONT></B>
<P>
<TABLE CELLPADDING=3>
<TBODY VALIGN=TOP>
<TR><TD WIDTH=83><STRONG><FONT SIZE="+1">AND</FONT></STRONG> <I>conj.</I>
<TD><FONT SIZE="+1">Logical AND.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Caret</FONT></STRONG> <I>n.</I>
<TD WIDTH=370><FONT SIZE="+1">The position in a document where typed characters or pasted clipboard contents will be placed. Many pre-drag-and-drop applications also use this position as the insertion point for dropped data, but drag-and-drop applications must use the ghost caret for this purpose instead. In textual documents, the caret is often shown by a red I-beam, but other representations of the caret may be more appropriate for other kinds of data. Some editors, such as !Draw, do not have a visible insertion point, but still "grab the caret" and mark it as invisible, in order to gain the input focus so that they may receive keystroke events.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Clear</FONT></STRONG> <I>v.</I>
<TD><FONT SIZE="+1">The operation by which a selection is undone.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Clipboard</FONT></STRONG> <I>n.</I>
<TD><FONT SIZE="+1">A hidden, temporary storage area that holds any type of data while the user is copying or moving it using the cut-and-paste protocol, whether internal to one application, or between applications. Conceptually, there is only one clipboard, but the actual storage area may actually be managed by different applications or modules, depending upon the circumstances.</FONT>
<TR><TD>
<TD><FONT SIZE="+1">The term may also be used to refer to the Clipboard module, although in this eventuality, the initial letter will be in upper case.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Copy</FONT></STRONG> <I>v.</I>
<TD><FONT SIZE="+1">The operation by which the current selection is replicated in the clipboard, overwriting any existing data in the clipboard.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Cut</FONT></STRONG> <I>v.</I>
<TD><FONT SIZE="+1">As copy, but the selection is subsequently deleted from its original location.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Data type</FONT></STRONG> <I>n.</I>
<TD><FONT SIZE="+1">A value equivalent to a filetype, but not necessarily referring to a file.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Drag</FONT></STRONG> <I>v.</I>
<TD><FONT SIZE="+1">The operation by which the user indicates where they wish a selection to be copied or moved to by dragging a representation of the data from the selection to the destination.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Drop</FONT></STRONG> <I>v.</I>
<TD><FONT SIZE="+1">At the end of a drag, the actual data transfer process. This combines the functionality of a paste operation with either a cut or copy operation, as appropriate.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Ghost caret</FONT></STRONG> <I>n.</I>
<TD><FONT SIZE="+1">During a drag operation, the position in a document where the data would be inserted, were the user to release the mouse button. In textual documents, the ghost caret is often shown similarly to a normal caret, but coloured grey, and "snapped" to the nearest character boundary. Other documents might better display the ghost caret as the bounding box of the data, scaled according to the destination window's zoom factor(s).</FONT>
<TR><TD><STRONG><FONT SIZE="+1">OR</FONT></STRONG> <I>conj.</I>
<TD><FONT SIZE="+1">Logical inclusive OR (i.e. not EOR) - used where the 'or' would have an ambiguous meaning, for example in English text.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Input focus</FONT></STRONG> <I>n.</I>
<TD><FONT SIZE="+1">The defining attribute of the window where keystroke events will be delivered. The user may be able to see a caret or a selection, or possibly neither, in the window that has the input focus; the window border will be coloured in an alternative colour (conventionally cream). Any parent nested windows (recursively), and any non-pane window behind a pane window, will also have their title bars recoloured.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Paste</FONT></STRONG> <I>v.</I>
<TD><FONT SIZE="+1">The operation that the user performs to copy the clipboard contents into a document, at the caret.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Selection</FONT></STRONG> <I>n.</I>
<TD><FONT SIZE="+1">The portion of a document which the user has chosen as the target for subsequent operations. This may be a contiguous selection (as in the case of selected text) or a non-contiguous selection (as in the case of a number of selected files in the Filer). The rendering of the selection is media-dependent, but typically may be shown by inversion of the colours of the selected region, or alternatively by the drawing of a bounding box around the selection(s).</FONT>
<TR><TD>
<TD><FONT SIZE="+1">A <I>shaded</I> selection, which ought be rendered to match the Wimp's rendering of shaded selections in writable icons, indicates the location of a selection after another selection has been made in another window - but not when a caret or selection is made in a non-drag-and-drop application.</FONT>
<TR><TD><STRONG><FONT SIZE="+1">Shadow caret</FONT></STRONG> <I>n.</I>
<TD><FONT SIZE="+1">The equivalent of a shaded selection, but for carets. A shadow caret must not be rendered in such a way that it can be mistaken for a ghost caret. It is optional, because applications are expected normally to use a Wimp-drawn caret, and the Wimp does not support shadow carets. However, shadow carets can be useful, especially if the application draws its own caret anyway (as, for example, if an I-beam is an unsuitable), because they fix an insertion point for a drop, whenever one or both of the sending and receiving tasks uses pre-drag-and-drop data transfer protocol. The shadow caret is also the position to which the caret will be returned if the user Adjust-clicks on the window, or clicks in a "dead" region of the window, such as a page border; this is particularly useful in cases where repositioning the caret would be time-consuming or fiddly, for example if the caret is in a deep "layer" of a document.</FONT>
</TBODY>
</TABLE>

<P>
<B><FONT SIZE="+3">14. References</FONT></B>
<P>
<FONT SIZE="+1">[1]: Support Group Application Note 240: <I>The RISC OS Selection Model and Clipboard</I></FONT>
<P>
<FONT SIZE="+1">[2]: Support Group Application Note 241: <I>The RISC OS Drag-and-Drop System</I></FONT>
<P>
<FONT SIZE="+1">[3]: RISC OS 3 PRM <STRONG>3</STRONG> &sect;53: <I>The Window Manager</I>, pp 3-249 - 3-256</FONT>
<P>
<FONT SIZE="+1">[4]: RISC OS Style Guide, issue 3, &sect;11: <I>Handling selection</I>, pp 77-82</FONT>
<P>
<FONT SIZE="+1">[5]: Document Ref 1309,413/FS: <I>Ursula Window Manager Changes Functional Specification</I></FONT>

<P>
<B><FONT SIZE="+3">15. History</FONT></B>
<DIV ALIGN="LEFT">
<TABLE BORDER=1 CELLPADDING=4>
<TR><TD ALIGN=CENTER WIDTH=62><B><FONT SIZE="+1">Revision</FONT></B>
<TD ALIGN=CENTER WIDTH=43><B><FONT SIZE="+1">Who</FONT></B>
<TD ALIGN=CENTER WIDTH=79><B><FONT SIZE="+1">Date</FONT></B>
<TD WIDTH=241><B><FONT SIZE="+1">Comment</FONT></B>
<TR><TD ALIGN=CENTER><FONT SIZE="+1">A (aka 0.00)</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">BJGA</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">12-09-1997</FONT>
<TD><FONT SIZE="+1">Started</FONT>
<TR><TD ALIGN=CENTER><FONT SIZE="+1">B (aka 0.01)</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">BJGA</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">13-10-1997</FONT>
<TD><FONT SIZE="+1">First release for comment</FONT>
<TR><TD ALIGN=CENTER><FONT SIZE="+1">C (aka 0.02)</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">BJGA</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">14-10-1997</FONT>
<TD><FONT SIZE="+1">Released for review</FONT>
<TR><TD ALIGN=CENTER><FONT SIZE="+1">D</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">BJGA</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">19-05-1998</FONT>
<TD><FONT SIZE="+1">Prepared for D.O.</FONT>
<TR><TD ALIGN=CENTER><FONT SIZE="+1">E</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">BJGA</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">26-02-1999</FONT>
<TD><FONT SIZE="+1">Started reworking document for Java 1.2 project, didn't get far before cancelled again</FONT>
<TR><TD ALIGN=CENTER><FONT SIZE="+1">F</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">BJGA</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">16-10-2007</FONT>
<TD><FONT SIZE="+1">Finally finished integrating the Ursula review comments and 8 years' worth of mental notes, for initial release alongside shared source code</FONT>
<TR><TD ALIGN=CENTER><FONT SIZE="+1">G</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">RPS</FONT>
<TD ALIGN=CENTER><FONT SIZE="+1">22-02-2015</FONT>
<TD><FONT SIZE="+1">Updated the page references in the Style Guide</FONT>
</TABLE>
</DIV>

</BODY>
</HTML>
