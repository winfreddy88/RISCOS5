REM >SupportDP
REM for dot matrix printers

/* Changes list:
 *
 * AMcC: 20-Sep-94
 * - Now pre-processed using CPP (cc -E) instead of basic prog 'Constants'.
 *   Allows us to use the same include file "Values" as used by front-end
 *   prog (!Printers.!RunImage).
 * - Uses C-style comments where cc -E  complains about // ones.
 * - All constants changed from the form CONST_name% to CONST_name.
 *
 */

#include "Values.h"
#include "Trace.h"

DEF FNdp_support(buff%)
  LOCAL reason%,psup%,prnt%,prdt%,cnfg%,xbuff%,psize_head%,code_entry%
  reason%=buff%!0
  psup%=buff%!4
  prnt%=buff%!8
  xbuff%=buff%!12
  psize_head%=buff%!16
  code_entry%=buff%!20
  IF prnt% THEN
    prdt%=FNprinter_find_prdata_entry(psup%,$prnt%!CONST_prnt_type)
    cnfg%=prnt%!CONST_prnt_cnfg
  ENDIF
  CASE reason% OF
    WHEN -1: PROCdp_m1
    WHEN -2: PROCdp_m2
    WHEN -3: PROCdp_m3
    WHEN -4: PROCdp_m4
    WHEN -5: PROCdp_m5
    WHEN -6: PROCdp_m6
    WHEN -7: PROCdp_m7
    WHEN -8: PROCdp_m8
    WHEN 3: PROCdp_p3
    WHEN 6: PROCdp_p6
    WHEN 8: PROCdp_p8
    WHEN 9: PROCdp_p9
    WHEN 17,18: PROCdp_p17
  ENDCASE
=FALSE

DEF PROCdp_m1
  LOCAL colours%, pdriverdp%, exists%
  // psup%!CONST_psup_flags OR= 0
  psup%!CONST_psup_type=&FF4
  psup%!CONST_psup_text=%0100
  psup%!CONST_psup_cnfg=CONST_cnfg_dp_MAX/4
  psup%!CONST_psup_vsn=2
  // note that the version number really only reflects
  // the status of the files being read, ie only change
  // this number if the file contents change.
  psup%!CONST_psup_dvsn=100
  psup%!CONST_psup_rma_block=0
  colours%=FNrmload_latest_module("ColourTrans","System:Modules.Colours")
  IFFNrmload_latest_module("PDriver","Printers:Modules.PDriver")
  IFFNrmload_latest_module("PDumperSupport","Printers:Modules.PDumperSpt")
  pdriverdp%=FNrmload_latest_module("PDriverDP","Printers:Modules.PDriverDP")
  // ***** WARNING!
  // ***** THESE VERSION NUMBERS ARE HARD CODED!
  IFpdriverdp%>400 AND colours%<150 THEN
    SYS"Wimp_ReportError",FNmsg_0(FNdp_host_desc,"WA12"), 1 OR 1<<4,FNmsg_1(FNdp_host_desc,"ER2",FNmsg_0(FNdp_host_desc,"ID"))
  ENDIF
/* do not allow this now
  SYS "XOS_ReadVarVal","Printers$DPLJfullQ",,-1,,3 TO,,exists%
  IF exists% THEN DPQ$="F" ELSE DPQ$="S"
*/
DPQ$="S"
ENDPROC

DEF PROCdp_m2
/*  We don't want to free up the RMA when we quit, thank you very much
 *   IF psup%!CONST_psup_rma_block THEN
 *     PROCftracef("*** FREEING R M A ***")
 *     SYS "ResourceFS_DeregisterFiles",psup%!CONST_psup_rma_block
 *     SYS "OS_Module",7,,psup%!CONST_psup_rma_block  // OSModule_Free
 *     psup%!CONST_psup_rma_block=0
 *   ENDIF
 */
ENDPROC

DEF PROCdp_m3
  // initialise the configuration window
  LOCAL config%,dp_i%,dp_j%
  config%=FNprinter_find_window(prnt%,"configure")
  PROCicon_write(config%,30,FNprinter_read_string(prnt%!CONST_prnt_name))
  PROCicon_write(config%,6,$prnt%!CONST_prnt_type)
  PROCicon_write(config%,3,FNdp_res(cnfg%))
  PROCicon_write(config%,15,FNdp_qual(cnfg%))
  dp_i%=!cnfg%!CONST_cnfg_dp_flags
  dp_j%=dp_i%>>CONST_dp_flags_feed_offset AND CONST_dp_flags_feed_width
  PROCicon_write(config%,17,FNmsg_0(psup%!CONST_psup_msg,"PF"+STR$ dp_j%))
  IF FNhas_external_config_app(prnt%) THEN
    PROCicon_unshade(config%,35)
  ELSE
    PROCicon_shade(config%,35)
  ENDIF
  IF prnt%!CONST_prnt_flags AND 1<<6 THEN
    PROCicon_shade(config%,8)
    PROCicon_shade(config%,11)
    PROCicon_shade(config%,12)
    PROCicon_shade(config%,14)
    PROCicon_shade(config%,19)
    PROCicon_shade(config%,23)
    PROCicon_shade(config%,24)
  ELSE
    dp_j%=dp_i% AND %000010
    IF dp_j% PROCicon_select(config%,8)ELSE PROCicon_deselect(config%,8)
    dp_j%=dp_i% AND %000100
    IF dp_j% PROCicon_select(config%,11)ELSE PROCicon_deselect(config%,11)
    dp_j%=dp_i% AND %001000
    IF dp_j% PROCicon_select(config%,12)ELSE PROCicon_deselect(config%,12)
    dp_j%=(dp_i% AND %110000)>>4
    PROCicon_write(config%,14,FNmsg_0(psup%!CONST_psup_msg,"TQ"+STR$ dp_j%))
    dp_j%=(dp_i% AND &F00)>>8
    PROCicon_write(config%,23,FNmsg_0(psup%!CONST_psup_msg,"CC"+STR$ dp_j%))
  ENDIF
  dp_i%=prnt%!CONST_prnt_psze
  PROCicon_write(config%,27,$dp_i%!CONST_psze_name)
ENDPROC

DEF PROCdp_m4
  // create a CNFG block with suitable defaults
  LOCAL dp_s$,dp_nm$,dp_nm2$,dp_i%,dp_s%,dp_t%,dp_co%,dp_ht%,B%,C%,dp_inf%,dp_x%,dp_y%

  // OSS set the text options to be no highlights, Print linefeeds.
  // PJC: default changed to be draft with linefeeds.
  cnfg%!CONST_cnfg_dp_flags=FNstore_integer(%011000)
  dp_i%=FNprinter_read_list_integer_entry(prdt%,5,2,1)
  IF dp_i%=0 THEN
    // no draft - fall back to no highlights
    !cnfg%!CONST_cnfg_dp_flags=%001000
    dp_i%=FNprinter_read_list_integer_entry(prdt%,5,1,1)
  ENDIF
  IF dp_i% THEN
    B%=CONST_ident_POTR
    C%=4
    cnfg%!CONST_cnfg_dp_text=USR(code_entry%+CONST_entry_heap_claim)
    IFcnfg%!CONST_cnfg_dp_text=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
    !cnfg%!CONST_cnfg_dp_text=dp_i%
  ELSE
    prnt%!CONST_prnt_flags=prnt%!CONST_prnt_flags OR 1<<6
  ENDIF

  // try to read the default x and y resolutions and name from the PRDT block
  dp_x%=FNprinter_read_integer_entry(prdt%,8)
  dp_y%=FNprinter_read_integer_entry(prdt%,9)
  dp_nm$=FNprinter_read_string_entry(prdt%,12)
  IF dp_nm$<>"" THEN
    // try to find the graphics mode which matches this name
    C%=1
    REPEAT
      B%=FNprinter_read_list_integer_entry(prdt%,4,C%,1)
      // first of all, see if we've run out of modes
      IF B%=0 THEN
        C%=-1
      ELSE
        dp_nm2$=FNprinter_read_string_entry(B%,8)
        // if no match, try the next mode
        IFdp_nm$<>dp_nm2$ C%+=1
      ENDIF
    UNTIL C%=-1 OR dp_nm$=dp_nm2$
    // if we found it, remember where it was
    IF C%<>-1 dp_i%=C%
  ELSE
    IF (dp_x%<>0 AND dp_y%<>0) THEN
      // try to find the graphics mode which matches this resolution
      C%=1
      REPEAT
        B%=FNprinter_read_list_integer_entry(prdt%,4,C%,1)
        // first of all, see if we've run out of modes
        IF B%=0 THEN
          C%=-1
        ELSE
          dp_s%=FNprinter_read_integer_entry(B%,4)
          dp_t%=FNprinter_read_integer_entry(B%,5)
          // if no match, try the next mode
          IFdp_s%<>dp_x% OR dp_t%<>dp_y% C%+=1
        ENDIF
      UNTIL C%=-1 OR (dp_s%=dp_x% AND dp_t%=dp_y%)
      // if we found it, remember where it was
      IF C%<>-1 dp_i%=C%
    ELSE
      // show we didn't match - which we couldn't 'cos we didn't have the values
      C%=-1
    ENDIF
  ENDIF

  // if didn't match on supplied resolutions, or no resolutions given
  // do a best fit

  IF C%=-1 THEN
    // OSS set the graphics options to be the highest non-interlaced resolution
    B%=CONST_ident_PDBF
    C%=256
    dp_inf%=USR(code_entry%+CONST_entry_heap_claim)
    IFdp_inf%=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
    C%=1
    dp_i%=FALSE
    REPEAT
      B%=FNprinter_read_list_integer_entry(prdt%,4,C%,1)
      IF B%=0 THEN
        // run out of parameters, go back to the last one
        C%-=1
        dp_i%=TRUE
      ELSE
        $dp_inf%=FNprinter_read_string_entry(B%,6)
        IF dp_inf%?CONST_dp_y_interlace=0 AND dp_inf%?CONST_dp_x_interlace=0 THEN
          C%+=1
        ELSE
          C%-=1
          dp_i%=TRUE
        ENDIF
      ENDIF
    UNTIL dp_i%
    dp_i%=C%
    B%=CONST_ident_PDBF
    C%=dp_inf%
    CALL code_entry%+CONST_entry_heap_free
  ENDIF

  B%=CONST_ident_POTR
  C%=4
  cnfg%!CONST_cnfg_dp_graphics=USR(code_entry%+CONST_entry_heap_claim)
  IFcnfg%!CONST_cnfg_dp_graphics=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
  !cnfg%!CONST_cnfg_dp_graphics=FNprinter_read_list_integer_entry(prdt%,4,dp_i%,1)

  // ensure that the module is present in memory
  dp_s$=FNprinter_read_string_entry(FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,1),2)
  IFFNrmload_latest_module(dp_s$,"Printers:PDumpers."+dp_s$)

  // ensure that the palette file needed at the resolution is cached
  // bit 23 of palette no. flags whether already ensured or not
  dp_s$=STR$(FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,2) AND &7FFFFF)
  PROCdp_ensure_resource_file("Resources.Printers.Palettes."+dp_s$,"Printers:Palettes."+dp_s$,!cnfg%!CONST_cnfg_dp_graphics)

  // initialise the quality
  // see if a quality was provided in the PDF
  dp_i%=FNprinter_read_integer_entry(prdt%,10)
  // get the qualities available at the configured resolution
  dp_s%=FNdp_get_quality_options(!cnfg%!CONST_cnfg_dp_graphics)
  IF dp_i%<>0 THEN

    // validate values! reset dp_i% to zero if the requested
    // colour and halftone type aren't available at the specified
    // resolution
    //
    // Note that the 'new' strip types (3,4 and 5) cannot be set from
    // the printer definition file, therefore aren't checked for here

    dp_co%=dp_i% AND &FF
    dp_ht%=(dp_i% AND &FF00)>>8
    CASE dp_co% OF
      WHEN 0  // mono
        IF (dp_s% AND 7) THEN
          IF dp_ht%=4 AND (dp_s% AND 1)=0 dp_i%=0
          IF dp_ht%=8 AND (dp_s% AND 2)=0 dp_i%=0
          IF dp_ht%=1 AND (dp_s% AND 4)=0 dp_i%=0
        ELSE
          dp_i%=0
        ENDIF
      WHEN 1  // greyscale
        IF (dp_s% AND &70) THEN
          IF dp_ht%=4 AND ((dp_s%>>4) AND 1)=0 dp_i%=0
          IF dp_ht%=8 AND ((dp_s%>>4) AND 2)=0 dp_i%=0
          IF dp_ht%=1 AND ((dp_s%>>4) AND 4)=0 dp_i%=0
        ELSE
          dp_i%=0
        ENDIF
      WHEN 2  // colour
        IF (dp_s% AND &700) THEN
          IF dp_ht%=4 AND ((dp_s%>>8) AND 1)=0 dp_i%=0
          IF dp_ht%=8 AND ((dp_s%>>8) AND 2)=0 dp_i%=0
          IF dp_ht%=1 AND ((dp_s%>>8) AND 4)=0 dp_i%=0
        ELSE
          dp_i%=0
        ENDIF
    ENDCASE
  ENDIF
  IF dp_i%<>0 THEN
    cnfg%!CONST_cnfg_dp_options=FNstore_integer(dp_i%)
  ELSE
    PROCdp_decode_options(dp_s%,dp_co%,dp_ht%)
    cnfg%!CONST_cnfg_dp_options=FNstore_integer(dp_ht%<<8 OR dp_co%)
  ENDIF

  $buff%=FNprinter_read_string_entry(prdt%,2)
  B%=buff%
  C%=2
  prnt%!CONST_prnt_name=USR(code_entry%+CONST_entry_store_string)
  dp_s$=FNprinter_read_string_entry(prdt%,3)
  // if the sprite name isn't the same as the class name, store the new sprite name
  IF dp_s$<>"dp" $buff%=dp_s$:B%=buff%:C%=2:prnt%!CONST_prnt_sprt=USR(code_entry%+CONST_entry_store_string)

  // initialise the best paper size we can find ...
  // start by trying to read the 'default_paper_size' entry
  // from the PRDT block (entry 7)
  dp_s$=FNprinter_read_string_entry(prdt%,7)
  // fall back to going for the default
  IF dp_s$="" dp_s$=FNmsg_0(psup%!CONST_psup_msg,"PAP")

  dp_i%=psize_head%
  WHILE dp_s$<>FNprinter_read_string(dp_i%!CONST_psze_name)
    dp_i%=dp_i%!CONST_psze_next
    // if we run out of paper entries, go for the first one
    IF dp_i%=0 dp_i%=psize_head%: dp_s$=FNprinter_read_string(dp_i%!CONST_psze_name)
  ENDWHILE
  prnt%!CONST_prnt_psze=dp_i%

  // if this printer supports fast parallel, set the appropriate flag
  dp_i%=FNprinter_read_integer_entry(prdt%,11)
  IFdp_i%<>0 prnt%!CONST_prnt_flags = prnt%!CONST_prnt_flags OR (1<<7)
ENDPROC

DEF PROCdp_ensure_resource_file(resource$,disc$,gprdt%)
  LOCAL obj_type%,load_addr%,exec_addr%,file_size%,obj_attr%,rma_size%,rma_block%
  LOCAL found_type%,found_load%,found_exec%,found_size%,c%,a%,w%,pnum%,reload_if_outofdate%
  VDU: PROCftracef("dp_ensure_resource_file")
  // We use this to load palette files for the printers in order to reduce
  // the probability of having to ask for the printers disc again later.

  // check for out of date palette if we have not ensured this one before (bit 23 of palette number)
  pnum% = FNprinter_read_integer_entry(gprdt%,2)
  reload_if_outofdate% = ((pnum% AND &800000) = 0)
  PROCprinter_write_integer_entry(gprdt%,2,pnum% OR &800000) // we (will) have ensured it

  // First of all, check if the file exists already
  SYS "OS_File",17,"Resources:"+resource$ TO found_type%,,found_load%,found_exec%,found_size%  // OS_FileReadNoPath

  IF found_type% AND reload_if_outofdate%=FALSE ENDPROC

  SYS "OS_File",17,disc$ TO obj_type%,,load_addr%,exec_addr%,file_size%,obj_attr%  // OS_FileReadNoPath
  IF obj_type%<>1 SYS "OS_File",19,disc$,obj_type%  // OS_FileMakeError

  IF found_type% THEN
    IFfound_load%=load_addr% AND found_exec%=exec_addr% AND found_size%=file_size% ENDPROC
    // cached palette is not the same as the one on disc
    // try to remove the cached palette
    c%=OPENIN("Resources:"+resource$)
    IFc%=0 ERROR CONST_error_ok, FNmsg_1(FNdp_host_desc,"OKBB",resource$)
    SYS"OS_FSControl",21,c% TO ,a%,w%
    CLOSE#c%
    IF(w%AND&FF)<>46 ERROR CONST_error_ok, FNmsg_1(FNdp_host_desc,"OKBC",resource$)
    a%-=(LENresource$+4ANDNOT3)+4
    a%-=20
    IFa%!-4 = &48434143 THEN
      SYS"ResourceFS_DeregisterFiles",a%
      SYS"OS_Module",7,,a%-4
    ENDIF
  ENDIF

  rma_size%=20+(LEN resource$+4 AND NOT 3)+4+(file_size%+3 AND NOT 3)  // Size needed for this file only
  VDU: PROCftracef("File "+disc$+", size "+STR$ file_size%)

  // claim some RMA for the file
  SYS "OS_Module",6,,,rma_size%+8 TO,,rma_block%  // OSModule_Alloc
  // Put a check tag at the beginning of the block
  !rma_block%=&48434143 // CACH
  rma_block%+=4
  // Fill in the block
  rma_block%!0=rma_size%
  rma_block%!4=load_addr%
  rma_block%!8=exec_addr%
  rma_block%!12=file_size%
  rma_block%!16=obj_attr%
  $(rma_block%+20)=resource$
  rma_block%!(20+LEN resource$)=0 /*   // pad with 0's */
  rma_block%!(20+(LEN resource$+4 AND NOT 3))=file_size%+4
  SYS "OS_File",16,disc$,rma_block%+20+(LEN resource$+4 AND NOT 3)+4  // OS_FileLoadNoPath
  rma_block%!rma_size%=0  // Terminator
  SYS "ResourceFS_RegisterFiles",rma_block%
ENDPROC

DEF PROCdp_m5
  // cache any palette files that are used by dp printers and ensure
  // that the relevant PDumper modules are loaded
  LOCAL dp_prnt%,dp_cnfg%,dp_graphics_prdt%,dp_pal$
  dp_prnt%=prnt%
  WHILE dp_prnt%>0
    IF dp_prnt%!CONST_prnt_psup=psup% THEN
      // got a printer in our class - cache the palette file
      dp_cnfg%=dp_prnt%!CONST_prnt_cnfg
      dp_graphics_prdt%=!dp_cnfg%!CONST_cnfg_dp_graphics
      // bit 23 of palette no. flags whether already ensured or not
      dp_pal$=STR$(FNprinter_read_integer_entry(dp_graphics_prdt%,2) AND &7FFFFF)
      PROCdp_ensure_resource_file("Resources.Printers.Palettes."+dp_pal$,"Printers:Palettes."+dp_pal$,dp_graphics_prdt%)

      // and ensure the pdumper module
      dp_pal$=FNprinter_read_string_entry(FNprinter_read_integer_entry(dp_graphics_prdt%,1),2)
      IFFNrmload_latest_module(dp_pal$, "Printers:PDumpers."+dp_pal$)
    ENDIF
    dp_prnt%=dp_prnt%!CONST_prnt_next
  ENDWHILE
ENDPROC

DEF PROCdp_m6
  // do whatever is necessary to prime the specified printer
  LOCAL dp_s$,dp_t$,dp_i%,xres%,yres%,halftone%,ptr%,flags%,pal%,dmp$,inf%,strip%,graphics_prdt%,text_prdt%,B%,C%
  LOCAL flags%,newblock%,i%,a$,s%
  // 7 is the magic number for the dumper driver
  SYS "XPDriver_SelectDriver",7
  dp_s$=FNprinter_read_string(prnt%!CONST_prnt_name)
  IF dp_s$="" THEN
    dp_s$=$prnt%!CONST_prnt_type
    IF LEN dp_s$>20 THEN
      dp_i%=LEN dp_s$
      WHILE MID$(dp_s$,dp_i%,1)<>" " AND dp_i%>0
        dp_i%-=1
      ENDWHILE
      IF dp_i% dp_s$=LEFT$(dp_s$,dp_i%-1)ELSE dp_s$=LEFT$(dp_s$,20)
    ENDIF
  ENDIF
  graphics_prdt%=!cnfg%!CONST_cnfg_dp_graphics
  xres%=FNprinter_read_integer_entry(graphics_prdt%,4)
  yres%=FNprinter_read_integer_entry(graphics_prdt%,5)
  halftone%=(!cnfg%!CONST_cnfg_dp_options AND &FF00)>>8
  strip%=!cnfg%!CONST_cnfg_dp_options AND &FF
  // WARNING!
  // The comparison is made against strip type 2 (colour) or greater
  // This assumes, therefore, that any strip types that are 2 or greater
  // are colour which is currently true
  IF (strip% >= 2) THEN
   SYS"XPDriver_SetInfo",,xres%,yres%,1,dp_s$,xres%/halftone%,yres%/halftone% TO ptr%;dp_i%
  ELSE
   SYS"XPDriver_SetInfo",,xres%,yres%,0,dp_s$,xres%/halftone%,yres%/halftone% TO ptr%;dp_i%
  ENDIF
  IF (dp_i% AND 1) AND (ptr%<>0) THEN
    dp_s$="": ptr%+=4
    WHILE ?ptr%: dp_s$+=CHR$ ?ptr%: ptr%+=1: ENDWHILE
    ERROR CONST_error_ok,dp_s$
    ENDPROC
  ENDIF

  // bit 23 of palette no. flags whether already ensured or not
  dp_s$=STR$(FNprinter_read_integer_entry(graphics_prdt%,2) AND &7FFFFF)

  B%=CONST_ident_PDBF
  C%=256

  pal%=USR(code_entry%+CONST_entry_heap_claim)
  IF pal% ELSE ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
  $pal%="Resources:$.Resources.Printers.Palettes."+dp_s$

  inf%=USR(code_entry%+CONST_entry_heap_claim)
  IF inf% ELSE ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
  $inf%=FNprinter_read_string_entry(graphics_prdt%,6)
  strip%=!cnfg%!CONST_cnfg_dp_options AND &FF

  // if we have strip type 5 and the dumper doesn't support it,
  // deprecate it down to strip type 3

  IF strip%=5 THEN
   dp_i%=FNprinter_read_integer_entry(graphics_prdt%,1)
   dp_i%=FNprinter_read_integer_entry(dp_i%,1)
   // we've selected the dumper driver, so this should work :-)
   SYS"XPDriver_MiscOp",&80000002,dp_i% TO ptr%;dp_i%
   IF(dp_i%AND1)=0 IFptr%<>&80000002 IF(ptr% AND (1<<5))=0 strip%=3
  ENDIF
  // this may be necessary, if multiple palettes for one printer
  PROCdp_ensure_resource_file("Resources.Printers.Palettes."+dp_s$,"Printers:Palettes."+dp_s$,graphics_prdt%)

  // Module name:
  dp_s$=FNprinter_read_string_entry(FNprinter_read_integer_entry(graphics_prdt%,1),2)
  dmp$="RMLoad Printers:PDumpers."+dp_s$+CHR$ 13

  // set passes per line entry
  // WARNING!
  // The comparison is made against strip type 2 (colour) or greater
  // This assumes, therefore, that any strip types that are 2 or greater
  // are colour which is currently true
  IF strip%>=2 inf%?CONST_dp_pass_per_line=4 ELSE inf%?CONST_dp_pass_per_line=1

  // set strip type field
  inf%?CONST_dp_strip_type=strip%

  // set output bpp field
  IF strip%=0 inf%?CONST_dp_output_bpp=1 ELSE inf%?CONST_dp_output_bpp=8

  // set num passes field
  IF strip%=3 inf%?CONST_dp_no_passes=3 ELSE inf%?CONST_dp_no_passes=1

  // OSS Set the NoPageAdvance bit in the flags if paper feed is "Roll"
  flags%=FNprinter_read_integer_entry(graphics_prdt%,7)
  IF(!cnfg%!CONST_cnfg_dp_flags>>CONST_dp_flags_feed_offset AND CONST_dp_flags_feed_width)=CONST_dp_flags_feed_roll flags%+=2

  // OSS Fixup old version numbers by moving it to the new location.
  IF(flags%>>>24)=0 flags%=flags% OR inf%?CONST_dp_data_old_version<<24

  // OSS Set lines per page if version>0. We only need to check the new
  // version field as the fixup has already been done.
  IF(flags%>>>24)>0 THEN
    dp_i%=prnt%!CONST_prnt_psze
    inf%?CONST_dp_data_num_lines=dp_i%!CONST_psze_theight
  ENDIF

  flags%=FNprinter_read_integer_entry(graphics_prdt%,7)
  IF ((flags% >>> 24) < 5) = 0 THEN
    ptr% = CONST_dp_data_text_start // Free space for each string
    ptr% = FNdp_dataN_block(inf%, ptr%, 0,  CONST_dp_data_set_lines)      // data1
    ptr% = FNdp_dataN_block(inf%, ptr%, 1,  CONST_dp_data_page_start)
    ptr% = FNdp_dataN_block(inf%, ptr%, 2,  CONST_dp_data_form_feed)
    ptr% = FNdp_dataN_block(inf%, ptr%, 3,  CONST_dp_data_page_end)
    ptr% = FNdp_dataN_block(inf%, ptr%, 4,  CONST_dp_data_line_return)
    ptr% = FNdp_dataN_block(inf%, ptr%, 5,  CONST_dp_data_line_skip)
    ptr% = FNdp_dataN_block(inf%, ptr%, 6,  CONST_dp_data_line_end)
    ptr% = FNdp_dataN_block(inf%, ptr%, 7,  CONST_dp_data_line_end_i2)
    ptr% = FNdp_dataN_block(inf%, ptr%, 8,  CONST_dp_data_line_end_i3)
    ptr% = FNdp_dataN_block(inf%, ptr%, 9,  CONST_dp_data_zero_skip)
    ptr% = FNdp_dataN_block(inf%, ptr%, 10, CONST_dp_data_line_start)
    ptr% = FNdp_dataN_block(inf%, ptr%, 11, CONST_dp_data_line_start_2)
    ptr% = FNdp_dataN_block(inf%, ptr%, 12, CONST_dp_data_pass1_start)
    ptr% = FNdp_dataN_block(inf%, ptr%, 13, CONST_dp_data_pass1_start_2)
    ptr% = FNdp_dataN_block(inf%, ptr%, 14, CONST_dp_data_pass2_start)
    ptr% = FNdp_dataN_block(inf%, ptr%, 15, CONST_dp_data_pass2_start_2)
    ptr% = FNdp_dataN_block(inf%, ptr%, 16, CONST_dp_data_pass3_start)
    ptr% = FNdp_dataN_block(inf%, ptr%, 17, CONST_dp_data_pass3_start_2)
    ptr% = FNdp_dataN_block(inf%, ptr%, 18, CONST_dp_data_pass4_start)
    ptr% = FNdp_dataN_block(inf%, ptr%, 19, CONST_dp_data_pass4_start_2)  // data20
  ENDIF
  SYS "XPDriver_SetDriver",, FNprinter_read_integer_entry(FNprinter_read_integer_entry(graphics_prdt%, 1), 1), dmp$, pal%, inf%, flags%
  B%=CONST_ident_PDBF
  C%=pal%
  CALL code_entry%+CONST_entry_heap_free
  C%=inf%
  CALL code_entry%+CONST_entry_heap_free
  SYS "OS_CLI","Unset PDriver$TextChars1"

  // point to the chars PRDT block
  dp_i%=FNprinter_read_integer_entry(prdt%,6)
  IF dp_i% THEN
    dp_i%=dp_i%!CONST_prdt_1st
    WHILE dp_i%
      IF dp_i%?CONST_char_char=ASC"£" THEN
        dp_s$=FNdp_hex2(ASC "£")+FNdp_hex2(dp_i%?CONST_char_len)
        ptr%=dp_i%+CONST_char_trans: dp_i%=dp_i%?CONST_char_len
        WHILE dp_i%
          dp_s$+=FNdp_hex2(?ptr%)
          ptr%+=1
          dp_i%-=1
        ENDWHILE
        SYS"OS_CLI","Set PDriver$TextChars1 "+dp_s$
      ELSE
        dp_i%=dp_i%!CONST_char_next
      ENDIF
    ENDWHILE
  ENDIF

  IF cnfg%!CONST_cnfg_dp_text=0 THEN
    SYS"OS_CLI","Unset PDriver$TextPage"
  ELSE
    text_prdt%=!cnfg%!CONST_cnfg_dp_text
    dp_i%=prnt%!CONST_prnt_psze
    dp_s$="-Ph "+STR$ dp_i%!CONST_psze_theight+" -Mt "+STR$ dp_i%!CONST_psze_ttop+" -Mb "
    dp_s$+=STR$ dp_i%!CONST_psze_tbottom+" -Ml "+STR$ dp_i%!CONST_psze_tleft+" -Th "
    IF cnfg%!CONST_cnfg_dp_flags AND 2 dp_s$+="2" ELSE dp_s$+="0"
    dp_s$+=" -Nl "
    IF cnfg%!CONST_cnfg_dp_flags AND 8 THEN
      dp_s$+=FNungstrans(FNungstrans(FNprinter_read_string_entry(text_prdt%,6)))
    ELSE
      dp_s$+=FNungstrans(FNungstrans(FNprinter_read_string_entry(text_prdt%,5)))
    ENDIF
    dp_t$=FNprinter_read_string_entry(text_prdt%,7)
    IF dp_t$<>"" dp_s$+=" -Rs "+FNungstrans(FNungstrans(dp_t$))
    dp_t$=FNprinter_read_string_entry(text_prdt%,11)
    IF dp_t$<>"" dp_s$+=" -Cd "+FNungstrans(FNungstrans(dp_t$))
    SYS"OS_CLI","Set PDriver$TextPage "+dp_s$
  ENDIF
ENDPROC

// Fill in the inf% block based on the "dataN:" lines in the PDF
DEF FNdp_dataN_block(inf%, ptr%, B%, C%)
  LOCAL type%, str%, len%

Ftracef("graphics_prdt%=&"+STR$~graphics_prdt%+", inf%=&"+STR$~inf%+", ptr%=&"+STR$~ptr%+", B%="+STR$B%)

  // Get a pointer to the string and read its type
  str% = FNprinter_read_string_pointer(graphics_prdt%, 10 + B%)
Ftracef("str%=&"+STR$~str%)
  IF str% = 0 THEN
    inf%?C% = 0
    =ptr%
  ENDIF

#ifdef Trace
  CASE str%!-4 OF
    WHEN CONST_ident_STRG
      Ftracef("dataN: type=STRG (CR-terminated)")
    WHEN CONST_ident_STR0
      Ftracef("dataN: type=STR0 (zero-terminated)")
    WHEN CONST_ident_GSTR
      Ftracef("dataN: type=GSTR (byte counted)")
    WHEN CONST_ident_LSTR
      Ftracef("dataN: type=LSTR (word counted)")
    OTHERWISE
      Ftracef("dataN: type=UNKNOWN")
  ENDCASE
#endif

  // If this entry is not of long string type, return an error
  IF str%!-4 <> CONST_ident_LSTR THEN
    // This was probably the result
    ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc, "FAM")
  ENDIF

  // Read string length and point to start of string
  len%  = !str%
  str% += 4
  Ftracef("len%="+STR$len%)

  // If the string is of zero length, record that and exit
  IF len% = 0 THEN
    inf%?C% = 0
    =ptr%
  ENDIF

#ifdef Trace
  // Make sure that we're writing to word-aligned addresses
  IF (inf% + ptr%) AND %11 THEN
    ERROR CONST_error_fatal, FNmsg_0(FNlj_host_desc, "FAN")
  ENDIF
#endif

  // Copy the string and return pointer for next entry (long string format)
  inf%?C%        = ptr% - CONST_dp_data_dlm
  inf%!ptr%      = len% << 8
  !(inf%+ptr%+4) = str%
=ptr% + 8

DEF PROCdp_m7
  LOCAL queu%,dp_p%,B%,C%
  queu%=!xbuff%
  dp_p%=queu%!CONST_queu_tprv
  IF dp_p% THEN
    PROCfree_structure(dp_p%!CONST_tprv_dp_page_prologue)
    B%=CONST_ident_TPRV
    C%=dp_p%
    CALL code_entry%+CONST_entry_heap_free
    queu%!CONST_queu_tprv=0
  ENDIF
ENDPROC

DEF PROCdp_p3
  SYS"Wimp_CloseWindow",,xbuff%
ENDPROC

DEF PROCdp_p6
  LOCAL wind%,dummy%
  // mouseclick on the configure window
  CASE xbuff%!8 OF
    WHEN 2  // menu
      CASE xbuff%!16 OF
        WHEN 20: PROCdp_menu("ME1",TRUE,TRUE)
        WHEN 18: PROCdp_menu("ME2",TRUE,TRUE)
        WHEN  4: PROCdp_menu("ME3",TRUE,TRUE)
        WHEN 19: PROCdp_menu("ME4",TRUE,TRUE)
        WHEN 24: PROCdp_menu("ME5",TRUE,TRUE)
        WHEN 26: PROCdp_menu("MP1",TRUE,TRUE)
      ENDCASE
    WHEN 4  // select
      CASE xbuff%!16 OF
        WHEN 25
          wind%=xbuff%!12
          PROCdp_save_configuration(wind%)
          !xbuff%=wind%:SYS"Wimp_CloseWindow",,xbuff%
        WHEN 20
          PROCdp_menu("ME1",TRUE,TRUE)
        WHEN 18
          PROCdp_menu("ME2",TRUE,TRUE)
        WHEN  4
          PROCdp_menu("ME3",TRUE,TRUE)
        WHEN 19
          PROCdp_menu("ME4",TRUE,TRUE)
        WHEN 24
          PROCdp_menu("ME5",TRUE,TRUE)
        WHEN 26
          PROCdp_menu("MP1",TRUE,TRUE)
        WHEN 31
          !xbuff%=xbuff%!12
          SYS"Wimp_CloseWindow",,xbuff%
        WHEN 35
          dummy%=FNexternal_config_app(prnt%)
      ENDCASE
    WHEN 1  // adjust
      CASE xbuff%!16 OF
        WHEN 25
          wind%=xbuff%!12
          PROCdp_save_configuration(wind%)
        WHEN 35
          dummy%=FNexternal_config_app(prnt%)
      ENDCASE
  ENDCASE
ENDPROC

DEF PROCdp_p8
  // a key press!
  LOCAL dp_i%
  dp_i%=psup%!CONST_psup_wind
  WHILE dp_i%
    IF dp_i%!CONST_wind_hand=!xbuff% THEN
      IF xbuff%!24=13 THEN
        CASE $(dp_i%+CONST_wind_name)OF
          WHEN "configure"
            SYS "Wimp_CloseWindow",,xbuff%
            PROCdp_save_configuration(!xbuff%)
        ENDCASE
      ELSE
        SYS "Wimp_ProcessKey",xbuff%!24
      ENDIF

      ENDPROC
    ENDIF

    dp_i%=dp_i%!CONST_wind_next
  ENDWHILE
ENDPROC

DEF PROCdp_p9
  LOCAL adjust%,wind%,icon%,ptr%,xres%,yres%,dp_s$,dp_i%,dp_j%,dp_k%

  // menu selections are easy ... we just write the
  // selected string into the appropriate icon.
  // some other actions may be taken to ensure that
  // other choices are OK, but we don't touch any
  // data yet.

  wind%=FNprinter_find_window(prnt%,"configure")
  adjust%=FNwas_adjust_used
  CASE dp_menu_chsn$ OF
    WHEN "ME1": icon%=3
    WHEN "ME2": icon%=17
    WHEN "ME3": icon%=15
    WHEN "ME4": icon%=14
    WHEN "ME5": icon%=23
    WHEN "MP1": icon%=27
  ENDCASE
  ptr%=dp_menu%+28+!xbuff%*24
  IF ptr%!8 AND &100 THEN
    PROCicon_write(wind%,icon%,$ptr%!12)
  ELSE
    PROCicon_write(wind%,icon%,$(ptr%+12))
  ENDIF
  IF dp_menu_chsn$="ME1" THEN
    // if the resolution changes, we may have to change the quality as well
    dp_j%=prdt%!20
    dp_s$=FNicon_read(wind%,3)
    WHILE dp_j%
      dp_k%=!dp_j%!CONST_lstd_1st
      IF (dp_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !dp_k%!20,STR$ !dp_k%!24)) OR \
         (dp_s$=FNsafe_string(dp_k%!36)) THEN

        // ok - found the pointer to the graphics data, now check the graphics quality
        // basically, we need to see if the request quality is available in this dump
        // if it isn't, we reset it to the best fit we can manage

        dp_s$=FNicon_read(wind%,15): dp_i%=INSTR(dp_s$,",")
        CASE LEFT$(dp_s$,dp_i%-1)OF
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"):  dp_j%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1s"): dp_j%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"):  dp_j%=2
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"):  dp_j%=4
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"):  dp_j%=5
          WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5s"): dp_j%=5
          OTHERWISE:                                 dp_j%=0
        ENDCASE
        dp_s$=MID$(dp_s$,dp_i%+2)
        CASE dp_s$ OF
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"):  dp_i%=8
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8s"): dp_i%=8
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"):  dp_i%=1
          WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1s"): dp_i%=1
          OTHERWISE:                                 dp_i%=4
        ENDCASE
        dp_k%=FNdp_get_quality_options(dp_k%)
        IF(dp_k% AND (7<<(dp_j%*4)))=0 dp_j%=-1
        IF dp_j%<>-1 THEN
          dp_j%=dp_k%>>(dp_j%*4)
          CASE dp_i% OF
            WHEN 4: IF(dp_j% AND 1)=0 dp_i%=-1
            WHEN 8: IF(dp_j% AND 2)=0 dp_i%=-1
            WHEN 1: IF(dp_j% AND 4)=0 dp_i%=-1
          ENDCASE
        ENDIF
        IF dp_j%=-1 OR dp_i%=-1 THEN
          PROCdp_decode_options(dp_k%,dp_j%,dp_i%)
          PROCicon_write(wind%,15,FNdp_qual_name(dp_j% + (dp_i% << 8)))
        ENDIF
        dp_j%=0
      ELSE
        dp_j%=!dp_j%
      ENDIF
    ENDWHILE
  ENDIF
  IF adjust% THEN
    SYS"Wimp_GetPointerInfo",,xbuff%
    PROCdp_menu(dp_menu_chsn$,FALSE,FALSE)
  ENDIF
ENDPROC

DEF PROCdp_p17
  LOCAL wind%,dp_s$,dp_t$
  CASE xbuff%!16 OF
    WHEN &502  // HelpRequest
      wind%=psup%!CONST_psup_wind
      WHILE wind%
        IF wind%!CONST_wind_hand=xbuff%!32 THEN
          CASE $(wind%+CONST_wind_name)OF
            WHEN "configure"
              dp_s$=STR$ xbuff%!36
              CASE xbuff%!36 OF
                WHEN 8,11,12: IF FNicon_set(xbuff%!32,xbuff%!36)dp_s$+="b" ELSE dp_s$+="a"
              ENDCASE
              dp_t$=FNmsg_0(psup%!CONST_psup_msg,"CON"+dp_s$)
              IFdp_t$="CON"+dp_s$ dp_t$=FNmsg_0(psup%!CONST_psup_msg,"CON")
              PROCinteractive_help(dp_t$)
          ENDCASE
          wind%=0
        ELSE
          wind%=wind%!CONST_wind_next
          IF wind%=0 PROCinteractive_help(FNmsg_0(psup%!CONST_psup_msg,"H"+dp_menu_chsn$))
        ENDIF
      ENDWHILE
    WHEN &8014B
      /*PrintInterrogate*/
      CASE xbuff%!20 OF
      WHEN 0
        IF prnt% AND xbuff%!24=prnt% THEN PROCdp_interrogate0
      ENDCASE
  ENDCASE
ENDPROC

DEF PROCdp_interrogate0
  LOCAL a$,sender%
  /* Ack the message */
  xbuff%!12=xbuff%!8
  sender%=xbuff%!4
  SYS "Wimp_SendMessage",19,xbuff%,sender%
  /* Construct and send the reply */
  xbuff%!28=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,2)
  xbuff%!32=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,3)
  xbuff%!36=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,4)
  xbuff%!40=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,5)
  xbuff%!44=FNprinter_read_integer_entry(!cnfg%!CONST_cnfg_dp_graphics,7)
  a$=FNprinter_read_string_entry(!cnfg%!CONST_cnfg_dp_graphics,8)+CHR$(0)
  $(xbuff%+48)=a$
  !xbuff%=(48+3+LENa$)ANDNOT3
  SYS "Wimp_SendMessage",17,xbuff%,sender%
ENDPROC

DEF PROCdp_save_configuration(window%)
  LOCAL dp_i%,dp_j%,dp_k%,dp_s$,B%,C%
  prdt%=FNprinter_find_prdata_entry(psup%,FNicon_read(window%,6))
  PROCfree_structure(prnt%!CONST_prnt_name)
  $buff%=FNicon_read(window%,30)
  B%=buff%
  C%=2
  prnt%!CONST_prnt_name=USR(code_entry%+CONST_entry_store_string)
  dp_i%=cnfg%
  FOR dp_j%=1 TO CONST_cnfg_dp_MAX/4
    PROCfree_structure(!dp_i%)
   !dp_i%=0: dp_i%+=4
  NEXT

  dp_j%=0
  IF FNicon_read(window%,17)=FNmsg_0(psup%!CONST_psup_msg,"PF1")dp_j%+=CONST_dp_flags_feed_manual<<CONST_dp_flags_feed_offset
  IF FNicon_read(window%,17)=FNmsg_0(psup%!CONST_psup_msg,"PF2")dp_j%+=CONST_dp_flags_feed_roll<<CONST_dp_flags_feed_offset
  IF FNicon_set(window%,8)dp_j%+=2
  IF FNicon_set(window%,11)dp_j%+=4
  IF FNicon_set(window%,12)dp_j%+=8
  CASE FNicon_read(window%,14)OF
    WHEN FNmsg_0(psup%!CONST_psup_msg,"TQ1"): dp_j%+=1<<4: dp_i%=2
    WHEN FNmsg_0(psup%!CONST_psup_msg,"TQ2"): dp_j%+=1<<5: dp_i%=3
    OTHERWISE: dp_i%=1
  ENDCASE
  CASE FNicon_read(window%,23)OF
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CC1"): dp_j%+=1<<8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CC2"): dp_j%+=1<<9
  ENDCASE
  cnfg%!CONST_cnfg_dp_flags=FNstore_integer(dp_j%)

  dp_j%=FNprinter_read_list_integer_entry(prdt%,5,dp_i%,1)
  IF dp_j% THEN
    B%=CONST_ident_POTR
    C%=4
    cnfg%!CONST_cnfg_dp_text=USR(code_entry%+CONST_entry_heap_claim)
    IFcnfg%!CONST_cnfg_dp_text=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
    !cnfg%!CONST_cnfg_dp_text=dp_j%
    prnt%!CONST_prnt_flags=prnt%!CONST_prnt_flags AND NOT(1<<6)
  ELSE
    prnt%!CONST_prnt_flags=prnt%!CONST_prnt_flags OR 1<<6
  ENDIF

  // point to the resolution possibilities
  dp_j%=prdt%!20  // printer name is 8, short name is 12, sprite name is 16, resolution is 20
  dp_s$=FNicon_read(window%,3)
  WHILE dp_j%
    dp_k%=!dp_j%!CONST_lstd_1st  // get the pointer
    // module is 8, palette is 12, options is 16, pxres is 20, pyres is 24
    IF (dp_s$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !dp_k%!20,STR$ !dp_k%!24)) OR \
       (dp_s$=FNsafe_string(dp_k%!36)) THEN
      dp_j%=0
    ELSE
      dp_j%=!dp_j%
    ENDIF
  ENDWHILE
  B%=CONST_ident_POTR:C%=4
  cnfg%!CONST_cnfg_dp_graphics=USR(code_entry%+CONST_entry_heap_claim)
  IFcnfg%!CONST_cnfg_dp_graphics=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
  !cnfg%!CONST_cnfg_dp_graphics=dp_k%

  dp_s$=FNicon_read(window%,15)
  dp_i%=INSTR(dp_s$,",")
  CASE LEFT$(dp_s$,dp_i%-1)OF
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1"):  dp_j%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO1s"): dp_j%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO2"):  dp_j%=2
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO4"):  dp_j%=4
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5"):  dp_j%=5
    WHEN FNmsg_0(psup%!CONST_psup_msg,"CO5s"): dp_j%=5
    OTHERWISE: dp_j%=0
  ENDCASE
  dp_s$=MID$(dp_s$,dp_i%+2)
  CASE dp_s$ OF
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8"):  dp_i%=8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT8s"): dp_i%=8
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1"):  dp_i%=1
    WHEN FNmsg_0(psup%!CONST_psup_msg,"HT1s"): dp_i%=1
    OTHERWISE: dp_i%=4
  ENDCASE
  cnfg%!CONST_cnfg_dp_options=FNstore_integer((dp_i%<<8)+dp_j%)

  dp_j%=prnt%!CONST_prnt_psze
  dp_s$=FNicon_read(window%,27)
  IF $dp_j%!CONST_psze_name<>dp_s$ THEN
    dp_i%=psize_head%
    WHILE dp_i%
      IF $dp_i%!CONST_psze_name=dp_s$ THEN
        prnt%!CONST_prnt_psze=dp_i%
        dp_i%=0
      ELSE
        dp_i%=!dp_i%
      ENDIF
    ENDWHILE
  ENDIF

  IF prnt%!CONST_prnt_icon<>-1 THEN

    // this printer is ACTIVE!
    // ensure that its details are correct

    PROCselect_printer(prnt%,TRUE,FALSE)

    // The front end code will spot that the selected printer has
    // changed and put everything back the way it was
    // PROCselect_printer(0,TRUE,TRUE): Don't do this - calls overlay

  ENDIF
ENDPROC

DEF FNdp_res(cnfg%)
  LOCAL xres%,yres%,graphics_prdt%,nm$
  graphics_prdt%=!cnfg%!CONST_cnfg_dp_graphics
  xres%=FNprinter_read_integer_entry(graphics_prdt%,4)
  yres%=FNprinter_read_integer_entry(graphics_prdt%,5)
  nm$=FNprinter_read_string_entry(graphics_prdt%,8)
  IF nm$="" THEN  nm$=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%)
=nm$

DEF FNdp_qual_name(dp_i%)
  LOCAL dp_s$,dp_t$
  IF DPQ$ = "S" THEN
    dp_s$=FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$(dp_i% AND &FF)+"s")
    dp_t$=FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$((dp_i% AND &FF00)>>8)+"s")
  ELSE
    dp_s$=FNmsg_0(psup%!CONST_psup_msg,"CO"+STR$(dp_i% AND &FF))
    dp_t$=FNmsg_0(psup%!CONST_psup_msg,"HT"+STR$((dp_i% AND &FF00)>>8))
  ENDIF
=dp_s$+", "+dp_t$

DEF FNdp_qual(cnfg%)
  LOCAL dp_i%
  dp_i%=!cnfg%!CONST_cnfg_dp_options
=FNdp_qual_name(dp_i%)

DEF FNdp_get_quality_options(graphics_definition%)
LOCAL s%,c%,t%
s%=FNprinter_read_integer_entry(graphics_definition%,3)
// if colour small halftone present, add colour large halftone
IF (s% AND &100) s% = s% OR &200
// if colour available, add new colour options
IF (s% AND &700) THEN
 t%=FNprinter_read_integer_entry(graphics_definition%,1) // ptr to module defn
 t%=FNprinter_read_integer_entry(t%,1) // module number
 // need to pass the MiscOp through to the dumper driver
 SYS"XPDriver_MiscOpForDriver",&80000002,t%,,,,,,,7 TO t%;c% // strip type mask
 IF(c%AND1)=0 AND t%<>&80000002 THEN
  IF (t% AND (1<<3)) THEN
   // add strip type 3 based on the greyscale options (or colour, if no grey)
   c%=s% AND &70
   IF c%=0 THEN c%=(s% AND &700)>>4
   s%=s% OR (c%<<16)
  ENDIF
  IF (t% AND (1<<4)) THEN
/*   // add strip type 4 based on the colour options */
   c%=s% AND &700
   s%=s% OR (c%<<8)
  ENDIF
  IF (t% AND (1<<5)) THEN
   // add strip type 5 based on the colour options
   c%=s% AND &700
   s%=s% OR (c%<<12)
  ENDIF
 ENDIF
ENDIF
// If simple qualities, knock out Mono,256 colours,32k colours
IF DPQ$ = "S" s%=s% AND &700070
=s%

// If DPQ$ = "S" then the following qualities are
// actually deemed not to exist:
// - Any 'Mono'; '256 colours'; '32k colours'

// This procedure tries to find a good default quality to pick.
// Modified on 22-Jul-93/3-Dec-93 to pick in this order:
// Modified on 02-Aug-95 to favour error diff instead of halftone
// * 16 million, diffused
// * colour, diffused
// * grey, diffused
// * mono, diffused
//
// The option value is split into 3 nibbles:
// &7xxxxx = 24bpp colour, either strip type 3 or 5 depending on
//                         whether or not it is a full colour system
// &x7xxxx = 16bpp colour, strip type 4
// &xxx7xx = colour, strip type 2
// &xxxx7x = greyscale, strip type 1
// &xxxxx7 = monochrome, strip type 0
//
// Within the 3 nibbles, the following values are valid:
// 1 = small halftone, tone type 4
// 2 = large halftone, tone type 8
// 4 = dithered, tone type 1
DEF PROCdp_decode_options(option%,RETURN strip%,RETURN tone%)
  // try to pick colour, then grey, then mono
  IF option% AND &700000 THEN
   strip%=5
  ELSE
   IF option% AND &700 THEN
    strip%=2
   ELSE
    IF option% AND &70 THEN
     strip%=1
    ELSE
     // force grey if Simple (Mono not allowed)
     IF DPQ$ = "S" THEN strip%=1 ELSE strip%=0
    ENDIF
   ENDIF
  ENDIF

  // find out what is available now
  option%=option%>>(strip%*4)
  tone%=-1
  IF (strip%=5 AND (option% AND 4)<>0) tone%=1
  IF (strip%=2 AND (option% AND 4)<>0) tone%=1
  IF (strip%=1 AND (option% AND 4)<>0) tone%=1
  IF (strip%=0 AND (option% AND 4)<>0) tone%=1

  // if we've failed now, try to pick
  // dithered, large halftone, small halftone

  IF tone%=-1 THEN
    IF option% AND 4 THEN
      tone%=1
    ELSE
      IF option% AND 2 THEN
        tone%=8
      ELSE
        tone%=4
      ENDIF
    ENDIF
  ENDIF
ENDPROC

DEF PROCdp_menu(top$,rebuild%,iconpos%)
  LOCAL wind%,dp_ix%,dp_iy%,dp_i%,dp_x%,dp_j%,dp_k%,xres%,yres%,indt%
  IF rebuild% dp_menu_xpos%=xbuff%!0-64: dp_menu_ypos%=xbuff%!4
  IF iconpos% THEN
    !buff%=xbuff%!12:buff%!4=xbuff%!16:SYS"Wimp_GetIconState",,buff%
    dp_ix%=buff%!16:dp_iy%=buff%!20
    SYS"Wimp_GetWindowState",,buff%
    dp_menu_xpos%=buff%!20+buff%!4+dp_ix%+2
    dp_menu_ypos%=buff%!24+buff%!16+dp_iy%-2
  ENDIF
  wind%=FNprinter_find_window(prnt%,"configure")
  dp_menu_chsn$=top$
  // because of the way the configuration window works,
  // we have to adjust prdt% to point to the printer data
  // record for the printer specified in the window, NOT
  // the current printer.
  prdt%=FNprinter_find_prdata_entry(psup%,FNicon_read(wind%,6))
  CASE top$ OF
    WHEN "ME1"
      PROCmenu_create(dp_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME1"))
      indt%=(dp_menu%!28 AND &100)<>0
      // get the resolution strings for this printer
      dp_j%=prdt%!20: dp_i%=0: dp_x%=0
      WHILE dp_j%
        dp_k%=!dp_j%!CONST_lstd_1st
        xres%=FNprinter_read_integer_entry(dp_k%,4)
        yres%=FNprinter_read_integer_entry(dp_k%,5)
        nm$=FNprinter_read_string_entry(dp_k%,8)
        IF nm$<>"" THEN
          PROCmenu_item(dp_menu%,dp_i%,nm$,indt%)
        ELSE
          PROCmenu_item(dp_menu%,dp_i%,FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ xres%,STR$ yres%),indt%)
        ENDIF
        dp_i%+=1
        dp_j%=!dp_j%
      ENDWHILE
      PROCmenu_tick_match(dp_menu%,FNicon_read(wind%,3))
    WHEN "ME2"
      PROCmenu_create(dp_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME2"))
      PROCmenu_tick_match(dp_menu%,FNicon_read(wind%,17))
    WHEN "ME3"
      PROCmenu_create(dp_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME3"))
      // need to find the right graphics entry for the current resolution
      dp_j%=prdt%!20  // point to first record for this list
      WHILE dp_j%
        dp_k%=!dp_j%!CONST_lstd_1st
        IF (FNicon_read(wind%,3)=FNmsg_2(psup%!CONST_psup_msg,"RES",STR$ !dp_k%!20,STR$ !dp_k%!24)) OR \
           (FNicon_read(wind%,3)=FNsafe_string(dp_k%!36)) THEN
          // ok - found the graphics entry, now get the options word
          dp_j%=FNdp_get_quality_options(dp_k%): dp_i%=0: dp_x%=0
          IF dp_j% AND &000007 PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO0"),dp_j%)
          IF dp_j% AND &000070 THEN
            IF DPQ$="S" THEN
              PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO1s"),dp_j%>>4)
            ELSE
              PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO1"),dp_j%>>4)
            ENDIF
          ENDIF
          IF dp_j% AND &000700 PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO2"),dp_j%>>8)
          IF dp_j% AND &070000 PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO4"),dp_j%>>16)
          IF dp_j% AND &700000 THEN
            IF DPQ$="S" THEN
              PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO5s"),dp_j%>>20)
            ELSE
              PROCdp_menu_quality(dp_menu%,dp_i%,FNmsg_0(psup%!CONST_psup_msg,"CO5"),dp_j%>>20)
            ENDIF
          ENDIF
          dp_j%=0
        ELSE
          dp_j%=!dp_j%
        ENDIF
      ENDWHILE
      PROCmenu_tick_match(dp_menu%,FNicon_read(wind%,15))
    WHEN "ME4"
      PROCmenu_create(dp_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME4"))
      indt%=(dp_menu%!28 AND &100)<>0
      IF FNprinter_read_list_integer_entry(prdt%,5,2,1)THEN
        // we have draft highlights
        PROCmenu_item(dp_menu%,1,FNmsg_0(psup%!CONST_psup_msg,"TQ1"),indt%)
        IF FNprinter_read_list_integer_entry(prdt%,5,3,1)PROCmenu_item(dp_menu%,2,FNmsg_0(psup%!CONST_psup_msg,"TQ2"),indt%)
      ENDIF
      PROCmenu_tick_match(dp_menu%,FNicon_read(wind%,14))
    WHEN "ME5"
      PROCmenu_create(dp_menu%,FNmsg_0(psup%!CONST_psup_msg,"ME5"))
      PROCmenu_tick_match(dp_menu%,FNicon_read(wind%,23))
    WHEN "MP1"
      PROCcreate_paper_menu(dp_menu%,wind%,27)
  ENDCASE
  PROCdisplay_menu(prnt%,dp_menu%,dp_menu_xpos%,dp_menu_ypos%)
ENDPROC

DEF PROCdp_menu_quality(RETURN dp_menu%,RETURN dp_i%,strip$,tone%)
  LOCAL indt%
  indt%=(dp_menu%!28 AND &100)<>0
  IF tone% AND 1 THEN
    IF DPQ$="S" THEN
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT4s"),indt%)
    ELSE
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT4"),indt%)
    ENDIF
    dp_i%+=1
  ENDIF
  IF tone% AND 2 THEN
    IF DPQ$="S" THEN
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT8s"),indt%)
    ELSE
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT8"),indt%)
    ENDIF
    dp_i%+=1
  ENDIF
  IF tone% AND 4 THEN
    IF DPQ$="S" THEN
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT1s"),indt%)
    ELSE
      PROCmenu_item(dp_menu%,dp_i%,strip$+", "+FNmsg_0(psup%!CONST_psup_msg,"HT1"),indt%)
    ENDIF
    dp_i%+=1
  ENDIF
ENDPROC

DEF FNdp_hex2(v%)
=RIGHT$("0"+STR$~v%,2)

// text printing code

DEF PROCdp_m8
  LOCAL dp_r%,queu%,tpub%,tprv%,text_prdt%
  VDU: PROCftracef("dp_m8(), reason "+STR$!xbuff%)
  VDU: PROCftracef(STR$~cnfg%)
  VDU: PROCftracef(STR$~cnfg%!CONST_cnfg_dp_text)
  VDU: PROCftracef(STR$~!cnfg%!CONST_cnfg_dp_text)
  text_prdt%=!cnfg%!CONST_cnfg_dp_text
  dp_r%=!xbuff%
  queu%=xbuff%!4
  tpub%=queu%!CONST_queu_tpub
  tprv%=queu%!CONST_queu_tprv
  CASE dp_r% OF
    WHEN  -1: PROCdp_1
    WHEN  -2: PROCdp_2
    WHEN  -4: PROCdp_4
    WHEN  -6: PROCdp_6
    WHEN  -7: PROCdp_7
    WHEN  -9: PROCdp_9
    WHEN -10: PROCdp_10
    WHEN -11: PROCdp_11
    WHEN -12: PROCdp_12
    WHEN -13: PROCdp_13
    WHEN -15: PROCdp_15
    WHEN -16: PROCdp_16
    WHEN -17: PROCdp_17
    WHEN -18: PROCdp_18
    WHEN -19: PROCdp_19
  ENDCASE
  VDU: PROCftracef("Afterwards ...")
  VDU: PROCftracef(STR$~cnfg%)
  VDU: PROCftracef(STR$~cnfg%!CONST_cnfg_dp_text)
  VDU: PROCftracef(STR$~!cnfg%!CONST_cnfg_dp_text)
ENDPROC

DEF PROCdp_1
  // only called if we aren't printing a DP file
  LOCAL dp_i%,dp_i$,psze%,dp_j%,B%,C%,D%
  B%=CONST_ident_TPRV:C%=CONST_tprv_dp_MAX
  tprv%=USR(code_entry%+CONST_entry_heap_claim)
  IFtprv%=0 ERROR CONST_error_fatal, FNmsg_0(FNdp_host_desc,"FA5")
  queu%!CONST_queu_tprv=tprv%
  FOR dp_i%=0 TO CONST_tprv_dp_MAX-4
    tprv%!dp_i%=0
  NEXT
  psze%=prnt%!CONST_prnt_psze
  tprv%!CONST_tprv_dp_left_print=psze%!CONST_psze_tleft
  dp_j%=!cnfg%!CONST_cnfg_dp_flags
  tpub%!CONST_tpub_cc_print=(dp_j% AND &FF00)>>8
  IF dp_j% AND 4 tpub%!CONST_tpub_number_print=TRUE
  IF dp_j% AND 2 tpub%!CONST_tpub_title_print=TRUE
  IF(dp_j%>>CONST_dp_flags_feed_offset AND CONST_dp_flags_feed_width)=CONST_dp_flags_feed_manual tpub%!CONST_tpub_manual_flag=TRUE
  // set the line epilogue string
  IF dp_j% AND 8 THEN
    dp_i$=FNprinter_read_string_entry(text_prdt%,6)
  ELSE
    dp_i$=FNprinter_read_string_entry(text_prdt%,5)
  ENDIF
  B%=A%!CONST_interface_scratch
  $B%=dp_i$
  C%=5
  D%=LEN dp_i$
  tpub%!CONST_tpub_line_epilogue=USR(code_entry%+CONST_entry_store_string)
  dp_i$=STRING$(psze%!CONST_psze_ttop,dp_i$)
  $B%=dp_i$
  C%=5
  D%=LEN dp_i$
  tprv%!CONST_tprv_dp_page_prologue=USR(code_entry%+CONST_entry_store_string)
  tprv%!CONST_tprv_dp_height_print=psze%!CONST_psze_theight
  tpub%!CONST_tpub_line_max=psze%!CONST_psze_theight-psze%!CONST_psze_ttop-psze%!CONST_psze_tbottom
  // set the pointer to the char translation list
  dp_j%=FNprinter_read_integer_entry(prdt%,6)  // point to the PRDT block
  IF dp_j% dp_j%=dp_j%!CONST_prdt_1st
  queu%!CONST_queu_char=dp_j%
ENDPROC

DEF PROCdp_2
  LOCAL dp_s$,pheight%,graphics_prdt%
  // output job start string
  dp_s$=FNprinter_read_string_entry(text_prdt%,7)
  IF dp_s$<>"" BPUT#xbuff%!8,dp_s$;
  dp_s$=FNprinter_read_string_entry(text_prdt%,1)
  pheight%=prnt%!CONST_prnt_psze
  pheight%=pheight%!CONST_psze_theight

  // Ouput set lines if both string exists and page length is not zero.
  // OSS Kludge - if dumper name = "PDumperIW" then output as 144ths of
  // an inch as a four digit decimal number with leading zeros. Assume
  // 6 lines per inch, 144/6 = 24.

  IF dp_s$<>"" AND pheight%<>0 THEN
    graphics_prdt%=!cnfg%!CONST_cnfg_dp_graphics
    IF FNprinter_read_string_entry(FNprinter_read_integer_entry(graphics_prdt%,1),2)="PDumperIW" THEN
      dp_s$+="0000"
      RIGHT$(dp_s$,4)=STR$(pheight%*24)
      BPUT#xbuff%!8,dp_s$;
    ELSE
      BPUT#xbuff%!8,dp_s$+CHR$(pheight%);
    ENDIF
  ENDIF
ENDPROC

DEF PROCdp_4
  // no data to output
  xbuff%?8=0
ENDPROC

DEF PROCdp_6
  // do control code processing
  LOCAL dp_b$
  dp_b$=FNdp_display(xbuff%!8)
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_7
  // process a backspace
  LOCAL dp_b$
  dp_b$=FNprinter_read_string_entry(text_prdt%,2)
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_9
  LOCAL changed_bits%,clr_bits%,set_bits%,bit%,dp_b$
  changed_bits%=tpub%!CONST_tpub_style_bits EOR xbuff%!8
  clr_bits%=tpub%!CONST_tpub_style_bits AND changed_bits%
  set_bits%=changed_bits% AND NOTclr_bits%
  IF clr_bits% OR set_bits% THEN
    FOR bit%=0 TO 5
      IF clr_bits% AND 1<<bit% THEN dp_b$+=FNdp_style_off(bit%)
      IF set_bits% AND 1<<bit% THEN dp_b$+=FNdp_style_on(bit%)
    NEXT
  ENDIF
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_10
  // start a new line
  LOCAL dp_s$,dp_b$
  tpub%!CONST_tpub_line_page+=1
  tpub%!CONST_tpub_line_doc+=1
  IF tpub%!CONST_tpub_number_print<>0 OR tprv%!CONST_tprv_dp_left_print>0 THEN
    dp_b$=FNdp_font(0)  // pica
    FOR bit%=0 TO 5
     IF tpub%!CONST_tpub_style_bits AND 1<<bit% dp_b$+=FNdp_style_off(bit%)
    NEXT
    dp_b$+=STRING$(tprv%!CONST_tprv_dp_left_print," ")
    IF tpub%!CONST_tpub_number_print THEN
      dp_s$=STR$ tpub%!CONST_tpub_line_doc
      dp_b$+=STRING$(5-LEN dp_s$," ")+dp_s$+" "
    ENDIF
    FOR bit%=0 TO 5
      IF tpub%!CONST_tpub_style_bits AND 1<<bit% dp_b$+=FNdp_style_on(bit%)
    NEXT
  ENDIF
  dp_b$+=FNdp_font(tpub%!CONST_tpub_font_num)+STRING$(tprv%!CONST_tprv_dp_left_ruler," ")
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_11
  LOCAL dp_b$,dp_i%
  PROCdp_10:dp_b$=FNprinter_read_string(tpub%!CONST_tpub_line_epilogue)+$(xbuff%+9)
  PROCdp_10:dp_b$+=FNprinter_read_string(tpub%!CONST_tpub_line_epilogue)+$(xbuff%+9)
  dp_b$+=FNdp_style_on(4)  // superscript
  dp_b$+=FNdp_trans(RIGHT$("  "+STR$ tpub%!CONST_tpub_footnote_num,3)+STRING$(3,FNprinter_read_string_entry(text_prdt%,2)))
  dp_b$+=FNdp_style_off(4)
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_12
  LOCAL dp_b$
  dp_b$=FNdp_trans($(xbuff%+8))
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_13
  tpub%!CONST_tpub_font_num=xbuff%!8
  xbuff%?8=0
ENDPROC

DEF PROCdp_15
/*  // end of job */
  LOCAL text_prdt%,tpub%,dp_epilogue$,dp_formfeed$,dp_lineepi$
  IF queu%!CONST_queu_type<>&FF4 THEN
    text_prdt%=!cnfg%!CONST_cnfg_dp_text
    tpub%=queu%!CONST_queu_tpub
    dp_lineepi$=FNprinter_read_string(tpub%!CONST_tpub_line_epilogue)
    IF queu%!CONST_queu_type=&FFF THEN

      // if the page pause flag is true, it means that the user stopped
      // the printing, so don't bother to tidy up

      IF(tpub%!CONST_tpub_pause_flag)=0 THEN
        dp_epilogue$=FNprinter_read_string_entry(text_prdt%,8)
        dp_formfeed$=FNprinter_read_string_entry(text_prdt%,4)
        IF INSTR(dp_epilogue$,dp_lineepi$)<>1 THEN
          IF dp_lineepi$<>"" BPUT#xbuff%!8,dp_lineepi$;
        ENDIF
        IF dp_epilogue$<>"" BPUT#xbuff%!8,dp_epilogue$;
      ENDIF
    ELSE
      // output a blank line between files
      IF dp_lineepi$<>"" BPUT#xbuff%!8,dp_lineepi$;
    ENDIF
  ENDIF
ENDPROC

DEF PROCdp_16
  // process a tab
  LOCAL dp_b$
  dp_b$=FNprinter_read_string_entry(text_prdt%,3)
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_17
  // do a formfeed
  LOCAL dp_b$
  dp_b$=FNprinter_read_string_entry(text_prdt%,4)
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_18
  // change layout
  LOCAL layout_height%,layout_top%,layout_bottom%,dp_b$,dp_i%,dp_i$,B%,C%,D%,graphics_prdt%
  layout_height%=xbuff%!8
  layout_top%=xbuff%!12
  layout_bottom%=xbuff%!16
  IF layout_height%<=tprv%!CONST_tprv_dp_height_print AND layout_top%<=layout_height%*0.33 AND layout_bottom%<=layout_height%*0.33 THEN
    tpub%!CONST_tpub_line_max=layout_height%-layout_top%-layout_bottom%
    IF tprv%!CONST_tprv_dp_page_prologue THEN
      VDU: PROCftracef("Calling heap free with ptr "+STR$~tprv%!CONST_tprv_dp_page_prologue)
      B%=CONST_ident_GSTR
      C%=tprv%!CONST_tprv_dp_page_prologue
      CALL code_entry%+CONST_entry_heap_free
    ENDIF
    dp_i$=STRING$(layout_top%,FNprinter_read_string(tpub%!CONST_tpub_line_epilogue))
    B%=A%!CONST_interface_scratch
    $B%=dp_i$
    C%=5
    D%=LEN dp_i$
    tprv%!CONST_tprv_dp_page_prologue=USR(code_entry%+CONST_entry_store_string)
    dp_b$=FNprinter_read_string_entry(text_prdt%,1)  // text_page_line

    // OSS Kludge - if dumper name = "PDumperIW" then output as 144ths of
    // an inch as a four digit decimal number with leading zeros. Assume
    // 6 lines per inch, 144/6 = 24.

    IF dp_b$<>"" AND layout_height%<>0 THEN
      graphics_prdt%=!(cnfg%!CONST_cnfg_dp_graphics)
      IF FNprinter_read_string_entry(FNprinter_read_integer_entry(graphics_prdt%,1),2)="PDumperIW" THEN
        dp_b$+="0000"
        RIGHT$(dp_b$,4)=STR$(layout_height%*24)
      ELSE
        dp_b$+=CHR$ layout_height%
      ENDIF
    ENDIF
  ENDIF
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF PROCdp_19
  LOCAL dp_b$,dp_i%,dp_s$,bit%
  dp_b$=FNprinter_read_string(tprv%!CONST_tprv_dp_page_prologue)
  tpub%!CONST_tpub_line_page=0
  tpub%!CONST_tpub_page_num+=1
  IF tpub%!CONST_tpub_title_print THEN
    tpub%!CONST_tpub_line_page+=2
    dp_b$+=FNdp_font(0)  // pica
    FOR bit%=0 TO 5
     IF tpub%!CONST_tpub_style_bits AND 1<<bit% dp_b$+=FNdp_style_off(bit%)
    NEXT
    dp_b$+=STRING$(tprv%!CONST_tprv_dp_left_print+tprv%!CONST_tprv_dp_left_ruler," ")
    dp_s$=FNprinter_read_string(tpub%!CONST_tpub_name)+"   "+FNprinter_read_string(tpub%!CONST_tpub_time)
    dp_s$+="   "+FNmsg_1(psup%!CONST_psup_msg,"PAG",STR$ tpub%!CONST_tpub_page_num)
    dp_b$+=FNdp_trans(dp_s$)
    FOR bit%=0 TO 5
      IF tpub%!CONST_tpub_style_bits AND 1<<bit% dp_b$+=FNdp_style_on(bit%)
    NEXT
    dp_b$+=STRING$(2,FNprinter_read_string(tpub%!CONST_tpub_line_epilogue))
  ENDIF
  xbuff%?8=LEN dp_b$
  $(xbuff%+9)=dp_b$
ENDPROC

DEF FNdp_trans(dp_s$)
  LOCAL dp_i%,byte%,out$,str$
  IF dp_s$="" THEN =""
  FOR dp_i%=1 TO LEN dp_s$
    byte%=ASC MID$(dp_s$,dp_i%,1)
    str$=""
    CASE TRUE OF
      WHEN byte%<32 OR byte%=127
        IF tpub%!CONST_tpub_cc_print=1 str$=FNdp_display(byte%)
      WHEN byte%>127 AND tpub%!CONST_tpub_cc_print<>0
        IF tpub%!CONST_tpub_cc_print=1 str$=FNdp_display(byte%)
      WHEN tpub%!CONST_tpub_cc_print<>0
        str$=CHR$ byte%
      OTHERWISE
        str$=FNdp_text_char(byte%)
        IF str$="" str$=CHR$ byte%
    ENDCASE
    out$+=str$
  NEXT
=out$

DEF FNdp_text_char(byte%)
  LOCAL dp_p%,dp_s$,dp_i%
  dp_p%=queu%!CONST_queu_char
  WHILE dp_p%
    CASE TRUE OF
      WHEN dp_p%?4=byte%
        dp_i%=dp_p%?5:dp_p%=dp_p%+6
        WHILE dp_i%
          dp_s$+=CHR$ ?dp_p%
          dp_p%+=1
          dp_i%-=1
        ENDWHILE
        =dp_s$
      WHEN dp_p%?4>byte%
        dp_p%=0
      OTHERWISE
        dp_p%=!dp_p%
    ENDCASE
  ENDWHILE
=""

DEF FNdp_display(byte%)
="["+RIGHT$("0"+FNtask_lower(STR$~byte%),2)+"]"

DEF FNdp_style_on(bit%)
  CASE bit% OF
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,13)  // bold on
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,17)  // light on
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,15)  // italic on
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,23)  // underline on
    WHEN 4: =FNprinter_read_string_entry(text_prdt%,19)  // superscript on
    WHEN 5: =FNprinter_read_string_entry(text_prdt%,21)  // subscript on
  ENDCASE
=""
:
DEF FNdp_style_off(bit%)
  CASE bit% OF
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,14)  // bold off
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,18)  // light off
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,16)  // italic off
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,24)  // underline off
    WHEN 4: =FNprinter_read_string_entry(text_prdt%,20)  // superscript off
    WHEN 5: =FNprinter_read_string_entry(text_prdt%,22)  // subscript off
  ENDCASE
=""

DEF FNdp_font(font%)
  CASE font% OF
    WHEN 0: =FNprinter_read_string_entry(text_prdt%,9)  // pica
    WHEN 1: =FNprinter_read_string_entry(text_prdt%,10) // elite
    WHEN 2: =FNprinter_read_string_entry(text_prdt%,11) // condensed
    WHEN 3: =FNprinter_read_string_entry(text_prdt%,12) // expanded
  ENDCASE
=""

DEF FNdp_host_desc
LOCAL a%
a%=buff%!24
=a%!CONST_interface_host_desc
