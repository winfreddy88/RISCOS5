/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * msgs.c - nicer wrappers on top of SCormie's
 *          MsgTrans stuff.
 */

#include <stdio.h>
#include <kernel.h>
#include <swis.h>
#include <stdarg.h>
#include <string.h>

#include "debug.h"
#include "msgs.h"
#include "MsgTrans.h"

int msgs_handle[5] ; /* Messages file */
int map_handle[5] ;  /* USB printer mappings file */

static _kernel_oserror err ;


_kernel_oserror *msgs_openfile (int handle[], char *pathname)
{
        handle[4] = 0 ;
        return (msgtrans_openfile (pathname, handle)) ;
}

void msgs_closefile (int handle[])
{
        msgtrans_closefile (handle) ;
}

char *msgs_lookup (int handle[], char *token, int num_args,  ...)
{
        _kernel_oserror *e ;
        va_list         ap ;
        char            *p[4], *s ;
        int             idx = 0 ;
        int             args = num_args ;
        char            *buffer ;

        p[0] = p[1] = p[2] = p[3] = (char *) 0 ;

        va_start (ap, num_args) ;

        while (((s = va_arg (ap, char *)) != NULL) && (args--))
        {
                if ((s != NULL) && (*s != '\0'))
                {
                        p[idx++] = s ;
                }
        }

        va_end (ap) ;

        if ((e = msgtrans_lookup (handle, token, &buffer,
             p[0], p[1], p[2], p[3])) != NULL)
                _kernel_raise_error (e) ;

        return (buffer) ;
}

char *msgs_quick_lookup (int handle[], char *token)
{
        _kernel_oserror *e ;
        char            *buffer ;

        e = msgtrans_lookup (handle, token, &buffer, 0, 0, 0, 0) ;
        if (e) buffer = 0 ;

        return (buffer) ;
}

/* Assumes that the handle = msgs_handle */
_kernel_oserror *msgs_error_lookup (int errnum, char *token, int num_args,  ...)
{
        va_list         ap ;
        char            *p[4], *s ;
        int             idx = 0 ;
        int             args = num_args ;

        p[0] = p[1] = p[2] = p[3] = (char *) 0 ;

        va_start (ap, num_args) ;

        while (((s = va_arg (ap, char *)) != NULL) && (args--))
        {
                if ((s != NULL) && (*s != '\0'))
                {
                        p[idx++] = s ;
                }
        }

        va_end (ap) ;

        err.errnum = errnum ;
        strcpy (err.errmess, token) ;

        return (msgtrans_error_lookup (msgs_handle, &err, p[0], p[1], p[2], p[3])) ;
}
