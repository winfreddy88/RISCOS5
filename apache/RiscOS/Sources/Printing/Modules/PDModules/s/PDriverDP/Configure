; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.PDriverDP.Configure


; ************************************************************************
; printer specific initialisation of the configuration.
;  This routine must initialise the variables in info_globalvalues and
;  size_globalvalues, as well as any variables of its own.
; It should preserve all registers.
; ************************************************************************

configure_init  ROUT


      [ (:LNOT: hostvdu) :LAND: debug
        Debug_Open "<Debug$File>"
      ]

        Push    "r0-r7, lr"

        MOV     R0, #0                  ; Clear the PDumper handling stuff
        STR     R0, printer_pdumper_pointer
        STR     R0, printer_stringblocksize
        STR     R0, pdumper_list
        STR     R0, pending_info_flag
        STR     R0, pending_pdumper_command
        MOV     R0, #-1
        STR     R0, printer_pdumper_number

        ADR     R0,config_callback
        MOV     R1,#Service_PDumperStarting
        SWI     XOS_AddCallBack         ; setup a call back handler

        ADR     r6, config_data         ; Copy the default printer page size, resolution etc...
        ADR     lr, info_globalvalues
        LDMIA   r6!, {r0-r5}
        STMIA   lr!, {r0-r5}
        LDMIA   r6!, {r0-r5, r7}
        STMIA   lr!, {r0-r5, r7}


        ADR     lr, printer_dump_depth  ; Start of configured data. Basically just interlace and dump depth and strip type.
        MOV     r5, #mde-mydata

01      LDR     r0, [r6], #4
        STR     r0, [lr], #4
        SUBS    r5, r5, #4
        BGT     %BT01

        Pull   "r0-r7, pc"

config_data
        &       120                     ;       Real x resolution
        &       180                     ;       Real y resolution
        &       PDriverInfo_TransformedSprites +PDriverInfo_TransformedFonts +PDriverInfo_MiscOp +PDriverInfo_SetDevice +PDriverInfo_DrawPageFlags
                                        ;       Info word

        &       &0                      ;
        &       120/1                   ;       Halftone resolution (x)
        &       180/1                   ;       Halftone resolution (y)
        &       0                       ;

        &       594960                  ; A4 paper
        &       841920
        &       17280
        &       72000/2
        &       577680
        &       841920-36000


mydata
        =   24, 0, 0, 255   ; dump depth, not interlaced (y nor x), strip type
;                              255 to give an error. Must do PDriver_SetPrinter!
;                              (to set a palette up for PDumper).
mde



; ************************************************************************
; declare a pdumperxx module using the service call entry
; ************************************************************************

config_callback ROUT
        Push    "R1,LR"
        MOV     R1,wp
        SWI     XOS_ServiceCall
        Pull    "R1,PC"                 ; issued when module in module chain



; ************************************************************************
; printer specific finalisation of the configuration.
;  This routine must free the RMA claimed in initialisation, in this case
; we must remove all all the blocks claimed for holding the PDumper
; chain.
; It should preserve all registers.
; ************************************************************************

configure_finalise ROUT
        Entry   "R0-R3"

        MOV     R1,#Service_PDumperDying
        SWI     XOS_ServiceCall         ; hello world we are disappearing!

        LDR     R2,printer_stringblocksize
        TEQ     R2,#0
        LDRNE   R2,printer_stringblockptr
        MOVNE   R0,#ModHandReason_Free  ; could be megs of dump strings in there!
        SWINE   XOS_Module

      [ (:LNOT: hostvdu) :LAND: debug
        Debug_Close
      ]
        LDR     R3,pdumper_list         ; -> pdumper list
00
        MOVS    R2,R3                   ; end of list yet?
        STREQ   R2,pdumper_list
        EXIT    EQ                      ; yes, so return

        MOV     R0,#ModHandReason_Free
        LDR     R3,[R2,#pdumper_next]
        SWI     XOS_Module              ; attempt to free the block (ignoring the error)
        B       %00                     ; loop back until they are all zapped



; ************************************************************************
; printer specific production of an error for PDriver_CheckFeatures.
;   Entry: R0, R1 are PDriver_CheckFeatures parameters
;          R2 is ((features) AND R0) and is known not to be the same as R1.
;   Exit:  Appropriate error should have been produced.
; ************************************************************************

configure_makeerror EntryS   "r1-r2"
        EOR      r1, r1, r2
        BIC      r1, r1, #2_110
        BICS     r1, r1, #2_11100000000
        EXITS    EQ

        MOV      r2, #0                 ; find first mismatched bit between r1, r2
01      MOVS     r1, r1, LSR #1
        ADDCC    r2, r2, #1
        BCC      %BT01

        ADR      r1, error_table
        LDR      r0, [r1, r2, LSL #2]
        ADD      r0, r0, r1
        addr     r1, title              ; %0 -> "PDriverDP"
        BL       LookupError            ; Always sets the V bit
        EXIT

error_table
        & ErrorBlock_PrintNoColour     - error_table        ; bit 0
        & 0                                                 ; bit 1
        & 0                                                 ; bit 2
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 3
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 4
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 5
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 6
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 7
        & 0                                                 ; bit 8
        & 0                                                 ; bit 9
        & 0                                                 ; bit 10
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 11
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 12
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 13
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 14
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 15
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 16
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 17
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 18
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 19
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 20
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 21
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 22
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 23
        & ErrorBlock_PrintNoScreenDump - error_table        ; bit 24
        & ErrorBlock_PrintBadTransform - error_table        ; bit 25
        & ErrorBlock_PrintNoIncludedFiles  - error_table    ; bit 26
        & 0                                                 ; bit 27
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 28
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 29
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 30
        & ErrorBlock_PrintBadFeatures  - error_table        ; bit 31

        MakeInternatErrorBlock PrintBadFeatures,,BadFeat
        MakeInternatErrorBlock PrintNoColour,,NoCol
        ALIGN



; *****************************************************************
; routine to vet parameters for PDriver_SetInfo
; Entry parameters as for PDriver_SetInfo
; *****************************************************************

configure_vetinfo ROUT
        [ Libra1        ; no longer need to get upset - cos all dumpers
                        ; support colour!
        Push    "LR"
        Pull    "PC"
        |
        CLRV
        TST     R3, #1
        MOVEQ   pc, lr

        Push    "R1,LR"
        ADR     R0,ErrorBlock_PrintNoColour
        ADDR    R1,title                ; %0 -> "PDriverDP"
        BL      LookupError             ; Always sets the V flag
        Pull    "R1,PC"
        ]



; *****************************************************************
; Set Printer and information
; This SWI is ignored by the PDumper module for version 3 drivers.
; *****************************************************************

configure_setprinter ROUT

        Debug   Configure,"SetPrinter called"

        ADR     R0,ErrorBlock_PrintBadSetPrinter
        B       LookupSingle            ;Translate the error message

        MakeInternatErrorBlock PrintBadSetPrinter,,NoPDSet


; *****************************************************************
; Set PDumper and information
;       R1 =  PDumper number
;       R2 => Command for getting the PDumperXX module (max 256 bytes)
;       R3 => 256 bytes of PDumperXX specific data
;       R4 => 256 bytes for dump_depth, interlace, strip type, no. passes and strings for printing
;             When a string is marked as present in the top level but zero length when you actually
;             get there this signifies an extended (potentially up to 16Mbyte) dump string.This
;             routine adds up all the lengths and rejigs the block to collect them all together.
;       R5 =  Configuration word for Dumper
; *****************************************************************

configure_setdriver ROUT

        Push    "R0-R8,R11,LR"

        Debug   Configure,"Setting configuration for PDumper",R1
        DebugS  Configure,"Command line to execute",R2
        Debug   Configure,"PDumper specific data at",R3
        Debug   Configure,"Configuration block at",R4
        Debug   Configure,"Configuration word of",R5

        STR     R5,printer_configureword

        MOV     R5,#252                 ; index
        ADR     R6,printer_dump_depth
00
        LDR     LR,[R4,R5]              ; copy the main block of config data
        STR     LR,[R6,R5]
        SUBS    R5,R5,#4
        BPL     %00                     ; while index >= 0

        ; Now accumulate how long the long dump strings are
        ADRL    R5,setdriver_table      ; -> offsets from printer_dump_depth to a string entry
        MOV     R7,#0
05
        LDRB    LR,[R5],#1
        TEQ     LR,#255                 ; end of offsets table?
        BEQ     %FT10
        LDRB    LR,[R6,LR]
        TEQ     LR,#0                   ; no dump string present
        BEQ     %BT05
        ADD     LR,LR,#dp_data_dlm      ; -> [len1] [string] or possibly [0] [len3] [ptr]
        LDRB    R8,[R6,LR]
        TST     R8,#255
        BNE     %BT05                   ; no action,it's a [len1] [string]
        LDR     R8,[R6,LR]              ; extended strings are expected to be word aligned
        MOV     R8,R8,LSR#8
        ADD     R7,R7,R8                ; accumulate the [len3] >> 8 bit
        B       %BT05

        ; Extend,or claim a slice of pie
10
        Debug   Configure,"Need a dump string block of size",R7
        TEQ     R7,#0                   ; do nothing (the block is free'd on finalisation)
        BEQ     %FT30
        LDR     R8,printer_stringblocksize
        CMP     R7,R8
        BLS     %FT15                   ; no need to grow block
        CMP     R8,#0                   ; zero'd on initialisation
        Push    "R0,R2,R3"
        MOVNE   R0,#ModHandReason_Free
        LDRNE   R2,printer_stringblockptr
        SWINE   XOS_Module
        MOV     R0,#ModHandReason_Claim
        MOV     R3,R7
        SWI     XOS_Module
        STRVC   R2,printer_stringblockptr
        STRVC   R3,printer_stringblocksize
        Debug   Configure,"Claim dump block at",R2
        Debug   Configure,"Claim dump block size",R3
        STRVS   R0,[SP]
        Pull    "R0,R2,R3"
        BVS     %FT45                   ; couldn't get enough RMA

        ; Copy strings to claimed RMA region and update original structure
        ; R5 = string entry being fiddled
        ; R6 = printer_dump_depth from earlier
        ; R7 = next free byte in RMA
        ; R8,R0,LR = scrap
15
        ADRL    R5,setdriver_table      ; -> offsets from printer_dump_depth to a string entry
        LDR     R7,printer_stringblockptr
        Debug   Configure,"Use dump block at",R7
20
        LDRB    LR,[R5],#1
        TEQ     LR,#255                 ; end of offsets table?
        BEQ     %FT30
        Debug   Configure,"--Inspect dump string#",LR
        LDRB    LR,[R6,LR]
        TEQ     LR,#0                   ; no dump string present
        BEQ     %BT20
        ADD     LR,LR,#dp_data_dlm      ; -> [len1] [string] or possibly [0] [len3] [ptr]
        LDRB    R8,[R6,LR]
        TST     R8,#255
        BNE     %BT20                   ; no action,it's a [len1] [string]
        LDR     R8,[R6,LR]
        ADD     LR,LR,#4
        LDR     R0,[R6,LR]              ; := source
        STR     R7,[R6,LR]              ; fiddle to where it's about to be copied
        Debug   Configure,"  Store string at",R7
        MOV     R8,R8,LSR#8             ; := length
        Debug   Configure,"  Length",R8
25
        LDRB    LR,[R0],#1
        STRB    LR,[R7],#1
        SUBS    R8,R8,#1
        BNE     %BT25
        B       %BT20

30
        LDR     R5,pdumper_list         ; -> pdumper list
35
        TEQ     R5,#0
        BEQ     %50                     ; not found so mark as pending.

        LDR     R6,[R5,#pdumper_number]
        TEQ     R6,R1                   ; found the pdumper we want?
        LDRNE   R5,[R5,#pdumper_next]
        BNE     %35                     ; loop until all finished scanning
40
        Debug   Configure,"PDumper record at",R5

        STR     R1,printer_pdumper_number
        STR     R5,printer_pdumper_pointer

        LDR     R5,printer_configureword

        MOV     R11,#PDumperReason_SetDriver
        BL      CallPDumper

        MOV     LR,#0
        STR     LR,pending_info_flag    ; mark as no pending info
45
        STRVS   R0,[SP]
        Pull    "R0-R8,R11,PC"
50
        Debug   Configure,"Pending PDumper is",R1
        Debug   Configure,"Pointer being set to",R5

        STR     R1,printer_pdumper_number
        STR     R5,printer_pdumper_pointer      

        MOV     R1,#-1
        STR     R1,pending_info_flag    

        TEQ     R2,#0                   ; is there a command string?
        STREQ   R2,pending_pdumper_command
        BEQ     %65
        
        MOV     R0,#0                   ; index into buffer
        ADRL    R5,pending_pdumper_command

        Debug   Configure,"Storing pending command at",R5
60
        LDRB    R6,[R2],#1              ; get a character
        CMP     R6,#32
        MOVLT   R6,#0                   ; terminate with a null
        MOVLT   R0,#255                 ; index to end of string
        STRB    R6,[R5],#1

        ADD     R0,R0,#1
        TEQ     R0,#256                 ; end of buffer yet?
        BNE     %60                     ; loop back until all copied or overflow

        TEQ     R6,#0                   ; end of the string?
        BEQ     %65
   
        ADR     R0,ErrorBlock_PrintOverflow
        BL      LookupSingle 
        B       %45                     ; return because of the overflow
65
        Debug   Configure,"About to copy the dumper specific block"

        MOV     R11,#252
        ADRL    R9,pending_info_data
70
        LDR     R10,[R3,R11]
        STR     R10,[R9,R11]
        SUBS    R11,R11,#4
        BGE     %70                     ; loop until all copied

        CLRV
        Pull    "R0-R8,R11,PC"
        
        MakeInternatErrorBlock PrintOverflow,,BufOFlo

setdriver_table
        ; as the dump strings aren't in a nice row in the block,here's a table of offsets
        DCB 15  ; dp_data_page_start
        DCB 16  ; dp_data_page_end         
        DCB 17  ; dp_data_line_return      
        DCB 18  ; dp_data_line_skip        
        DCB 19  ; dp_data_line_end         
        DCB 20  ; dp_data_line_end_i2      
        DCB 21  ; dp_data_line_end_i3      
        DCB 22  ; dp_data_zero_skip        
        DCB 23  ; dp_data_line_start       
        DCB 24  ; dp_data_line_start_2     
        DCB 25  ; dp_data_pass1_start      
        DCB 26  ; dp_data_pass1_start_2    
        DCB 27  ; dp_data_pass2_start      
        DCB 28  ; dp_data_pass2_start_2    
        DCB 29  ; dp_data_pass3_start      
        DCB 30  ; dp_data_pass3_start_2    
        DCB 31  ; dp_data_pass4_start      
        DCB 32  ; dp_data_pass4_start_2    
        DCB 33  ; dp_data_set_lines        
        DCB 48  ; dp_data_form_feed
        DCB 255 ; end
        ALIGN

; *****************************************************************
;
; CallPDumper
;
; In:   R11  =reason code and other registers setup correctly.
;
; Out:  V clear, registers setup.
;       V set, R0 -> error block.
;
; *****************************************************************

CallPDumper ROUT

        Push    "R10-R12,LR"

        Debug   CallPDumper,"+CallPDumper",R11

        CLRV
        BL      enableescapes   ; Must make sure escapes are enabled for any PDumper call JRC 12 May '97
        LDR     R12,printer_pdumper_pointer     ;based on r12

        [ Libra1
        ; validate strip type
        TEQ     R11,#PDumperReason_SetDriver
        ; MOVEQ   R9,#0
        LDREQB  R9, [R4, #4]
        ANDNE   R9,R2,#&FF              ;Get the strip type or make one up if required
        MOV     LR, #1
        MOV     LR, LR, LSL R9
        Debug   CallPDumper,"Strip type as a mask = ",LR
        LDR     R9, [R12,#pdumper_striptypemask]
        Debug   CallPDumper,"Permissible mask = ",R9
        ANDS    R9, R9, LR
        BNE     %FT10
        Debug   CallPDumper,"Bad strip type requested"
        ADR     R0,ErrorBlock_PDumperBadStrip
        ADDR    R1,title                ;->Title string
        Debug   CallPDumper,"PDumper_LookupError"
        SWI     XPDumper_LookupError
        Pull    "R10-R12,lr"
        Push    lr
        BL      disableandcheckescapes  ;Error---reenable
        Pull    pc

10
        ]

        [ MakeUpCallsAtEntry
        BL      upcallPDumperActionAtEntry
        ]
        [ MakeUpCallsAtExit
        Push    "r12"
        ]

        ADD     R12,R12,#pdumper_workspace

        MOV     LR,PC
        LDMIA   R12,{R12,PC}            ; call the routine

        DebugIf VC, CallPDumper,"-CallPDumper---no error"
        DebugE  CallPDumper,"-CallPDumper"

        [ MakeUpCallsAtExit
        Pull    "r12"
        BL      upcallPDumperActionAtExit
        ]

        Pull    "R10-R12,lr"            ; and then return
        Push    lr
        BL      disableandcheckescapes  ;Reenable afterwards JRC Mon 12th May 1997
        Pull    pc

        MakeInternatErrorBlock PDumperBadStrip,,BadStrp


CallPDumperForJob ROUT
        DebugEscState CallPDumperForJob
        Push    "R10-R12,LR"

        Debug   CallPDumper,"+CallPDumperForJob",R9
        Debug   CallPDumper,"Job record is at",R11

        CLRV
        BL      enableescapes           ; JRC Mon 12th May 1997
        LDR     R12,job_pdumper_pointer

        [ Libra1
        Push    "R9"
        ; validate strip type
        TEQ     R11,#PDumperReason_SetDriver
        ; MOVEQ   R9,#0
        LDREQB  R9, [R4, #4]
        ANDNE   R9,R2,#&FF              ;Get the strip type or make one up if required
        MOV     LR, #1
        MOV     LR, LR, LSL R9
        Debug   CallPDumper,"Strip type as a mask = ",LR
        LDR     R9, [R12,#pdumper_striptypemask]
        Debug   CallPDumper,"Permissible mask = ",R9
        ANDS    R9, R9, LR
        BNE     no_error
        Debug   CallPDumper,"Bad strip type requested"
        ADR     R0,ErrorBlock_PDumperBadStrip
        ADDR    R1,title                ;->Title string
        Debug   CallPDumper,"PDumper_LookupError"
        SWI     XPDumper_LookupError
        Pull    "R9"
        Pull    "R10-R12,lr"
        Push    lr
        BL      disableandcheckescapes  ; JRC Mon 12th May 1997
        Pull    pc

no_error      Pull    "R9"
        ]
        [ MakeUpCallsAtEntry
        BL      upcallPDumperActionAtEntry
        ]
        [ MakeUpCallsAtExit
        Push    "r12"
        ]

        ADD     R12,R12,#pdumper_workspace

        MOV     R11,R9


        MOV     R14,PC
        LDMIA   R12,{R12,PC}            ; call the routine

        DebugIf VC, CallPDumper, "-CallPDumperForJob---no error"
        DebugE  CallPDumper, "-CallPDumperForJob"

        [ MakeUpCallsAtExit
        Pull    "r12"
        BL      upcallPDumperActionAtExit
        ]

        Pull    "R10-R12,lr"
        Push    lr
        BL      disableandcheckescapes  ; JRC Mon 12th May 1997
        Pull    pc


; Upcall generating code
        [ MakeUpCallsAtEntry

upcallPDumperActionAtEntry ROUT

        Push    "r0-r12,lr"
        MOV     r0, #UpCall_PDumperAction
        MOV     r1, #0                         ; PDumper entry flag
        MOV     r2, sp                         ; Pointer to r0-r12
        SWI     XOS_UpCall
        Pull    "r0-r12,pc"
        ]

        [ MakeUpCallsAtExit

upcallPDumperActionAtExit ROUT

        Push    "r0-r12,lr"
        MOV     r0, #UpCall_PDumperAction
        MOV     r1, #1                         ; PDumper exit flag
        ORRVS   r1, r1, #2                     ; Error flag
        MOV     r2, sp                         ; Pointer to r0-r12
        SWI     XOS_UpCall
        TST     r1, #2                         ; restore error (if any)
        SETV    NE
        Pull    "r0-r12,pc"
        ]

        END
