REM Copyright 2013 Castle Technology Ltd
REM
REM Licensed under the Apache License, Version 2.0 (the "License");
REM you may not use this file except in compliance with the License.
REM You may obtain a copy of the License at
REM
REM     http://www.apache.org/licenses/LICENSE-2.0
REM
REM Unless required by applicable law or agreed to in writing, software
REM distributed under the License is distributed on an "AS IS" BASIS,
REM WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
REM See the License for the specific language governing permissions and
REM limitations under the License.
REM
REM > !RunImage
REM
REM
ON ERROR PROCmsg_end:ERROR EXT ERR, REPORT$+" ("+STR$(ERL)+")"
SYS"Hourglass_On"
PROCmsg_initialise("<PrintEdit$Dir>.Messages")
PROCheap_initialise
PROCtask_initialise(FNmsg_0("ID"))
PROCerror_initialise
PROClocale_initialise
PROCicon_initialise
PROCwin_initialise
PROCmenu_initialise
PROCsave_initialise
PROCinitialise
SYS"Hourglass_Off"
ON ERROR PROCerror
PROCload_specified_file
:
ON ERROR PROCerror
REPEAT
 PROCdespatch_poll(global_mask%)
UNTIL FALSE
END
:
DEFPROCdespatch_poll(mask%)
LOCAL r%
r%=FNtask_poll(mask%)
CASE r% OF
WHEN     1: PROCredraw_window
WHEN     2: PROCopen_window
WHEN     3: PROCclose_window
WHEN     6: PROCmouseclick
WHEN     7: PROCsave_decodedrag
WHEN     8: PROCkeypress
WHEN     9: PROCmenuaction
WHEN 17,18: PROCreceive(r%)
WHEN    19: PROCack
ENDCASE
ENDPROC
:
DEFPROCinitialise
PROCinitialise_constants
PROCinitialise_memory
PROCinitialise_globals
PROCinitialise_windows
ENDPROC
:
DEFPROCload_specified_file
IFspecial_load_file$<>"" THEN
 $(task_buff%+44)=special_load_file$+CHR$(0)
 special_load_file$=""
 PROCload_file
 PROCcheck_main_window
 IFspecial_print_file% THEN
  PROCprint_file("<Printer$Temp>")
  PROCrestart_everything
  special_print_file%=FALSE
 ELSE
  PROCopen_main_window
 ENDIF
ENDIF
ENDPROC
:
DEFPROCinitialise_constants
LOCAL dp_p%
REM define poll masks
REM           1111111111
REM           98765432109876543210
global_mask%=%00000001100000110001
dp_p%=0
        dp_dump_depth%=dp_p%:dp_p%+=1
       dp_y_interlace%=dp_p%:dp_p%+=1
       dp_x_interlace%=dp_p%:dp_p%+=1
     dp_pass_per_line%=dp_p%:dp_p%+=1
        dp_strip_type%=dp_p%:dp_p%+=1
        dp_output_bpp%=dp_p%:dp_p%+=1
         dp_no_passes%=dp_p%:dp_p%+=1
              dp_pass%=dp_p%:dp_p%+=1
      dp_data_version%=dp_p%:dp_p%+=1:REM OSS At runtime these 4 bytes hold
 dp_rest_private_word%=dp_p%:dp_p%+=3:REM the PDumper module's private word!
          dp_data_dlm%=dp_p%:dp_p%+=1:REM data length multiplier
          dp_data_dla%=dp_p%:dp_p%+=1:REM data length added
          dp_data_dht%=dp_p%:dp_p%+=1:REM dump height
   dp_data_page_start%=dp_p%:dp_p%+=1
     dp_data_page_end%=dp_p%:dp_p%+=1
  dp_data_line_return%=dp_p%:dp_p%+=1
    dp_data_line_skip%=dp_p%:dp_p%+=1
     dp_data_line_end%=dp_p%:dp_p%+=1
  dp_data_line_end_i2%=dp_p%:dp_p%+=1
  dp_data_line_end_i3%=dp_p%:dp_p%+=1
    dp_data_zero_skip%=dp_p%:dp_p%+=1
   dp_data_line_start%=dp_p%:dp_p%+=1
 dp_data_line_start_2%=dp_p%:dp_p%+=1
  dp_data_pass1_start%=dp_p%:dp_p%+=1
dp_data_pass1_start_2%=dp_p%:dp_p%+=1
  dp_data_pass2_start%=dp_p%:dp_p%+=1
dp_data_pass2_start_2%=dp_p%:dp_p%+=1
  dp_data_pass3_start%=dp_p%:dp_p%+=1
dp_data_pass3_start_2%=dp_p%:dp_p%+=1
  dp_data_pass4_start%=dp_p%:dp_p%+=1
dp_data_pass4_start_2%=dp_p%:dp_p%+=1
    dp_data_set_lines%=dp_p%:dp_p%+=1
    dp_data_num_lines%=dp_p%:dp_p%+=1
 dp_data_pixel_run_up%=dp_p%:dp_p%+=1
dp_data_skip_multiplier%=dp_p%:dp_p%+=4
 dp_data_skip_divider%=dp_p%:dp_p%+=4
 dp_data_roll_advance%=dp_p%:dp_p%+=4
    dp_data_form_feed%=dp_p%:dp_p%+=1
 dp_data_unused_bytes%=dp_p%:dp_p%+=3:REM OSS Put extra byte size stuff here.
  dp_data_left_offset%=dp_p%:dp_p%+=4:REM OSS The section of the paper that
   dp_data_top_offset%=dp_p%:dp_p%+=4:REM cannot be printed on.
   dp_data_text_start%=dp_p%:dp_p%+=1

REM OSS Constants for the icon numbers in the graphics window. grwric_
REM stands for GRaphics WRteable ICon.

dp_p%=44
grwric_xres%=dp_p%:dp_p%+=1
grwric_yres%=dp_p%:dp_p%+=1
grwric_modnam%=dp_p%:dp_p%+=1
grwric_modnum%=dp_p%:dp_p%+=1
grwric_palfile%=dp_p%:dp_p%+=1
grwric_skipres%=dp_p%:dp_p%+=1
grwric_dumpdepth%=dp_p%:dp_p%+=1
grwric_dumpheight%=dp_p%:dp_p%+=1
grwric_xint%=dp_p%:dp_p%+=1
grwric_dlm%=dp_p%:dp_p%+=1
grwric_yint%=dp_p%:dp_p%+=1
grwric_dla%=dp_p%:dp_p%+=1
grwric_setlines%=dp_p%:dp_p%+=1
grwric_pagestart%=dp_p%:dp_p%+=1
grwric_formfeed%=dp_p%:dp_p%+=1
grwric_pageend%=dp_p%:dp_p%+=1
grwric_linereturn%=dp_p%:dp_p%+=1
grwric_lineskip%=dp_p%:dp_p%+=1
grwric_lineend1%=dp_p%:dp_p%+=1
grwric_lineend2%=dp_p%:dp_p%+=1
grwric_lineend3%=dp_p%:dp_p%+=1
grwric_zeroskip%=dp_p%:dp_p%+=1
grwric_linestart1%=dp_p%:dp_p%+=1
grwric_linestart2%=dp_p%:dp_p%+=1
grwric_linepass1%=dp_p%:dp_p%+=1
grwric_linepass1b%=dp_p%:dp_p%+=1
grwric_linepass2%=dp_p%:dp_p%+=1
grwric_linepass2b%=dp_p%:dp_p%+=1
grwric_linepass3%=dp_p%:dp_p%+=1
grwric_linepass3b%=dp_p%:dp_p%+=1
grwric_linepass4%=dp_p%:dp_p%+=1
grwric_linepass4b%=dp_p%:dp_p%+=1

dp_p%=88
grwric_gname%=dp_p%:dp_p%+=2
grwric_gcalib%=dp_p%:dp_p%+=2

SHORT%=FALSE
LONG%=TRUE

ENDPROC
:
DEFPROCinitialise_memory
LOCAL h%,l%,a%,w%
buff1%=FNheap_claim("PRIV",1024):REM Used for temporary storage all over the place
longstring%=FNheap_claim("PRIV",1024):REM Used to get round BASIC's 256 byte string limit
ENDPROC
:
DEFPROCinitialise_globals
LOCAL q%,E%,E1%
line_space%=44:REM same as a menu ...
modified%=FALSE
got_some_data%=FALSE
graphics_head%=0
REM a state variable:
REM 0 - no shutdown taking place
REM 1 - save taking place then application quitting
REM 2 - shutdown caused by app quitting
REM 3 - save taking place then desktop quitting
REM 4 - shutdown caused by desktop quitting
REM 5 - save taking place then data chucked
REM 6 - data being chucked
doing_shutdown%=0
no_hilit_head%=FNheap_claim("TEXT",24*4)
draft_hilit_head%=FNheap_claim("TEXT",24*4)
nlq_hilit_head%=FNheap_claim("TEXT",24*4)
FORq%=0 TO 23
 no_hilit_head%!(q%*4)=0
 draft_hilit_head%!(q%*4)=0
 nlq_hilit_head%!(q%*4)=0
NEXT
charmap_count%=0
charmap_head%=0
DIM charmap_icdf%(3)
got_no_hilits%=FALSE
got_draft_hilits%=FALSE
got_nlq_hilits%=FALSE
text_ptr%=0
default_xres%=0
default_yres%=0
default_qual%=0
default_gname$=""
dp_paper_sizes%=FNread_paper_sizes("dp")
lj_paper_sizes%=FNread_paper_sizes("lj")
saveref%=0
printref%=0

REM *** OSS Variables for the paper X and Y offset.
paper_offsets_in_mm% = TRUE
mm_to_inches_multiplier = 0.039375
paper_x_offset = 0
paper_y_offset = 0

SYS"OS_GetEnv" TO E%
REM syntax is BASIC -quit progname [-print] filename
SYS"OS_ReadArgs","/g,quit/s,/g,print/s,/g",E%,task_buff%,256
IFtask_buff%!12=0 THEN
 special_print_file%=FALSE
ELSE
 special_print_file%=TRUE
ENDIF
special_load_file$=""
E%=task_buff%!16
IFE%<>0 THEN
 E1%=!E% AND &FFFF
 E%+=2
 WHILE E1%
  special_load_file$+=CHR$(?E%)
  E%+=1
  E1%-=1
 ENDWHILE
ENDIF
ENDPROC
:
DEFFNread_paper_sizes(root$)
LOCAL f%,ptr%,last_ptr%,f$,block%,flags%
ptr%=0:last_ptr%=0
SYS"XOS_Find",&40,"Printers:"+root$+".Resources.PaperRO" TO f%;flags%:IF(flags%AND1) f%=0
REM don't use an internal copy of the Paper files
REM IFf%=0 f%=OPENIN("<PrintEdit$Dir>.Paper"+root$)
IFf%=0 ERROR task_fatal%,FNmsg_1("FA2",root$)
WHILE NOT EOF#f%
 f$=GET$#f%
 IFLEFT$(f$,4)="pn: " THEN
  block%=FNheap_claim("PAPR", LEN(f$)+1)
  !block%=0
  $(block%+4)=MID$(f$,5)
  IFlast_ptr%<>0 THEN
    !last_ptr%=block%
  ELSE
    ptr%=block%
  ENDIF
  last_ptr%=block%
 ENDIF
ENDWHILE
CLOSE#f%
=ptr%
:
DEFPROCinitialise_windows
LOCAL i%,j%,W%,H%,xeig%,yeig%
PROCwin_template_open
PROCwin_load_create("","info",1,info%)
PROCwin_load_create("","mapping",1,mapping%)
PROCwin_load_create("","graphics",1,graphics%)
PROCwin_load_create("","chars",1,chars%)
PROCwin_load_create("","text",1,text%)
PROCwin_load_create("","main",1,main%)
PROCwin_load_create("","save",1,save%)
PROCwin_load_create("","warning",1,warning%)
PROCwin_template_close

REM get the definitions of the four mapping icons
REM then delete them from the window
FORi%=0 TO 3
 j%=FNheap_claim("ICDF", 40)
 !j%=chars%:j%!4=i%
 SYS"Wimp_GetIconState",,j%
 SYS"Wimp_DeleteIcon",,j%
 charmap_icdf%(i%)=j%+8
NEXT

PROCicon_write(SHORT%,info%,3,FNmsg_0("_Version"))
PROCwin_open_centre(mapping%):PROCwin_close(mapping%)
PROCwin_open_centre(graphics%):PROCwin_close(graphics%)
PROCwin_open_centre(chars%):PROCwin_close(chars%)
PROCwin_open_centre(text%):PROCwin_close(text%)
PROCwin_open_centre(main%):PROCwin_close(main%)
PROCrestart_everything
REM create an icon on the iconbar
SYS"Wimp_SpriteOp",40,,FNmsg_0("SN") TO,,,W%,H%
SYS"OS_ReadModeVariable",-1,4 TO,,xeig%
SYS"OS_ReadModeVariable",-1,5 TO,,yeig%
!task_buff%=-1
task_buff%!4=0
task_buff%!8=0
task_buff%!12=W%<<xeig%
task_buff%!16=H%<<yeig%
task_buff%!20=&3002
$(task_buff%+24)=FNmsg_0("SN")
SYS"Wimp_CreateIcon",0,task_buff% TO iconbar_handle%
ENDPROC
:
DEFPROCrestart_everything
PROCinit_main_window
PROCrestart_graphics
PROCrestart_text(no_hilit_head%)
PROCrestart_text(draft_hilit_head%)
PROCrestart_text(nlq_hilit_head%)
PROCrestart_mappings
PROCcheck_main_window
got_some_data%=FALSE
ENDPROC
:
DEFPROCredraw_charmapping(node%)
LOCAL y0%,y1%,ptr%
y0%=charmap_icdf%(0)!4
y1%=charmap_icdf%(0)!12
ptr%=charmap_head%
WHILE ptr%<>node%
 y1%=y0%
 y0%-=(charmap_icdf%(0)!12 - charmap_icdf%(0)!4)
 ptr%=!ptr%
ENDWHILE
!win_buff%=chars%:SYS"Wimp_GetWindowState",,win_buff%
SYS"Wimp_ForceRedraw",chars%,0,y0%,win_buff%!12-win_buff%!4,y1%
ENDPROC
:
DEFPROCredraw_window
REM should be only the character mappings window ...
LOCAL more%, node%, y0%, y1%, i%, l%, f%
LOCAL yy1%, yy2%, y%, j%, size%

y0%=charmap_icdf%(0)!4
y1%=charmap_icdf%(0)!12
size%=y1%-y0%

SYS"Wimp_RedrawWindow",,task_buff% TO more%
WHILE more%
 REM find out which vertical region of the window
 REM is being redrawn
 node%=charmap_head%
 y%=task_buff%!16-task_buff%!24
 yy1%=(y%-task_buff%!40) DIV size%
 yy2%=(y%-task_buff%!32) DIV size%
 IF yy1%<0 yy1%=0
 IF yy2%>=yy1% THEN

  REM if we aren't redrawing from the start
  REM shuffle down the list
  y%=0
  IF yy1%<>0 THEN
   FORi%=0 TO yy1%-1
    IFnode% node%=!node%
    y%-=size%
   NEXT
  ENDIF

  REM initialise the icon block to the start offset
  REM FORi%=0 TO 3
  REM  charmap_icdf%(i%)!4=y%-size%
  REM  charmap_icdf%(i%)!12=y%
  REM NEXT

  REM now redraw the bit we've been asked to
  FOR j%=yy1% TO yy2%
   IF node% THEN
    $charmap_icdf%(0)!20=STR$(node%?4)
    $charmap_icdf%(1)!20=CHR$(node%?4)
    $charmap_icdf%(3)!20=$(node%+8)

    REM find out how wide the string is
    SYS"XWimp_TextOp",1,charmap_icdf%(3)!20,0 TO l%;f%
    IF(f%AND1) l%=LEN($charmap_icdf%(3)!20)*16
    charmap_icdf%(3)!8 = charmap_icdf%(3)!0 + l% + 16

    FORi%=0 TO 3
     IF node%?5 THEN
      charmap_icdf%(i%)!16 = charmap_icdf%(i%)!16 OR (1<<21)
     ELSE
      charmap_icdf%(i%)!16 = charmap_icdf%(i%)!16 AND NOT(1<<21)
     ENDIF
     charmap_icdf%(i%)!12=y%
     charmap_icdf%(i%)!4=y%-size%
     SYS"Wimp_PlotIcon",,charmap_icdf%(i%)
    NEXT

    y%-=size%
    IFnode% node%=!node%
   ENDIF
  NEXT
 ENDIF

 SYS "Wimp_GetRectangle",,task_buff% TO more%
ENDWHILE

REM restore the original offsets
FORi%=0 TO 3
 charmap_icdf%(i%)!4=y0%
 charmap_icdf%(i%)!12=y1%
NEXT
ENDPROC
:
DEFPROCopen_window
SYS"Wimp_OpenWindow",,task_buff%
ENDPROC
:
DEFPROCclose_window
IF!task_buff%=main% THEN
 IFmodified% THEN
  doing_shutdown%=6
  !task_buff%=warning%:SYS"Wimp_GetWindowState",,task_buff%
  SYS"OS_ReadModeVariable",-1,4 TO ,,mc_dx%:mc_dx%=1<<mc_dx%
  SYS"OS_ReadModeVariable",-1,5 TO ,,mc_dy%:mc_dy%=1<<mc_dy%
  SYS"OS_ReadModeVariable",-1,11 TO ,,mc_sw%:mc_sw%+=1
  SYS"OS_ReadModeVariable",-1,12 TO ,,mc_sh%:mc_sh%+=1
  scrx%=mc_sw%*mc_dx%
  scry%=mc_sh%*mc_dy%
  c%=(scrx%-(task_buff%!12-task_buff%!4)) DIV 2
  d%=(scry%-(task_buff%!8-task_buff%!16)) DIV 2
  SYS"Wimp_CreateMenu",,warning%,c%,d%
  ENDPROC
 ENDIF
 !task_buff%=main%:SYS"Wimp_CloseWindow",,task_buff%
 PROCrestart_everything
ELSE
 IF!task_buff%=text% text_ptr%=0
 SYS"Wimp_CloseWindow",,task_buff%
ENDIF
ENDPROC
:
DEFPROCack
IFtask_buff%!16=&80142 THEN
 ERROR task_ok%,FNmsg_0("OKS")
ENDIF
ENDPROC
:
DEFPROCreceive(r%)
LOCAL s$,i%,ref%
CASE task_buff%!16 OF
WHEN 0: PROChost_shutdown
WHEN 2: PROCsave_datasaveack(task_buff%)
WHEN 3: IFtask_buff%!40=&FC6 THEN
         PROCdataloadack
         PROCrestart_everything
         PROCload_file
         PROCcheck_main_window
         PROCopen_main_window
        ELSE
         ERROR task_ok%,FNmsg_0("OKN")
        ENDIF
WHEN 8: IFmodified% THEN
         IF!task_buff%<>20 THEN
          IF(task_buff%!20 AND 1)=0 doing_shutdown%=4 ELSE doing_shutdown%=2
         ELSE
          doing_shutdown%=4
         ENDIF
         task_buff%!12=task_buff%!8
         SYS"Wimp_SendMessage",19,task_buff%,task_buff%!4
         REM since the modified flag is setting, calling
         REM PROChost_shutdown will cause the warning window
         REM to open :-)
         PROChost_shutdown
        ENDIF
WHEN &502: PROCdetermine_help
WHEN &400C0: CASE task_buff%!32 OF
             WHEN 0: PROCwin_title(mapping%,FNmsg_0("TI7"))
                     i%=charmap_head%
                     WHILE i%
                      IFi%?5 THEN
                       PROCicon_write(SHORT%,mapping%,2,CHR$(i%?4))
                       PROCicon_write(SHORT%,mapping%,3,$(i%+8))
                       PROCicon_button_type(mapping%,2,0)
                       PROCicon_validation(mapping%,2,"Krat")
                       i%=0
                      ENDIF
                      IFi% i%=!i%
                     ENDWHILE
             WHEN 3: PROCwin_title(mapping%,FNmsg_0("TI8"))
                     PROCicon_write(SHORT%,mapping%,2,"")
                     PROCicon_write(SHORT%,mapping%,3,"")
                     PROCicon_button_type(mapping%,2,15)
                     PROCicon_validation(mapping%,2,"Krat;Pptr_write")
             ENDCASE
             SYS"Wimp_CreateSubMenu",,task_buff%!20,task_buff%!24,task_buff%!28
WHEN &400C9: IFtask_buff%!20=save% doing_shutdown%=0:ENDPROC
             IFtask_buff%!20=warning% THEN
              IFdoing_shutdown%<>5 AND doing_shutdown%<>3 AND doing_shutdown%<>1 THEN
               REM 1 or 3 or 5 means that we had moved onto the save dbox
               doing_shutdown%=0
              ENDIF
              ENDPROC
             ENDIF
             PROCcancel_menued_item
WHEN &400CF: REM Font changed
             PROCreset_mapping_extent
WHEN &80145: REM PrintTypeOdd
             IF NOTgot_some_data% AND task_buff%!40=&FC6 THEN
              i%=task_buff%!4:ref%=task_buff%!8
              PROCload_file
              PROCcheck_main_window
              PROCprint_file("<Printer$Temp>")
              task_buff%!0=20
              task_buff%!12=ref%
              task_buff%!16=&80146
              SYS"Wimp_SendMessage",17,task_buff%,i%
              PROCrestart_everything
             ENDIF
ENDCASE
ENDPROC
:
DEFPROCdetermine_help
LOCAL s$,t$
CASE task_buff%!32 OF
WHEN   -2: s$=FNmsg_0("ICON")
WHENinfo%: s$=FNmsg_0("INFO")
WHENtext%: s$=FNmsg_0("TEXT"+STR$(task_buff%!36))
           IFs$="TEXT"+STR$(task_buff%!36) s$=FNmsg_0("TEXT")
WHENmain%: t$="MAIN"+STR$(task_buff%!36)
           CASE task_buff%!36 OF
           WHEN 6,7: IFFNicon_read(SHORT%,main%,10)="lj" t$+="a"
           WHEN 16,17: IFFNicon_read(SHORT%,main%,10)="lj" THEN
                        IFFNicon_set(main%,task_buff%!36) t$+="d" ELSE t$+="c"
                       ELSE
                        IFFNicon_set(main%,task_buff%!36) t$+="b" ELSE t$+="a"
                       ENDIF
           WHEN 18,19,36: IFFNicon_set(main%,task_buff%!36) t$+="b" ELSE t$+="a"
           ENDCASE
           s$=FNmsg_0(t$)
           IFs$=t$ s$=FNmsg_0("MAIN")
WHENsave%: s$=FNmsg_0("SAVE"+STR$(task_buff%!36))
           IFs$="SAVE"+STR$(task_buff%!36) s$=FNmsg_0("SAVE")
WHENchars%: s$=FNmsg_0("CHARS")
WHENmapping%: s$=FNmsg_0("MAPPING"+STR$(task_buff%!36))
              IFs$="MAPPING"+STR$(task_buff%!36) s$=FNmsg_0("MAPPING")
WHENgraphics%: t$="GRAPHICS"+STR$(task_buff%!36)
               CASE task_buff%!36 OF
               WHEN 36,37,38,39,40,41,42,43,80,81,92,93: IFFNicon_set(graphics%,task_buff%!36) t$+="b" ELSE t$+="a"
               ENDCASE
               s$=FNmsg_0(t$)
               IFs$=t$ s$=FNmsg_0("GRAPHICS")
OTHERWISE: IF task_buff%!36<>-1 THEN
            SYS"Wimp_GetMenuState",1,buff1%,task_buff%!32,task_buff%!36
            CASE menu_chsn$ OF
            WHEN "ME2": IF!buff1%=0 s$=FNmsg_0("HME2-0") ELSE s$=FNmsg_0("HME2")
            WHEN "ME3": s$="HME3-"+STR$(!buff1%)
                        SYS"Wimp_WhichIcon",chars%,win_buff%,1<<21,1<<21
                        IF!buff1%=2 THEN
                         IF!win_buff%=-1 s$+="c" ELSE s$+="a"
                        ENDIF
                        IF!buff1%=0 THEN
                         IF!win_buff%=-1 THEN
                          s$+="c"
                         ELSE
                          CASE buff1%!4 OF
                          WHEN 0: IFwin_buff%!4=-1 s$="HME3-0-0a" ELSE s$="HME3-0-0b"
                          WHEN 1: IFwin_buff%!4=-1 s$="HME3-0-1a" ELSE s$="HME3-0-1b"
                          WHEN-1: IFwin_buff%!4=-1 THEN
                                   s$+="a"
                                  ELSE
                                   s$+="b"
                                  ENDIF
                          ENDCASE
                         ENDIF
                        ENDIF
                        s$=FNmsg_0(s$)
             OTHERWISE: s$=FNmsg_0("H"+menu_chsn$+"-"+STR$(!buff1%))
                        IFs$="H"+menu_chsn$+"-"+STR$(!buff1%) s$=FNmsg_0("H"+menu_chsn$)
            ENDCASE
           ENDIF
ENDCASE
IFs$<>"" THEN
 !task_buff%=(25+LEN(s$))ANDNOT3
 task_buff%!12=task_buff%!8
 task_buff%!16=&503
 $(task_buff%+20)=s$+CHR$0
 SYS"Wimp_SendMessage",17,task_buff%,task_buff%!4
ENDIF
ENDPROC
:
DEFPROCdataloadack
task_buff%!12=task_buff%!8
task_buff%!16=4
SYS"Wimp_SendMessage",17,task_buff%,task_buff%!4
ENDPROC
:
DEFPROCload_file
LOCAL t$,x$,y$,updated_version%,save_at%
updated_version%=FALSE
SYS"Hourglass_On"
IFNOT(FNload_file(FNtask_rtoz(task_buff%+44))) THEN
 ERROR task_ok%, FNmsg_1("OK1",FNtask_rtoz(task_buff%+44))
ENDIF
PROCsave_setup(&FC6,FNtask_rtoz(task_buff%+44))
REM in order to keep the display clean, we'll just look for "res:" first
IFFNmatch_line("cl:",t$)=FALSE PROCram_file_error(FNmsg_0("OK6"))
IFFNmatch_line("pr_nme:",t$)=FALSE PROCram_file_error(FNmsg_0("OK6"))
IFFNmatch_line("sh_nme:",t$)=FALSE PROCram_file_error(FNmsg_0("OK6"))
IFFNmatch_line("sp_nme:",t$)=FALSE PROCram_file_error(FNmsg_0("OK6"))
IFFNmatch_line("res:",t$)=FALSE PROCram_file_error(FNmsg_0("OK6"))
PROCwrite_data_ptr(0)
IFFNmatch_line("cl:",t$) PROCicon_write(SHORT%,main%,10,t$)
IFFNmatch_line("pr_nme:",t$) PROCicon_write(SHORT%,main%,11,t$)
IFFNmatch_line("sh_nme:",t$) PROCicon_write(SHORT%,main%,12,t$)
IFFNmatch_line("sp_nme:",t$) PROCicon_write(SHORT%,main%,13,t$)
IFFNmatch_line("res:",t$) PROCload_graphics(t$,updated_version%)
IFFNmatch_line("txt_cds:",t$) THEN
 PROCload_text(t$)
 IFFNmatch_line("chars: char_maps:",t$) PROCload_charmaps
ENDIF
PROCicon_deselect(main%,36)
IFFNmatch_line("default_paper_size:",t$) THEN
 PROCicon_write(SHORT%,main%,27,t$)
 IFFNmatch_line("default_xresolution:",x$) AND FNmatch_line("default_yresolution:",y$) THEN
  default_xres%=VAL(x$):default_yres%=VAL(y$)
  IFFNmatch_line("default_quality:",t$) THEN
   default_qual%=EVAL(t$)
   PROCicon_write(SHORT%,main%,33,FNquality_number_to_string(default_qual%))
   IF FNmatch_line("supports_fast_parallel:",t$) THEN
    IFVAL(t$)<>0 PROCicon_select(main%,36)
    IF FNmatch_line("default_gname:",t$) THEN default_gname$ = t$
   ENDIF
  ENDIF
 ENDIF
ENDIF
IF default_gname$ <> "" THEN
  PROCicon_write(SHORT%,main%,30,default_gname$)
ELSE
  IFdefault_xres%<>0 AND default_yres%<>0 PROCicon_write(SHORT%,main%,30,FNmsg_2("RES",x$,y$))
ENDIF
REM
REM Look for two comments at the end of the file which hold the REAL paper X and Y offsets
REM Note that they are stored in inches :-)
WHILE NOTFNdata_eof
 s$=FNread_string
 IFLEFT$(s$,19)="# Paper X offset = " THEN paper_x_offset = VAL(MID$(s$,20))
 IFLEFT$(s$,19)="# Paper Y offset = " THEN paper_y_offset = VAL(MID$(s$,20))
ENDWHILE

save_at% = @%
IF paper_offsets_in_mm% THEN
 @% = "+F10"+decimal_point$+"2"
 paper_x_offset = paper_x_offset / mm_to_inches_multiplier
 paper_y_offset = paper_y_offset / mm_to_inches_multiplier
ELSE
 @% = "+F10"+decimal_point$+"3"
ENDIF
PROCicon_write(SHORT%,main%,22,STR$(paper_x_offset))
PROCicon_write(SHORT%,main%,23,STR$(paper_y_offset))
@% = save_at%
REM
PROCrelease_file
got_some_data%=TRUE
SYS"Hourglass_Off"

IF updated_version% THEN
 PROCerror_box(FNmsg_0("OK8"),1)
 PROCmodified
 PROCwin_close(graphics%)
ENDIF
ENDPROC
:
DEFFNquality_number_to_string(n%)
LOCAL co%,ht%
IFn%=0 :=""
co%=n% AND &FF
ht%=(n% AND &FF00)>>8
=FNmsg_0("CO"+STR$(co%))+", "+FNmsg_0("HT"+STR$(ht%))
:
DEFPROCrestart_graphics
LOCAL i%
WHILE graphics_head%
 PROCheap_free("STRG",graphics_head%!4)
 PROCheap_free("INTG",graphics_head%!8)
 PROCheap_free("STRG",graphics_head%!12)
 PROCheap_free("INTG",graphics_head%!16)
 PROCheap_free("INTG",graphics_head%!20)
 PROCheap_free("INTG",graphics_head%!24)
 PROCheap_free("GSTR",graphics_head%!28)
 PROCheap_free("INTG",graphics_head%!32)
 PROCheap_free("STRG",graphics_head%!36)
 PROCheap_free("STRG",graphics_head%!40)
 FOR i%=44 TO 44+20*4-4 STEP 4
  PROCheap_free("LONG",graphics_head%!i%)
 NEXT
 i%=!graphics_head%
 PROCheap_free("GRPH",graphics_head%)
 graphics_head%=i%
ENDWHILE
PROCicon_write(SHORT%,main%,14,"0")
PROCicon_write(SHORT%,main%,30,"")
PROCicon_write(SHORT%,main%,33,"")
PROCwin_close(graphics%)
ENDPROC
:
DEFPROCload_graphics(t$,RETURN updated_version%)
LOCAL num%,i%,p%,q%
LOCAL mod_name$,mod_num%,pal$,opt%,pxres%,pyres%,data$,flags%
LOCAL gname$,gcalib$
LOCAL data1$,data2$,data3$,data4$,data5$,data6$,data7$,data8$
LOCAL data9$,data10$,data11$,data12$,data13$,data14$,data15$
LOCAL data16$,data17$,data18$,data19$,data20$
LOCAL a%,b%
num%=VAL(t$)
FORi%=1 TO num%
 data1$="":data2$="":data3$="":data4$="":data5$="":data6$=""
 data7$="":data8$="":data9$="":data10$="":data11$="":data12$=""
 data13$="":data14$="":data15$="":data16$="":data17$="":data18$=""
 data19$="":data20$="":data$=""
 IFNOT(FNmatch_line("g_mode:",t$)) PROCram_file_error(FNmsg_0("OK7"))
 IFNOT(FNmatch_line("module: dumpers:",t$)) PROCram_file_error(FNmsg_0("OK7"))
 IFFNmatch_line("number:",t$) mod_num%=FNevaluate(t$) ELSE PROCram_file_error(FNmsg_0("OK7"))
 IFFNmatch_line("name:",t$) mod_name$=t$ ELSE PROCram_file_error(FNmsg_0("OK7"))
 IFFNmatch_line("palette:",t$) pal$=t$ ELSE PROCram_file_error(FNmsg_0("OK7"))
 IFFNmatch_line("options:",t$) opt%=FNevaluate(t$) ELSE PROCram_file_error(FNmsg_0("OK7"))
 IFFNmatch_line("pxres:",t$) pxres%=FNevaluate(t$) ELSE PROCram_file_error(FNmsg_0("OK7"))
 IFFNmatch_line("pyres:",t$) pyres%=FNevaluate(t$) ELSE PROCram_file_error(FNmsg_0("OK7"))
 IFFNmatch_line("data:",t$) THEN data$=t$ ELSE PROCram_file_error(FNmsg_0("OK7"))
 IFFNmatch_line("flags:",t$) flags%=FNevaluate(t$) ELSE PROCram_file_error(FNmsg_0("OK7"))
 IF (flags% >>> 24) >= 4 THEN
   REM we expect gname,gcalib fields for version >= 4
   IFFNmatch_line("gname:",t$) gname$=t$ ELSE PROCram_file_error(FNmsg_0("OK7"))
   IFFNmatch_line("gcalib:",t$) gcalib$=t$ ELSE PROCram_file_error(FNmsg_0("OK7"))
   a%=FNread_data_ptr
 ELSE
   gname$=""
   gcalib$=""
 ENDIF
 REM Claim the memory up front,so long strings don't have to linger in longstring%
 REM If something fails,it can be released later
 p%=FNheap_claim("GRPH",44+20*4)
 IF (flags% >>> 24) >= 5 THEN
   REM All manner of dumpstrings for version >= 5
   REM Note you can't mix and match,if data1 is there then *all* must be there
   IFFNmatch_line("data1:",t$) THENok%=TRUE ELSEok%=FALSE
   IFok% THEN
    PROCwrite_data_ptr(a%):REM Rewind a line
    IFok% THENok%=FNload_long_dumpstring("data1:",p%,44)
    IFok% THENok%=FNload_long_dumpstring("data2:",p%,48)
    IFok% THENok%=FNload_long_dumpstring("data3:",p%,52)
    IFok% THENok%=FNload_long_dumpstring("data4:",p%,56)
    IFok% THENok%=FNload_long_dumpstring("data5:",p%,60)
    IFok% THENok%=FNload_long_dumpstring("data6:",p%,64)
    IFok% THENok%=FNload_long_dumpstring("data7:",p%,68)
    IFok% THENok%=FNload_long_dumpstring("data8:",p%,72)
    IFok% THENok%=FNload_long_dumpstring("data9:",p%,76)
    IFok% THENok%=FNload_long_dumpstring("data10:",p%,80)
    IFok% THENok%=FNload_long_dumpstring("data11:",p%,84)
    IFok% THENok%=FNload_long_dumpstring("data12:",p%,88)
    IFok% THENok%=FNload_long_dumpstring("data13:",p%,92)
    IFok% THENok%=FNload_long_dumpstring("data14:",p%,96)
    IFok% THENok%=FNload_long_dumpstring("data15:",p%,100)
    IFok% THENok%=FNload_long_dumpstring("data16:",p%,104)
    IFok% THENok%=FNload_long_dumpstring("data17:",p%,108)
    IFok% THENok%=FNload_long_dumpstring("data18:",p%,112)
    IFok% THENok%=FNload_long_dumpstring("data19:",p%,116)
    IFok% THENok%=FNload_long_dumpstring("data20:",p%,120)
    IF NOTok%  PROCheap_free("GRPH",p%):PROCram_file_error(FNmsg_0("OK7"))
   ELSE
    PROCwrite_data_ptr(a%):REM Rewind a line
   ENDIF
 ELSE
   REM Old format file,at least zero the array
   FORok%=44TO120STEP4:p%!ok%=0:NEXT
 ENDIF
 REM Now fill in the other bits and pieces
 !p%=0
 p%!4=FNstore_string(mod_name$,2)
 p%!8=FNstore_integer(mod_num%)
 p%!12=FNstore_string(pal$,2)
 p%!16=FNstore_integer(opt%)
 p%!20=FNstore_integer(pxres%)
 p%!24=FNstore_integer(pyres%)
 p%!28=FNstore_string(data$,4):REM gstrans it
 p%!32=FNstore_integer(flags%)
 p%!36=FNstore_string(gname$,2)
 p%!40=FNstore_string(gcalib$,2)
 REM Because the x and y paper offsets are held at pixel resolution
 REM we no longer update the window from these values, unless
 REM the two 'comments' at the end can't be found, in which case
 REM we use the last read values
 IF (flags% >>> 24) >= 3 THEN
  REM Read left and top offset if data version is three or greater.
  paper_x_offset = !(p%!28 + 1 + dp_data_left_offset%)/pxres%
  paper_y_offset = !(p%!28 + 1 + dp_data_top_offset%)/pyres%
 ENDIF

 PROCinsert_graphics_entry(p%,"")

 REM If the data version isn't the latest, decode
 REM and re-encode the data
 IF updated_version% OR (flags% >>> 24) <> 5 THEN
   PROCopen_graphics_window(p%)
   PROCsave_graphics
   updated_version%=TRUE
 ENDIF
NEXT
ENDPROC
:
DEFPROCinsert_graphics_entry(ptr%,gname$)
LOCAL i%,last%,gn$
REM Add an entry to the graphics popup menu
i%=VAL(FNicon_read(SHORT%,main%,14))+1
PROCicon_write(SHORT%,main%,14,STR$(i%))
i%=graphics_head%:last%=0
IF gname$="" THEN
  WHILE i%
    last%=i%
    i%=!i%
  ENDWHILE
ELSE
  WHILE i%
    gn$=$(i%!36):IF gn$="" THEN gn$=STR$(i%!20)+STR$(i%!24)
    IF gn$<gname$ THEN
      last%=i%
      i%=!i%
    ELSE
      i%=0
    ENDIF
  ENDWHILE
ENDIF
IFlast% THEN
 !ptr%=!last%
 !last%=ptr%
ELSE
 !ptr%=graphics_head%
 graphics_head%=ptr%
ENDIF
ENDPROC
:
DEFPROCrestart_text(p%)
LOCAL i%
FORi%=0 TO 23
 IFp%!(i%*4)<>0 PROCheap_free("GSTR",p%!(i%*4)):p%!(i%*4)=0
NEXT
CASE p% OF
WHEN    no_hilit_head%: got_no_hilits%=FALSE:PROCicon_deselect(main%,16)
WHEN draft_hilit_head%: got_draft_hilits%=FALSE:PROCicon_deselect(main%,17)
WHEN   nlq_hilit_head%: got_nlq_hilits%=FALSE:PROCicon_deselect(main%,18)
ENDCASE
ENDPROC
:
DEFPROCload_text(t$)
LOCAL i%,j%
i%=VAL(t$)
IFi%<>0 THEN
 FORj%=1 TO i%
  IFFNmatch_line("t_mode:",t$) THEN
   CASE j% OF
   WHEN 1: got_no_hilits%=TRUE
           PROCread_text(no_hilit_head%)
   WHEN 2: got_draft_hilits%=TRUE
           PROCread_text(draft_hilit_head%)
   WHEN 3: got_nlq_hilits%=TRUE
           PROCread_text(nlq_hilit_head%)
   ENDCASE
   PROCicon_select(main%,15+j%)
  ELSE
   PROCram_file_error(FNmsg_0("OK7"))
  ENDIF
 NEXT
ENDIF
ENDPROC
:
DEFPROCread_text(p%)
LOCAL t$
IF FNmatch_line("t_page_lines:",t$) p%!0=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_08:",t$)         p%!4=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_09:",t$)         p%!8=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_0C:",t$)         p%!12=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_0D:",t$)         p%!16=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_0D0A:",t$)       p%!20=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_start:",t$)      p%!24=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_end:",t$)        p%!28=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_pica:",t$)       p%!32=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_elite:",t$)      p%!36=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_condensed:",t$)  p%!40=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_expanded:",t$)   p%!44=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_b_on:",t$)       p%!48=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_b_off:",t$)      p%!52=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_i_on:",t$)       p%!56=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_i_off:",t$)      p%!60=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_l_on:",t$)       p%!64=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_l_off:",t$)      p%!68=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_sup_on:",t$)     p%!72=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_sup_off:",t$)    p%!76=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_sub_on:",t$)     p%!80=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_sub_off:",t$)    p%!84=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_u_on:",t$)       p%!88=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
IF FNmatch_line("t_u_off:",t$)      p%!92=FNstore_string(t$,4) ELSE PROCram_file_error(FNmsg_0("OK7"))
ENDPROC
:
DEFPROCcancel_menued_item
LOCAL p%,i%,ic%
IFmenu_chsn$="ME3" THEN
 p%=charmap_head%:i%=0
 WHILE p%
  IFp%?5 THEN
   ic%=p%:REM remember this node
   i%+=1
   IFi%=2 p%=0:REM we've got a selection
  ENDIF
  IFp% p%=!p%
 ENDWHILE
 IFi%=1 ic%?5=0:PROCredraw_charmapping(ic%)
ENDIF
ENDPROC
:
DEFPROChost_shutdown
LOCAL c%,d%
LOCAL mc_dx%,mc_dy%,mc_sw%,mc_sh%,scrx%,scry%
IFmodified% THEN
 !task_buff%=warning%:SYS"Wimp_GetWindowState",,task_buff%
 SYS"OS_ReadModeVariable",-1,4 TO ,,mc_dx%:mc_dx%=1<<mc_dx%
 SYS"OS_ReadModeVariable",-1,5 TO ,,mc_dy%:mc_dy%=1<<mc_dy%
 SYS"OS_ReadModeVariable",-1,11 TO ,,mc_sw%:mc_sw%+=1
 SYS"OS_ReadModeVariable",-1,12 TO ,,mc_sh%:mc_sh%+=1
 scrx%=mc_sw%*mc_dx%
 scry%=mc_sh%*mc_dy%
 c%=(scrx%-(task_buff%!12-task_buff%!4)) DIV 2
 d%=(scry%-(task_buff%!8-task_buff%!16)) DIV 2
 SYS"Wimp_CreateMenu",,warning%,c%,d%
 ENDPROC
ENDIF
PROCmsg_end
PROCtask_shutdown
REM never returns ...
ENDPROC
:
DEFPROCkeypress
IFtask_buff%!24=13 THEN
 CASE !task_buff% OF
 WHEN     main%: IFmain_string$<>FNicon_read(SHORT%,main%,task_buff%!4) THEN
                  PROCmodified
                  IFtask_buff%!4=10 PROCcheck_main_window
                 ENDIF
                 CASE task_buff%!4 OF
                 WHEN 10: PROCcaret_set(main%,11)
                 WHEN 11: PROCcaret_set(main%,12)
                 WHEN 12: PROCcaret_set(main%,13)
                 WHEN 13: PROCcaret_set(main%,22)
                 WHEN 22: PROCcaret_set(main%,23):REM OSS Paper X offset
                 WHEN 23: PROCcaret_set(main%,10):REM OSS Paper Y offset
                 ENDCASE
 WHEN  mapping%: PROCcreate_mapping
 WHEN     save%: PROCsave_file(FALSE,"")
 WHEN graphics%: PROCsave_graphics
                 PROCmodified
                 PROCwin_close(graphics%)
 WHEN     text%: PROCsave_text
                 PROCmodified
                 PROCwin_close(text%)
 ENDCASE
ELSE
 SYS"Wimp_ProcessKey",task_buff%!24
ENDIF
ENDPROC
:
DEFPROCrestart_mappings
LOCAL i%
IFcharmap_count%=0 ENDPROC
WHILE charmap_head%
 REM a character mapping consists of the character
 REM value (a byte), a flags byte, 2 wasted bytes and
 REM the mapping string
 i%=!charmap_head%
 PROCheap_free("CMAP",charmap_head%)
 charmap_head%=i%
ENDWHILE
charmap_count%=0
PROCreset_mapping_extent
PROCicon_deselect(main%,19)
ENDPROC
:
DEFPROCload_charmaps
LOCAL i%,n%,t$,v%,v$,last%,node%
IFNOT(FNmatch_line("char:",t$)) PROCram_file_error(FNmsg_0("OK7"))
n%=VAL(t$)
last%=0
FORi%=1 TO n%
 IFNOT(FNmatch_line("",t$)) PROCram_file_error(FNmsg_0("OK7"))
 SYS"OS_GSTrans",t$,buff1%,256 TO ,,p%
 v%=?buff1%
 IFv%<>0 THEN
  REM PJC: a mapping of character 0 is a special one
  REM Since it isn't legal anyway, we can spot it
  ?buff1%=p%-1
  v$=FNdecode_string(buff1%,SHORT%)
  node%=FNheap_claim("CMAP",9+LEN(v$))
  !node%=0
  node%!4=v%:REM automagically set the flag and wasted bytes to 0
  $(node%+8)=v$
  IF last% THEN !last%=node% ELSE charmap_head%=node%
  charmap_count%+=1
  last%=node%
 ENDIF
NEXT
IF charmap_count% PROCicon_select(main%,19)
PROCreset_mapping_extent
PROCunmodified:REM ... 'cos the software is screwy!
ENDPROC
:
DEFPROCcreate_mapping
LOCAL i%,s$,p%,t$,last%,next%
s$=FNicon_read(SHORT%,mapping%,2)
t$=FNicon_read(SHORT%,mapping%,3)
IFLEN(s$)=1 i%=ASC(s$) ELSE i%=VAL(s$)
IFi%<32 ERROR task_ok%, FNmsg_0("OKV")
REM validate the mapping string
s$=FNencode_string(SHORT%,t$,"",STR$(i%+1))
SYS"Wimp_CreateMenu",,-1

p%=charmap_head%
last%=0
WHILE p%
 IFp%?4=i% THEN
  REM a replacement definition
  REM free the existing one and relink in
  REM the new definition
  next%=!p%
  PROCheap_free("CMAP",p%)
  p%=FNheap_claim("CMAP",9+LEN(t$))
  !p%=next%
  p%!4=i%:REM automagically reset the flag/wasted bytes
  $(p%+8)=t$
  IF last% THEN !last%=p% ELSE charmap_head%=p%
  PROCreset_mapping_extent
  PROCmodified
  PROCredraw_whole_window
  ENDPROC
 ENDIF
 IFp%?4>i% THEN
  REM gone too far
  REM insert the new definition
  p%=FNheap_claim("CMAP",9+LEN(t$))
  IF last% THEN !p%=!last%:!last%=p% ELSE !p%=charmap_head%:charmap_head%=p%
  p%!4=i%:REM automagically reset the flag/wasted bytes
  $(p%+8)=t$
  charmap_count%+=1
  PROCreset_mapping_extent
  PROCmodified
  PROCredraw_whole_window
  ENDPROC
 ENDIF
 last%=p%
 p%=!p%
ENDWHILE
REM if we get to here, we missed it!
REM ergo, it must go at the end
p%=FNheap_claim("CMAP",9+LEN(t$))
!p%=0
p%!4=i%:REM automagically reset the flag/wasted bytes
$(p%+8)=t$
IF last% THEN !last%=p% ELSE charmap_head%=p%
charmap_count%+=1
PROCreset_mapping_extent
PROCmodified
PROCredraw_whole_window
ENDPROC
:
DEFPROCdelete_selected_mappings
LOCAL last%, node%
node%=charmap_head%
last%=0
WHILE node%
 IF node%?5 THEN
  IF last% THEN !last%=!node% ELSE charmap_head%=!node%
  PROCheap_free("CMAP", node%)
  charmap_count%-=1
  IF last% THEN node%=last% ELSE node%=charmap_head%
 ELSE
  last% = node%
  node% = !node%
 ENDIF
ENDWHILE
PROCreset_mapping_extent
PROCmodified
PROCredraw_whole_window
ENDPROC
:
DEFPROCredraw_whole_window
LOCAL x0%,x1%,y0%,y1%
!win_buff%=chars%
SYS"Wimp_GetWindowState",,win_buff%
IF(win_buff%!32 AND (1<<16))<>0 THEN
 x0%=win_buff%!20
 y0%=win_buff%!8-win_buff%!16+win_buff%!24
 x1%=win_buff%!20+win_buff%!12-win_buff%!4
 y1%=win_buff%!24
 SYS"Wimp_ForceRedraw",chars%,x0%,y0%,x1%,y1%
ENDIF
ENDPROC
:
DEFPROCreset_mapping_extent
LOCAL i%,x%,l%,node%,f%
node%=charmap_head%
WHILE node%
 SYS"XWimp_TextOp",1,node%+8,0 TO l%;f%
 IF(f%AND1) l%=LEN($(node%+8))*16
 IFl%>x% x%=l%
 node%=!node%
ENDWHILE
IFx%<32 x%=32
!task_buff%=0
task_buff%!4=-charmap_count%*44
task_buff%!8=x%+charmap_icdf%(3)!0+16
task_buff%!12=0
SYS"Wimp_SetExtent",chars%,task_buff%
REM reopen the window if it is currently open
!win_buff%=chars%:SYS"Wimp_GetWindowState",,win_buff%
IF(win_buff%!32 AND (1<<16)) SYS"Wimp_OpenWindow",,win_buff%
ENDPROC
:
DEFPROCconvert_to_mm
LOCAL @%,paper_x_offset,paper_y_offset
REM *** OSS Ensure mm
paper_x_offset = FNlocale_val(FNicon_read(SHORT%,main%,22)) / mm_to_inches_multiplier
paper_y_offset = FNlocale_val(FNicon_read(SHORT%,main%,23)) / mm_to_inches_multiplier
@%="+F10"+decimal_point$+"2"
PROCicon_write(SHORT%,main%,22,STR$(paper_x_offset))
PROCicon_write(SHORT%,main%,23,STR$(paper_y_offset))
paper_offsets_in_mm% = TRUE
ENDPROC
:
DEFPROCconvert_to_inches
LOCAL @%,paper_x_offset,paper_y_offset
REM *** OSS Ensure inches
paper_x_offset = FNlocale_val(FNicon_read(SHORT%,main%,22)) * mm_to_inches_multiplier
paper_y_offset = FNlocale_val(FNicon_read(SHORT%,main%,23)) * mm_to_inches_multiplier
@%="+F10"+decimal_point$+"3"
PROCicon_write(SHORT%,main%,22,STR$(paper_x_offset))
PROCicon_write(SHORT%,main%,23,STR$(paper_y_offset))
paper_offsets_in_mm% = FALSE
ENDPROC
:
DEFPROCmouseclick
CASE task_buff%!8 OF
WHEN &40: IFtask_buff%!12=save% PROCsave_dragicon(!task_buff%,task_buff%!4)
WHEN 2: CASE task_buff%!12 OF
        WHEN  main%: CASE task_buff%!16 OF
                     WHEN 15: PROCmenu("ME2",TRUE,TRUE)
                     WHEN 28: PROCmenu("ME4",TRUE,TRUE)
                     WHEN 31: PROCmenu("ME5",TRUE,TRUE)
                     WHEN 34: PROCmenu("ME6",TRUE,TRUE)
                     OTHERWISE PROCmenu("ME7",TRUE,FALSE)
                     ENDCASE
        WHEN chars%: PROCmenu("ME3",TRUE,FALSE)
        WHEN     -2: PROCmenu("ME1",TRUE,FALSE)
        ENDCASE
WHEN 4: CASE task_buff%!12 OF
        WHEN    -2: PROCopen_main_window
        WHEN main%: CASE task_buff%!16 OF
                    WHEN 6: PROCopen_text_window(no_hilit_head%)
                    WHEN 7: PROCopen_text_window(draft_hilit_head%)
                    WHEN 8: PROCopen_text_window(nlq_hilit_head%)
                    WHEN 9: PROCwin_open(chars%)
                    WHEN15: PROCmenu("ME2",TRUE,TRUE)
                    WHEN16: PROCcheck_main_window
                    WHEN17: IFFNicon_set(main%,17) PROCicon_select(main%,16):REM must have no highlights as well
                            PROCcheck_main_window
                    WHEN18: IFFNicon_set(main%,18) PROCicon_select(main%,16):PROCicon_select(main%,17)
                            PROCcheck_main_window
                    WHEN19: IFFNicon_set(main%,19) PROCicon_select(main%,16)
                            PROCcheck_main_window
                    WHEN24: IF NOT paper_offsets_in_mm% PROCconvert_to_mm
                    WHEN25: IF paper_offsets_in_mm% PROCconvert_to_inches
                    WHEN28: PROCmenu("ME4",TRUE,TRUE)
                    WHEN31: PROCmenu("ME5",TRUE,TRUE)
                    WHEN34: PROCmenu("ME6",TRUE,TRUE)
                    ENDCASE
        WHEN warning%: SYS"Wimp_CreateMenu",,-1
                       CASE task_buff%!16 OF
                       WHEN 1: REM discard
                               PROCunmodified
                               IFdoing_shutdown%=2 PROChost_shutdown
                               IFdoing_shutdown%=4 SYS"Wimp_ProcessKey",&1FC
                               IFdoing_shutdown%=6 !task_buff%=main%:PROCclose_window
                       WHEN 3: REM save
                               IFdoing_shutdown%=2 doing_shutdown%=1
                               IFdoing_shutdown%=4 doing_shutdown%=3
                               IFdoing_shutdown%=6 doing_shutdown%=5
                               SYS"Wimp_CreateMenu",,save%,!task_buff%,task_buff%!4
                       ENDCASE
        WHEN graphics%: CASE task_buff%!16 OF
                        WHEN41: IFFNicon_set(graphics%,41) THEN
                                  PROCicon_select(graphics%,42)
                                ELSE
                                  PROCicon_deselect(graphics%,42)
                                ENDIF
                        WHEN42: IFFNicon_set(graphics%,42) THEN
                                  PROCicon_select(graphics%,41)
                                ELSE
                                  PROCicon_deselect(graphics%,41)
                                ENDIF
                        WHEN77: PROCicon_select(graphics%,77)
                        WHEN78: PROCicon_select(graphics%,78)
                        WHEN83: PROCsave_graphics
                                PROCcheck_quality_validity
                                PROCmodified
                                PROCwin_close(graphics%)
                        WHEN86: PROCdelete_graphics
                                PROCcheck_quality_validity
                                PROCmodified
                                PROCwin_close(graphics%)
                        ENDCASE
        WHEN text%: IFtask_buff%!16=47 THEN
                     PROCsave_text
                     PROCmodified
                     PROCwin_close(text%)
                    ENDIF
        WHEN save%: IFtask_buff%!16=save_ok% THEN
                     PROCsave_file(FALSE,"")
                    ENDIF
        ENDCASE
WHEN 1: CASE task_buff%!12 OF
        WHEN graphics%: CASE task_buff%!16 OF
                        WHEN77: PROCicon_select(graphics%,77)
                        WHEN78: PROCicon_select(graphics%,78)
                        WHEN83: PROCsave_graphics
                                PROCcheck_quality_validity
                                PROCmodified
                        ENDCASE
        WHEN     text%: IFtask_buff%!16=47 PROCsave_text:PROCmodified
        WHEN     main%: CASE task_buff%!16 OF
                        WHEN24: IF NOT paper_offsets_in_mm% PROCconvert_to_mm
                        WHEN25: IF paper_offsets_in_mm% PROCconvert_to_inches
                        ENDCASE
                        IF task_buff%!16=24 OR task_buff%!16=25 THEN
                          PROCicon_select(main%,task_buff%!16)
                        ENDIF
        ENDCASE
ENDCASE
ENDPROC
:
DEFPROCinit_main_window
PROCsave_setup(&FC6,FNmsg_0("DEFN"))
PROCunmodified
default_xres%=0
default_yres%=0
default_qual%=0
PROCicon_write(SHORT%,main%,10,"")
PROCicon_write(SHORT%,main%,11,"")
PROCicon_write(SHORT%,main%,12,"")
PROCicon_write(SHORT%,main%,13,"")
PROCicon_write(SHORT%,main%,27,"")
PROCicon_deselect(main%,36)
REM *** OSS Set default size as appropriate.
IF paper_offsets_in_mm% THEN
 PROCicon_write(SHORT%,main%,22,"0"+decimal_point$+"00")
 PROCicon_write(SHORT%,main%,23,"0"+decimal_point$+"00")
ELSE
 PROCicon_write(SHORT%,main%,22,"0"+decimal_point$+"000")
 PROCicon_write(SHORT%,main%,23,"0"+decimal_point$+"000")
ENDIF
REM PROCwin_open(main%)
REM PROCcaret_set(main%,10)
ENDPROC
:
DEFPROCopen_main_window
PROCwin_open(main%)
PROCcaret_set(main%,10)
ENDPROC
:
DEFPROCcheck_main_window
IFFNicon_read(SHORT%,main%,10)="lj" THEN
 IFFNicon_read(SHORT%,main%,6)<>FNmsg_0("ICN6b") THEN
  PROCicon_hide(main%,8):PROCicon_hide(main%,18)
  PROCicon_write(SHORT%,main%,6,FNmsg_0("ICN6b"))
  PROCicon_write(SHORT%,main%,7,FNmsg_0("ICN7b"))
 ENDIF
ELSE
 IFFNicon_read(SHORT%,main%,6)<>FNmsg_0("ICN6a") THEN
  PROCicon_unhide(main%,8):PROCicon_unhide(main%,18)
  PROCicon_write(SHORT%,main%,6,FNmsg_0("ICN6a"))
  PROCicon_write(SHORT%,main%,7,FNmsg_0("ICN7a"))
 ENDIF
ENDIF
IFFNicon_set(main%,16) THEN
 PROCicon_unshade(main%,6)
ELSE
 PROCicon_shade(main%,6)
 PROCicon_deselect(main%,17)
 PROCicon_deselect(main%,19)
 IFtext_ptr%=no_hilit_head% PROCwin_close(text%):text_ptr%=0
ENDIF
IFFNicon_set(main%,17) THEN
 PROCicon_unshade(main%,7)
ELSE
 PROCicon_shade(main%,7)
 PROCicon_deselect(main%,18)
 IFtext_ptr%=draft_hilit_head% PROCwin_close(text%):text_ptr%=0
ENDIF
IFFNicon_set(main%,18) THEN
 PROCicon_unshade(main%,8)
ELSE
 PROCicon_shade(main%,8)
 IFtext_ptr%=nlq_hilit_head% PROCwin_close(text%):text_ptr%=0
ENDIF
IFFNicon_set(main%,19) THEN
 PROCicon_unshade(main%,9)
ELSE
 PROCicon_shade(main%,9)
 PROCwin_close(chars%)
ENDIF
ENDPROC
:
DEFPROCunmodified
IFmodified%=FALSE ENDPROC
modified%=FALSE
PROCwin_title(main%,FNmsg_0("TI5"))
ENDPROC
:
DEFPROCmodified
IFmodified% ENDPROC
modified%=TRUE:got_some_data%=TRUE
PROCwin_title(main%,FNmsg_0("TI4"))
ENDPROC
:
DEFPROCopen_text_window(ptr%)
LOCAL i%,lj_class%
lj_class%=(FNicon_read(SHORT%,main%,10)="lj")

text_ptr%=ptr%
IFptr%=no_hilit_head% THEN
 IF lj_class% THEN
  PROCwin_title(text%,FNmsg_0("PMODE"))
 ELSE
  PROCwin_title(text%,FNmsg_0("TI1"))
 ENDIF
ELSE
 IFptr%=draft_hilit_head% THEN
  IF lj_class% THEN
   PROCwin_title(text%,FNmsg_0("LMODE"))
  ELSE
   PROCwin_title(text%,FNmsg_0("TI2"))
  ENDIF
 ELSE
  PROCwin_title(text%,FNmsg_0("TI3"))
 ENDIF
ENDIF
IFptr%=0 THEN
 FORi%=22 TO 45
  PROCicon_write(SHORT%,text%,i%,"")
 NEXT
ELSE
 FORi%=22 TO 45
  PROCicon_write(SHORT%,text%,i%,FNdecode_string(!ptr%,SHORT%)):ptr%+=4
 NEXT
ENDIF
PROCwin_open(text%)
PROCcaret_set(text%,22)
ENDPROC
:
DEFPROCsave_text
LOCAL p%,i%,s$
p%=text_ptr%
FORi%=22 TO 45
 s$=FNicon_read(SHORT%,text%,i%)
 s$=FNencode_string(SHORT%,s$,"TC"+STR$(i%),"")
 PROCreset_string(p%,0,s$,5)
 p%+=4
NEXT
ENDPROC
:
DEFPROCdelete_graphics
LOCAL i%,x%,y%,last%,gn$,f%
i%=graphics_head%
last%=0
x%=VAL(FNicon_read(SHORT%,graphics%,grwric_xres%))
y%=VAL(FNicon_read(SHORT%,graphics%,grwric_yres%))
gn$=FNicon_read(SHORT%,graphics%,grwric_gname%)
WHILE i%
 IF gn$<>"" THEN f% = ($(i%!36) = gn$) ELSE f% = (!(i%!20)=x% AND !(i%!24)=y%)
 IF f% THEN
  IFlast% THEN
   !last%=!i%
  ELSE
   graphics_head%=!i%
  ENDIF
  PROCheap_free("STRG",i%!4)
  PROCheap_free("INTG",i%!8)
  PROCheap_free("STRG",i%!12)
  PROCheap_free("INTG",i%!16)
  PROCheap_free("INTG",i%!20)
  PROCheap_free("INTG",i%!24)
  PROCheap_free("GSTR",i%!28)
  PROCheap_free("INTG",i%!32)
  PROCheap_free("STRG",i%!36)
  PROCheap_free("STRG",i%!40)
  FOR f%=44 TO 44+20*4-4 STEP 4
   PROCheap_free("LONG",i%!f%):REM Free the graphics dump strings
  NEXT
  PROCheap_free("GRPH",i%)
  i%=VAL(FNicon_read(SHORT%,main%,14))-1
  PROCicon_write(SHORT%,main%,14,STR$(i%))
  i%=0
 ELSE
  last%=i%
  i%=!i%
 ENDIF
ENDWHILE
ENDPROC
:
DEFPROCsave_graphics
LOCAL part1$, part2$,i%,ptr%,x%,y%,lj_class%,mult%,div%,skip%,gn$,gn2$,f%
lj_class%=(FNicon_read(SHORT%,main%,10)="lj")
IFLEN(FNicon_read(SHORT%,graphics%,grwric_modnam%))=0 ERROR task_ok%,FNmsg_0("OKG")
IFLEN(FNicon_read(SHORT%,graphics%,grwric_palfile%))=0 ERROR task_ok%,FNmsg_0("OKH")
IF LEN(FNicon_read(SHORT%,graphics%,grwric_zeroskip%))>0 AND LEN(FNicon_read(SHORT%,graphics%,grwric_skipres%))=0 ERROR task_ok%,FNmsg_0("OKQ")
x%=VAL(FNicon_read(SHORT%,graphics%,grwric_xres%))
y%=VAL(FNicon_read(SHORT%,graphics%,grwric_yres%))
gn$=FNicon_read(SHORT%,graphics%,grwric_gname%)
gn2$=gn$: IF gn2$="" THEN gn2$=STR$(x%)+STR$(y%)
IFx%=0 OR y%=0 ERROR task_ok%,FNmsg_0("OKI")
i%=graphics_head%
WHILE i%
 REM are we replacing an existing entry?
 IF gn$<>"" THEN f% = ($(i%!36)=gn$) ELSE f% = (!(i%!20)=x% AND !(i%!24)=y%)
 IF f% THEN
  ptr%=i%
  i%=0
 ELSE
  i%=!i%
 ENDIF
ENDWHILE
IFptr%=0 THEN
 REM No,it's a new one so insert it
 ptr%=FNheap_claim("GRPH",44+20*4)
 !ptr%=0
 ptr%!4=0
 ptr%!8=FNstore_integer(0)
 ptr%!12=0
 ptr%!16=FNstore_integer(0)
 ptr%!20=FNstore_integer(x%)
 ptr%!24=FNstore_integer(y%)
 ptr%!28=0
 ptr%!32=FNstore_integer(0)
 ptr%!36=0
 ptr%!40=0
 PROCinsert_graphics_entry(ptr%,gn2$)
 REM Zero the dump string array
 FORi%=44TO120STEP4:ptr%!i%=0:NEXT
ENDIF
PROCreset_string(ptr%,4,FNicon_read(SHORT%,graphics%,grwric_modnam%),2)
!(ptr%!8)=VAL(FNicon_read(SHORT%,graphics%,grwric_modnum%))
PROCreset_string(ptr%,12,FNicon_read(SHORT%,graphics%,grwric_palfile%),2)
PROCreset_string(ptr%,36,FNicon_read(SHORT%,graphics%,grwric_gname%),2)
PROCreset_string(ptr%,40,FNicon_read(SHORT%,graphics%,grwric_gcalib%),2)
ptr%!20=FNstore_integer(x%)
ptr%!24=FNstore_integer(y%)
i%=0
IFFNicon_set(graphics%,36) i%=i% OR 1
IFFNicon_set(graphics%,37) i%=i% OR 2
IFFNicon_set(graphics%,38) i%=i% OR &10
IFFNicon_set(graphics%,39) i%=i% OR &20
IFFNicon_set(graphics%,40) i%=i% OR &40
IFFNicon_set(graphics%,41) i%=i% OR &100
IFFNicon_set(graphics%,42) i%=i% OR &200
IFFNicon_set(graphics%,43) i%=i% OR &400
IFi%=0 ERROR task_ok%,FNmsg_0("OKP")
!(ptr%!16)=i%
part1$=STRING$(dp_data_text_start%,CHR$(0))
REM SMC,MJS Preserve the flags bits we don't know about (for Tony Cheal
REM of Ace Computing - he uses bits 2-3 for PaintJet/DeskJet500 control).
REM Note that bits 4-6 are ours (we now know about 4)
i% = !(ptr%!32) AND &00FFFF8C
IFlj_class% THEN
 IFFNicon_set(graphics%,80) i%=i% OR 1:REM supports copies command
 IFFNicon_set(graphics%,81) i%=i% OR 2:REM supports compression
 IFFNicon_set(graphics%,41)ORFNicon_set(graphics%,42)ORFNicon_set(graphics%,43) i%=i% OR 32:REM supports colour printing
 IFFNicon_set(graphics%,92) i%=i% OR 16:REM four inks (CMYK data) rather than 3 (RGB data)
 IFFNicon_set(graphics%,93) i%=i% OR 64:REM supports Y Offset raster command
ELSE
 IFFNicon_set(graphics%,77) i%=i% OR 1:REM integrex type output
ENDIF
REM Version is held in top eight bits of the word called
REM pd_private_word (configuration data) by the PDumpers. Version is 5
!(ptr%!32)=(i% OR (5 << 24))
REM Now build the "data:" string which corresponds to the data at +12 within a PDumperReason block
MID$(part1$,dp_dump_depth%+1,1)=CHR$(VAL(FNicon_read(SHORT%,graphics%,grwric_dumpdepth%)))
MID$(part1$,dp_data_dht%+1,1)=CHR$(VAL(FNicon_read(SHORT%,graphics%,grwric_dumpheight%)))
MID$(part1$,dp_x_interlace%+1,1)=CHR$(VAL(FNicon_read(SHORT%,graphics%,grwric_xint%)))
MID$(part1$,dp_data_dlm%+1,1)=CHR$(VAL(FNicon_read(SHORT%,graphics%,grwric_dlm%)))
MID$(part1$,dp_y_interlace%+1,1)=CHR$(VAL(FNicon_read(SHORT%,graphics%,grwric_yint%)))
MID$(part1$,dp_data_dla%+1,1)=CHR$(VAL(FNicon_read(SHORT%,graphics%,grwric_dla%)))
MID$(part1$,dp_data_set_lines%+1,1)=""
MID$(part1$,dp_data_page_start%+1,1)=""
MID$(part1$,dp_data_form_feed%+1,1)=""
MID$(part1$,dp_data_page_end%+1,1)=""
MID$(part1$,dp_data_line_return%+1,1)=""
MID$(part1$,dp_data_line_skip%+1,1)=""
MID$(part1$,dp_data_line_end%+1,1)=""
MID$(part1$,dp_data_line_end_i2%+1,1)=""
MID$(part1$,dp_data_line_end_i3%+1,1)=""
MID$(part1$,dp_data_zero_skip%+1,1)=""
MID$(part1$,dp_data_line_start%+1,1)=""
MID$(part1$,dp_data_line_start_2%+1,1)=""
MID$(part1$,dp_data_pass1_start%+1,1)=""
MID$(part1$,dp_data_pass1_start_2%+1,1)=""
MID$(part1$,dp_data_pass2_start%+1,1)=""
MID$(part1$,dp_data_pass2_start_2%+1,1)=""
MID$(part1$,dp_data_pass3_start%+1,1)=""
MID$(part1$,dp_data_pass3_start_2%+1,1)=""
MID$(part1$,dp_data_pass4_start%+1,1)=""
MID$(part1$,dp_data_pass4_start_2%+1,1)=""
PROCreset_string(ptr%,44,FNstore_graphics_new(grwric_setlines%),6)
PROCreset_string(ptr%,48,FNstore_graphics_new(grwric_pagestart%),6)
PROCreset_string(ptr%,52,FNstore_graphics_new(grwric_formfeed%),6)
PROCreset_string(ptr%,56,FNstore_graphics_new(grwric_pageend%),6)
PROCreset_string(ptr%,60,FNstore_graphics_new(grwric_linereturn%),6)
PROCreset_string(ptr%,64,FNstore_graphics_new(grwric_lineskip%),6)
PROCreset_string(ptr%,68,FNstore_graphics_new(grwric_lineend1%),6)
PROCreset_string(ptr%,72,FNstore_graphics_new(grwric_lineend2%),6)
PROCreset_string(ptr%,76,FNstore_graphics_new(grwric_lineend3%),6)
PROCreset_string(ptr%,80,FNstore_graphics_new(grwric_zeroskip%),6)
PROCreset_string(ptr%,84,FNstore_graphics_new(grwric_linestart1%),6)
PROCreset_string(ptr%,88,FNstore_graphics_new(grwric_linestart2%),6)
PROCreset_string(ptr%,92,FNstore_graphics_new(grwric_linepass1%),6)
PROCreset_string(ptr%,96,FNstore_graphics_new(grwric_linepass1b%),6)
PROCreset_string(ptr%,100,FNstore_graphics_new(grwric_linepass2%),6)
PROCreset_string(ptr%,104,FNstore_graphics_new(grwric_linepass2b%),6)
PROCreset_string(ptr%,108,FNstore_graphics_new(grwric_linepass3%),6)
PROCreset_string(ptr%,112,FNstore_graphics_new(grwric_linepass3b%),6)
PROCreset_string(ptr%,116,FNstore_graphics_new(grwric_linepass4%),6)
PROCreset_string(ptr%,120,FNstore_graphics_new(grwric_linepass4b%),6)
skip%=x% DIV 6
IF skip%>255 THEN skip%=255
MID$(part1$,dp_data_pixel_run_up%+1,1)=CHR$(skip%)

REM OSS Reduce skip resolution to a divider and a multiplier. One or the
REM other is set to 1 if possible as the dumper code optimises out divide
REM and multiply by 1. Other values are not worth worrying about, and are
REM in fact rare (the only example being the IBM 180 DPI mode with a
REM skip of 120.

skip%=VAL(FNicon_read(SHORT%,graphics%,grwric_skipres%))
IF skip%=0 THEN
 mult%=0
 div%=1
ELSE
 IF skip%=x% THEN
  mult%=1
  div%=1
 ELSE
  IF skip%>x% THEN
   IF (skip% MOD x%)=0 THEN
    mult%=skip% DIV x%
    div%=1
   ELSE
    mult%=skip%
    div%=x%
   ENDIF
  ELSE
   IF (x% MOD skip%)=0 THEN
    mult%=1
    div%=x% DIV skip%
   ELSE
    mult%=skip%
    div%=x%
   ENDIF
  ENDIF
 ENDIF
ENDIF

MID$(part1$,dp_data_skip_multiplier%+1,1)=CHR$(mult% AND &FF)
MID$(part1$,dp_data_skip_multiplier%+2,1)=CHR$((mult% >> 8) AND &FF)
MID$(part1$,dp_data_skip_multiplier%+3,1)=CHR$((mult% >> 16) AND &FF)
MID$(part1$,dp_data_skip_multiplier%+4,1)=CHR$((mult% >> 24) AND &FF)

MID$(part1$,dp_data_skip_divider%+1,1)=CHR$(div% AND &FF)
MID$(part1$,dp_data_skip_divider%+2,1)=CHR$((div% >> 8) AND &FF)
MID$(part1$,dp_data_skip_divider%+3,1)=CHR$((div% >> 16) AND &FF)
MID$(part1$,dp_data_skip_divider%+4,1)=CHR$((div% >> 24) AND &FF)

REM OSS One inch advance is equal to the vertical resolution.

MID$(part1$,dp_data_roll_advance%+1,1)=CHR$(y% AND &FF)
MID$(part1$,dp_data_roll_advance%+2,1)=CHR$((y% >> 8) AND &FF)
MID$(part1$,dp_data_roll_advance%+3,1)=CHR$((y% >> 16) AND &FF)
MID$(part1$,dp_data_roll_advance%+4,1)=CHR$((y% >> 24) AND &FF)

PROCreset_string(ptr%,28,part1$+part2$,5)
ENDPROC
:
DEFFNstore_graphics_new(icon%)
REM Returns a string in longstring% which is the encoded (ie.binary) version of
REM the human readable text typed into icon%
LOCAL s$
s$=FNicon_read(LONG%,graphics%,icon%):IFs$="" THEN!longstring%=0:=""
s$=FNencode_string(LONG%,s$,"GC"+STR$(icon%),"")
FORicon%=0TO1023STEP4:longstring%!icon%=buff1%!icon%:NEXT:REM Quick shuffle
=""
:
DEFPROCdummy:ENDPROC
DEFPROCopen_graphics_window(ptr%)
LOCAL i%,lj_class%,skip%
lj_class%=(FNicon_read(SHORT%,main%,10)="lj")
IFlj_class% THEN
 PROCicon_hide(graphics%,76)
 PROCicon_hide(graphics%,77)
 PROCicon_hide(graphics%,78)
 PROCicon_unhide(graphics%,79)
 PROCicon_unhide(graphics%,80)
 PROCicon_unhide(graphics%,81)
 PROCicon_unhide(graphics%,92)
 PROCicon_unhide(graphics%,93)
ELSE
 PROCicon_unhide(graphics%,76)
 PROCicon_unhide(graphics%,77)
 PROCicon_unhide(graphics%,78)
 PROCicon_hide(graphics%,79)
 PROCicon_hide(graphics%,80)
 PROCicon_hide(graphics%,81)
 PROCicon_hide(graphics%,92)
 PROCicon_hide(graphics%,93)
ENDIF
REM don't support editing gcalib in this version
PROCicon_shade(graphics%,grwric_gcalib%)
PROCicon_shade(graphics%,grwric_gcalib%+1)
IFptr%=0 THEN
 FORi%=36 TO 43
  PROCicon_deselect(graphics%,i%)
 NEXT
 FORi%=grwric_xres% TO grwric_linepass4b%
  PROCicon_write(SHORT%,graphics%,i%,"")
 NEXT
 IFlj_class% THEN
  PROCicon_deselect(graphics%,80)
  PROCicon_deselect(graphics%,81)
  PROCicon_deselect(graphics%,92)
  PROCicon_deselect(graphics%,93)
 ELSE
  PROCicon_select(graphics%,77)
  PROCicon_deselect(graphics%,78)
 ENDIF
ELSE
 PROCicon_write(SHORT%,graphics%,grwric_xres%,STR$(!(p%!20)))
 PROCicon_write(SHORT%,graphics%,grwric_yres%,STR$(!(p%!24)))
 PROCicon_write(SHORT%,graphics%,grwric_modnam%,$(p%!4))
 PROCicon_write(SHORT%,graphics%,grwric_modnum%,STR$(!(p%!8)))
 PROCicon_write(SHORT%,graphics%,grwric_palfile%,$(p%!12))
 PROCicon_write(SHORT%,graphics%,grwric_gname%,$(p%!36))
 PROCicon_write(SHORT%,graphics%,grwric_gcalib%,$(p%!40))
 i%=!(p%!16)
 IFi% AND    1 PROCicon_select(graphics%,36) ELSE PROCicon_deselect(graphics%,36)
 IFi% AND    2 PROCicon_select(graphics%,37) ELSE PROCicon_deselect(graphics%,37)
 IFi% AND  &10 PROCicon_select(graphics%,38) ELSE PROCicon_deselect(graphics%,38)
 IFi% AND  &20 PROCicon_select(graphics%,39) ELSE PROCicon_deselect(graphics%,39)
 IFi% AND  &40 PROCicon_select(graphics%,40) ELSE PROCicon_deselect(graphics%,40)
 IFi% AND &100 PROCicon_select(graphics%,41) ELSE PROCicon_deselect(graphics%,41)
 REM for large halftones, select if either small or large halftones
 IFi% AND &300 PROCicon_select(graphics%,42) ELSE PROCicon_deselect(graphics%,42)
 IFi% AND &400 PROCicon_select(graphics%,43) ELSE PROCicon_deselect(graphics%,43)
 IFlj_class% THEN
  IF(!(p%!32) AND  1) PROCicon_select(graphics%,80) ELSE PROCicon_deselect(graphics%,80)
  IF(!(p%!32) AND  2) PROCicon_select(graphics%,81) ELSE PROCicon_deselect(graphics%,81)
  IF(!(p%!32) AND 16) PROCicon_select(graphics%,92) ELSE PROCicon_deselect(graphics%,92)
  IF(!(p%!32) AND 64) PROCicon_select(graphics%,93) ELSE PROCicon_deselect(graphics%,93)
 ELSE
  IF(!(p%!32) AND 1) THEN
   PROCicon_select(graphics%,77)
   PROCicon_deselect(graphics%,78)
  ELSE
   PROCicon_deselect(graphics%,77)
   PROCicon_select(graphics%,78)
  ENDIF
 ENDIF
 i%=1+p%!28:REM miss the length byte
 PROCicon_write(SHORT%,graphics%,grwric_dumpdepth%,STR$(i%?dp_dump_depth%))
 PROCicon_write(SHORT%,graphics%,grwric_dumpheight%,STR$(i%?dp_data_dht%))
 PROCicon_write(SHORT%,graphics%,grwric_xint%,STR$(i%?dp_x_interlace%))
 PROCicon_write(SHORT%,graphics%,grwric_dlm%,STR$(i%?dp_data_dlm%))
 PROCicon_write(SHORT%,graphics%,grwric_yint%,STR$(i%?dp_y_interlace%))
 PROCicon_write(SHORT%,graphics%,grwric_dla%,STR$(i%?dp_data_dla%))

 REM For compatibility with pre V4 file formats,extract the dump strings from the "data:" field
 PROCgraphics_decode_old(grwric_pagestart%,i%,dp_data_page_start%)
 PROCgraphics_decode_old(grwric_pageend%,i%,dp_data_page_end%)
 PROCgraphics_decode_old(grwric_linereturn%,i%,dp_data_line_return%)
 PROCgraphics_decode_old(grwric_lineskip%,i%,dp_data_line_skip%)
 PROCgraphics_decode_old(grwric_lineend1%,i%,dp_data_line_end%)
 PROCgraphics_decode_old(grwric_lineend2%,i%,dp_data_line_end_i2%)
 PROCgraphics_decode_old(grwric_lineend3%,i%,dp_data_line_end_i3%)
 PROCgraphics_decode_old(grwric_zeroskip%,i%,dp_data_zero_skip%)
 PROCgraphics_decode_old(grwric_linestart1%,i%,dp_data_line_start%)
 PROCgraphics_decode_old(grwric_linestart2%,i%,dp_data_line_start_2%)
 PROCgraphics_decode_old(grwric_linepass1%,i%,dp_data_pass1_start%)
 PROCgraphics_decode_old(grwric_linepass1b%,i%,dp_data_pass1_start_2%)
 PROCgraphics_decode_old(grwric_linepass2%,i%,dp_data_pass2_start%)
 PROCgraphics_decode_old(grwric_linepass2b%,i%,dp_data_pass2_start_2%)
 PROCgraphics_decode_old(grwric_linepass3%,i%,dp_data_pass3_start%)
 PROCgraphics_decode_old(grwric_linepass3b%,i%,dp_data_pass3_start_2%)
 PROCgraphics_decode_old(grwric_linepass4%,i%,dp_data_pass4_start%)
 PROCgraphics_decode_old(grwric_linepass4b%,i%,dp_data_pass4_start_2%)

 REM V4 and later,override the strings just done above with the "dataN:" ones
 PROCgraphics_decode_new(grwric_pagestart%, p%,48)
 PROCgraphics_decode_new(grwric_pageend%,   p%,56)
 PROCgraphics_decode_new(grwric_linereturn%,p%,60)
 PROCgraphics_decode_new(grwric_lineskip%,  p%,64)
 PROCgraphics_decode_new(grwric_lineend1%,  p%,68)
 PROCgraphics_decode_new(grwric_lineend2%,  p%,72)
 PROCgraphics_decode_new(grwric_lineend3%,  p%,76)
 PROCgraphics_decode_new(grwric_zeroskip%,  p%,80)
 PROCgraphics_decode_new(grwric_linestart1%,p%,84)
 PROCgraphics_decode_new(grwric_linestart2%,p%,88)
 PROCgraphics_decode_new(grwric_linepass1%, p%,92)
 PROCgraphics_decode_new(grwric_linepass1b%,p%,96)
 PROCgraphics_decode_new(grwric_linepass2%, p%,100)
 PROCgraphics_decode_new(grwric_linepass2b%,p%,104)
 PROCgraphics_decode_new(grwric_linepass3%, p%,108)
 PROCgraphics_decode_new(grwric_linepass3b%,p%,112)
 PROCgraphics_decode_new(grwric_linepass4%, p%,116)
 PROCgraphics_decode_new(grwric_linepass4b%,p%,120)

 REM OSS Only read the new entries if the file version is new enough.
 REM Check both new then old location to make upgrading files trivial.

 IF (!(p%!32) >>> 24) >= 1 OR i%?dp_data_version%>=1 THEN
  PROCgraphics_decode_old(grwric_setlines%,i%,dp_data_set_lines%)
  PROCgraphics_decode_new(grwric_setlines%, p%, 44)
  skip%=(!(p%!20) * i%!dp_data_skip_multiplier%) DIV i%!dp_data_skip_divider%
  PROCicon_write(SHORT%,graphics%,grwric_skipres%,STR$(skip%))
 ELSE
  PROCicon_write(SHORT%,graphics%,grwric_setlines%,"")
  PROCicon_write(SHORT%,graphics%,grwric_skipres%,STR$(0))
 ENDIF

 IF (!(p%!32) >>> 24) >= 2 OR i%?dp_data_version%>=2 THEN
  PROCgraphics_decode_old(grwric_formfeed%,i%,dp_data_form_feed%)
  PROCgraphics_decode_new(grwric_formfeed%, p%, 52)
 ELSE
  PROCicon_write(SHORT%,graphics%,grwric_formfeed%,"")
 ENDIF

 REM OSS Version numbers 3 and upwards are always in the new location.

REM IF (!(p%!32) >>> 24) >= 3 THEN
REM There is nothing special to do for version 3 here.
REM ENDIF

REM PROCgraphics_decode_new(grwric_setlines%, p%, 44)
REM PROCgraphics_decode_new(grwric_formfeed%, p%, 52)

ENDIF
PROCwin_open(graphics%)
PROCcaret_set(graphics%,grwric_xres%)
ENDPROC
:
DEFPROCreset_string(block%,offset%,val$,type%)
IFblock%!offset% THEN
 CASE type% OF
 WHEN 2:   PROCheap_free("STRG",block%!offset%)
 WHEN 3:   PROCheap_free("STR0",block%!offset%)
 WHEN 4,5: PROCheap_free("GSTR",block%!offset%)
 WHEN 6:   PROCheap_free("LONG",block%!offset%)
 ENDCASE
ENDIF
IFtype%<>6 THEN
 REM BASIC "knows" the length of val$
 block%!offset%=FNstore_string(val$,type%)
ELSE
 REM The string at longstring% may contain control characters,so hand create it
 type%=FNheap_claim("LONG",!longstring%+4)
 block%!offset%=type%:offset%=!longstring%:REM The length of string
 !type%=offset%:type%+=4:REM The address of the string
 block%=0:REM Offset copied up to
 WHILE offset%
  type%?block%=longstring%?(block%+4):block%+=1:offset%-=1
 ENDWHILE
ENDIF
ENDPROC
:
DEFPROCgraphics_decode_old(icon%,block%,offset%)
PROCicon_write(SHORT%,graphics%,icon%,FNgraphics_decode(block%,offset%))
ENDPROC
:
DEFPROCgraphics_decode_new(icon%,add%,offset%)
REM Update icon% in window 'graphics' with the human readable version of the dump string at add/offset%
REM If the string at add%!offset% is empty,do nothing
IFFNgraphics_decode_new(add%!offset%)<>"" THENPROCicon_write(LONG%,graphics%,icon%,"")
ENDPROC
:
DEFFNgraphics_decode_new(add%)
REM Returns the human readable expanded string held at add%,or "" if no string defined
IFadd%<>0 AND !add%<>0 THEN
 REM Something worth decoding
 =FNdecode_string(add%,LONG%)
ELSE
 REM Return a null string
 !longstring%=0:=""
ENDIF
:
DEFFNgraphics_decode(block%,offset%)
IFblock%?offset%<>0 THEN
 =FNdecode_string(block%+dp_data_dlm%+block%?offset%,SHORT%)
ENDIF
=""
:
DEFFNdecode_string(addr%,style%)
LOCAL size%,i%,eos%
IFaddr%<>0 THEN
 IFstyle%=SHORT% THEN
  size%=?addr%
 ELSE
  size%=!addr%:addr%=addr%+3:REM The FOR loop starts at 1,net result is +4
 ENDIF
 IF size%<>0 THEN
  FORi%=1 TO size%
   IFaddr%?i%<33 OR addr%?i%>126 OR addr%?i%=34 THEN
    $(longstring%+eos%)=STR$(addr%?i%):eos%=eos%+LENSTR$(addr%?i%)
   ELSE
    $(longstring%+eos%)=CHR$34+CHR$(addr%?i%)+CHR$34:eos%=eos%+3
   ENDIF
   IFi%<>size% $(longstring%+eos%)=",":eos%=eos%+1
  NEXT
 ENDIF
ENDIF
longstring%?eos%=13
IFstyle%=SHORT% THEN=$longstring% ELSE="LONG"
:
DEFPROCencoding_error(tag1$,tag2$,entry$)
IFtag2$="" THEN
 tag2$=FNmsg_1("OKCb",entry$)
ELSE
 tag2$=FNmsg_1("OKCa",FNmsg_0(tag2$))
ENDIF
ERROR task_ok%,FNmsg_1(tag1$,tag2$)
ENDPROC
:
DEFFNencode_string(style%,s$,tag$,entry$)
REM Source string in s$,returns the encoded version of the string
REM In the LONG% case,source string is in longstring% and returned in buff1%
LOCAL i%,u$,eos%,ptr%,old%
IFstyle%=SHORT% THEN$longstring%=s$
!buff1%=0:eos%=4:ptr%=longstring%
REM rpsrps
WHILE(?ptr%)>31
 IF?ptr%=34 THEN
   old%=ptr%
   ptr%=ptr%+1:WHILE?ptr%<>34 AND?ptr%>31:ptr%+=1:ENDWHILE
   IF?ptr%<>34 PROCencoding_error("OKC",tag$,entry$)
   IF(ptr%-old%)<>2 PROCencoding_error("OKD",tag$,entry$)
   buff1%?eos%=?(ptr%-1):eos%+=1:ptr%+=1
   IF?ptr%>31 THEN
    IF?ptr%<>ASC"," PROCencoding_error("OKE",tag$,entry$)
    ptr%=ptr%+1
   ENDIF
 ELSE
   old%=ptr%
   WHILE?ptr%<>44 AND?ptr%>31:ptr%+=1:ENDWHILE
   IF?ptr%=44 THENptr%+=1:?(ptr%-1)=13 ELSE?ptr%=13
   u$=$old%:IFLEN(u$)=0 PROCencoding_error("OKE",tag$,entry$)
   IFVAL(u$)<0 OR VAL(u$)>255 PROCencoding_error("OKF",tag$,entry$)
   buff1%?eos%=VALu$:eos%+=1
 ENDIF
ENDWHILE
IFstyle%=SHORT% THEN
 u$=""
 IFeos%=4 THEN=u$ ELSEFORi%=4TO(eos%-1):u$=u$+CHR$(buff1%?i%):NEXT:=u$
ELSE
 !buff1%=eos%-4
 ="LONG"
ENDIF
:
DEFFNcharmapping_hit(y%)
LOCAL node%,y0%,y1%
!win_buff%=chars%:SYS"Wimp_GetWindowState",,win_buff%
y% -= win_buff%!16-win_buff%!24
y0%=charmap_icdf%(0)!4
y1%=charmap_icdf%(0)!12
node%=charmap_head%
WHILE node%
 IF(y0%<y%) AND (y%<y1%) :=node%
 y1% = y0%
 y0% -= (charmap_icdf%(0)!12 - charmap_icdf%(0)!4)
 node% = !node%
ENDWHILE
=0
:
DEFPROCmenu(top$,rebuild%,iconpos%)
LOCAL y%,t$,i%,p%,s$,f%
LOCAL ix%,iy%
IFrebuild% THEN
 menu_xpos%=task_buff%!0-64
 menu_ypos%=task_buff%!4
 menu_hand%=task_buff%!12
 menu_icon%=task_buff%!16
ENDIF
IFiconpos% THEN
 !win_buff%=menu_hand%:win_buff%!4=menu_icon%:SYS"Wimp_GetIconState",,win_buff%
 ix%=win_buff%!16:iy%=win_buff%!20
 SYS"Wimp_GetWindowState",,win_buff%
 menu_xpos%=win_buff%!20+win_buff%!4+ix%+2
 menu_ypos%=win_buff%!24+win_buff%!16+iy%-2
ENDIF
menu_chsn$=top$
CASE top$ OF
WHEN "ME1": PROCmenu_release(menu_top%):menu_top%=0
            PROCmenu_create(menu%,FNmsg_0("ME1"))
            PROCmenu_attach(menu%,0,info%,TRUE)
            menu_ypos%=96+2*44
WHEN "ME2": PROCmenu_release(menu_top%):menu_top%=0
            PROCmenu_create(menu%,FNmsg_0("ME2"))
            p%=graphics_head%:i%=1
            WHILE p%
             IF $(p%!36) <> "" THEN
               PROCmenu_item(menu%,i%,$(p%!36))
             ELSE
               PROCmenu_item(menu%,i%,FNmsg_2("RES",STR$(!(p%!20)),STR$(!(p%!24))))
             ENDIF
             i%+=1
             p%=!p%
            ENDWHILE
WHEN "ME3": p%=charmap_head%:i%=0
            WHILE p%
             IFp%?5 THEN
              i%-=1
              IFi%=-2 p%=0:REM we've got a selection
             ENDIF
             IFp% p%=!p%
            ENDWHILE
            IFi%=0 THEN
             REM no mapping selected - can we select one?
             i%=FNcharmapping_hit(menu_ypos%)
             IFi% i%?5=1:PROCredraw_charmapping(i%):i%=-1
            ENDIF
            PROCmenu_release(menu_top%):menu_top%=0
            IFi%=-2 THEN
             PROCmenu_create(p%,FNmsg_1("ME3a",FNmsg_0("ME3c")))
             PROCmenu_create(menu%,FNmsg_1("ME3",FNmsg_0("ME3c")))
             PROCmenu_shade(p%,0,TRUE)
            ELSE
             PROCmenu_create(p%,FNmsg_1("ME3a",FNmsg_0("ME3b")))
             PROCmenu_create(menu%,FNmsg_1("ME3",FNmsg_0("ME3b")))
             IFi%=0 THEN
              PROCmenu_shade(menu%,0,TRUE)
              PROCmenu_shade(p%,0,TRUE)
              PROCmenu_shade(p%,1,TRUE)
              PROCmenu_shade(menu%,2,TRUE)
             ENDIF
            ENDIF
            PROCmenu_attach(menu%,0,p%,TRUE)
            PROCmenu_attach(p%,0,mapping%,FALSE)
            PROCmenu_attach(menu%,3,mapping%,FALSE)
WHEN "ME4": PROCmenu_release(menu_top%):menu_top%=0
            IFFNicon_read(SHORT%,main%,10)="lj" p%=lj_paper_sizes% ELSE p%=dp_paper_sizes%
            IFp% THEN
             t$=FNicon_read(SHORT%,main%,27)
             PROCmenu_create(menu%,FNmsg_0("ME4")):i%=1
             WHILE p%
              PROCmenu_item(menu%,i%,$(p%+4))
              IFt$=$(p%+4) PROCmenu_tick(menu%,i%)
              IFt$="" AND i%=1 PROCmenu_tick(menu%,0)
              i%+=1
              p%=!p%
             ENDWHILE
            ENDIF
WHEN "ME5": PROCmenu_release(menu_top%):menu_top%=0
            IFgraphics_head% THEN
              t$=FNicon_read(SHORT%,main%,30)
              p%=graphics_head%
              PROCmenu_create(menu%,FNmsg_0("ME5"))
              i%=1
              WHILE p%
               IF $(p%!36) <> "" THEN
                 s$=$(p%!36)
               ELSE
                 s$=FNmsg_2("RES",STR$(!(p%!20)),STR$(!(p%!24)))
               ENDIF
               PROCmenu_item(menu%,i%,s$)
               IFt$=s$ PROCmenu_tick(menu%,i%)
               IFt$="" AND i%=1 PROCmenu_tick(menu%,0)
               i%+=1
               p%=!p%
              ENDWHILE
            ELSE
              ERROR task_ok%, FNmsg_0("OKT")
            ENDIF
WHEN "ME6": PROCmenu_release(menu_top%):menu_top%=0
            REM find the graphics definition first
            p%=graphics_head%:i%=FALSE
            WHILE p%<>0 AND i%=FALSE
              IF default_gname$ <> "" THEN
                f% = ($(p%!36) = default_gname$)
              ELSE
                f% = (!(p%!20)=default_xres% AND !(p%!24)=default_yres%)
              ENDIF
              IF f% THEN
                i%=TRUE
              ELSE
                p%=!p%
              ENDIF
            ENDWHILE
            REM now build a menu of qualities for that definition
            IFp% THEN
              i%=!(p%!16):p%=1
              IF(i%AND7)    PROCquality_menu(p%,FNmsg_0("CO0"),i%)
              IF(i%AND&70)  PROCquality_menu(p%,FNmsg_0("CO1"),i%>>4)
              IF(i%AND&700) PROCquality_menu(p%,FNmsg_0("CO2"),i%>>8)
            ELSE
              ERROR task_ok%, FNmsg_0("OKU")
            ENDIF
WHEN "ME7": PROCmenu_release(menu_top%):menu_top%=0
            PROCmenu_create(menu%,FNmsg_0("ME7"))
            PROCmenu_attach(menu%,0,save%,TRUE)
            IFFNicon_read(SHORT%,save%,save_nm%)="" THEN
             t$=FNicon_read(SHORT%,main%,12)
             FORi%=1 TO LEN(t$)
              IFMID$(t$,i%,1)=" " MID$(t$,i%,1)="_"
             NEXT
             PROCicon_write(SHORT%,save%,save_nm%,t$)
            ENDIF
ENDCASE
IFmenu_top% SYS"Wimp_CreateMenu",,menu%,menu_xpos%,menu_ypos%,&00000101
ENDPROC
:
DEFPROCquality_menu(RETURN offset%,colour$,ht%)
IFht%AND1 PROCquality_menu_add(offset%,colour$+", "+FNmsg_0("HT4"))
IFht%AND2 PROCquality_menu_add(offset%,colour$+", "+FNmsg_0("HT8"))
IFht%AND4 PROCquality_menu_add(offset%,colour$+", "+FNmsg_0("HT1"))
ENDPROC
:
DEFPROCquality_menu_add(RETURN offset%,string$)
IFoffset%=1 PROCmenu_create(menu%,FNmsg_0("ME6"))
PROCmenu_item(menu%,offset%,string$)
IFFNicon_read(SHORT%,main%,33)=string$ PROCmenu_tick(menu%,offset%)
IFFNicon_read(SHORT%,main%,33)="" AND offset%=1 PROCmenu_tick(menu%,0)
offset%+=1
ENDPROC
:
DEFFNwas_adjust_used
SYS"Wimp_GetPointerInfo",,buff1%
=(buff1%!8 AND1)
:
DEFPROCmenuaction
LOCAL adjust%,p%,s$,co%,ht%,node%
adjust%=FNwas_adjust_used
CASE menu_chsn$ OF
WHEN "ME1": IF!task_buff%=1 doing_shutdown%=2:PROChost_shutdown
WHEN "ME2": IF!task_buff%=0 THEN
             PROCopen_graphics_window(0)
            ELSE
             p%=graphics_head%
             WHILE !task_buff%>1
              p%=!p%
              !task_buff%-=1
             ENDWHILE
             PROCopen_graphics_window(p%)
            ENDIF
WHEN "ME3": CASE !task_buff% OF
            WHEN 0: IFtask_buff%!4=1 PROCdelete_selected_mappings:menu_icon%=-1
            WHEN 1: node%=charmap_head%
                    WHILE node%
                     node%?5=1
                     PROCredraw_charmapping(node%)
                     node%=!node%
                    ENDWHILE
            WHEN 2: node%=charmap_head%
                    WHILE node%
                     node%?5=0
                     PROCredraw_charmapping(node%)
                     node%=!node%
                    ENDWHILE
            ENDCASE
WHEN "ME4": IFFNicon_read(SHORT%,main%,10)="lj" p%=lj_paper_sizes% ELSE p%=dp_paper_sizes%
            IF !task_buff%=0 THEN
              PROCicon_write(SHORT%,main%,27,"")
              PROCmodified
            ELSE
              WHILE !task_buff%>1 AND p%
                p%=!p%
                !task_buff%-=1
              ENDWHILE
              IFp% PROCicon_write(SHORT%,main%,27,$(p%+4)):PROCmodified
            ENDIF
WHEN "ME5": p%=graphics_head%
            IF !task_buff%=0 THEN
              default_xres%=0:default_yres%=0
              default_qual%=0
              PROCicon_write(SHORT%,main%,30,"")
              PROCicon_write(SHORT%,main%,33,"")
              PROCmodified
            ELSE
              WHILE !task_buff%>1 AND p%
               p%=!p%
               !task_buff%-=1
              ENDWHILE
              IFp% THEN
                default_xres%=!(p%!20)
                default_yres%=!(p%!24)
                default_gname$=$(p%!36)
                IF default_gname$ <> "" THEN
                  PROCicon_write(SHORT%,main%,30,default_gname$)
                ELSE
                  PROCicon_write(SHORT%,main%,30,FNmsg_2("RES",STR$default_xres%,STR$default_yres%))
                ENDIF
                PROCcheck_quality_validity
                PROCmodified
              ENDIF
            ENDIF
WHEN "ME6": IF !task_buff%=0 THEN
              PROCicon_write(SHORT%,main%,33,"")
              default_qual%=0
            ELSE
              p%=menu_top%+28+!task_buff%*24
              IF p%!8 AND &100 THEN
                s$=$p%!12
              ELSE
                s$=$(p%+12)
              ENDIF
              PROCicon_write(SHORT%,main%,33,s$)
              p%=INSTR(s$,",")
              CASE LEFT$(s$,p%-1) OF
                WHEN FNmsg_0("CO1"): co%=1
                WHEN FNmsg_0("CO2"): co%=2
                OTHERWISE:           co%=0
              ENDCASE
              CASE MID$(s$,p%+2) OF
                WHEN FNmsg_0("HT4"): ht%=4
                WHEN FNmsg_0("HT8"): ht%=8
                OTHERWISE:           ht%=1
              ENDCASE
              default_qual%=(ht%<<8)+co%
            ENDIF
            PROCmodified
WHEN "ME7": CASE !task_buff% OF
            WHEN 1: PROCinitiate_printing_of_file
            WHEN 2: PROCrestart_everything
                    PROCinit_main_window
            ENDCASE
ENDCASE
IFadjust% THEN
 PROCmenu(menu_chsn$,FALSE,FALSE)
ELSE
 PROCcancel_menued_item
ENDIF
ENDPROC
:
DEFPROCinitiate_printing_of_file
task_buff%!12=0
task_buff%!16=&80142:REM PrintSave
task_buff%!36=-1
task_buff%!40=&AF8:REM 1st Word Plus
s$=FNicon_read(SHORT%,save%,save_nm%)
IFs$="" s$=FNmsg_0("ID")
p%=LEN(s$)
WHILE p%>1
 IFMID$(s$,p%,1)="." s$=MID$(s$,p%+1):p%=0 ELSE p%-=1
ENDWHILE
$(task_buff%+44)=s$+CHR$0
task_buff%!0=(48+LEN(s$))ANDNOT3
SYS"Wimp_SendMessage",18,task_buff%,0
printref% = task_buff%!8
ENDPROC
:
DEFPROCcheck_quality_validity
REM if the resolution changes, or the definition of it changes, we may
REM need to reset the default quality
LOCAL p%,i%,ht%,co%,f%
p%=graphics_head%
WHILE p%
 IF default_gname$ <> "" THEN
   f% = ($(p%!36) = default_gname$)
 ELSE
   f% = (!(p%!20)=default_xres% AND !(p%!24)=default_yres%)
 ENDIF
 IF f% THEN
  REM found ptr to graphics block. check quality is still available
  IF default_qual%<>0 THEN
   co%=default_qual% AND &FF
   ht%=(default_qual% AND &FF00)>>8
   p%=!(p%!16)
   CASE co% OF
    WHEN 0: IF (p%AND7)=0 co%=-1
    WHEN 1: IF (p%AND&70)=0 co%=-1
    WHEN 2: IF (p%AND&700)=0 co%=-1
   ENDCASE
   IFco%<>-1 THEN
    i%=p%>>(co%*4)
    CASE ht% OF
      WHEN 4: IF(i%AND1)=0 ht%=-1
      WHEN 8: IF(i%AND2)=0 ht%=-1
      WHEN 1: IF(i%AND4)=0 ht%=-1
    ENDCASE
   ENDIF
   IFco%=-1 OR ht%=-1 THEN
    default_qual%=0
    PROCicon_write(SHORT%,main%,33,"")
    PROCerror_box(FNmsg_0("OKR"), 1)
   ENDIF
  ENDIF
  p%=0
 ELSE
  p%=!p%
 ENDIF
ENDWHILE
ENDPROC
:
DEFPROCram_file_error(s$)
PROCrelease_file
PROCrestart_everything
PROCinit_main_window
ERROR task_ok%, s$
ENDPROC
:
DEFFNmatch_line(m$,RETURN post$)
REM Returns FALSE if either no match found or EOF occured
LOCAL s$
REPEAT
 s$=FNread_string
 IFLEFT$(s$,1)<>"#" THEN
  PROCltrim(s$)
  IFs$<>"" THEN
   IFLEFT$(s$,LEN(m$))=m$ OR m$="" THEN
    post$=MID$(s$,LEN(m$)+1)
    PROCltrim(post$)
    =TRUE
   ELSE
    post$=""
    =FALSE
   ENDIF
  ENDIF
 ENDIF
UNTIL FNdata_eof
post$=""
=FALSE
:
DEFFNload_long_dumpstring(tag$,block%,offset%)
LOCALptr%,short$,ok%,eos%
ok%=FNmatch_line(tag$,short$):IFNOTok% THEN=ok%:REM Couldn't even find the short tag
ptr%=FNread_data_ptr
s$=FNread_string:PROCltrim(s$)
IFLEFT$(s$,LEN("# "+tag$+" "))="# "+tag$+" " THEN
 REM Has a hidden dump string extension
 REPEAT
  $(longstring%+eos%)=MID$(s$,LEN("# "+tag$+" ")):eos%+=LENMID$(s$,LEN("# "+tag$+" "))
  IFeos%>=1024 THENPROCram_file_error("OKL")
  ptr%=FNread_data_ptr
  s$=FNread_string:PROCltrim(s$)
 UNTILLEFT$(s$,1)<>"#"
ELSE
 REM Fall back to the short string instead
 $longstring%=short$
ENDIF
PROCwrite_data_ptr(ptr%)
block%!offset%=FNstore_string("",6)
=TRUE
:
DEFFNmatch_string(s$,m$,RETURN post$)
IFLEFT$(s$,LEN(m$))=m$ THEN
 post$=MID$(s$,LEN(m$)+1)
 PROCltrim(post$)
 =TRUE
ENDIF
=FALSE
:
DEFPROCltrim(RETURN s$)
WHILE LEFT$(s$,1)=" "
 s$=MID$(s$,2)
ENDWHILE
ENDPROC
:
DEFFNstore_integer(v%)
LOCAL b%
b%=FNheap_claim("INTG",4)
!b%=v%
=b%
:
DEFFNstore_string(s$,type%)
LOCAL b%,p%,i%
REM
REM mjs: allow empty strings as proper string ptrs (eg. for gname, gcalib fields)
REM IFs$="" THEN
REM  =0
REM ENDIF
REM
CASE type% OF
WHEN 2: b%=FNheap_claim("STRG",LEN(s$)+1)
        $b%=s$
WHEN 3: b%=FNheap_claim("STR0",LEN(s$)+1)
        $b%=s$:?(b%+LEN(s$))=0
WHEN 4: SYS"OS_GSTrans",s$,buff1%,256 TO ,,p%:REM For strings we can fit in BASIC variables
        b%=FNheap_claim("GSTR",p%+1)
        !b%=p%:b%+=1
        WHILE p%
         b%?i%=buff1%?i%:i%+=1:p%-=1
        ENDWHILE
        b%-=1
WHEN 5: b%=FNheap_claim("GSTR",LEN(s$)+1)
        ?b%=LEN(s$)
        FORi%=1TOLEN(s$)
         b%?i%=ASC(MID$(s$,i%,1))
        NEXT
WHEN 6: SYS"OS_GSTrans",longstring%,buff1%,1024 TO ,,p%:REM For long strings > 255 via a buffer
        b%=FNheap_claim("LONG",p%+4)
        !b%=p%:b%+=4
        WHILE p%
         b%?i%=buff1%?i%:i%+=1:p%-=1
        ENDWHILE
        b%-=4
ENDCASE
=b%
:
DEFFNungstrans(s$)
LOCAL t$,i%,c%
IFs$="" :=""
FORi%=1 TO LEN(s$)
 c%=ASC(MID$(s$,i%,1))
 IFc%<32 c%+=64:t$+="|"
 IFc%=ASC"|" OR c%=ASC"<" t$+="|"
 t$+=CHR$(c%)
NEXT
=t$
:
DEF FNload_file (name$)

    LOCAL c%, handle%, hdr$, l%

    SYS"OS_File",17,name$ TO c%,,,,data_size%

    IF (c% <> 1) THEN
       REM It's not of object type "file"
       =FALSE
    ENDIF

    handle% = OPENUP name$

    IF handle% = 0 THEN
        REM If this fails, the world's broken...
        =FALSE
    ENDIF

    hdr$ = ""
    FOR l% = 1 TO 4
        IF NOT EOF#handle% THEN
             hdr$ += CHR$(BGET#handle%)
        ENDIF
    NEXT

    CLOSE#handle%

    CASE hdr$ OF
        WHEN "SQSH"
            = FNload_file_squashed (name$)
        OTHERWISE
            = FNload_file_unsquashed (name$)
    ENDCASE

=FALSE
:
DEF FNload_file_unsquashed (name$)

    LOCAL c%

    SYS"OS_File",17,name$ TO c%,,,,data_size%

    IF c% <> 1 THEN
        =FALSE
    ENDIF

    data_block%=FNheap_claim("DATA",data_size%)

    SYS"OS_File",16,name$,data_block%

    data_ptr%=0

= TRUE
:
DEF FNload_file_squashed (name$)

    LOCAL c%, unsquashed_length%, sqdt_block%, workspace%, worksize%, status%

    SYS"OS_File",17,name$ TO c%,,,,data_size%

    IF c% <> 1 THEN
        =FALSE
    ENDIF

    sqdt_block% = FNheap_claim ("SQDT",data_size%)

    SYS"OS_File",16,name$,sqdt_block%

    unsquashed_length% = (sqdt_block%?4) + ((sqdt_block%?5) << 8) + ((sqdt_block%?6) << 16) + ((sqdt_block%?7) << 24)

    REM Figure out workspace size from input block size

    SYS "Squash_Decompress", 8, data_size%-20 TO worksize%

    workspace%  = FNheap_claim ("SQWS", worksize%)
    data_block% = FNheap_claim ("DATA", unsquashed_length%)

    REM Do the decompression from store to store - fast :-)
    REM r0 = start new, end of input, assume all output will fit
    REM r1 = workspace
    REM r2 = input pointer
    REM r3 = number of input bytes
    REM r4 = output pointer
    REM r5 = number of output bytes avail.

    SYS "Squash_Decompress", 4, workspace%, sqdt_block%+20, data_size%-20, data_block%, unsquashed_length% TO status%

    PROCheap_free ("SQWS", workspace%)
    PROCheap_free ("SQDT", sqdt_block%)

    data_ptr%=0
    data_size% = unsquashed_length%

    IF status% = 0 THEN
        = TRUE
    ELSE
        = FALSE
    ENDIF

= TRUE
:
REM Long since redundant
REM DEFFNload_file_ORIGINAL(name$)
REM LOCAL c%
REM SYS"OS_File",17,name$ TO c%,,,,data_size%
REM IFc%<>1 THEN
REM   = FALSE
REM ENDIF
REM data_block%=FNheap_claim("DATA",data_size%)
REM SYS"OS_File",16,name$,data_block%
REM data_ptr%=0
REM = TRUE
:
DEFPROCrelease_file
PROCheap_free("DATA",data_block%)
data_block%=0
data_size%=0
ENDPROC
:
DEFFNread_data_ptr
=data_ptr%
:
DEFPROCwrite_data_ptr(v%)
data_ptr%=v%
ENDPROC
:
DEFFNdata_eof
=(data_ptr%>=data_size%)
:
DEFFNread_string
LOCAL i%
i%=data_ptr%:IFdata_ptr%>=data_size% THEN =""
WHILE data_ptr%<data_size% AND data_block%?data_ptr%<>10 AND data_block%?data_ptr%<>13
 data_ptr%+=1
ENDWHILE
data_block%?data_ptr%=13
data_ptr%+=1
=$(data_block%+i%)
:
DEFFNevaluate(s$)
LOCAL i%,t%,n%,f%
i%=FNheap_claim("TEMP",256)
SYS"XOS_EvaluateExpression",s$,i%,256 TO ,t%,n%;f%
IFt% OR (f% AND 1) THEN
 ERROR task_fatal%, FNmsg_1("FAD",s$)
ENDIF
PROCheap_free("TEMP",i%)
=n%
:
DEFFNprinter_read_string(ptr%)
LOCAL i%,s$
IFptr%=0 THEN=""
CASE ptr%!-4 OF
WHEN FNheap_ident_num("STRG"): =$ptr%
WHEN FNheap_ident_num("STR0"): =FNtask_rtoz(ptr%)
WHEN FNheap_ident_num("GSTR"): IF?ptr%=0 THEN
                                =""
                               ENDIF
                               i%=?ptr%:ptr%+=1
                               WHILE i%
                                s$+=CHR$(?ptr%):ptr%+=1:i%-=1
                               ENDWHILE
WHEN FNheap_ident_num("LONG"): IF!ptr%<>0 THEN
                                 FORi%=0TO((!ptr%)-1)
                                  REM Returns the string from the heap block in longbuffer%,CHR$13 terminated
                                  ?(longbuffer%+i%)=?(ptr%+4+i%)
                                 NEXT
                               ENDIF
                               ?(longbuffer%+i%)=13:s$="LONG"
OTHERWISE: ERROR task_fatal%, FNmsg_0("FA7")
ENDCASE
=s$
:
REM Message handling routines
:
DEFPROCmsg_initialise(N$)
LOCAL f$
REM LOCAL ERROR
REM ON ERROR LOCAL f$=REPORT$:RESTORE ERROR:ERROR 0,"Cannot find messages file ("+f$+")"
DIM msg_text% 256
SYS "OS_Module",6,,,17+LEN(N$) TO ,,msg_desc%
$(msg_desc%+16)=N$
SYS "MessageTrans_OpenFile",msg_desc%,msg_desc%+16,0
ENDPROC
:
DEFFNmsg_0(T$)
=FNmsg_4(T$,"","","","")
:
DEFFNmsg_1(T$,S$)
=FNmsg_4(T$,S$,"","","")
:
DEFFNmsg_2(T$,S0$,S1$)
=FNmsg_4(T$,S0$,S1$,"","")
:
DEFFNmsg_3(T$,S0$,S1$,S2$)
=FNmsg_4(T$,S0$,S1$,S2$,"")
:
DEFFNmsg_4(T$,S0$,S1$,S2$,S3$)
LOCAL F%,L%
SYS "XMessageTrans_Lookup",msg_desc%,T$,msg_text%,256,S0$,S1$,S2$,S3$ TO ,,,L%;F%
IF F% AND 1 :=T$
msg_text%?L%=13
=$msg_text%
:
DEFPROCmsg_end
IFmsg_desc% THEN
  SYS"MessageTrans_CloseFile",msg_desc%
  SYS"XOS_Module",7,,msg_desc%
ENDIF
ENDPROC
:
REM Heap handling routines
:
DEFPROCheap_initialise
SYS"OS_ReadMemMapInfo" TO heap_psize%
SYS"OS_GetEnv" TO ,heap_start%
heap_size%=0
PROCheap_increase
ENDPROC
:
DEFPROCheap_increase
LOCAL slot%,f%
SYS"Wimp_SlotSize",-1,-1 TO slot%
SYS"Wimp_SlotSize",slot%+heap_psize%,-1
IFheap_size%=0 THEN
 SYS"XOS_Heap",0,heap_start%,,heap_psize% TO ;f%
 IF(f% AND 1) ERROR 0, FNmsg_1("FA1",STR$((slot%+heap_psize%)/1024))
ELSE
 SYS"XOS_Heap",5,heap_start%,,heap_psize% TO ;f%
 IF(f% AND 1) ERROR task_fatal%, FNmsg_0("FA3")
ENDIF
heap_size%+=heap_psize%
ENDPROC
:
DEFFNheap_freespace
LOCAL f%
IFheap_size%=0 THEN =0
SYS"OS_Heap",1,heap_start% TO ,,f%
=f%
:
DEFFNheap_ident_num(v$)
LOCAL i%,j%
FORi%=0 TO 3
 j%=j% OR ASC(MID$(v$,i%+1,1))<<(i%*8)
NEXT
=j%
:
DEFFNheap_claim(ident$,size%)
LOCAL p%,f%
REM need to add 4 extra bytes 'cos if the block needs
REM extending then the first word gets trampled on
size%+=4
WHILE size%>=FNheap_freespace
 PROCheap_increase
ENDWHILE
REM claim the block and store the ident
SYS"XOS_Heap",2,heap_start%,,size% TO ,,p%;f%
IF(f%AND1) ERROR task_fatal%,FNmsg_0("FA3")
!p%=FNheap_ident_num(ident$)
=p%+4
:
DEFPROCheap_free(ident$,block%)
LOCAL r0%,f%
IFblock% THEN
 block%-=4
IF!block%<>FNheap_ident_num(ident$) ERROR task_ok%,FNmsg_1 ("BNF", ident$)
 !block%=0:REM ensure that the ident is overwritten as a safety measure
 SYS"XOS_Heap",3,heap_start%,block% TO r0%;f%
 IF(f% AND 1) ERROR task_fatal%,FNmsg_2("ODD1", ident$, FNtask_rtoz(r0%+4))
ENDIF
ENDPROC
:
DEFFNheap_extend(ident$,block%,size%)
LOCAL p%,current%,i%,f%
block%-=4
IF!block%<>FNheap_ident_num(ident$) ERROR task_ok%,FNmsg_1 ("BNE", ident$)
REM find out how big this block is
SYS"OS_Heap",6,heap_start%,block% TO ,,,current%
REM check that there is enough space in the heap for a duplicate of this block
WHILE (current%+size%)>=FNheap_freespace PROCheap_increase:ENDWHILE
SYS"XOS_Heap",4,heap_start%,block%,size% TO ,,p%;f%
IF(f% AND 1) ERROR task_fatal%,FNmsg_0("FA3")
=p%+4
:
DEFFNheap_blocksize(block%)
block%-=4
SYS"OS_Heap",6,heap_start%,block% TO ,,,block%
=block%
:
REM DEFPROCheap_dump(filename$,comment$)
REM LOCAL c%,free%,hwm%,end%,hpd%,ptr%,nfree%,nused%,tmp%
REM LOCAL ERROR
REM ON ERROR LOCAL RESTORE ERROR:BPUT#c%,REPORT$:CLOSE#c%:SYS"OS_File",18,filename$,&FFF:PROChost_shutdown
REM c%=OPENOUT(filename$)
REM c%=OPENUP(filename$)
REM IFc%=0 THEN
REM  c%=OPENOUT(filename$)
REM ELSE
REM  PTR#c%=EXT#c%
REM ENDIF
REM IFcomment$<>"" BPUT#c%,comment$
REM IFc%<>0 THEN
REM  IF!hpd%<>&70616548 ERROR 1,"No 'Heap' string"
REM  free%=hpd%+4+hpd%!4
REM  hwm%=hpd%+hpd%!8
REM  end%=hpd%+hpd%!12
REM  IFhwm%>end% ERROR 1,"Heap top > heap end"
REM  ptr%=hpd%+16
REM  BPUT#c%,"Describing heap at "+FNheap_hex(hpd%,8)
REM  BPUT#c%,"Free offset = "+FNheap_hex(hpd%!4,8)
REM  BPUT#c%," HWM offset = "+FNheap_hex(hpd%!8,8)
REM  BPUT#c%," END offset = "+FNheap_hex(hpd%!12,8)
REM  BPUT#c%,""
REM  REPEAT
REM   CASE TRUE OF
REM   WHEN ptr%=hwm%:
REM    nfree%+=1
REM    BPUT#c%,"Last block at "+FNheap_hex(ptr%,8)+"; "+FNheap_hex(end%-ptr%,8)+" free"
REM    ptr%=end%
REM   WHEN ptr%=free%:
REM    nfree%+=1
REM    BPUT#c%,"Free block at "+FNheap_hex(ptr%,8)+"; "+FNheap_hex(!ptr%,8)+" offset; "+FNheap_hex(ptr%!4,8)+" free"
REM    free%=ptr%+!ptr%
REM    IFptr%!4=0 ERROR 1, "Link to next block is zero"
REM    ptr%+=ptr%!4
REM   OTHERWISE:
REM    nused%+=1
REM    BPUT#c%,"Used block at "+FNheap_hex(ptr%,8)+"; "+FNheap_hex(!ptr%,8)+" offset; "+FNheap_hex(!ptr%,8)+" used, ";
REM    tmp%=ptr%+4
REM    BPUT#c%,CHR$(tmp%?0)+CHR$(tmp%?1)+CHR$(tmp%?2)+CHR$(tmp%?3)
REM    IF!ptr%=0 ERROR 1, "Link to next block is zero"
REM    ptr%+=!ptr%
REM   ENDCASE
REM   IF (ptr%>end%) OR (ptr%<hpd%+16) ERROR 1,"Link outside heap"
REM  UNTIL ptr%=end%
REM  PROCheap_show(c%,"used",nused%)
REM  PROCheap_show(c%,"free",nfree%)
REM  CLOSE#c%
REM  SYS"OS_File",18,filename$,&FFF
REM ENDIF
REM ENDPROC
REM :
REM DEFPROCheap_show(c%,n$,d%)
REM BPUT#c%,"There w";
REM IFd%=1 BPUT#c%,"as"; ELSE BPUT#c%,"ere";
REM BPUT#c%," "+STR$(d%)+" "+n$+" block";
REM IFd%=1 BPUT#c%,"." ELSE BPUT#c%,"s."
REM ENDPROC
REM :
REM DEFFNheap_hex(A%,B%)
REM =RIGHT$("00000000"+STR$~(A%),B%)
:
REM Task handling routines
:
DEFPROCtask_initialise(n$)
task_id$=n$
task_buff%=FNheap_claim("TASK",256)
REM List of messages we're interested in
task_buff%!0=2
task_buff%!4=3
task_buff%!8=8
task_buff%!12=&502
task_buff%!16=&400C0
task_buff%!20=&400C9
task_buff%!24=&400CF
task_buff%!28=&80142
task_buff%!32=&80145
task_buff%!36=0
SYS"Wimp_Initialise",310,&4B534154,n$,task_buff% TO wimp_version%,task_handle%
task_ok%=254
task_fatal%=253
ENDPROC
:
DEFPROCtask_shutdown
SYS"Wimp_CloseDown"
END
ENDPROC
:
DEFFNtask_poll(mask%)
LOCAL task_action%
SYS"Wimp_Poll",mask%,task_buff% TO task_action%
=task_action%
:
DEFFNtask_rtoz(p%)
LOCAL p$
WHILE ?p%
 p$+=CHR$(?p%)
 p%+=1
ENDWHILE
=p$
:
REM Error handling routines
:
DEFPROCerror_initialise
DIM error_buff% 256
ENDPROC
:
DEFPROCerror
LOCAL r$,r%
r$=REPORT$
IFERR=task_ok% OR ERR=task_fatal% THEN
 r%=INSTR(r$,"in "+CHR$34)
 IFr% r$=LEFT$(r$,r%-1)
ENDIF
CASE ERR OF
WHEN    task_ok%: PROCerror_box(r$,1)
WHEN task_fatal%: PROCerror_box(r$,2)
       OTHERWISE: PROCerror_box(FNmsg_3("ER1",r$,STR$(ERR),STR$(ERL)),3)
ENDCASE
ENDPROC
:
DEFPROCerror_box(r$,error_flag%)
LOCAL r%
SYS"Wimp_CreateMenu",,-1
!error_buff%=ERR:$(error_buff%+4)=r$+CHR$0
SYS"Wimp_ReportError",error_buff%,error_flag%,task_id$ TO ,r%
IFr%=2 THEN
 ON ERROR OFF
 doing_shutdown%=2
 REM PROCheap_dump("$.Heap","")
 PROChost_shutdown:REM if heap dumping, never gets to here
ENDIF
ENDPROC
:
REM Locale handling routines
:
DEF PROClocale_initialise
  LOCAL p%
  SYS "Territory_ReadSymbols",-1,0 TO p%
  decimal_point$ = CHR$(?p%)
ENDPROC
:
DEF FNlocale_val(n$)
  IF decimal_point$="." : =VALn$
  LOCAL i%
  i%=INSTR(n$,decimal_point$)
  IF i%<>0 : =VAL(LEFT$(n$,i%-1)+"."+MID$(n$,i%+1))
=VALn$
:
REM Icon handling routines
:
DEFPROCicon_initialise
icon_buffer%=FNheap_claim("ICON",256)
ENDPROC
:
DEFPROCicon_write(style%,a%,b%,s$)
LOCAL h%,i%,n%
!icon_buffer%=a%
icon_buffer%!4=b%
SYS"Wimp_GetIconState",,icon_buffer%
IFstyle%=SHORT% THEN
 IF(LEN(s$)+1)>icon_buffer%!36 THEN
  ERROR task_fatal%,FNmsg_2("WFI", s$, STR$(b%))
 ENDIF
 $(icon_buffer%!28)=s$
ELSE
 h%=0
 WHILE(longstring%?h%)>31:h%=h%+1:ENDWHILE
 IF(h%+1)>icon_buffer%!36 THEN
  ERROR task_fatal%,FNmsg_1("WFL", STR$(b%))
 ENDIF
 FORi%=0TOh%:?((icon_buffer%!28)+i%)=longstring%?i%:NEXT
ENDIF
icon_buffer%!8=0:icon_buffer%!12=0
SYS"Wimp_SetIconState",,icon_buffer%
PROCcaret_info(h%,i%,n%)
IFh%=a% AND i%=b% PROCcaret_set(h%,i%)
ENDPROC
:
DEFFNicon_read(style%,a%,b%)
!icon_buffer%=a%
icon_buffer%!4=b%
SYS"Wimp_GetIconState",,icon_buffer%
IFstyle%=SHORT% THEN
 =$(icon_buffer%!28)
ELSE
 a%=-1
 REPEAT:a%=a%+1:longstring%?a%=?((icon_buffer%!28)+a%):UNTIL(longstring%?a%)<32
 IFa%=0 THEN="" ELSE="LONG"
ENDIF
:
DEFPROCicon_validation(a%,b%,s$)
!icon_buffer%=a%
icon_buffer%!4=b%
SYS"Wimp_GetIconState",,icon_buffer%
$(icon_buffer%!32)=s$
icon_buffer%!8=0:icon_buffer%!12=0
SYS"Wimp_SetIconState",,icon_buffer%
ENDPROC
:
DEFPROCicon_unshade(a%,b%)
!icon_buffer%=a%
icon_buffer%!4=b%
icon_buffer%!8=0
icon_buffer%!12=1<<22
SYS"Wimp_SetIconState",,icon_buffer%
ENDPROC
:
DEFPROCicon_shade(a%,b%)
!icon_buffer%=a%
icon_buffer%!4=b%
icon_buffer%!8=1<<22
icon_buffer%!12=1<<22
SYS"Wimp_SetIconState",,icon_buffer%
ENDPROC
:
DEFPROCicon_unhide(a%,b%)
!icon_buffer%=a%
icon_buffer%!4=b%
icon_buffer%!8=0
icon_buffer%!12=1<<23
SYS"Wimp_SetIconState",,icon_buffer%
ENDPROC
:
DEFPROCicon_hide(a%,b%)
!icon_buffer%=a%
icon_buffer%!4=b%
icon_buffer%!8=(1<<7)+(1<<23)
icon_buffer%!12=(1<<7)+(1<<23)
SYS"Wimp_SetIconState",,icon_buffer%
ENDPROC
:
DEFPROCicon_deselect(a%,b%)
!icon_buffer%=a%
icon_buffer%!4=b%
icon_buffer%!8=0
icon_buffer%!12=1<<21
SYS"Wimp_SetIconState",,icon_buffer%
ENDPROC
:
DEFPROCicon_select(a%,b%)
!icon_buffer%=a%
icon_buffer%!4=b%
icon_buffer%!8=1<<21
icon_buffer%!12=1<<21
SYS"Wimp_SetIconState",,icon_buffer%
ENDPROC
:
DEFFNicon_set(a%,b%)
!icon_buffer%=a%
icon_buffer%!4=b%
SYS"Wimp_GetIconState",,icon_buffer%
=((icon_buffer%!24 AND (1<<21))<>0)
:
DEFPROCicon_button_type(a%,b%,type%)
!icon_buffer%=a%
icon_buffer%!4=b%
icon_buffer%!8=type%<<12
icon_buffer%!12=%1111<<12
SYS"Wimp_SetIconState",,icon_buffer%
ENDPROC
:
DEFPROCicon_info(a%,b%,RETURN x1%,RETURN y1%,RETURN x2%,RETURN y2%)
!icon_buffer%=a%
icon_buffer%!4=b%
SYS"Wimp_GetIconState",,icon_buffer%
x1%=icon_buffer%!8
y1%=icon_buffer%!12
x2%=icon_buffer%!16
y2%=icon_buffer%!20
ENDPROC
:
DEFPROCcaret_disown
SYS"Wimp_SetCaretPosition",-1
ENDPROC
:
DEFPROCcaret_set(h%,i%)
LOCAL j%
j%=LEN(FNicon_read(SHORT%,h%,i%))
SYS"Wimp_SetCaretPosition",h%,i%,-1,-1,0,j%
SYS"Wimp_SetCaretPosition",h%,i%,-1,-1,-1,j%
IFh%=main% main_string$=FNicon_read(SHORT%,h%,i%)
ENDPROC
:
DEFPROCcaret_index(h%,i%,j%)
SYS"Wimp_SetCaretPosition",h%,i%,-1,-1,0,j%
SYS"Wimp_SetCaretPosition",h%,i%,-1,-1,-1,j%
ENDPROC
:
DEFPROCcaret_info(RETURN h%,RETURN i%,RETURN n%)
SYS"Wimp_GetCaretPosition",,icon_buffer%
h%=!icon_buffer%
i%=icon_buffer%!4
n%=icon_buffer%!20
ENDPROC
:
REM Window handling routines
:
DEFPROCwin_initialise
win_buff%=FNheap_claim("WIND",256)
win_template$="<PrintEdit$Dir>.Templates"
ENDPROC
:
DEFPROCwin_template_open
SYS"Wimp_OpenTemplate",,win_template$
ENDPROC
:
DEFPROCwin_template_close
SYS"Wimp_CloseTemplate"
ENDPROC
:
DEFPROCwin_load_create(f$,n$,sprite_pool%,RETURN handle%)
LOCAL win_buff%
PROCwin_load(f$,n$,win_buff%)
win_buff%!64=sprite_pool%
PROCwin_create(win_buff%,handle%)
PROCheap_free("WIND",win_buff%)
ENDPROC
:
DEFPROCwin_load(f$,n$,RETURN buf%)
REM   f$ - filename of template file
REM   n$ - name of template to load
REM buf% - buffer which needs to be big enough to hold the window definition
REM        AND the indirected data, due to the way Wimp_LoadTemplate works.
REM
REM PROCwin_load will automatically dimension enough memory for
REM the indirected data.
LOCAL ws_buf%
LOCAL size%
LOCAL data%
LOCAL found%
LOCAL s%,f%
IFf$<>"" THEN
 PROCwin_sizes(f$,n$,size%,data%)
ELSE
REM PROCwin_sizes(win_template$,n$,size%,data%)
 PROCwin_sizes_RO3(n$, size%, data%) : REM File already open.
ENDIF
buf%=FNheap_claim("WIND",size%+data%)
IFf$<>"" SYS"Wimp_OpenTemplate",,f$
IF data% THEN
 ws_buf%=FNheap_claim("BUFF",data%)
 SYS"XWimp_LoadTemplate",,buf%,ws_buf%,ws_buf%+data%,-1,n$,0 TO s%,,,,,,found%;f%
ELSE
 SYS"XWimp_LoadTemplate",,buf%,0,0,-1,n$,0 TO s%,,,,,,found%;f%
ENDIF
IFf$<>"" SYS"Wimp_CloseTemplate"
REM IF(f%AND1) ERROR task_ok%,n$+": "+FNtask_rtoz(s%+4)
REM IFfound%=0 ERROR task_ok%,"Template '"+n$+"' not found"
IF(f%AND1) ERROR task_ok%,FNmsg_2 ("ODD", n$, FNtask_rtoz(s%+4))
IFfound%=0 ERROR task_ok%,FNmsg_1 ("TNF", n$)
ENDPROC
:
DEF PROCwin_sizes_RO3 (name$, RETURN size%, RETURN data%)
    REM size% will be the size of the window
    REM data% will be the size of the indirected data

    SYS "Wimp_LoadTemplate",,0,,,,name$,0 TO ,size%,data%
ENDPROC
:
DEFPROCwin_create(buf%,RETURN handle%)
REM    buf% - buffer holding the window definition
REM handle% - handle of the created window
SYS"Wimp_CreateWindow",,buf% TO handle%
ENDPROC
:
DEFPROCwin_open(a%)
!win_buff%=a%
SYS"Wimp_GetWindowState",,win_buff%
win_buff%!28=-1
SYS"Wimp_OpenWindow",,win_buff%
ENDPROC
:
DEFPROCwin_open_centre(a%)
LOCAL x%,y%,dx%,dy%,dx1%
LOCAL mc_dx%,mc_dy%,mc_sw%,mc_sh%
SYS"OS_ReadModeVariable",-1,4 TO ,,mc_dx%:mc_dx%=1<<mc_dx%
SYS"OS_ReadModeVariable",-1,5 TO ,,mc_dy%:mc_dy%=1<<mc_dy%
SYS"OS_ReadModeVariable",-1,11 TO ,,mc_sw%:mc_sw%+=1
SYS"OS_ReadModeVariable",-1,12 TO ,,mc_sh%:mc_sh%+=1
x%=mc_sw%*mc_dx%
y%=mc_sh%*mc_dy%
!win_buff%=a%
SYS"Wimp_GetWindowState",,win_buff%

dx%=win_buff%!12 - win_buff%!4
dx1%=dx%
IF(win_buff%!32 AND (1<<31))<>0 THEN
 IF(win_buff%!32 AND (1<<28))<>0 THEN
  dx1%+=44
 ENDIF
ELSE
 IF(win_buff%!32 AND (1<<2))<>0 THEN
  dx1%+=44
 ENDIF
ENDIF
win_buff%!4=(x%-dx1%) DIV 2
win_buff%!12=win_buff%!4 + dx%

dy%=win_buff%!16 - win_buff%!8
win_buff%!8 = (y% - dy%) DIV 2
win_buff%!16 = win_buff%!8 + dy%
SYS"Wimp_OpenWindow",,win_buff%
ENDPROC
:
DEFPROCwin_close(a%)
!win_buff%=a%
SYS"Wimp_CloseWindow",,win_buff%
ENDPROC
:
DEFPROCwin_title(a%,s$)
LOCAL wox0%,way1%,wox1%,woy1%
!win_buff%=a%
SYS"Wimp_GetWindowInfo",,win_buff% OR 1:REM return JUST the window header
$(win_buff%!76)=s$
way1%=win_buff%!16
SYS"Wimp_GetWindowOutline",,win_buff%
wox0%=win_buff%!4
wox1%=win_buff%!12
woy1%=win_buff%!16
SYS"Wimp_ForceRedraw",-1,wox0%,way1%,wox1%,woy1%
ENDPROC
:
REM It is not advisable for you to use any of the following routines.
REM They exist to do something for the rest of the templates library.
:
DEFPROCwin_sizes(f$,n$,RETURN size%,RETURN data%)
LOCAL i%
LOCAL file%
LOCAL ptr%
LOCAL offset%
LOCAL type%
LOCAL ident$
LOCAL num_icons%
file%=OPENIN(f$)
size%=0
data%=0
ptr%=16
REPEAT
 PTR#file%=ptr%
 offset%=FNwin_word(file%)
 IF offset% THEN
  PTR#file%=ptr%+8
  type%=FNwin_word(file%)
  ident$=FNwin_string(file%)
  ptr%+=24
  IFtype%=1 THEN
   IFident$=n$ THEN
    PTR#file%=offset%+84
    num_icons%=FNwin_word(file%)
    data%=FNwin_title(file%,offset%)
    IFnum_icons% data%+=FNwin_icon(file%,num_icons%,offset%)
    size%=88+(num_icons%*32)
    offset%=0:REM just to get out of the loop
   ENDIF
  ENDIF
 ENDIF
UNTIL offset%=0
SYS"XOS_Find",0,file%
ENDPROC
:
DEFFNwin_word(h%)
=BGET#h%+(BGET#h% << 8)+(BGET#h% << 16)+(BGET#h% << 24)
:
DEFFNwin_string(h%)
LOCAL s$,c%
REPEAT
 c%=BGET#h%
 IFc%>31 s$+=CHR$(c%)
UNTIL c%<32
=s$
:
DEFFNwin_title(file%,offset%)
LOCAL v%
PTR#file%=offset%+28
v%=FNwin_word(file%)
IF (v% AND 1<<31) THEN
 IF (v% AND 1<<26) THEN
  =FNwin_isd(file%,offset%+56,offset%+72,offset%)
 ENDIF
ELSE
 IF (v% AND 1) THEN
  =FNwin_isd(file%,offset%+56,offset%+72,offset%)
 ENDIF
ENDIF
=0
:
DEFFNwin_icon(file%,num%,offset%)
LOCAL i%,j%
j%=0
FORi%=0 TO num%-1
 j%+=FNwin_isd(file%,offset%+88+i%*32+16,offset%+88+i%*32+20,offset%)
NEXT
=j%
:
DEFFNwin_isd(file%,o1%,o2%,offset%)
LOCAL v%,ist%,size%,i%
PTR#file%=o1%
v%=FNwin_word(file%)
REM even if an icon is marked as deleted
REM it must be allowed for!
i%=(v% AND %100000000)
ist%=(v% AND 3) + (i% >> 6)
CASE ist% OF
WHEN   0: size%=0
WHEN   1: size%=0
WHEN   2: size%=0
WHEN   3: size%=0
WHEN   4: size%=0
WHEN 5,7: PTR#file%=o2%+4
          v%=FNwin_word(file%)
          IFv%=-1 THEN
           size%=0
          ELSE
           PTR#file%=offset%+v%
           size%=LEN(FNwin_string(file%))+1
          ENDIF
          PTR#file%=o2%+8
          size%+=FNwin_word(file%)
WHEN   6: PTR#file%=o2%+8
          size%=FNwin_word(file%)
ENDCASE
=size%
:
REM Save handling code
:
DEFPROCsave_initialise
LOCAL f%
SYS"XOS_SWINumberFromString",,"DragASprite_Start" TO save_start%;f%
IF(f% AND 1) THEN
 save_start%=-1
ENDIF
SYS"XOS_SWINumberFromString",,"DragASprite_Stop" TO save_stop%;f%
IF(f% AND 1) THEN
 save_stop%=-1
ENDIF
SYS"OS_Byte",161,&1C TO ,,f%
IF(f% AND 2)=0 THEN
 REM CMOS has turned DragASprite off
 save_start%=-1
 save_stop%=-1
ENDIF
save_ic%=0
save_nm%=1
save_ok%=2
save_buff%=FNheap_claim("SAVE",256)
ENDPROC
:
DEFPROCsave_datasaveack(buff%)
LOCAL i%
i%=buff%!12
buff%!16=3
buff%!12=buff%!8
SYS"Wimp_SendMessage",17,buff%,buff%!4
IFi%=saveref% THEN
 IFbuff%!36=-1 THEN
  PROCsave_file(TRUE,FNtask_rtoz(buff%+44))
 ELSE
  PROCicon_write(SHORT%,save%,save_nm%,FNtask_rtoz(buff%+44))
  PROCsave_file(FALSE,"")
 ENDIF
ELSE
 IFi%=printref% THEN
  PROCprint_file(FNtask_rtoz(buff%+44))
 ELSE
  ERROR task_ok%, "Unknown reference in DataSaveAck message"
 ENDIF
ENDIF
ENDPROC
:
DEFPROCsave_setup(filetype%,icon_name$)
LOCAL b$
b$=STR$~(filetype%)
b$=RIGHT$("000"+b$,3)
save_filetype%=filetype%
PROCicon_validation(save%,save_ic%,"sfile_"+b$)
PROCicon_write(SHORT%,save%,save_nm%,icon_name$)
ENDPROC
:
DEFPROCsave_dragicon(mousex%,mousey%)
LOCAL bx%,by%,ix0%,ix1%,iy0%,iy1%,scrx%,scry%,f$
LOCAL mc_dx%,mc_dy%,mc_sw%,mc_sh%
!save_buff%=save%:SYS"Wimp_GetWindowState",,save_buff%
bx%=save_buff%!4 - save_buff%!20
by%=save_buff%!16 - save_buff%!24
PROCicon_info(save%,save_ic%,ix0%,iy0%,ix1%,iy1%)
SYS"OS_ReadModeVariable",-1,4 TO ,,mc_dx%:mc_dx%=1<<mc_dx%
SYS"OS_ReadModeVariable",-1,5 TO ,,mc_dy%:mc_dy%=1<<mc_dy%
SYS"OS_ReadModeVariable",-1,11 TO ,,mc_sw%:mc_sw%+=1
SYS"OS_ReadModeVariable",-1,12 TO ,,mc_sh%:mc_sh%+=1
scrx%=mc_sw%*mc_dx%
scry%=mc_sh%*mc_dy%
!save_buff%=save%
save_buff%!4=5
save_buff%!8=bx%+ix0%
save_buff%!12=by%+iy0%
save_buff%!16=bx%+ix1%
save_buff%!20=by%+iy1%
save_buff%!24=save_buff%!8-mousex%
save_buff%!28=save_buff%!12-mousey%
save_buff%!32=scrx%+save_buff%!16-mousex%
save_buff%!36=scry%+save_buff%!20-mousey%
IFsave_start%<>-1 THEN
 f$="file_"+RIGHT$("000"+STR$~(save_filetype%),3)
 SYS save_start%,%11000101,1,f$,save_buff%+8,save_buff%+24
ELSE
 SYS"Wimp_DragBox",,save_buff%
ENDIF
ENDPROC
:
DEFPROCsave_decodedrag
LOCAL h%,i%,mx%,my%,ft%
IFsave_stop%<>-1 THEN
 SYS save_stop%
ENDIF
SYS"Wimp_GetPointerInfo",,save_buff%
mx%=!save_buff%
my%=save_buff%!4
h%=save_buff%!12
i%=save_buff%!16
IFh%=save% ENDPROC:REM dropped on myself!
PROCsave_dragfile(h%,i%,mx%,my%)
ENDPROC
:
DEFPROCsave_dragfile(h%,i%,mx%,my%)
LOCAL f1$
f1$=FNsave_leafname
!save_buff%=(48+LENf1$)ANDNOT3
save_buff%!12=0
save_buff%!16=1
save_buff%!20=h%
save_buff%!24=i%
save_buff%!28=mx%
save_buff%!32=my%
save_buff%!36=0:REM well, we don't really know!
save_buff%!40=save_filetype%
$(save_buff%+44)=f1$+CHR$(0)
SYS"Wimp_SendMessage",17,save_buff%,h%,i%
saveref%=save_buff%!8
ENDPROC
:
DEFPROCprint_file(filename$)
REM Puts the PDF to printer in "English",either because someone tried to print
REM a PDF or clicked "Print" in Print Edit
LOCAL c%,d%,d$,n$,i%,b$,o$,u$,bu$,temp$
bu$=CHR$27+CHR$%10001001:REM bold and underlined
 u$=CHR$27+CHR$%10001000:REM underlined
 b$=CHR$27+CHR$%10000001:REM bold
 o$=CHR$27+CHR$%10000000:REM all off
c%=OPENOUTfilename$:IFc%=0 ENDPROC
REM Attempt to stop the title line wordwrapping with long paths
temp$=FNicon_read(SHORT%,save%,save_nm%)
IFLENtemp$>40 THEN
 IFINSTR(RIGHT$(temp$,40),".")<>0 THEN
  temp$=".."+MID$(RIGHT$(temp$,40),INSTR(RIGHT$(temp$,40),"."))
 ELSE
  temp$="..."+RIGHT$(temp$,37)
 ENDIF
ENDIF
BPUT#c%,bu$+FNmsg_1("PR01",temp$)+o$
BPUT#c%,10
BPUT#c%,FNmsg_1("PR02",FNicon_read(SHORT%,main%,10))
BPUT#c%,FNmsg_1("PR03",FNicon_read(SHORT%,main%,11))
BPUT#c%,FNmsg_1("PR04",FNicon_read(SHORT%,main%,12))
BPUT#c%,FNmsg_1("PR05",FNicon_read(SHORT%,main%,13))
IFFNicon_set(main%,36) THEN
 BPUT#c%,FNmsg_0("PR53")
ELSE
 BPUT#c%,FNmsg_0("PR54")
ENDIF
IFpaper_offsets_in_mm% THEN
 BPUT#c%,FNmsg_2("PR06",FNicon_read(SHORT%,main%,22),FNmsg_0("PR06a"))
ELSE
 BPUT#c%,FNmsg_2("PR06",FNicon_read(SHORT%,main%,22),FNmsg_0("PR06b"))
ENDIF
IFpaper_offsets_in_mm% THEN
 BPUT#c%,FNmsg_2("PR07",FNicon_read(SHORT%,main%,23),FNmsg_0("PR06a"))
ELSE
 BPUT#c%,FNmsg_2("PR07",FNicon_read(SHORT%,main%,23),FNmsg_0("PR06b"))
ENDIF
IFFNicon_read(SHORT%,main%,27)<>"" BPUT#c%,FNmsg_1("PR08",FNicon_read(SHORT%,main%,27))
IFFNicon_read(SHORT%,main%,30)<>"" BPUT#c%,FNmsg_1("PR09",FNicon_read(SHORT%,main%,30))
IFFNicon_read(SHORT%,main%,33)<>"" BPUT#c%,FNmsg_1("PR10",FNicon_read(SHORT%,main%,33))
IF graphics_head% THEN
 d%=graphics_head%
 WHILE d%
  i%=!(d%!16)
  BPUT#c%,11:BPUT#c%,8:BPUT#c%,10
  BPUT#c%,u$+FNmsg_2("PR11",STR$(!(d%!20)),STR$(!(d%!24)))+o$
  BPUT#c%,FNmsg_0("PR12")
  BPUT#c%,FNmsg_0("PR13")
  BPUT#c%,FNmsg_1("PR14",FNdump_quality( i%AND%000000000111 ))
  BPUT#c%,FNmsg_1("PR15",FNdump_quality((i%AND%000011110000)>>4))
  BPUT#c%,FNmsg_1("PR16",FNdump_quality((i%AND%111100000000)>>8))
  IFFNicon_read(SHORT%,main%,10)="lj" THEN
    IF(!(d%!32) AND 1) BPUT#c%,FNmsg_0("PR17")
    IF(!(d%!32) AND 2) BPUT#c%,FNmsg_0("PR18")
  ELSE
    IF(!(d%!32) AND 1) THEN
      BPUT#c%,FNmsg_1("PR19",FNmsg_0("PR19a"))
    ELSE
      BPUT#c%,FNmsg_1("PR19",FNmsg_0("PR19b"))
    ENDIF
  ENDIF
  BPUT#c%,FNmsg_1("PR20",$(d%!4))
  BPUT#c%,FNmsg_1("PR21",STR$(!(d%!8)))
  BPUT#c%,FNmsg_1("PR22",$(d%!12))
  i%=1+d%!28
  BPUT#c%,FNmsg_1("PR23",STR$((!(d%!20)*i%!dp_data_skip_multiplier%) DIV i%!dp_data_skip_divider%))
  BPUT#c%,FNmsg_1("PR24",STR$(i%?dp_dump_depth%))
  BPUT#c%,FNmsg_1("PR25",STR$(i%?dp_data_dht%))
  BPUT#c%,FNmsg_1("PR26",STR$(i%?dp_x_interlace%))
  BPUT#c%,FNmsg_1("PR27",STR$(i%?dp_y_interlace%))
  BPUT#c%,FNmsg_1("PR28",STR$(i%?dp_data_dlm%))
  BPUT#c%,FNmsg_1("PR29",STR$(i%?dp_data_dla%))
  BPUT#c%,10
  BPUT#c%,FNmsg_0("PR30")
  BPUT#c%,FNmsg_1("PR31","");:PROCbputlongstring(d%!44,c%)
  BPUT#c%,FNmsg_1("PR32","");:PROCbputlongstring(d%!48,c%)
  BPUT#c%,FNmsg_1("PR33","");:PROCbputlongstring(d%!52,c%)
  BPUT#c%,FNmsg_1("PR34","");:PROCbputlongstring(d%!56,c%)
  BPUT#c%,FNmsg_1("PR35","");:PROCbputlongstring(d%!60,c%)
  BPUT#c%,FNmsg_1("PR36","");:PROCbputlongstring(d%!64,c%)
  BPUT#c%,FNmsg_1("PR37","");:PROCbputlongstring(d%!68,c%)
  BPUT#c%,FNmsg_1("PR38","");:PROCbputlongstring(d%!72,c%)
  BPUT#c%,FNmsg_1("PR39","");:PROCbputlongstring(d%!76,c%)
  BPUT#c%,FNmsg_1("PR40","");:PROCbputlongstring(d%!80,c%)
  BPUT#c%,FNmsg_1("PR41","");:PROCbputlongstring(d%!84,c%)
  BPUT#c%,FNmsg_1("PR42","");:PROCbputlongstring(d%!88,c%)
  BPUT#c%,FNmsg_1("PR43","");:PROCbputlongstring(d%!92,c%)
  BPUT#c%,FNmsg_1("PR44","");:PROCbputlongstring(d%!96,c%)
  BPUT#c%,FNmsg_1("PR45","");:PROCbputlongstring(d%!100,c%)
  BPUT#c%,FNmsg_1("PR46","");:PROCbputlongstring(d%!104,c%)
  BPUT#c%,FNmsg_1("PR47","");:PROCbputlongstring(d%!108,c%)
  BPUT#c%,FNmsg_1("PR48","");:PROCbputlongstring(d%!112,c%)
  BPUT#c%,FNmsg_1("PR49","");:PROCbputlongstring(d%!116,c%)
  BPUT#c%,FNmsg_1("PR50","");:PROCbputlongstring(d%!120,c%)
  d%=!d%
 ENDWHILE
ENDIF

IF FNicon_set(main%,16) PROCprint_text_mode(c%,no_hilit_head%)
IF FNicon_set(main%,17) PROCprint_text_mode(c%,draft_hilit_head%)
IF FNicon_set(main%,18) PROCprint_text_mode(c%,nlq_hilit_head%)

IF FNicon_set(main%,19) AND charmap_count%<>0 THEN
 BPUT#c%,10
 BPUT#c%,u$+FNmsg_0("PR51")+o$
 i%=charmap_head%
 FORd%=0 TO charmap_count%-1
  BPUT#c%,FNmsg_3("PR52",CHR$(i%?4),STR$(i%?4),$(i%+8))
  i%=!i%
 NEXT
ENDIF
CLOSE#c%
SYS"OS_CLI","Settype "+filename$+" &AF8"
ENDPROC
:
DEFFNdump_quality(bits%)
LOCAL s$
IFbits% AND 1 s$=FNmsg_0("HT4")
IFbits% AND 2 IFs$<>"" s$+=", "
IFbits% AND 2 s$+=FNmsg_0("HT8")
IFbits% AND 4 IFs$<>"" s$+=", "
IFbits% AND 4 s$+=FNmsg_0("HT1")
=s$
:
DEFPROCbputlongstring(add%,c%)
LOCALu$
u$=FNgraphics_decode_new(add%)
add%=longstring%
WHILE(?add%>31):BPUT#c%,?add%:add%+=1:ENDWHILE
BPUT#c%,10
ENDPROC
:
DEFPROCprint_text_mode(c%,p%)
LOCAL i%,u$
u$=CHR$27+CHR$%10001000
BPUT#c%,11:BPUT#c%,25:BPUT#c%,10:BPUT#c%,u$;
IFFNicon_read(SHORT%,main%,10)="lj" THEN
 IFp%=no_hilit_head% BPUT#c%,FNmsg_0("PMODE");
 IFp%=draft_hilit_head% BPUT#c%,FNmsg_0("LMODE");
ELSE
 IFp%=no_hilit_head% BPUT#c%,FNmsg_0("TI1");
 IFp%=draft_hilit_head% BPUT#c%,FNmsg_0("TI2");
 IFp%=nlq_hilit_head% BPUT#c%,FNmsg_0("TI3");
ENDIF
BPUT#c%,o$
FORi%=22 TO 45
 BPUT#c%,FNmsg_0("TC"+STR$(i%))+": "+FNdecode_string(!p%,SHORT%)
 p%+=4
NEXT
ENDPROC
:
DEFPROCsave_file(f%,n$)
LOCAL l$,c%,d$,d%,i%, worklen%, maxsize%, workspace%, status%, left%, filelen%, paper_x_offset, paper_y_offset
LOCAL uncomp_buffer%, comp_buffer%, uncomp_length%, comp_length%, written%, load%, exec%

paper_x_offset = FNlocale_val(FNicon_read(SHORT%,main%,22))
paper_y_offset = FNlocale_val(FNicon_read(SHORT%,main%,23))
IF paper_offsets_in_mm% THEN
 paper_x_offset = paper_x_offset * mm_to_inches_multiplier
 paper_y_offset = paper_y_offset * mm_to_inches_multiplier
ENDIF

SYS "Hourglass_On"
written% = 0
uncomp_buffer% = FNheap_claim("SAVE", 2048)
uncomp_length% = 2048:REM allocated 2K to start with

IF FNicon_read(SHORT%,main%,14)="0" PROCheap_free("SAVE",uncomp_buffer%):ERROR task_ok%,FNmsg_0("OKO")

IF f% THEN
  l$ = n$
ELSE
  l$ = FNicon_read(SHORT%,save%,save_nm%)
  IF INSTR(l$,".")=0 AND INSTR(l$,":")=0  PROCheap_free("SAVE",uncomp_buffer%):ERROR task_ok%,FNmsg_0("OKJ")
ENDIF

PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, FNmsg_2("TI6",FNicon_read(SHORT%,main%,11),FNicon_read(SHORT%,main%,10)))
PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "cl: "+FNicon_read(SHORT%,main%,10))
PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "pr_nme: "+FNicon_read(SHORT%,main%,11))
PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "sh_nme: "+FNicon_read(SHORT%,main%,12))
PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "sp_nme: "+FNicon_read(SHORT%,main%,13))
IF graphics_head% THEN
  PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "res: "+FNicon_read(SHORT%,main%,14))
  d%=graphics_head%
  WHILE d%
    REM *** OSS Put the top and left offsets into the data string,
    REM if data version is three or greater.
    IF (!(d%!32) >>> 24) >= 3 THEN
      !(d%!28 + 1 + dp_data_left_offset%) = paper_x_offset * !(d%!20)
      !(d%!28 + 1 + dp_data_top_offset%) = paper_y_offset * !(d%!24)
    ENDIF

    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, " g_mode:")
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "  module: dumpers:")
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "   number: "+STR$(!(d%!8)))
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "   name: "+$(d%!4))
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "  palette: "+$(d%!12))
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "  options: "+STR$(!(d%!16)))
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "  pxres: "+STR$(!(d%!20)))
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "  pyres: "+STR$(!(d%!24)))
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "  data: "+FNungstrans(FNprinter_read_string(d%!28)))
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "  flags: "+STR$(!(d%!32)))
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "  gname: "+$(d%!36))
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "  gcalib: "+$(d%!40))
    IF (!(d%!32) >>> 24) >= 5 THEN
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data1: ", d%!44)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data2: ", d%!48)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data3: ", d%!52)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data4: ", d%!56)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data5: ", d%!60)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data6: ", d%!64)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data7: ", d%!68)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data8: ", d%!72)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data9: ", d%!76)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data10: ", d%!80)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data11: ", d%!84)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data12: ", d%!88)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data13: ", d%!92)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data14: ", d%!96)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data15: ", d%!100)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data16: ", d%!104)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data17: ", d%!108)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data18: ", d%!112)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data19: ", d%!116)
      PROCadd_to_buffer_long(uncomp_buffer%, uncomp_length%, written%, "  data20: ", d%!120)
      PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "")
    ENDIF
    d%=!d%
  ENDWHILE
ENDIF

REM PJC: need to ensure that the txt_cds: entry
REM *always* gets added, even if there are no txt_cds:

PROCadd_to_buffer_nocr(uncomp_buffer%, uncomp_length%, written%, "txt_cds: ")
IF FNicon_set(main%,16) THEN
 CASE TRUE OF
  WHEN FNicon_set(main%,18)
   PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "3")
  WHEN FNicon_set(main%,17)
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "2")
  OTHERWISE
    PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "1")
 ENDCASE
 PROCoutput_text_mode(no_hilit_head%)
 IFFNicon_set(main%,17) PROCoutput_text_mode(draft_hilit_head%)
 IFFNicon_set(main%,18) PROCoutput_text_mode(nlq_hilit_head%)
ELSE
 PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "0")
ENDIF

REM PJC: need to ensure that there is always at least one char mapping
REM so add a recognised dummy entry if necessary

PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "chars: char_maps:")
IF FNicon_set(main%,19) AND charmap_count%<>0 THEN
 PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, " char: "+STR$(charmap_count%))
 i%=charmap_head%
 FORd%=0 TO charmap_count%-1
  n$=CHR$(i%?4)
  d$=FNencode_string(SHORT%,$(i%+8),"",STR$(d%+1))
  PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "  "+FNungstrans(n$+d$))
  i%=!i%
 NEXT
ELSE
 PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, " char: 1")
 PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "  |@|@")
ENDIF

PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "default_paper_size: "+FNicon_read(SHORT%,main%,27))
PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "default_xresolution: "+STR$(default_xres%))
PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "default_yresolution: "+STR$(default_yres%))
PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "default_quality: "+STR$(default_qual%))
IFFNicon_set(main%,36) THEN
 PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "supports_fast_parallel: 1")
ELSE
 PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "supports_fast_parallel: 0")
ENDIF
PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "default_gname: "+default_gname$)

REM PJC: Add two comments to the end of the file so that the most accurate
REM      X and Y paper offsets are kept
PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "# Paper X offset = "+STR$(paper_x_offset))
PROCadd_to_buffer(uncomp_buffer%, uncomp_length%, written%, "# Paper Y offset = "+STR$(paper_y_offset))

SYS "Squash_Compress", 8, written% TO worklen%, maxsize%
comp_buffer% = FNheap_claim("COMP", maxsize%)
workspace%   = FNheap_claim("WSPC", worklen%)
SYS "Squash_Compress", 0, workspace%, uncomp_buffer%, written%, comp_buffer%, maxsize% TO status%,,,,,left%

c% = OPENOUT(l$)
IF c% = 0 THEN
  PROCheap_free("COMP",comp_buffer%)
  PROCheap_free("SAVE", uncomp_buffer%)
  PROCheap_free("WSPC", workspace%)
  ERROR task_ok%,FNmsg_0("OKK")
ENDIF

SYS "OS_File", 9,  l$ : REM Stamp it
SYS "OS_File", 17, l$ TO ,,load%, exec% : REM Read back the stamp
BPUT#c%, "SQSH";
file_len% = maxsize% - left%
BPUT#c%, written%       
BPUT#c%, written% >>  8 
BPUT#c%, written% >>  16
BPUT#c%, written% >>> 24
BPUT#c%, load%          
BPUT#c%, load% >>  8    
BPUT#c%, load% >>  16   
BPUT#c%, load% >>> 24   
BPUT#c%, exec%          
BPUT#c%, exec% >>  8    
BPUT#c%, exec% >>  16   
BPUT#c%, exec% >>> 24   
SYS "OS_GBPB", 1, c%, comp_buffer%, file_len%, 20
CLOSE#c%
SYS "OS_File", 18, l$, save_filetype% : REM Type the file correctly

SYS "Wimp_CreateMenu",,-1
PROCheap_free("COMP", comp_buffer%)
PROCheap_free("SAVE", uncomp_buffer%)
PROCheap_free("WSPC", workspace%)
SYS "Hourglass_Off"
PROCunmodified
IFdoing_shutdown%=1 PROChost_shutdown
IFdoing_shutdown%=3 SYS"Wimp_ProcessKey",&1FC
IFdoing_shutdown%=5 !task_buff%=main%:PROCclose_window
ENDPROC
:
DEFPROCoutput_text_mode(p%)
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, " t_mode:")
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_page_lines: "+FNungstrans(FNprinter_read_string(p%!0)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_08: "+FNungstrans(FNprinter_read_string(p%!4)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_09: "+FNungstrans(FNprinter_read_string(p%!8)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_0C: "+FNungstrans(FNprinter_read_string(p%!12)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_0D: "+FNungstrans(FNprinter_read_string(p%!16)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_0D0A: "+FNungstrans(FNprinter_read_string(p%!20)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_start: "+FNungstrans(FNprinter_read_string(p%!24)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_end: "+FNungstrans(FNprinter_read_string(p%!28)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_pica: "+FNungstrans(FNprinter_read_string(p%!32)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_elite: "+FNungstrans(FNprinter_read_string(p%!36)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_condensed: "+FNungstrans(FNprinter_read_string(p%!40)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_expanded: "+FNungstrans(FNprinter_read_string(p%!44)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_b_on: "+FNungstrans(FNprinter_read_string(p%!48)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_b_off: "+FNungstrans(FNprinter_read_string(p%!52)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_i_on: "+FNungstrans(FNprinter_read_string(p%!56)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_i_off: "+FNungstrans(FNprinter_read_string(p%!60)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_l_on: "+FNungstrans(FNprinter_read_string(p%!64)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_l_off: "+FNungstrans(FNprinter_read_string(p%!68)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_sup_on: "+FNungstrans(FNprinter_read_string(p%!72)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_sup_off: "+FNungstrans(FNprinter_read_string(p%!76)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_sub_on: "+FNungstrans(FNprinter_read_string(p%!80)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_sub_off: "+FNungstrans(FNprinter_read_string(p%!84)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_u_on: "+FNungstrans(FNprinter_read_string(p%!88)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "  t_u_off: "+FNungstrans(FNprinter_read_string(p%!92)))
    PROCadd_to_buffer (uncomp_buffer%, uncomp_length%, written%, "")
ENDPROC
:
DEFPROCadd_to_buffer(RETURN buffer%, RETURN bufflen%, RETURN current_pos%, string$)

    REM buffer%      - points to the start of the buffer
    REM bufflen%     - is the current buffer length
    REM current_pos% - is the next free position in the buffer
    REM string$      - is the string to write into the buffer

    LOCAL len%, loop%

    len% = LENstring$

    REM Try to extend heap block if necessary
    IF (current_pos% + len%) >= bufflen% THEN
        buffer%  = FNheap_extend ("SAVE", buffer%, 2048)
        bufflen% = bufflen% + 2048
    ENDIF

    FOR loop% = 1 TO len%
        buffer%?(current_pos% + loop% - 1) = ASC(MID$(string$, loop%, 1))
    NEXT

    buffer%?(current_pos% + len%) = 10

    current_pos% += len% + 1
ENDPROC
:
DEFPROCadd_to_buffer_long(RETURN buffer%, RETURN bufflen%, RETURN current_pos%, tag$, addr%)

    REM Note this also performs "ungstrans" at the same time

    REM buffer%      - points to the start of the buffer
    REM bufflen%     - is the current buffer length
    REM current_pos% - is the next free position in the buffer
    REM string$      - is the string tag/prefix to write into the buffer
    REM addr%        - address of the long string

    LOCAL len%, loop%, c%, sub%, inner%

    len% = LENtag$

    REM Try to extend heap block if necessary,including space for a long string
    IF (current_pos% + len% + 1024) >= bufflen% THEN
        buffer%  = FNheap_extend ("SAVE", buffer%, 2048)
        bufflen% = bufflen% + 2048
    ENDIF

    FOR loop% = 1 TO len%
        buffer%?(current_pos% + loop% - 1) = ASC(MID$(tag$, loop%, 1))
    NEXT

    IF (!addr%)<>0 THEN
      c%=0:FOR loop% = 0 TO ((!addr%)-1)
             REM See how long the string when it gets made human readable
             IF(addr%?(4+loop%)>31) THEN c%+=4:REM Two quotes the character plus a comma
             IF(addr%?(4+loop%)<32) THEN c%+=LENSTR$(addr%?(4+loop%))+1:REM Text equivalent plus a comma
           NEXT
      IF c%<240 THEN
        REM For old Print Edit and Printer Managers,might as well save it in the old format since
        REM the long string isn't really long.Note the use of 240 as a threshold since icons use to
        REM be 240 characters wide plus you couldn't load strings from a file of > 255 bytes
        FOR loop% = 0 TO ((!addr%)-1)
          c% = addr%?(4+loop%)
          IFc%<32 c%+=64:buffer%?(current_pos% + len%)=ASC"|" : len%+=1
          IFc%=ASC"|" OR c%=ASC"<" buffer%?(current_pos% + len%)=ASC"|" : len%+=1
          buffer%?(current_pos% + len%) = c% : len%+=1
        NEXT
        buffer%?(current_pos% + len%) = 10 : len%+=1
      ELSE
        REM A long dump string was encountered.There's not much point putting the first portion of the
        REM dump string into the tag$ line,since without the rest the printer wont work anyway.
        REM Instead,slice the dump string into BASIC string length pieces and hide them in comment lines
        buffer%?(current_pos% + len%) = 10 : len%+=1
        loop% = 0
        REPEAT
           FOR inner% = 1 TO LEN(tag$)
               REM Output a comment line
               buffer%?(current_pos% + inner% + len% -1 ) = ASC(MID$("#"+MID$(tag$,2), inner% , 1))
           NEXT
           len%+=LEN(tag$)
           sub% = 0
           REPEAT
              c% = addr%?(4+loop%)
              IFc%<32 c%+=64:buffer%?(current_pos% + len%)=ASC"|" : len%+=1 : sub%+=1
              IFc%=ASC"|" OR c%=ASC"<" buffer%?(current_pos% + len%)=ASC"|" : len%+=1 : sub%+=1
              buffer%?(current_pos% + len%) = c% : len%+=1 : sub%+=1
              loop%+=1
           UNTIL (loop% >= !addr%)OR(sub% >= 240)
           buffer%?(current_pos% + len%) = 10 : len%+=1
        UNTIL loop% >= !addr%
      ENDIF
    ELSE
      REM An empty string just needs the tag terminating
      buffer%?(current_pos% + len%) = 10 : len%+=1
    ENDIF

    current_pos% += len%
ENDPROC

DEFPROCadd_to_buffer_nocr(RETURN buffer%, RETURN bufflen%, RETURN current_pos%, string$)

    REM buffer%      - points to the start of the buffer
    REM bufflen%     - is the current buffer length
    REM current_pos% - is the next free position in the buffer
    REM string$      - is the string to write into the buffer

    LOCAL len%, loop%

    len% = LENstring$

    REM Try to extend heap block if necessary
    IF (current_pos% + len%) >= bufflen% THEN
        buffer%  = FNheap_extend ("SAVE", buffer%, 2048)
        bufflen% = bufflen% + 2048
    ENDIF

    FOR loop% = 1 TO len%
        buffer%?(current_pos% + loop% - 1) = ASC(MID$(string$, loop%, 1))
    NEXT

    current_pos% += len%

ENDPROC
:
DEFFNsave_leafname
LOCAL f$,i%
f$=FNicon_read(SHORT%,save%,save_nm%)
REPEAT
 i%=INSTR(f$,":")
 IFi%<>0 f$=MID$(f$,i%+1)
UNTIL i%=0
REPEAT
 i%=INSTR(f$,".")
 IFi%<>0 f$=MID$(f$,i%+1)
UNTIL i%=0
=f$
:
REM Menu handling code
:
DEFPROCmenu_initialise
menu_top%=0
ENDPROC
:
DEFPROCmenu_create(RETURN menu%,menu$)
LOCAL menutitle$,i%,menu1$,item$,j%,x%,count%
LOCAL ind%, indirect%
indirect% = 0
IFLEFT$(menu$,1)="#" THEN
 i%=1
 menutitle$=FNmenu_par(menu$,",",i%)
ELSE
 menutitle$=""
ENDIF
menu1$=menu$:j%=i%
REPEAT
 item$=FNmenu_par(menu$,",",i%)
 IFitem$<>"" count%+=1
UNTIL item$=""
menu$=menu1$:i%=j%
menu_top%=FNheap_claim("MENU",28+count%*24)
IF wimp_version% < 310 OR LENmenutitle$ <= 12 THEN
  $menu_top%=LEFT$(menutitle$,12)
  x%=LEN(LEFT$(menutitle$,12))
  menu_top%!16=(x%*8+6)*2
ELSE
  ind% = FNheap_claim ("MENU", LEN(menutitle$)+1)
  $ind% = menutitle$
  menu_top%!0 = ind%
  x%=LEN(menutitle$)
  menu_top%!16=(x%*8+6)*2
  indirect% = 1<<8
ENDIF
menu_top%?12=7
menu_top%?13=2
menu_top%?14=7
menu_top%?15=0
menu_top%!16=196
menu_top%!20=44
menu_top%!24=0
x%=LEN(menutitle$)
menu_top%!16=(x%*8+6)*2
FORj%=0 TO count%-1
 item$=FNmenu_par(menu$,",",i%)
 PROCmenu_item(menu_top%,j%,item$)
 IF j% = 0 THEN menu_top%!28 = menu_top%!28 OR indirect% : REM Set the indirect bit
NEXT
menu%=menu_top%
ENDPROC
:
DEFPROCmenu_release(menu%)
LOCAL i%,p%
IFmenu%=0 ENDPROC
p%=menu%+28
REPEAT
 IF(p%!8 AND &100) THEN
  REM OK, we've got an indirected option
  REM is it writeable?
  IF(!p% AND 4)=0 THEN
   REM no, so it must just be an option
   PROCheap_free("MENU",p%!12)
  ENDIF
 ENDIF
 IFp%!4<>-1 THEN
  i%=p%!4
  IFi%!-4=FNheap_ident_num("MENU") PROCmenu_release(i%)
 ENDIF
 p%+=24
UNTIL (p%!-24 AND &80)
PROCheap_free("MENU",menu%)
ENDPROC
:
DEFPROCmenu_item(RETURN menu%,item%,item$)
LOCAL F%,p%,i%,x%,count%
x%=((menu%!16/2)-6)/8
IFRIGHT$(item$,1)="#" item$=LEFT$(item$):F%+=2:REM dotted line
IFRIGHT$(item$,1)="@" item$=LEFT$(item$):F%+=8:REM menu warning
count%=((FNheap_blocksize(menu%)-28)/24)
IFitem%>=count% THEN
 REM extend the menu block by enough bytes
 p%=FNheap_extend("MENU",menu%,(item%-count%+1)*24)
 IFmenu%=menu_top% menu_top%=p%
 menu%=p%
 p%=menu%+28+(count%-1)*24
 !p%=!p% AND NOT&80:REM cancel the last item flag
 count%=item%+1
ENDIF
IFitem%=count%-1 F%+=&80:REM last item
p%=menu%+28+item%*24
p%!0=F%
p%!4=-1
p%!8=&07000021
IFLEFT$(item$,1)="$" THEN
 !p%+=4
 item$=STRING$(12," ")
ELSE
 IFLEN(item$)<12 THEN
  $(p%+12)=item$
 ELSE
  i%=FNheap_claim("MENU",LEN(item$)+1)
  $i%=item$
  p%!8=p%!8 OR &100
  p%!12=i%
  p%!16=-1
  p%!20=LEN(item$)+1
 ENDIF
ENDIF
IFLEN(item$)>x% THEN
 x%=LEN(item$)
 menu%!16=(x%*8+6)*2
ENDIF
ENDPROC
:
DEFPROCmenu_attach(menu%,item%,ptr%,traverse%)
menu%+=28+item%*24
IF traverse% !menu%=!menu% OR (1<<4)
menu%!4=ptr%
ENDPROC
:
DEFFNmenu_par(menu$,sep$,RETURN I%)
LOCAL L%
L%=I%+1
I%=INSTR(menu$+sep$,sep$,L%)
=MID$(menu$,L%,I%-L%)
:
DEFPROCmenu_shade(menuhandle%,item%,value%)
IF -((menuhandle%!(28+8+24*item%) AND &400000)=&400000)<>value% THEN
 menuhandle%!(28+8+24*item%)=menuhandle%!(28+8+24*item%)EOR &400000
ENDIF
ENDPROC
:
DEFPROCmenu_tick(menuhandle%,item%)
menuhandle%!(28+24*item%)=menuhandle%!(28+24*item%)EOR 1
ENDPROC



REM  DEF PROCdebug (a$)
REM
REM      LOCAL a%, i%, l%
REM
REM      i% = LENa$
REM
REM      IF i% = 0 THEN ENDPROC
REM
REM      a% = OPENOUT ("serial:")
REM      FOR l% = 1 TO i%
REM          BPUT#a%, ASC(MID$(a$, l%, 1))
REM      NEXT
REM      BPUT#a%, 10
REM      BPUT#a%, 13
REM      CLOSE#a%
REM
REM
REM  ENDPROC
REM
REM
REMDEF PROCdump_memory (f$, start%, length%)
REM
REM  LOCAL zz%, l%
REM
REM  zz% = OPENOUT f$
REM
REM  FOR l% = start% TO start%+length%-1
REM        BPUT#zz%, ?l%
REM  NEXT
REM
REM  CLOSE#zz%
REM
REMENDPROC
REM
