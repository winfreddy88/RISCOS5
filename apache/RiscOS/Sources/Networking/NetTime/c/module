/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <string.h>
#include <sys/types.h>

#include <Global/Services.h>
#include <Global/Countries.h>
#include <Global/RISCOS.h>

#include "nettime.h"
#include "nt_nvram.h"
#include "header.h"
#include "rtcadjust.h"
#include "ntp.h"

static _kernel_oserror *err;
static int grabbed_event;

int we_are_setting;
void *privateword;
#ifdef STANDALONE
extern void *resource_files(void);
#endif

_kernel_oserror *module_init(const char *cmd_tail, int podule, void *pw)
{
  uint32_t time;
  struct riscos_time ltime = { 0 };

  /* Initialise DebugLib (if DEBUGLIB defined) */
  debug_initialise("NetTime", "NFS::NFSBoot.$.NetTimeLog", "");
  //debug_initialise_trace(FILE_OUTPUT, "");
  debug_atexit();
  debug_output_device(PRINTF_OUTPUT);
  debug_set_screen_cornering(0);

  privateword = pw;

  /* Enable and claim internet event */
  if (!grabbed_event)
  {
    if ((err = _swix(OS_Claim, _INR(0,2), EventV, module_evententry, pw)) != NULL)
      return err;

    if ((err = _swix(OS_Byte, _INR(0,1), Event_Enable, Event_Internet)) != NULL)
      goto getoffvector;

    grabbed_event = 1;
  }

  if ((err = _swix(OS_Claim, _INR(0,2), WordV, wordv_veneer, pw)) != NULL)
    goto getoffvector;

  if (current_time().cs < 0x4C00000000) /* Jun 2003, ish */
  {
      /* Time <= 2003, so duff */
      time = nvram_gettime(); /* get last stored time in seconds, host byte order */

      if (time)
      {
        ltime.cs = time * UINT64_C(100);
        if ((time & 0x80000000) == 0) ltime.cs += 0x100000000 * UINT64_C(100);

        module_set_time(&ltime);
      }
  }

  rtcadjust_init();

  machine(Init);

#ifdef STANDALONE
  if ((err = _swix(ResourceFS_RegisterFiles, _IN (0), resource_files())) != NULL)
    goto getoffvector;
#endif

  UNUSED(podule);
  UNUSED(cmd_tail);
  return NULL;

getoffvector:
  /* Here for fatal errors during initialisation */
  _swix(OS_Release, _INR(0,2), EventV, module_evententry, pw);
  _swix(OS_Release, _INR(0,2), WordV, wordv_veneer, pw);
  return err;
}


_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
  machine(Die);

  rtcadjust_final(1);

  _swix(OS_RemoveTickerEvent, _INR(0,1), module_timerentry, pw);
  _swix(OS_RemoveCallBack, _INR(0,1), module_callentry, pw);

  _swix(OS_Release, _INR(0,2), WordV, wordv_veneer, pw);

  /* Disable and release internet event */
  _swix(OS_Byte, _INR(0,1), Event_Disable, Event_Internet);
  _swix(OS_Release, _INR(0,2), EventV, module_evententry, pw);
  grabbed_event = 0;
#ifdef STANDALONE
  _swix(ResourceFS_DeregisterFiles, _IN (0), resource_files());
#endif

  UNUSED(podule);
  UNUSED(fatal);
  return NULL;
}


void module_service(int service, _kernel_swi_regs *r, void *pw)
{
  switch (service)
  {
  case Service_PreReset:
  case Service_ShutDown:
    rtcadjust_fixup_hardware_rtc();
    return;

  case Service_PostInit:
    machine(PostInit);
    return;

  case Service_Dialler:
    machine(CONNECTED(r->r[2]) ? LinkUp : LinkDown);
    return;

  case Service_InternetStatus:
    handle_dhcp(r);
    return;

  case Service_NCRegistry:
    if ((r->r[5] & BB_STATUS_BB_VALID) ||	/* Network bootblock changed */
        (r->r[4] & BB_STATUS_BB_VALID))
      machine(RegistryChanged);
    return;

  case Service_ResourceFSStarting:
#ifdef STANDALONE
    (*(void (*) (void*,void*,void*,void*)) r->r[2])
          (resource_files(), 0, 0, (void*) r->r[3]);
#endif
    return;

  default:
    dprintf(("debug", "Bogus service call &%x\n", service));
  }
  
  UNUSED(pw);
}


_kernel_oserror *module_timerhandler(_kernel_swi_regs *r, void *pw)
{
  setcallback(Timer, pw);

  UNUSED(r);
  return NULL;
}


int module_eventhandler(_kernel_swi_regs *r, void *pw)
{
  /* Assumes only requested event in CMHG is Internet */
  if ((r->r[2] == sockno))	/* Pour moi? */
  {
    switch (r->r[1])
    {
    case Async:
      setcallback(Response, pw);
      return 0;	/* Claim */

    case Broken:
      setcallback(Failure, pw);
      return 0;	/* Claim */
    }
  }

  return 1;	/* Don't claim */
}


_kernel_oserror *module_callhandler(_kernel_swi_regs *r, void *pw)
{
  machine(callback_reason);
  
  UNUSED(r);
  UNUSED(pw);
  return NULL;
}

_kernel_oserror *module_set_time(const struct riscos_time *t)
{
    _kernel_oserror *e;

    we_are_setting = 1;
    e = _swix(Territory_SetTime, _IN(0), t);
    we_are_setting = 0;

    return e;
}


int module_osword15handler(_kernel_swi_regs *r, void *pw)
{
  if (!we_are_setting)
  {
      machine(Die);
      rtcadjust_final(0);
  }

  UNUSED(pw);
  UNUSED(r);
  return 1;
}


_kernel_oserror *module_cmd_handler(const char *arg_string, int argc, int cmd_no, void *pw)
{
    switch (cmd_no)
    {
      case CMD_NetTime_Kick:
        _swix(OS_RemoveTickerEvent, _INR(0,1), module_timerentry, pw);
        setcallback(LinkUp, pw);
        break;

      case CMD_NetTime_Status:
      {
        print_status();
        break;
      }

      case CMD_NetTime_PollInterval:
      {
        struct
        {
            unsigned char *param1;
            char buffer[12];
        } arg_buff;
        _kernel_oserror *e;
        int p;
        e = _swix(OS_ReadArgs, _INR(0,3), "/A/E", arg_string, &arg_buff, sizeof arg_buff);
        if (e) return e;
        if (arg_buff.param1[4]) arg_buff.param1[4] = 1; /* Prevent overflow */
        p = (arg_buff.param1[4] << 24) | (arg_buff.param1[3] << 16) | (arg_buff.param1[2] << 8) |
             arg_buff.param1[1];
        /* Clamp to between 5 seconds and 1 day */
        if (p != 0 && p < 5)
            p = 5;
        else if (p > 24*60*60)
            p = 24*60*60;

        p *= 100;
        change_poll_period(p);
        break;
      }
    }

    UNUSED(argc);
    return NULL;
}


_kernel_oserror *module_swi_handler(int swi_offset, _kernel_swi_regs *r, void *pw)
{
    switch(swi_offset)
    {
      case NetTime_Status - NetTime_00:
        /* Hard to see what this is for, since the text can't easily be parsed */
        print_status();
        break;

      case NetTime_States - NetTime_00:
        /* Read the past, present, and future states */
        fill_status((nettime_state_t *)r);
        break;
    }

    UNUSED(pw);
    return NULL;
}
