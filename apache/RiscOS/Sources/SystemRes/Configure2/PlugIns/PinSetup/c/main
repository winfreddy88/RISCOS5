/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*---------------------------------------------------------------------------*/
/* File:    main.c                                                           */
/* Purpose: Main WIMP shell for Pinboard configuration                       */
/* Author:  Richard Leggett                                                  */
/* History: 28-Oct-97: RML: Begun.                                           */
/*          04-Nov-97: RML: First version given for testing.                 */
/*          13-Nov-97: RML: Minor modifications                              */
/*          30-Jan-98: RML: Tidied up a little.                              */
/*          20-Mar-98: RML: Minor modifications                              */
/*          16-Apr-98: RML: Tiled JPEGs no longer allowed.                   */
/*          23-Apr-98: RML: Now greys out the IconiseStack menu if Iconise   */
/*                          to Icon or Iconise to Iconbar is selected.       */
/*          01-Jul-98: RML: 'Drop image' in the custom tile drop zone is now */
/*                          icons, rather than a sprite.                     */
/*                          Reduced flicker in some redraw cases.            */
/*                          If Try was clicked, Cancel button restores saved */
/*                          state as was before Try.                         */
/*                                                                           */
/* Copyright © 1998 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "Global/FileTypes.h"
#include "Interface/HighFSI.h"
#include "toolbox.h"
#include "colourdbox.h"
#include "event.h"
#include "common.h"
#include "window.h"
#include "defines.h"
#include "pinboard.h"
#include "wimplib.h"
#include "sprite.h"

#define MaxFilenameSize         1024
#define DefaultBackgroundColour 0x77777700
#define DefaultTextColour       0xffffff00

static unsigned int background_colour = DefaultBackgroundColour;
static unsigned int text_colour = DefaultTextColour;
static MessagesFD   messages_desc;
static IdBlock      idb;
static char         messages_string[255];
static char         rand_suffix;
static int          config_id;
static int          bgcolourbox_id = 0;
static int          txcolourbox_id = 0;
static int          current_tile = 1;
static int          max_std_tile;
static char*        custom_filename;
static int          custom_filetype;
static int*         client_sprite_area;
static int          changes_have_been_made = FALSE;


/*---------------------------------------------------------------------------*
 * program_exit                                                              *
 *                                                                           *
 * Finished with this plug-in, so exit.                                      *
 *---------------------------------------------------------------------------*/

static void program_exit(void)
{
    exit(0);
}


/*---------------------------------------------------------------------------*
 * redraw_custom_image_icon                                                  *
 *                                                                           *
 * Force a redraw of the custom_image icon                                   *
 *---------------------------------------------------------------------------*/

static void redraw_custom_image_icon(void)
{
    BBox gadget_bbox;

    error_trap(gadget_get_bbox(0, config_id, CustomDropZoneE, &gadget_bbox), 0);
    gadget_bbox.xmin += 8;
    gadget_bbox.xmax -= 8;
    gadget_bbox.ymin += 8;
    gadget_bbox.ymax -= 8;
    error_trap(window_force_redraw(0, config_id, &gadget_bbox), 0);
}


/*---------------------------------------------------------------------------*
 * hide_custom_sprite_icons                                                  *
 *                                                                           *
 * Hide the default custom sprite drop zone icons (the spritefile icon, the  *
 * jpegfile icon and the display icon that says 'Drop image'). Show the icon *
 * which shows the custom image.                                             *
 *---------------------------------------------------------------------------*/

void hide_custom_sprite_icons(int hide)
{
    BBox bbox;
    int  invert;
    int  gadget;
    int  do_redraw;

    /* Always make sure the custom image area is redrawn */
    do_redraw = TRUE;

    /* There are two cases for the value of hide:
          hide = 1: Show the custom sprite icon with the tiled sprite in it, but hide the three
                    drop zone icons (sprite icon, jpeg icon, 'drop image' label).
          hide = 0: Show the three drop zone icons, but hide the icon with the tiled sprite in
                    it.
       In each case, the icons are hidden by putting them off the window (-ve x and -ve y co-ords)
    */

    for (gadget=CustomDropZoneA; gadget<=CustomDropZoneE; gadget++)
    {
        invert = 0;

        gadget_get_bbox(0, config_id, gadget, &bbox);

        if (gadget == CustomDropZoneE)
        {
            if ((hide) && (bbox.xmin < 0)) invert = TRUE;
            if ((!hide) && (bbox.xmin > 0)) invert = TRUE;
        }
        else
        {
            if ((hide) && (bbox.xmin > 0)) invert = TRUE;
            if ((!hide) && (bbox.xmin < 0)) invert = TRUE;
        }

        if (invert)
        {
            do_redraw = FALSE;
            bbox.xmin = -bbox.xmin;
            bbox.ymin = -bbox.ymin;
            bbox.xmax = -bbox.xmax;
            bbox.ymax = -bbox.ymax;
            gadget_move_gadget(0, config_id, gadget, &bbox);
        }
    }

    if (do_redraw) redraw_custom_image_icon();
}


/*---------------------------------------------------------------------------*
 * save_choices                                                              *
 *                                                                           *
 * Read the choices from the window and output a command file.               *
 *---------------------------------------------------------------------------*/

static void save_choices(void)
{
    char backdrop_command[MaxFilenameSize];
    char pinboard_command[256];
    char string[MaxFilenameSize];
    int  radio_on;
    int  grid_lock;
    int  selected;
    int  lighter;
    int  random;
    int  type;

    /* First work out the *Backdrop command */
    error_trap(radiobutton_get_state(0, config_id, StandardTileRadio, 0, &radio_on), 0);
    switch (radio_on)
    {
        case StandardTileRadio:
            error_trap(optionbutton_get_state(0, config_id, LighterOptionButton, &lighter), 0);
            error_trap(optionbutton_get_state(0, config_id, Randomise, &random), 0);
            if (random)
            {
               sprintf(backdrop_command,
                       TextureResPath "RTexture %c\nBackdrop -T",
                       lighter ? 'L' : ' ');
            }
            else
            {
               pinboard_get_tile_filename(current_tile, max_std_tile, lighter, string);
               sprintf(backdrop_command, "Backdrop -T %s", string);
            }
            break;

        case CustomImageRadio:
            if (custom_filename[0] != 0)
            {
                error_trap(radiobutton_get_state(0, config_id, ScaledRadioButton, 0, &type), 0);
                switch (type)
                {
                    case ScaledRadioButton: sprintf(string, "Backdrop -S"); break;
                    case CentredRadioButton: sprintf(string, "Backdrop -C"); break;
                    default: sprintf(string, "Backdrop -T"); break;
                }
                sprintf(backdrop_command, "%s %s", string, custom_filename);
            }
            else
            {
                sprintf(backdrop_command, "Backdrop -Remove");
            }
            break;

       default:
           sprintf(backdrop_command, "Backdrop -R");
           break;
    }

    /* Add the colour switch to the backdrop command... */
    sprintf(string, " -Colour &%x ", background_colour);
    strcat(backdrop_command, string);

    /* ...and the icon text colour */
    sprintf(string, " -TextColour &%x\0", text_colour);
    strcat(backdrop_command, string);

    /* Now work out the *Pinboard command */
    strcpy(pinboard_command, "PinboardOptions");
    error_trap(optionbutton_get_state(0, config_id, GridLockOption, &grid_lock), 0);
    if (grid_lock) strcat(pinboard_command, " -G");

    error_trap(stringset_get_selected(1, config_id, IconiseToMenu, &selected), 0);
    switch (selected)
    {
        case 1: strcat(pinboard_command, " -ITIB"); break;
        case 2: strcat(pinboard_command, " -ITTL"); break;
        case 3: strcat(pinboard_command, " -ITBL"); break;
        case 4: strcat(pinboard_command, " -ITTR"); break;
        case 5: strcat(pinboard_command, " -ITBR"); break;
    }

    error_trap(stringset_get_selected(1, config_id, IconiseStackMenu, &selected), 0);
    if (selected == 1) strcat(pinboard_command, " -ISV");

    error_trap(stringset_get_selected(1, config_id, TidyToMenu, &selected), 0);
    switch (selected)
    {
        case 0: strcat(pinboard_command, " -TTTL"); break;
        case 1: strcat(pinboard_command, " -TTBL"); break;
        case 2: strcat(pinboard_command, " -TTTR"); break;
        case 3: strcat(pinboard_command, " -TTBR"); break;
    }

    error_trap(stringset_get_selected(1, config_id, TidyStackMenu, &selected), 0);
    if (selected == 1) strcat(pinboard_command, " -TSV");

    /* Now write the commands to the choices file */
    error_trap(pinboard_write_choices(backdrop_command, pinboard_command), 0);
}


/*---------------------------------------------------------------------------*
 * try_it                                                                    *
 *                                                                           *
 * User has clicked on 'Try' button, so make up a *Backdrop command and      *
 * execute it.                                                               *
 *---------------------------------------------------------------------------*/

static void try_it(void)
{
    char  backdrop_string[MaxFilenameSize];
    char  string[256];
    int   lighter;
    int   random;
    int   option;
    int   radio;

    error_trap(radiobutton_get_state(0, config_id, StandardTileRadio, 0, &option), 0);
    switch (option)
    {
        case StandardTileRadio:
            error_trap(optionbutton_get_state(0, config_id, LighterOptionButton, &lighter), 0);
            error_trap(optionbutton_get_state(0, config_id, Randomise, &random), 0);
            strcpy(backdrop_string, "Backdrop -Tile ");
            if (random)
            {
               /* Use 'RTexture' directly to randomise */
               sprintf(string,
                       "WimpTask " TextureResPath "RTexture %c",
                       lighter ? 'L' : ' ');
               error_trap(_swix(Wimp_StartTask, _IN(0), string), 0);
            }
            else
            {
               pinboard_get_tile_filename(current_tile, max_std_tile, lighter, string);
               strcat(backdrop_string, string);
            }
            break;

        case CustomImageRadio:
            if (custom_filename[0] == 0)
            {
               sprintf(backdrop_string, "Backdrop -Remove");
               break;
            }
            memset(string, 0, 64);
            error_trap(radiobutton_get_state(0, config_id, ScaledRadioButton, 0, &radio), 0);
            switch (radio)
            {
                case ScaledRadioButton: sprintf(backdrop_string, "Backdrop -Scale "); break;
                case TiledRadioButton: sprintf(backdrop_string, "Backdrop -Tile "); break;
                default: sprintf(backdrop_string, "Backdrop -Centre "); break;
            }
            strcat(backdrop_string, custom_filename);
            break;

        default:
            sprintf(backdrop_string, "Backdrop -Remove");
            break;
    }

    /* Add the colour switch to the backdrop command... */
    sprintf(string, " -Colour &%x ", background_colour);
    strcat(backdrop_string, string);

    /* ...and the icon text colour */
    sprintf(string, " -TextColour &%x\0", text_colour);
    strcat(backdrop_string, string);

    error_trap(_swix(OS_CLI, _IN(0), backdrop_string), 0);
}


/*---------------------------------------------------------------------------*
 * update_colour_icon                                                        *
 *                                                                           *
 * Update the background/icon text colour icon to display the user's choice  *
 * of colour.                                                                *
 *---------------------------------------------------------------------------*/

static void update_colour_icon(int icon)
{
    _kernel_oserror *e;
    BBox             gadget_bbox;
    char            *sprite_addr;
    int              width, height, colour;
    char             sprname[12];

    if (icon == PlainColBox)
    {
      strcpy(sprname, "plain_col");
      colour = background_colour;
    }
    else
    {
      strcpy(sprname, "plain_colt");
      colour = text_colour;
    }

    e=sprite_find_address_of(client_sprite_area, sprname, &sprite_addr);
    if (!e) e=sprite_return_size(client_sprite_area, sprite_addr, &width, &height);

    /* Fill in the sprite with the new colour */
    if (!e)
    {
        int  i;
        int *sprite_data = (int*) (sprite_addr + 44);

        for (i=0; i < (width*height); i++)
        {
            sprite_data[i] = colour >> 8;
        }
    }

    /* Force a redraw of the icon */
    error_trap(gadget_get_bbox(0, config_id, icon, &gadget_bbox), 0);
    error_trap(window_force_redraw(0, config_id, &gadget_bbox), 0);
}


/*---------------------------------------------------------------------------*
 * update_standard_tile_icon                                                 *
 *                                                                           *
 * Update the standard tile icon to display the user's choice of tile.       *
 *                                                                           *
 * Globals: current_tile                                                     *
 *---------------------------------------------------------------------------*/

static void update_standard_tile_icon(void)
{
    BBox gadget_bbox;
    char tilename[128];
    int  lighter;

    error_trap(optionbutton_get_state(0, config_id, LighterOptionButton, &lighter), 0);

    /* Check if this tile exists. If not, then previous one must do, but that's already
     * displayed, so exit
     */
    if (!pinboard_get_tile_filename(current_tile, max_std_tile, lighter, tilename))
    {
        current_tile--;
        return;
    }

    /* Update sprite and redraw */
    error_trap(pinboard_plot_texture_into_sprite(client_sprite_area,
                                                 tilename,
                                                 0,
                                                 "std_tile"), 0);
    error_trap(gadget_get_bbox(0, config_id, StandardTileSprite, &gadget_bbox), 0);
    gadget_bbox.xmin += 8;
    gadget_bbox.xmax -= 8;
    gadget_bbox.ymin += 8;
    gadget_bbox.ymax -= 8;
    error_trap(window_force_redraw(0, config_id, &gadget_bbox), 0);
}




/*---------------------------------------------------------------------------*
 * update_custom_image_icon                                                  *
 *                                                                           *
 * Force an update of the custom image icon, so that it shows the user's     *
 * latest choice.                                                            *
 *---------------------------------------------------------------------------*/

static void update_custom_image_icon(int redraw)
{
      int radio_on;

      error_trap(radiobutton_get_state(0, config_id, ScaledRadioButton, 0, &radio_on), 0);

      /* Prevent tiled JPEGs */
/*      if (custom_filetype == FileType_JPEG)
      {
          grey_gadget(config_id, TiledRadioButton);

          if (radio_on == TiledRadioButton)
          {
              error_trap(radiobutton_set_state(0, config_id, CentredRadioButton, 1), 0);
              radio_on = CentredRadioButton;
          }
      }
      else
      {
          ungrey_gadget(config_id, TiledRadioButton);
      }*/

      /* Create custom image icon */
      switch (custom_filetype)
      {
          case FileType_Sprite:
              error_trap(pinboard_do_custom_image_sprite(client_sprite_area,
                                                         custom_filename,
                                                         radio_on,
                                                         background_colour), 0);
              break;

          case FileType_JPEG:
              error_trap(pinboard_do_custom_image_jpeg(client_sprite_area,
                                                       custom_filename,
                                                       radio_on,
                                                       background_colour), 0);
              break;
      }

      if (redraw) redraw_custom_image_icon();
}


/*---------------------------------------------------------------------------*
 * grey_backdrop_choices                                                     *
 *                                                                           *
 * Depending on which of the backdrop types (plain colour, standard tile or  *
 * custom image) is selected, grey appropriate options.                      *
 *                                                                           *
 * In: icon = id of the radio icon which is selected.                        *
 *---------------------------------------------------------------------------*/

static void grey_backdrop_choices(int icon)
{
    int haverand,random;

    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, TextureResPath "RTexture", &haverand), 0);
    error_trap(optionbutton_get_state(0, config_id, Randomise, &random), 0);
    switch (icon)
    {
        case PlainColourRadio:
            grey_gadget(config_id, LighterOptionButton);
            grey_gadget(config_id, TileUpArrow);
            grey_gadget(config_id, TileDownArrow);
            grey_gadget(config_id, Randomise);
            grey_gadget(config_id, ScaledRadioButton);
            grey_gadget(config_id, CentredRadioButton);
            grey_gadget(config_id, TiledRadioButton);
            break;

        case StandardTileRadio:
            ungrey_gadget(config_id, LighterOptionButton);
            if (haverand==1)
            {
               ungrey_gadget(config_id, Randomise);
               ungrey_gadget(config_id, TileUpArrow);   /* Always ungrey incase RTexture magically appeared since */
               ungrey_gadget(config_id, TileDownArrow); /* the plugin last checked */
               if (random)
               {
                  grey_gadget(config_id, TileUpArrow);
                  grey_gadget(config_id, TileDownArrow);
               }
            }
            else
            {
               random = 0;
               error_trap(optionbutton_set_state(0, config_id, Randomise, random), 0);
               grey_gadget(config_id, Randomise);
               ungrey_gadget(config_id, TileUpArrow);
               ungrey_gadget(config_id, TileDownArrow);
            }
            grey_gadget(config_id, ScaledRadioButton);
            grey_gadget(config_id, CentredRadioButton);
            grey_gadget(config_id, TiledRadioButton);
            break;

        case CustomImageRadio:
            grey_gadget(config_id, LighterOptionButton);
            grey_gadget(config_id, TileUpArrow);
            grey_gadget(config_id, TileDownArrow);
            grey_gadget(config_id, Randomise);
            ungrey_gadget(config_id, ScaledRadioButton);
            ungrey_gadget(config_id, CentredRadioButton);
            ungrey_gadget(config_id, TiledRadioButton);
            break;
    }
}


/*---------------------------------------------------------------------------*
 * parse_backdrop_command                                                    *
 *                                                                           *
 * Parse a *Backdrop command and set options in configure window as          *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Backdrop                                   *
 *                                                                           *
 * Globals: current_tile, background_colour, text_colour, custom_filetype    *
 *---------------------------------------------------------------------------*/

static void parse_backdrop_command(char *string)
{
    static const char backdrop_args[] = "path,"
                                        "Centre=C/S,Tile=T/S,Scale=S/S,NoRecache=N/S,Remove=R/S,"
                                        "Colour/E,TextColour/E,";
    char  default_path[] = DefaultTexture;
    char *path;
    int   buffer[16 + ((MaxFilenameSize /* Path */ + 5 /* Colour */ + 5 /* TextColour */)/sizeof(int))];
    int   custom_radio = TiledRadioButton;
    int   backdrop_type;
    int   filetype;
    int   random;
    int   texture_no;
    int   is_lighter;

    error_trap(_swix(OS_ReadArgs, _INR(0,3), backdrop_args, string, buffer, sizeof(buffer)), 0);

    /* Check for background colour */
    if (buffer[6])
    {
        char *answer = ((char*)buffer[6] + 1);

        background_colour = (answer[3]<<24) + (answer[2]<<16) + (answer[1]<<8);
        update_colour_icon(PlainColBox);
    }

    /* Check for icon text colour */
    if (buffer[7])
    {
        char *answer = ((char*)buffer[7] + 1);

        text_colour = (answer[3]<<24) + (answer[2]<<16) + (answer[1]<<8);
        update_colour_icon(TextColourBox);
    }

    /* Are we tiled, scaled or centred? */
    if (buffer[1]) custom_radio = CentredRadioButton;
    if (buffer[2]) custom_radio = TiledRadioButton;
    if (buffer[3]) custom_radio = ScaledRadioButton;
    error_trap(radiobutton_set_state(0, config_id, custom_radio, 1), 0);

    /* If a pathname was specified, ensure it is a sprite or a JPEG */
    path = (char*)buffer[0];
    if (path != NULL)
    {
        error_trap(_swix(OS_File, _INR(0,1)|_OUT(6), OSFile_ReadWithTypeNoPath, path, &filetype), 0);
        if ((filetype != FileType_Sprite) && (filetype != FileType_JPEG)) path = NULL;
    }

    /* Depending on the type of backdrop (plain colour, standard tile, custom image)... */
    error_trap(optionbutton_get_state(0, config_id, Randomise, &random), 0);
    if (random)
    {
        default_path[strlen(default_path)-1] = rand_suffix;
        path = (char *)default_path;
    }

    if (path == NULL)
    {
        /* No pathname - use a plain colour */
        backdrop_type = PlainColourRadio;
    }
    else if (pinboard_query_standard_texture(&texture_no, max_std_tile, &is_lighter, path))
    {
        /* This is a standard tile */
        backdrop_type = StandardTileRadio;
        current_tile = texture_no;
        error_trap(optionbutton_set_state(0, config_id, LighterOptionButton, is_lighter), 0);
        update_standard_tile_icon();
    }
    else
    {
        /* Custom image */
        backdrop_type = CustomImageRadio;
        strcpy(custom_filename, path);
        custom_filetype = filetype;
        update_custom_image_icon(0);
        hide_custom_sprite_icons(1);
        update_standard_tile_icon();
    }

    /* Grey other icons as appropriate */
    error_trap(radiobutton_set_state(0, config_id, backdrop_type, 1), 0);
    grey_backdrop_choices(backdrop_type);
}


/*---------------------------------------------------------------------------*
 * parse_pinboard_command                                                    *
 *                                                                           *
 * Parse a *Pinboard command and set options in configure window as          *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Pinboard                                   *
 *---------------------------------------------------------------------------*/

static void parse_pinboard_command(char *string)
{
    static const char pinboard_args[] = "Grid/S,IconiseToIconBar=ITIB/S,"
                                        "IconiseToTopLeft=ITTL/S,IconiseToBottomLeft=ITBL/S,"
                                        "IconiseToTopRight=ITTR/S,IconiseToBottomRight=ITBR/S,"
                                        "IconiseStackVertical=ISV/S,"
                                        "TidyToTopLeft=TTTL/S,TidyToBottomLeft=TTBL/S,"
                                        "TidyToTopRight=TTTR/S,TidyToBottomRight=TTBR/S,"
                                        "TidyStackVertical=TSV/S,";
    int  buffer[24];
    int  grid_lock = 0;
    int  iconise_to = 0;
    int  iconise_stack = 0;
    int  tidy_to = 0;
    int  tidy_stack = 0;
    int  n;

    error_trap(_swix(OS_ReadArgs, _INR(0,3), pinboard_args, string, buffer, sizeof(buffer)), 0);

    /* Read Grid lock option */
    if (buffer[0]) grid_lock = 1;
    else grid_lock = 0;

    /* Read Iconise to... options */
    for (n=1; n<=5; n++) if (buffer[n]) iconise_to = n;
    if (buffer[6]) iconise_stack = 1;
    else iconise_stack = 0;

    /* Read Tidy to... options */
    for (n=7; n<=10; n++) if (buffer[n]) tidy_to = n - 7;
    if (buffer[11]) tidy_stack = 1;
    else tidy_stack = 0;

    /* Update icons */
    error_trap(optionbutton_set_state(0, config_id, GridLockOption, grid_lock), 0);
    error_trap(stringset_set_selected(1, config_id, IconiseToMenu, (char*)iconise_to), 0);
    error_trap(stringset_set_selected(1, config_id, IconiseStackMenu, (char*)iconise_stack), 0);
    error_trap(stringset_set_selected(1, config_id, TidyToMenu, (char*)tidy_to), 0);
    error_trap(stringset_set_selected(1, config_id, TidyStackMenu, (char*)tidy_stack), 0);

    /* Grey out iconise stack menu if iconise to iconbar or to icon */
    if (iconise_to < 2) grey_gadget(config_id, IconiseStackMenu);
    else ungrey_gadget(config_id, IconiseStackMenu);
}


/*---------------------------------------------------------------------------*
 * read_choices                                                              *
 *                                                                           *
 * Read the *Pinboard and *Backdrop commands from the choices file.          *
 *---------------------------------------------------------------------------*/

static void read_choices(void)
{
    FILE *fp;
    char  string[1024];
    int   more = 1;

    /* Read current setup */
    fp = fopen(ChoicesFileRO, "r");
    if (fp != NULL)
    {
        while (more)
        {
            more = (int)fgets(string, 1024, fp);
            if (more)
            {
                if (strncmpa(string, "Backdrop", 8)==0) parse_backdrop_command(string+9);
                if (strncmpa(string, "PinboardOptions", 15)==0) parse_pinboard_command(string+16);
                if (strstr(string, "RTexture") != NULL)
                {
                   optionbutton_set_state(0, config_id, Randomise, 1); /* Tick randomise */
                   rand_suffix = string[(int)(strstr(string, "RTexture")-string)+9]; /* Deduce if lighter was requested */
                }
            }
        }
        fclose(fp);
    }
}


/*---------------------------------------------------------------------------*
 * set_default_choices                                                       *
 *                                                                           *
 * Set the default choices.                                                  *
 *                                                                           *
 * Globals: current_tile, background_colour                                  *
 *---------------------------------------------------------------------------*/

static void set_default_choices(void)
{
    memset(custom_filename, 0, MaxFilenameSize);

    error_trap(radiobutton_set_state(0, config_id, StandardTileRadio, 1), 0);
    error_trap(optionbutton_set_state(0, config_id, LighterOptionButton, 0), 0);
    error_trap(optionbutton_set_state(0, config_id, Randomise, 0), 0);
    error_trap(radiobutton_set_state(0, config_id, TiledRadioButton, 1), 0);
    error_trap(optionbutton_set_state(0, config_id, GridLockOption, 0), 0);
    error_trap(stringset_set_selected(1, config_id, IconiseToMenu, (char*)4), 0);
    error_trap(stringset_set_selected(1, config_id, IconiseStackMenu, (char*)1), 0);
    error_trap(stringset_set_selected(1, config_id, TidyToMenu, 0), 0);
    error_trap(stringset_set_selected(1, config_id, TidyStackMenu, 0), 0);
    ungrey_gadget(config_id, IconiseStackMenu);
    ungrey_gadget(config_id, TileUpArrow);
    ungrey_gadget(config_id, TileDownArrow);

    /* Change current tile? */
    if (current_tile != 1)
    {
        current_tile = 1;
        update_standard_tile_icon();
    }

    /* Change background colour? */
    if (background_colour != DefaultBackgroundColour)
    {
        background_colour = DefaultBackgroundColour;
        update_colour_icon(PlainColBox);
    }

    /* Change icon text colour? */
    if (text_colour != DefaultTextColour)
    {
        text_colour = DefaultTextColour;
        update_colour_icon(TextColourBox);
    }

    hide_custom_sprite_icons(0);
    grey_backdrop_choices(StandardTileRadio);
}


/*-----------------------------------------------------------------------------------------------*
 *                                      Event handlers                                           *
 *-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * toolbox_error                                                             *
 *                                                                           *
 * Handler for errors from toolbox.                                          *
 *---------------------------------------------------------------------------*/

static int toolbox_error(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
    ToolboxErrorEvent *error_event = (ToolboxErrorEvent *)event;
    _kernel_oserror    err;

    strcpy(err.errmess, error_event->errmess);
    err.errnum = error_event->errnum;
    wimp_report_error(&err, 0, "Configure", 0, 0, 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * default_key_handler                                                       *
 *                                                                           *
 * Handler for key presses.                                                  *
 *---------------------------------------------------------------------------*/

static int default_key_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
   int key_code = event->key_pressed.key_code;

   wimp_process_key(key_code);

   return 1;
}


/*---------------------------------------------------------------------------*
 * action_selected                                                           *
 *                                                                           *
 * Handler for when action buttons are clicked on.                           *
 *---------------------------------------------------------------------------*/

static int action_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    ActionButtonSelectedEvent *block = (ActionButtonSelectedEvent*) event_block;
    int                        icon = id_block->self_component;

    switch (icon)
    {
        case TryActionButton:
            try_it();
            changes_have_been_made = TRUE;
            break;

        case SetActionButton:
            save_choices();
            /* If Return pressed or click on Set was with Return, then exit program */
            if ( ((block->hdr.flags & Action_ReturnKey) == 0)
              || (block->hdr.flags & Action_SelectButton) )
            {
                program_exit();
            }
            break;

        case CancelActionButton:
            /* If right button pressed (meaning window stays open) or if changes
               have been made to the backdrop (eg. by clicking on Try), then
               read the original choices back in and update actual backdrop, if
               necessary */
            if ((block->hdr.flags & Action_AdjustButton) || (changes_have_been_made))
            {
                read_choices();
                if (changes_have_been_made) try_it();
                changes_have_been_made = FALSE;
            }

            /* If Escape pressed or click on Cancel was with Select, then exit */
            if ( ((block->hdr.flags & Action_EscapeKey) == 0)
              || (block->hdr.flags & Action_SelectButton) )
            {
                program_exit();
            }
            break;

        case DefaultActionButton:
            set_default_choices();
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * adjuster_clicked                                                          *
 *                                                                           *
 * Handler for when adjuster arrows are clicked.                             *
 *                                                                           *
 * Globals: current_tile                                                     *
 *---------------------------------------------------------------------------*/

static int adjuster_clicked(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    AdjusterClickedEvent *adjuster_block = (AdjusterClickedEvent*) event_block;
    int                   icon = id_block->self_component;

    if ((icon == TileUpArrow) || (icon == TileDownArrow))
    {
        if (adjuster_block->direction == 0) current_tile--;
        else current_tile++;

        if (current_tile < 1) current_tile = 1;
        else update_standard_tile_icon();
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * colour_selected                                                           *
 *                                                                           *
 * Handler for colour selection from Colour Dialogue Box                     *
 *                                                                           *
 * Globals: background_colour                                                *
 *---------------------------------------------------------------------------*/

static int colour_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->parent_component;
    ColourDboxColourSelectedEvent *evblock = (ColourDboxColourSelectedEvent*) event_block;
    char                          *colour_block = (char*)evblock + 16;

    switch (icon)
    {
      case PlainColourPopUp :
      {
        background_colour = (colour_block[3]<<24) + (colour_block[2]<<16) + (colour_block[1]<<8);

        update_colour_icon(PlainColBox);
        error_trap(toolbox_delete_object(0, bgcolourbox_id), 0);
        bgcolourbox_id = 0;
        break;
      }

      case TextColourPopUp :
      {
        text_colour = (colour_block[3]<<24) + (colour_block[2]<<16) + (colour_block[1]<<8);
        update_colour_icon(TextColourBox);
        error_trap(toolbox_delete_object(0, txcolourbox_id), 0);
        txcolourbox_id = 0;
        break;
      }
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * option_changed                                                            *
 *                                                                           *
 * Handler for option button changed events.                                 *
 *---------------------------------------------------------------------------*/

static int option_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->self_component;
    int random;

    if (icon == LighterOptionButton) update_standard_tile_icon();
    if (icon == Randomise)
    {
       error_trap(optionbutton_get_state(0, config_id, Randomise, &random), 0);
       if (random)
       {
          grey_gadget(config_id, TileUpArrow);
          grey_gadget(config_id, TileDownArrow);
       }
       else
       {
          ungrey_gadget(config_id, TileUpArrow);
          ungrey_gadget(config_id, TileDownArrow);
       }
    }
    return 1;
}


/*---------------------------------------------------------------------------*
 * radio_changed                                                             *
 *                                                                           *
 * Handler for radio button changed events.                                  *
 *---------------------------------------------------------------------------*/

static int radio_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->self_component;

    switch (icon)
    {
        case ScaledRadioButton:
        case CentredRadioButton:
        case TiledRadioButton:
            update_custom_image_icon(1);
            break;

        case PlainColourRadio:
        case StandardTileRadio:
        case CustomImageRadio:
            grey_backdrop_choices(icon);
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * stringset_changed                                                         *
 *                                                                           *
 * Handle event when stringset value changes.                                *
 *---------------------------------------------------------------------------*/

static int stringset_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->self_component;
    int selected;

    /* We're only interested in the iconise to menu */
    if (icon != IconiseToMenu) return 1;

    error_trap(stringset_get_selected(1, config_id, IconiseToMenu, &selected), 0);

    /* If Iconise to icon or iconise to iconbar, grey the iconise stack menu */
    if (selected < 2) grey_gadget(config_id, IconiseStackMenu);
    else ungrey_gadget(config_id, IconiseStackMenu);

    return 1;
}


/*---------------------------------------------------------------------------*
 * popup_showing                                                             *
 *                                                                           *
 * Called when a colour box popup is about to be displayed.                  *
 *---------------------------------------------------------------------------*/
static int popup_showing(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->self_component;
    unsigned int colour_block[2];
    ObjectId id = 0;

    switch (icon)
    {
      case PlainColourPopUp :
        colour_block[0] = background_colour;
        if (bgcolourbox_id == 0)
        {
          error_trap(toolbox_create_object(0, "BGColDbox", &bgcolourbox_id), 1);
        }
        id = bgcolourbox_id;
        break;

      case TextColourPopUp :
        colour_block[0] = text_colour;
        if (txcolourbox_id == 0)
        {
          error_trap(toolbox_create_object(0, "ITColDbox", &txcolourbox_id), 1);
        }
        id = txcolourbox_id;
        break;
    }

    if ((icon == PlainColourPopUp) || (icon == TextColourPopUp))
    {
      colour_block[1] = 0;
      error_trap(colourdbox_set_colour(0, id, (int*)&colour_block), 0);
      error_trap(toolbox_show_object(0, id, 0, 0, config_id, icon), 0);
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_quit                                                              *
 *                                                                           *
 * Called when wimp quit message received.                                   *
 *---------------------------------------------------------------------------*/

static int message_quit(WimpMessage *event, void *handler)
{
    program_exit();

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_reopen                                                            *
 *                                                                           *
 * Called when we receive a message from Configure telling us to reopen our  *
 * window.                                                                   *
 *---------------------------------------------------------------------------*/

static int message_reopen(WimpMessage *event, void *handler)
{
    error_trap(toolbox_show_object(0, config_id, 0, 0, 0, 0), 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_dataload                                                          *
 *                                                                           *
 * Called when wimp dataload message received.                               *
 *                                                                           *
 * Globals: custom_filetype                                                  *
 *---------------------------------------------------------------------------*/

static int message_dataload(WimpMessage *event, void *handler)
{
    int object;
    int component;
    int window = event->data.data_load.destination_window;
    int icon = event->data.data_load.destination_icon;
    int filetype = event->data.data_load.file_type;

    error_trap(window_wimp_to_toolbox(0, window, icon, &object, &component), 0);
    if (object != config_id) return 1;
    if ((component < CustomDropZoneA) && (component > CustomDropZoneE)) return 1;
    if ((filetype != FileType_Sprite) && (filetype != FileType_JPEG)) return 1;

    error_trap(radiobutton_set_state(0, config_id, CustomImageRadio, 1), 0);
    grey_backdrop_choices(CustomImageRadio);

    custom_filetype = filetype;
    strcpy(custom_filename, event->data.data_load.leaf_name);
    update_custom_image_icon(0);
    hide_custom_sprite_icons(1);

    return 1;
}


/*---------------------------------------------------------------------------*
 * close_window                                                              *
 *                                                                           *
 * Called when user has clicked on close icon of window.                     *
 *---------------------------------------------------------------------------*/

static int close_window(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    program_exit();

    return 1;
}


/*-----------------------------------------------------------------------------------------------*
 *                              Program startup & Polling loop                                   *
 *-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * open_configure_window                                                     *
 *                                                                           *
 * Called to open the configure window on screen and register handlers.      *
 *---------------------------------------------------------------------------*/

static void open_configure_window(int at_x, int at_y)
{
    int  screenx;
    int  screeny;
    ObjectTemplateHeader *objtemplate;
    WindowTemplate       *wintemplate;
    WimpWindow           *windef;

    /* Read the window object in by hand */
    error_trap(toolbox_template_lookup(0, "PinConfig", (void **)&objtemplate), 1);
    if (objtemplate->object_class != Window_ObjectClass)
    {
        error_trap(common_error(messages_lookup("BadClass")), 1);
    }
    wintemplate = objtemplate->body;
    windef = &wintemplate->window;
    if (common_read_screensize(&screenx, &screeny) == NULL)
    {
        /* Calculate the window height compared with the screen and
         * turn the vertical scrollbar on if it doesn't fit
         */
        if ((windef->visible_area.ymax - windef->visible_area.ymin) >= screeny)
        {
            windef->flags |= WimpWindow_VScroll;
        }
        else
        {
            windef->flags &= ~WimpWindow_VScroll;
        }
    }
    error_trap(toolbox_create_object(Toolbox_CreateObject_InCore, objtemplate, &config_id), 1);

    /* Register handlers for the configure window */
    error_trap(event_register_toolbox_handler(-1,Toolbox_Error,toolbox_error,NULL) ,0);
    error_trap(event_register_wimp_handler(config_id, Wimp_ECloseWindow, close_window, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, Adjuster_Clicked, adjuster_clicked, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, ActionButton_Selected, action_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, OptionButton_StateChanged, option_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(-1, ColourDbox_ColourSelected, colour_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, RadioButton_StateChanged, radio_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, StringSet_ValueChanged, stringset_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, PopUp_AboutToBeShown, popup_showing, NULL), 0);
    error_trap(event_register_message_handler(Wimp_MDataLoad, message_dataload, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_EKeyPressed, default_key_handler, NULL), 0);

    /* Read in the choices, populate and show dialogue */
    max_std_tile = pinboard_count_standard_textures();
    hide_custom_sprite_icons(0);
    update_standard_tile_icon();
    read_choices();
    if ((at_x==-1) && (at_y==-1))
    {
        /* No position supplied in the command line, just centre it */
        error_trap(toolbox_show_object(0, config_id, Toolbox_ShowObject_Centre, NULL, 0, 0), 0);
    }
    else
    {
        int  buffer[2];

        buffer[0] = at_x;
        buffer[1] = at_y;
        error_trap(toolbox_show_object(0, config_id, Toolbox_ShowObject_TopLeft, buffer, 0, 0), 0);
    }
}


/*---------------------------------------------------------------------------*
 * main_initialise                                                           *
 *                                                                           *
 * Initialise toolbox etc.                                                   *
 *                                                                           *
 * Returns: 1 if everything went okay, 0 otherwise                           *
 *                                                                           *
 * Globals: custom_filename, client_sprite_area                              *
 *---------------------------------------------------------------------------*/

static int main_initialise(void)
{
    static int mess_wanted[] = {Wimp_MQuit,
                                Wimp_MDataLoad,
                                Wimp_MOpenConfigWindow,
                                0};
    static int tbox_wanted[] = {Toolbox_Error,
                                Adjuster_Clicked,
                                ActionButton_Selected,
                                OptionButton_StateChanged,
                                ColourDbox_ColourSelected,
                                RadioButton_StateChanged,
                                StringSet_ValueChanged,
                                PopUp_AboutToBeShown,
                                0};
    void      *sprptr;
    int        task_handle;

    custom_filename = malloc(MaxFilenameSize);
    if (!custom_filename) return 0;
    memset(custom_filename, 0, MaxFilenameSize);

    error_trap(toolbox_initialise(0, 310, mess_wanted, tbox_wanted,
                                  "<PinSetup$Dir>", &messages_desc, &idb,
                                  0, &task_handle, &sprptr) ,1);
    client_sprite_area = (int*)sprptr;
    error_trap(event_initialise(&idb), 1);
    error_trap(event_set_mask(Wimp_Poll_NullMask), 0);
    messages_register(&messages_desc, messages_string);

    error_trap(event_register_message_handler(Wimp_MQuit, message_quit, NULL), 0);
    error_trap(event_register_message_handler(Wimp_MOpenConfigWindow, message_reopen, NULL), 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * main                                                                      *
 *                                                                           *
 * Main polling loop                                                         *
 *---------------------------------------------------------------------------*/

int main(int argc, char *argv[])
{
    WimpPollBlock wpb;
    int           event_code;
    int           openat_x = -1;
    int           openat_y = -1;

    /* Have we been passed any co-ordinates to open at? */
    if ((argc >= 4) && (strcmp(argv[1], "-openat") == 0))
    {
        openat_x = atoi(argv[2]);
        openat_y = atoi(argv[3]);
    }

    /* Do main initialisation */
    if (!main_initialise()) return 0;

    /* Open configure window */
    open_configure_window(openat_x, openat_y);

    /* Poll loop */
    while (TRUE)
    {
        error_trap(event_poll(&event_code, &wpb, NULL), 0);
    }

    return 0;
}

