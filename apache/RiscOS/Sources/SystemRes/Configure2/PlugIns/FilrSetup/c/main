/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*---------------------------------------------------------------------------*/
/* File:    c.main                                                           */
/* Purpose: Main WIMP shell for Filer configuration                          */
/* Author:  Richard Leggett                                                  */
/* History: 06-Nov-97: RML: Begun.                                           */
/*          20-Mar-98: RML: Minor modifications.                             */
/*          13-May-98: RML: If not high enough vertical resolution, use a    */
/*                          window with vertical scrollbar.                  */
/*          14-May-98: RML: Now redraws whole screen when Set clicked.       */
/*                                                                           */
/* Copyright © 1998 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "Global/CMOS.h"
#include "toolbox.h"
#include "event.h"
#include "common.h"
#include "window.h"
#include "menu.h"
#include "wimplib.h"
#include "defines.h"
#include "filer.h"

static IdBlock    idb;
static MessagesFD messages_desc;
static char       messages_string[255];
static ObjectId   main_window, sort_menu;
static int        fullinfo_truncation = 4096;
static BOOL       can_reversesort, can_numericalsort;

static int sort_selected(int, ToolboxEvent *, IdBlock *, void *);

/*---------------------------------------------------------------------------*
 * program_exit                                                              *
 *                                                                           *
 * Finished with this plug-in, so exit.                                      *
 *---------------------------------------------------------------------------*/

static void program_exit(void)
{
    exit(0);
}


/*---------------------------------------------------------------------------*
 * save_choices                                                              *
 *                                                                           *
 * Read the choices from the window and output a command file.               *
 *---------------------------------------------------------------------------*/

static void save_choices(void)
{
    char layout_command[256] = "Filer_Layout";
    char options_command[256] = "Filer_Options";
    char truncation_command[256] = "Filer_Truncation";
    char dclickhold_command[256] = "Filer_DClickHold";
    int  selected;
    int  largeicon_truncation;
    int  smallicon_truncation;
    int  dclickholddelay;
    int  value;

    /* Add icon size switch to Filer_Layout command */
    error_trap(stringset_get_selected(1, main_window, DisplayAsMenu, &selected), 0);
    switch (selected)
    {
        case 0: strcat(layout_command, " -LargeIcons"); break;
        case 1: strcat(layout_command, " -SmallIcons"); break;
        case 2: strcat(layout_command, " -FullInfo");   break;
    }

    /* Add sort type switch to Filer_Layout command */
    for (selected = 0; selected <= 3; selected++)
    {
        error_trap(menu_get_tick(0, sort_menu, selected, &value), 0);
        if (value) break;
    }
    switch (selected)
    {
        case 0: strcat(layout_command, " -SortByName"); break;
        case 1: strcat(layout_command, " -SortByType"); break;
        case 2: strcat(layout_command, " -SortBySize"); break;
        case 3: strcat(layout_command, " -SortByDate"); break;
    }

    if (can_reversesort)
    {
        /* Add sort order to Filer_Layout command */
        error_trap(menu_get_tick(0, sort_menu, MenuSortReversed, &selected), 0);
        if (selected) strcat(layout_command, " -ReverseSort");
    }

    if (can_numericalsort)
    {
        /* Add numerical sort style to Filer_Layout command */
        error_trap(menu_get_tick(0, sort_menu, MenuSortNumerical, &selected), 0);
        if (selected) strcat(layout_command, " -NumericalSort");
    }
    
    /* Make up Filer_Options command */
    error_trap(optionbutton_get_state(0, main_window, ConfirmOption, &selected), 0);
    if (selected)
    {
        error_trap(radiobutton_get_state(0, main_window, ConfirmAllRadio, 0, &selected), 0);
        switch(selected)
        {
            case ConfirmAllRadio:     strcat(options_command, " -ConfirmAll");     break;
            case ConfirmDeletesRadio: strcat(options_command, " -ConfirmDeletes"); break;
        }
    }

    error_trap(optionbutton_get_state(0, main_window, VerboseOption, &selected), 0);
    if (selected) strcat(options_command, " -Verbose");

    error_trap(optionbutton_get_state(0, main_window, NewerOption, &selected), 0);
    if (selected) strcat(options_command, " -Newer");

    error_trap(optionbutton_get_state(0, main_window, ForceOption, &selected), 0);
    if (selected) strcat(options_command, " -Force");

    error_trap(optionbutton_get_state(0, main_window, FasterOption, &selected), 0);
    if (selected) strcat(options_command, " -Faster");

    /* Make up a Filer_Truncation command */
    error_trap(numberrange_get_value(0, main_window, LargeIconRange, &largeicon_truncation), 0);
    error_trap(numberrange_get_value(0, main_window, SmallIconRange, &smallicon_truncation), 0);
    sprintf(truncation_command, "Filer_Truncation -LargeIconDisplay %d -SmallIconDisplay %d -FullInfoDisplay %d",
            largeicon_truncation, smallicon_truncation, fullinfo_truncation);

    /* Make up a Filer_DClickHold command */
    error_trap(optionbutton_get_state(0, main_window, DClickHoldOption, &selected), 0);
    if (selected)
    {
        error_trap(numberrange_get_value(0, main_window, DClickHoldDelay, &dclickholddelay), 0);
    }
    else
    {
        dclickholddelay = 0;
    }
    sprintf(dclickhold_command, "Filer_DClickHold %d", 10 * dclickholddelay);

    /* Now write the choices file */
    error_trap(write_filer_choices(options_command, truncation_command, layout_command, dclickhold_command), 0);

    /* Write the CMOS bits */
    value = read_cmos_value(FileSwitchCMOS) & ~(InteractiveCopyCMOSBit | DragASpriteCMOSBit);
    error_trap(optionbutton_get_state(0, main_window, ActiveCopyOption, &selected), 0);
    if (!selected) value = value | InteractiveCopyCMOSBit;
    error_trap(optionbutton_get_state(0, main_window, SolidDragOption, &selected), 0);
    if (selected) value = value | DragASpriteCMOSBit;
    write_cmos_value(FileSwitchCMOS, value);
}


/*---------------------------------------------------------------------------*
 * update_icon_widths                                                        *
 *                                                                           *
 * Update the 'at least...' boxes.                                           *
 *---------------------------------------------------------------------------*/

static void update_icon_widths(void)
{
    char string[256];
    int  value;

    error_trap(numberrange_get_value(0, main_window, LargeIconRange, &value), 0);
    sprintf(string, "%d", how_many_characters(value));
    error_trap(displayfield_set_value(0, main_window, LargeNotLessThan, string), 0);
    error_trap(numberrange_get_value(0, main_window, SmallIconRange, &value), 0);
    sprintf(string, "%d", how_many_characters(value));
    error_trap(displayfield_set_value(0, main_window, SmallNotLessThan, string), 0);
}


/*---------------------------------------------------------------------------*
 * set_default_choices                                                       *
 *                                                                           *
 * Fill in the default choices in the dialogue box.                          *
 *---------------------------------------------------------------------------*/

static void set_default_choices(void)
{
    IdBlock id;

    error_trap(stringset_set_selected(StringSet_IndexedSelection, main_window, DisplayAsMenu, 0), 0);
    error_trap(menu_set_tick(0, sort_menu, MenuSortReversed, 0), 0);
    error_trap(menu_set_tick(0, sort_menu, MenuSortNumerical, 0), 0);
    id.self_component = MenuSortName; /* Fake menu selection */
    sort_selected(0, NULL, &id, NULL);

    error_trap(optionbutton_set_state(0, main_window, ActiveCopyOption, 1), 0);
    error_trap(optionbutton_set_state(0, main_window, ConfirmOption, 0), 0);
    grey_gadget(main_window, ConfirmAllRadio);
    grey_gadget(main_window, ConfirmDeletesRadio);
    error_trap(optionbutton_set_state(0, main_window, VerboseOption, 1), 0);
    error_trap(optionbutton_set_state(0, main_window, NewerOption, 1), 0);
    error_trap(optionbutton_set_state(0, main_window, ForceOption, 0), 0);
    error_trap(optionbutton_set_state(0, main_window, FasterOption, 0), 0);
    error_trap(numberrange_set_value(0, main_window, LargeIconRange, 256), 0);
    error_trap(numberrange_set_value(0, main_window, SmallIconRange, 256), 0);
    error_trap(optionbutton_set_state(0, main_window, DClickHoldOption, 0), 0);
    grey_gadget(main_window, DClickHoldWhenLabel);
    grey_gadget(main_window, DClickHoldSecsLabel);
    grey_gadget(main_window, DClickHoldDelay);
    error_trap(numberrange_set_value(0, main_window, DClickHoldDelay, 2), 0);
    update_icon_widths();
}


/*---------------------------------------------------------------------------*
 * parse_options_command                                                     *
 *                                                                           *
 * Parse a *Filer_Options command and set options in configure window as     *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Filer_Options                              *
 *---------------------------------------------------------------------------*/

static void parse_options_command(char *string)
{
    static const char options_args[] = "ConfirmAll/S,ConfirmDeletes/S,Verbose/S,Force/S,Newer/S,Faster/S";
    int  buffer[32];

    error_trap(_swix(OS_ReadArgs, _INR(0,3), options_args, string, buffer, 32*sizeof(int)), 0);

    if (buffer[0] || buffer[1])
    {
        error_trap(optionbutton_set_state(0, main_window, ConfirmOption, 1), 0);
        ungrey_gadget(main_window, ConfirmAllRadio);
        ungrey_gadget(main_window, ConfirmDeletesRadio);
    }
    else
    {
        error_trap(optionbutton_set_state(0, main_window, ConfirmOption, 0), 0);
        grey_gadget(main_window, ConfirmAllRadio);
        grey_gadget(main_window, ConfirmDeletesRadio);
    }

    if (buffer[0]) error_trap(radiobutton_set_state(0, main_window, ConfirmAllRadio, 1), 0);
    if (buffer[1]) error_trap(radiobutton_set_state(0, main_window, ConfirmDeletesRadio, 1), 0);

    error_trap(optionbutton_set_state(0, main_window, VerboseOption, buffer[2]>0 ? 1:0), 0);
    error_trap(optionbutton_set_state(0, main_window, ForceOption,   buffer[3]>0 ? 1:0), 0);
    error_trap(optionbutton_set_state(0, main_window, NewerOption,   buffer[4]>0 ? 1:0), 0);
    error_trap(optionbutton_set_state(0, main_window, FasterOption,  buffer[5]>0 ? 1:0), 0);
}


/*---------------------------------------------------------------------------*
 * parse_truncation_command                                                  *
 *                                                                           *
 * Parse a *Filer_Truncation command and set options in configure window as  *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Filer_Truncation                           *
 *---------------------------------------------------------------------------*/

static void parse_truncation_command(char *string)
{
    static const char truncation_args[] = "LargeIconDisplay=LID/E,SmallIconDisplay=SID/E,FullInfoDisplay=FID/E";
    char *byte;
    int   buffer[64];
    int   value;

    _swi(OS_ReadArgs, _INR(0,3), truncation_args, string, (char*)buffer, 256);

    /* LargeIconDisplay */
    if (buffer[0])
    {
        byte = (char*)(buffer[0]);
        value = byte[1] + (byte[2]<<8) + (byte[3]<<16) + (byte[4]<<24);
        error_trap(numberrange_set_value(0, main_window, LargeIconRange, value), 0);
    }

    /* SmallIconDisplay */
    if (buffer[1])
    {
        byte = (char*)(buffer[1]);
        value = byte[1] + (byte[2]<<8) + (byte[3]<<16) + (byte[4]<<24);
        error_trap(numberrange_set_value(0, main_window, SmallIconRange, value), 0);
    }

    /* FullInfoDisplay */
    if (buffer[2])
    {
        byte = (char*)(buffer[2]);
        fullinfo_truncation = byte[1] + (byte[2]<<8) + (byte[3]<<16) + (byte[4]<<24);
    }

}


/*---------------------------------------------------------------------------*
 * parse_layout_command                                                      *
 *                                                                           *
 * Parse a *Filer_Layout command and set options in configure window as      *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Filer_Layout                               *
 *---------------------------------------------------------------------------*/

static void parse_layout_command(char *string)
{
    static const char layout_args[] = "LargeIcons=LI/S,SmallIcons=SI/S,FullInfo=FI/S,"
                                      "SortByName=SBN/S,SortByType=SBT/S,SortBySize=SBS/S,SortByDate=SBD/S,"
                                      "ReverseSort=RS/S,NumericalSort=NS/S";
    int  buffer[32];
    int  display_as = 0;
    int  sort_by = 0;
    int  n;
    IdBlock id;

    error_trap(_swix(OS_ReadArgs, _INR(0,3), layout_args, string, buffer, sizeof(buffer)), 0);

    /* Large, Small or Full Info */
    for (n=0; n<=2; n++)
    {
        if (buffer[n]) display_as = n;
    }
    error_trap(stringset_set_selected(StringSet_IndexedSelection, main_window, DisplayAsMenu, (char*)display_as), 0);

    /* Reverse sort order */
    if (!can_reversesort) buffer[7] = 0;
    error_trap(menu_set_tick(0, sort_menu, MenuSortReversed, buffer[7] ? 1 : 0), 0);

    /* Numerical sort order */
    if (!can_numericalsort) buffer[8] = 0;
    error_trap(menu_set_tick(0, sort_menu, MenuSortNumerical, buffer[8] ? 1 : 0), 0);

    /* Sort type (assumes menu entries are ids 0-3) */
    for (n=3; n<=6; n++)
    {
        if (buffer[n]) sort_by = n - 3;
    }
    id.self_component = sort_by; /* Fake menu selection */
    sort_selected(0, NULL, &id, NULL);
}


/*---------------------------------------------------------------------------*
 * parse_dclickhold_command                                                  *
 *                                                                           *
 * Parse a *Filer_DClickHold command and set options in configure window as  *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Filer_DClickHold                           *
 *---------------------------------------------------------------------------*/

static void parse_dclickhold_command(char *string)
{
    char  dclickhold_args[] = "/E";
    char *byte;
    int   buffer[32];
    int   value;

    error_trap(_swix(OS_ReadArgs, _INR(0,3), dclickhold_args, string, buffer, 32*sizeof(int)), 0);

    if (buffer[0])
    {
        byte = (char*)(buffer[0]);
        value = byte[1] + (byte[2]<<8) + (byte[3]<<16) + (byte[4]<<24);
        if (value)
        {
            error_trap(numberrange_set_value(0, main_window, DClickHoldDelay, value/10), 0);
            error_trap(optionbutton_set_state(0, main_window, DClickHoldOption, 1), 0);
            ungrey_gadget(main_window, DClickHoldWhenLabel);
            ungrey_gadget(main_window, DClickHoldSecsLabel);
            ungrey_gadget(main_window, DClickHoldDelay);
        }
        else
        {
            error_trap(numberrange_set_value(0, main_window, DClickHoldDelay, 2), 0);
            error_trap(optionbutton_set_state(0, main_window, DClickHoldOption, 0), 0);
            grey_gadget(main_window, DClickHoldWhenLabel);
            grey_gadget(main_window, DClickHoldSecsLabel);
            grey_gadget(main_window, DClickHoldDelay);
        }
    }
}


/*---------------------------------------------------------------------------*
 * read_cmos                                                                 *
 *                                                                           *
 * Read the options store in CMOS                                            *
 *---------------------------------------------------------------------------*/

static void read_cmos(void)
{
    int interactive, solid;

    /* Interactive file copying */
    interactive = (read_cmos_value(FileSwitchCMOS) & InteractiveCopyCMOSBit) ? 0:1;
    error_trap(optionbutton_set_state(0, main_window, ActiveCopyOption, interactive), 0);

    /* Solid drags */
    solid = (read_cmos_value(FileSwitchCMOS) & DragASpriteCMOSBit) ? 1:0;
    error_trap(optionbutton_set_state(0, main_window, SolidDragOption, solid), 0);
}


/*---------------------------------------------------------------------------*
 * read_choices                                                              *
 *                                                                           *
 * Read the *Filer_Options command from the choices file.                    *
 *---------------------------------------------------------------------------*/

static void read_choices(void)
{
    FILE *fp;
    char  string[256];
    int   more = 1;

    /* Read current setup */
    fp = fopen(ChoicesFileRO, "r");
    if (fp)
    {
        while (more)
        {
            more = (int)fgets(string, sizeof(string), fp);
            if (more)
            {
                if (strncmpa(string, "Filer_Options", 13)==0) parse_options_command(string+14);
                if (strncmpa(string, "Filer_Truncation", 16)==0) parse_truncation_command(string+17);
                if (strncmpa(string, "Filer_Layout", 12)==0) parse_layout_command(string+13);
                if (strncmpa(string, "Filer_DClickHold", 16)==0) parse_dclickhold_command(string+17);
            }
        }
        fclose(fp);
    }

    read_cmos();
}


/*---------------------------------------------------------------------------*
 * redraw_whole_screen                                                       *
 *                                                                           *
 * Force a redraw of the whole screen.                                       *
 *---------------------------------------------------------------------------*/

static void redraw_whole_screen(void)
{
    WimpMessage wm;

    wm.hdr.size = 32;
    wm.hdr.your_ref = 0;
    wm.hdr.action_code = Wimp_MFilerOpenDir;
    wm.data.words[0] = -1;
    wm.data.words[1] = 0;
    wm.data.words[2] = 0;
    error_trap(wimp_send_message(Wimp_EUserMessage, &wm, 0, 0, 0), 0);
}


/*-----------------------------------------------------------------------------------------------*/
/*                                          Event handlers                                       */
/*-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * toolbox_error                                                             *
 *                                                                           *
 * Handler for errors from toolbox.                                          *
 *---------------------------------------------------------------------------*/

static int toolbox_error(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
    ToolboxErrorEvent *error_event = (ToolboxErrorEvent *)event;
    _kernel_oserror    err;

    strcpy(err.errmess, error_event->errmess);
    err.errnum = error_event->errnum;
    wimp_report_error(&err, 0, "Configure", 0, 0, 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * sort_selected                                                             *
 *                                                                           *
 * Handler for when menu selection in the sort menu.                         *
 *---------------------------------------------------------------------------*/

static int sort_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int  gadget = id_block->self_component;
    int  i;
    BOOL reversed, numerical, state;
    char token[16];

    switch (gadget)
    {
        case MenuSortName:
        case MenuSortType:    
        case MenuSortSize:    
        case MenuSortDate:
            for (i = 0; i <= 3; i++)
            {
                error_trap(menu_set_tick(0, sort_menu, i, i == gadget), 0);
            }
            break;

        case MenuSortReversed:
            error_trap(menu_get_tick(0, sort_menu, MenuSortReversed, &reversed), 0);
            reversed = !reversed;
            error_trap(menu_set_tick(0, sort_menu, MenuSortReversed, reversed), 0);
            break;

        case MenuSortNumerical:
            error_trap(menu_get_tick(0, sort_menu, MenuSortNumerical, &numerical), 0);
            numerical = !numerical;
            error_trap(menu_set_tick(0, sort_menu, MenuSortNumerical, numerical), 0);
            break;
    }

    /* And update the top level display */
    for (i = 0; i <= 3; i++)
    {
        error_trap(menu_get_tick(0, sort_menu, i, &state), 0);
        if (state) break;
    }
    error_trap(menu_get_tick(0, sort_menu, MenuSortReversed, &reversed), 0);
    sprintf(token, "%s%d", reversed ? "Tors" : "Sort", i);
    error_trap(displayfield_set_value(0, main_window, SortByDisplay, messages_lookup(token)), 0);

    return 1; 
}


/*---------------------------------------------------------------------------*
 * default_key_handler                                                       *
 *                                                                           *
 * Handler for key presses.                                                  *
 *---------------------------------------------------------------------------*/

static int default_key_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
   int key_code = event->key_pressed.key_code;

   wimp_process_key(key_code);

   return 1;
}


/*---------------------------------------------------------------------------*
 * action_selected                                                           *
 *                                                                           *
 * Handler for when action buttons are clicked on.                           *
 *---------------------------------------------------------------------------*/

static int action_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    ActionButtonSelectedEvent *block = (ActionButtonSelectedEvent*) event_block;
    int                        icon = id_block->self_component;

    switch (icon)
    {
        case SetButton:
            save_choices();
            redraw_whole_screen();
            if ((block->hdr.flags & 7)==0) program_exit(); /* Return pressed */
            if (block->hdr.flags & 4) program_exit();      /* Left button */
            break;

        case CancelButton:
            if ((block->hdr.flags & 7)==0) program_exit(); /* Escape pressed */
            if (block->hdr.flags & 1)                      /* Right button */
            {
                 read_choices();
                 update_icon_widths();
            }
            if (block->hdr.flags & 4) program_exit();      /* Left button */
            break;

        case DefaultButton:
            set_default_choices();
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * option_changed                                                            *
 *                                                                           *
 * Handler for option button changed events.                                 *
 *---------------------------------------------------------------------------*/

static int option_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    OptionButtonStateChangedEvent *event = (OptionButtonStateChangedEvent*) event_block;
    int                            icon = id_block->self_component;
    int                            state = event->new_state;

    switch(icon)
    {
        case ConfirmOption:
            if (state==1)
            {
                ungrey_gadget(main_window, ConfirmAllRadio);
                ungrey_gadget(main_window, ConfirmDeletesRadio);
            }
            else
            {
                grey_gadget(main_window, ConfirmAllRadio);
                grey_gadget(main_window, ConfirmDeletesRadio);
            }
            break;

        case DClickHoldOption:
            if (state==1)
            {
                ungrey_gadget(main_window, DClickHoldWhenLabel);
                ungrey_gadget(main_window, DClickHoldSecsLabel);
                ungrey_gadget(main_window, DClickHoldDelay);
            }
            else
            {
                grey_gadget(main_window, DClickHoldWhenLabel);
                grey_gadget(main_window, DClickHoldSecsLabel);
                grey_gadget(main_window, DClickHoldDelay);
            }
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * numrange_changed                                                          *
 *                                                                           *
 * Handler for bounding the character widths.                                *
 *---------------------------------------------------------------------------*/

static int numrange_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    NumberRangeValueChangedEvent *event = (NumberRangeValueChangedEvent*)event_block;
    int                           icon = id_block->self_component;
    char                          string[16];

    switch(icon)
    {
        case LargeIconRange:
            sprintf(string, "%d", how_many_characters(event->new_value));
            error_trap(displayfield_set_value(0, main_window, LargeNotLessThan, string), 0);
            break;

        case SmallIconRange:
            sprintf(string, "%d", how_many_characters(event->new_value));
            error_trap(displayfield_set_value(0, main_window, SmallNotLessThan, string), 0);
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_quit                                                              *
 *                                                                           *
 * Called when wimp quit message received.                                   *
 *---------------------------------------------------------------------------*/

static int message_quit(WimpMessage *event, void *handler)
{
    program_exit();

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_reopen                                                            *
 *                                                                           *
 * Called when we receive a message from Configure telling us to reopen our  *
 * window.                                                                   *
 *---------------------------------------------------------------------------*/

static int message_reopen(WimpMessage *event, void *handler)
{
    error_trap(toolbox_show_object(0, main_window, Toolbox_ShowObject_Default, NULL, 0, 0), 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * close_window                                                              *
 *                                                                           *
 * Called when user has clicked on close icon of window.                     *
 *---------------------------------------------------------------------------*/

static int close_window(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    program_exit();

    return 1;
}


/*-----------------------------------------------------------------------------------------------*/
/*                               Program startup & polling loop                                  */
/*-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * open_configure_window                                                     *
 *                                                                           *
 * Called to open the configure window on screen and register handlers.      *
 *---------------------------------------------------------------------------*/

static void open_configure_window(int at_x, int at_y)
{
    int  screenx;
    int  screeny;
    ObjectTemplateHeader *objtemplate;
    WindowTemplate       *wintemplate;
    WimpWindow           *windef;

    /* Read the window object in by hand */
    error_trap(toolbox_template_lookup(0, "Filer", (void **)&objtemplate), 1);
    if (objtemplate->object_class != Window_ObjectClass)
    {
        error_trap(common_error(messages_lookup("BadClass")), 1);
    }
    wintemplate = objtemplate->body;
    windef = &wintemplate->window;
    if (common_read_screensize(&screenx, &screeny) == NULL)
    {
        /* Calculate the window height compared with the screen and
         * turn the vertical scrollbar on if it doesn't fit
         */
        if ((windef->visible_area.ymax - windef->visible_area.ymin) >= screeny)
        {
            windef->flags |= WimpWindow_VScroll;
        }
        else
        {
            windef->flags &= ~WimpWindow_VScroll;
        }
    }
    error_trap(toolbox_create_object(Toolbox_CreateObject_InCore, objtemplate, &main_window), 1);
    error_trap(toolbox_create_object(0, "SortMenu", &sort_menu), 1);
    error_trap(popup_set_menu(0, main_window, SortByPopUp, sort_menu), 1);

    /* Register handlers for the configure window */
    error_trap(event_register_toolbox_handler(-1, Toolbox_Error, toolbox_error, NULL) ,0);
    error_trap(event_register_wimp_handler(main_window, Wimp_ECloseWindow, close_window, NULL), 0);
    error_trap(event_register_toolbox_handler(main_window, ActionButton_Selected, action_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(main_window, OptionButton_StateChanged, option_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(main_window, NumberRange_ValueChanged, numrange_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(sort_menu, Menu_Selection, sort_selected, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_EKeyPressed, default_key_handler, NULL), 0);

    /* The Filer_Layout command faults unknown switches, so don't try setting them when
     * running on an older Filer. Fade the menu entries also.
     */
    can_reversesort   = (_swix(OS_CLI, _IN(0), "RMEnsure Filer 2.22") == NULL);
    error_trap(menu_set_fade(0, sort_menu, MenuSortReversed, can_reversesort ? 0 : 1), 0);
    can_numericalsort = (_swix(OS_CLI, _IN(0), "RMEnsure Filer 2.34") == NULL);
    error_trap(menu_set_fade(0, sort_menu, MenuSortNumerical, can_numericalsort ? 0 : 1), 0);

    /* Read in the choices, populate and show dialogue */
    set_default_choices();
    read_choices();
    update_icon_widths();
    if ((at_x==-1) && (at_y==-1))
    {
        /* No position supplied in the command line, just centre it */
        error_trap(toolbox_show_object(0, main_window, Toolbox_ShowObject_Centre, NULL, 0, 0), 0);
    }
    else
    {
        int  buffer[2];

        buffer[0] = at_x;
        buffer[1] = at_y;
        error_trap(toolbox_show_object(0, main_window, Toolbox_ShowObject_TopLeft, buffer, 0, 0), 0);
    }
}


/*---------------------------------------------------------------------------*
 * main_initialise                                                           *
 *                                                                           *
 * Initialise toolbox etc.                                                   *
 *                                                                           *
 * In: Nothing.                                                              *
 *                                                                           *
 * Returns: 1 if everything went okay, 0 otherwise                           *
 *---------------------------------------------------------------------------*/

static int main_initialise(void)
{
    static int mess_wanted[] = {Wimp_MQuit,
                                Wimp_MOpenConfigWindow,
                                0};
    static int tbox_wanted[] = {Toolbox_Error,
                                ActionButton_Selected,
                                OptionButton_StateChanged,
                                NumberRange_ValueChanged,
                                Menu_Selection,
                                0};
    int        task_handle;

    error_trap(toolbox_initialise(0, 310, mess_wanted, tbox_wanted,
                                  "<FilrSetup$Dir>", &messages_desc, &idb,
                                  0, &task_handle, 0) ,1);


    error_trap(event_initialise(&idb), 0);
    error_trap(event_set_mask(Wimp_Poll_NullMask), 0);
    messages_register(&messages_desc, messages_string);

    error_trap(event_register_message_handler(Wimp_MQuit, message_quit, NULL), 0);
    error_trap(event_register_message_handler(Wimp_MOpenConfigWindow, message_reopen, NULL), 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * main                                                                      *
 *                                                                           *
 * Main polling loop                                                         *
 *---------------------------------------------------------------------------*/

int main(int argc, char *argv[])
{
    WimpPollBlock wpb;
    int           event_code;
    int           openat_x = -1;
    int           openat_y = -1;

    /* Have we been passed any co-ordinates to open at? */
    if ((argc >= 4) && (strcmp(argv[1], "-openat")==0))
    {
        openat_x = atoi(argv[2]);
        openat_y = atoi(argv[3]);
    }

    /* Do main initialisation */
    if (!main_initialise()) return 0;

    /* Open configure window */
    open_configure_window(openat_x, openat_y);

    /* Poll loop */
    while (TRUE)
    {
        error_trap(event_poll(&event_code, &wpb, NULL), 0);
    }

    return 0;
}
