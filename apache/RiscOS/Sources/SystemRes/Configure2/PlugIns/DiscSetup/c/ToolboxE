/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/******	ToolboxE.c ********************************************************\

Project:	Ursula (RISC OS for Risc PC II)
Component:	Discs configuration plug-in
This file:	Toolbox event code

History:
Date		Who	Change
----------------------------------------------------------------------------
23/06/1998	BJGA	Created
24/06/1998	BJGA	Implemented ActionButton_Selected and
			Toolbox_ObjectAutoCreated event handlers
25/06/1998	BJGA	Implemented NumberRange_ValueChanged and
			OptionButton_StateChange event handlers
26/06/1998	BJGA	A value of 1 for ADFSbuffers can no longer be entered.
			SCSI discs icons faded when appropriate.
22/07/1998	BJGA	Removed support for automatic autodetect time gadgets

\**************************************************************************/

/* CLib */
#include <string.h>
#include "swis.h"
/* Toolbox */
#include "event.h"
#include "wimplib.h"
#include "gadgets.h"
/* Common */
#include "cmos.h"
#include "misc.h"
/* local headers */
#include "Main.h"
#include "Settings.h"

#undef SCSI_Version
#define SCSI_Version 0x403c0

static int static_ActionButtonSelected (int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle);
static int static_NumberRangeValueChanged (int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle);
static int static_ObjectAutoCreated (int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle);
static int static_OptionButtonStateChanged (int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle);

int ToolboxE_Events [5] =     { ActionButton_Selected,
				NumberRange_ValueChanged,
				Toolbox_ObjectAutoCreated,
				OptionButton_StateChanged,
				0 };

void ToolboxE_Register (void)
{
  throw (event_register_toolbox_handler (-1, ActionButton_Selected, static_ActionButtonSelected, NULL));
  throw (event_register_toolbox_handler (-1, NumberRange_ValueChanged, static_NumberRangeValueChanged, NULL));
  throw (event_register_toolbox_handler (-1, Toolbox_ObjectAutoCreated, static_ObjectAutoCreated, NULL));
  throw (event_register_toolbox_handler (-1, OptionButton_StateChanged, static_OptionButtonStateChanged, NULL));
}

/******	static_ActionButtonSelected() *************************************\

Purpose:	Handles ActionButton_Selected event

\**************************************************************************/

static int static_ActionButtonSelected (int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
  switch (id_block->self_component)
  {
    case Window_DEFAULT:
      Settings_Read (cmos_default);
      break;

    case Window_CANCEL:
      if (!(event->hdr.flags & ActionButton_Selected_Adjust))
      {
        Quit = TRUE;
      }
      else
      {
        Settings_Read (cmos_read);
      }
      break;

    case Window_SET:
      if (Settings_Write ())
      {
        if (!(event->hdr.flags & ActionButton_Selected_Adjust))
        {
          Quit = TRUE;
        }
        else
        {
          Settings_Read (cmos_read); /* Make sure writables are in range */
        }
      }
      break;
  }
  return 1;
}

/******	static_NumberRangeValueChanged() **********************************\

Purpose:	Handles NumberRange_ValueChanged event

\**************************************************************************/

static int static_NumberRangeValueChanged (int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
  switch (id_block->self_component)
  {
    case Window_CDFS_BUFFERS_ARROWS:
    {
      Settings_UpdateCDFSDisplay ();
      break;
    }
    case Window_ADFS_BUFFERS:
    {
      /* Avoid number 1 being selected, since we can't configure that value */
      static int last_adfs_value = 0;
      int new_value;
      throw (numberrange_get_value (0, Window_Obj, Window_ADFS_BUFFERS, &new_value));
      if (new_value == 1)
      {
        new_value += (new_value - last_adfs_value);
        throw (numberrange_set_value (0, Window_Obj, Window_ADFS_BUFFERS, new_value));
      }
      last_adfs_value = new_value;
      break;
    }
    case Window_IDE_SPINDOWN_ARROWS:
    {
      static int last_spindown_value = 0;
      int new_value;
      throw (numberrange_get_value (0, Window_Obj, Window_IDE_SPINDOWN_ARROWS, &new_value));
      if (new_value == 252)
      /* Avoid number 252 being selected, since that value is messy */
      {
        new_value += (new_value - last_spindown_value);
        throw (numberrange_set_value (0, Window_Obj, Window_IDE_SPINDOWN_ARROWS, new_value));
      }
      /* Stick to multiples of 30s (steps of 6 by this scale) at low values */
      else if (new_value < 241)
      {
        switch (new_value % 6)
        {
          case 1: new_value += 5; break;
          case 2: new_value += 4; break; /* Added for completeness */
          case 3: new_value += 3; break; /* Added for completeness */
          case 4: new_value -= 4; break; /* Added for completeness */
          case 5: new_value -= 5; break;
        }
        throw (numberrange_set_value (0, Window_Obj, Window_IDE_SPINDOWN_ARROWS, new_value));
      }
      last_spindown_value = new_value;
      Settings_UpdateSpindownDisplay ();
      break;
    }
  }
  return 1;
}

/******	static_ObjectAutoCreated() ****************************************\

Purpose:	Handles Toolbox_ObjectAutoCreated event

\**************************************************************************/

static int static_ObjectAutoCreated (int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
  if (0 == strcmp ("Discs", ((ToolboxObjectAutoCreatedEvent *)event)->template_name))
  {
    Window_Obj = id_block->self_id;

    /* It's barmy to allow the RAM disc to be specified larger than the RAM! */
    throw (numberrange_set_bounds (NumberRange_UpperBound, Window_Obj,
        Window_RAMFS_SIZE, 0, RAMFS_Limit, 0, 0));

    misc_shadecomponents (TRUE, Window_Obj, Window_SCSI_SPRITE, Window_SCSI_DISCS);

    /* If there's no Acorn-compatible SCSIFS, leave the SCSI options faded */
    /* Otherwise check to see nobody objects to us unfading them */
    if (_swix (SCSI_Version, 0) == NULL)
    {
      WimpMessage block;
      block.hdr.size = sizeof (block.hdr);
      block.hdr.your_ref = 0;
      block.hdr.action_code = Wimp_MUnfadingSCSIIcons;
      throw (wimp_send_message (Wimp_EUserMessageRecorded, &block, 0, 0, NULL));
    }

    misc_openwindow (Window_Obj, TRUE);
    Settings_Read (cmos_read);
  }
  return 1;
}

/******	static_OptionButtonStateChanged() *********************************\

Purpose:	Handles OptionButton_StateChanged event

\**************************************************************************/

static int static_OptionButtonStateChanged (int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
  if (id_block->self_component == Window_RAMFS_ENABLE)
  {
    if (((OptionButtonStateChangedEvent *) event)->new_state == 1)
    {
      misc_shadecomponents (FALSE, Window_Obj, Window_RAMFS_SIZE, Window_RAMFS_SIZE_LABEL);
    }
    else
    {
      misc_shadecomponents (TRUE, Window_Obj, Window_RAMFS_SIZE, Window_RAMFS_SIZE_LABEL);
    }
  }
  return 1;
}
