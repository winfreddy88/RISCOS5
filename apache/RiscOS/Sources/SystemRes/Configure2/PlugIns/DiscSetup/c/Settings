/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/******	Settings.c ********************************************************\

Project:	Ursula (RISC OS for Risc PC II)
Component:	Discs configuration plug-in
This file:	GUI <-> settings routines

History:
Date		Who	Change
----------------------------------------------------------------------------
23/06/1998	BJGA	Created
24/06/1998	BJGA	Implemented most of Settings_Read, added static_UpdateCDFSDisplay
25/06/1998	BJGA	Now reads RAM disc size. Implemented most of Settings_Write; added
			static_ReadRAMFSSize, static_WriteRAMFSSize and static_WriteDiscs.
26/06/1998	BJGA	Completed Settings_Write, including warning box before buffer changes.
			Capped and collared RAM disc sizes when read in static_WriteRAMFSSize.
			Made sure ADFS only gets RMReInited once during a set operation.
29/07/1998	BJGA	Now copes if value returned for RAM disc size has overflowed.
28/08/1998	BJGA	Implemented autodetect time numberrange

\**************************************************************************/

/* CLib */
#include <string.h>
#include "swis.h"
#include "Global/NewErrors.h"
#include "Global/ModHand.h"
#include "Interface/HighFSI.h"
/* Toolbox */
#include "wimplib.h"
#include "gadgets.h"
/* Common */
#include "message.h"
#include "misc.h"
#include "str.h"
/* local headers */
#include "Main.h"
#include "Settings.h"

/* Global variables */

const cmos CmosDetails [7] =  { { 0x87, 0, 3 },		/* ADFSFloppies */
				{ 0x89, 0, 8 },		/* ADFSBuffers */
				{ 0x8A, 5, 3 },		/* CDFSBuffers */
				{ 0xC7, 0, 8 },		/* ADFSDirCache */
				{ 0xD0, 0, 3 },		/* SCSIDiscs */
				{ 0x8A, 0, 5 },		/* CDROMDrives */
				{ 0x1A, 0, 8 } };	/* IDE spindown */

/* Prototypes */

static unsigned int static_ReadRAMFSSize (void);
static void static_WriteRAMFSSize (void);
static void static_WriteDiscs (BOOL *ReInit_ADFS, BOOL *ReInit_CDFS);


/******	Settings_Read() ***************************************************\

Purpose:	Reads current / default settings, reflect them in GUI
In:		Routine to determine settings (cmos_read or cmos_default)

\**************************************************************************/

void Settings_Read (int(*get)(cmos item, void *messages))
{
  int value;

  value = get (cmos_ADFS_FLOPPIES, &messages);
  throw (numberrange_set_value (0, Window_Obj, Window_FLOPPY_DISCS, value));

  value = get (cmos_SCSI_DISCS, &messages);
  throw (numberrange_set_value (0, Window_Obj, Window_SCSI_DISCS, value));

  value = get (cmos_CDROM_DRIVES, &messages);
  throw (numberrange_set_value (0, Window_Obj, Window_CDROM_DRIVES, value));

  value = get (cmos_ADFS_DIR_CACHE, &messages);
  if (value == 0) value = ADFS_Default_Buffer;
  throw (numberrange_set_value (0, Window_Obj, Window_ADFS_DIR_CACHE, value));

  value = get (cmos_ADFS_BUFFERS, &messages);
  if (value == 1) value = ADFS_Default_Buffer;
  throw (numberrange_set_value (0, Window_Obj, Window_ADFS_BUFFERS, value));

  value = get (cmos_CDFS_BUFFERS, &messages);
  throw (numberrange_set_value (0, Window_Obj, Window_CDFS_BUFFERS_ARROWS, value));
  Settings_UpdateCDFSDisplay ();

  value = get (cmos_IDE_SPINDOWN, &messages);
  switch (value)
  {
    case 254: value = 0; break;   /* Reserved */
    case 252: value = 240; break; /* 00:21:00 */
    case 255: value = 240; break; /* 00:21:15 */
    default:
      if ((value < 241) && (value % 6))  /* Strange multiples of 5s */
        value = 6 * ((value + 5) / 6);   /* Round-up to nearest 30s */
  }

  throw (numberrange_set_value (0, Window_Obj, Window_IDE_SPINDOWN_ARROWS, value));
  Settings_UpdateSpindownDisplay ();

  /* Now read the configured RAMFS size */
  if (get == cmos_default)
  {
    value = 0;
  }
  else
  {
    value = static_ReadRAMFSSize ();
  }
  /* Set numberrange and optionbutton, and fade/unfade as necessary */
  if (value == 0)
  {
    throw (numberrange_set_value (0, Window_Obj, Window_RAMFS_SIZE, RAMFS_Default_Size));
    misc_shadecomponents (TRUE, Window_Obj, Window_RAMFS_SIZE, Window_RAMFS_SIZE_LABEL);
    throw (optionbutton_set_state (0, Window_Obj, Window_RAMFS_ENABLE, 0));
  }
  else
  {
    throw (numberrange_set_value (0, Window_Obj, Window_RAMFS_SIZE, value));
    misc_shadecomponents (FALSE, Window_Obj, Window_RAMFS_SIZE, Window_RAMFS_SIZE_LABEL);
    throw (optionbutton_set_state (0, Window_Obj, Window_RAMFS_ENABLE, 1));
  }

}

/******	Settings_Write() **************************************************\

Purpose:	Reads GUI, reflect in current and configured settings
Out:		TRUE => operation performed successfully

\**************************************************************************/

BOOL Settings_Write (void)
{
  BOOL success = TRUE;
  int old_floppies;
  int new_floppies;
  int old_scsi;
  int new_scsi;
  int old_cdrom;
  int new_cdrom;
  int old_adfsdir;
  int new_adfsdir;
  int old_adfsbuf;
  int new_adfsbuf;
  int old_cdfsbuf;
  int new_cdfsbuf;
  int old_idespindown;
  int new_idespindown;

  /* Before we proceed, check if the user is aware of the consequences of RMReIniting modules... */

  old_floppies = cmos_read (cmos_ADFS_FLOPPIES, &messages);
  throw (numberrange_get_value (0, Window_Obj, Window_FLOPPY_DISCS, &new_floppies));

  old_scsi = cmos_read (cmos_SCSI_DISCS, &messages);
  throw (numberrange_get_value (0, Window_Obj, Window_SCSI_DISCS, &new_scsi));

  old_cdrom = cmos_read (cmos_CDROM_DRIVES, &messages);
  throw (numberrange_get_value (0, Window_Obj, Window_CDROM_DRIVES, &new_cdrom));

  old_adfsdir = cmos_read (cmos_ADFS_DIR_CACHE, &messages);
  throw (numberrange_get_value (0, Window_Obj, Window_ADFS_DIR_CACHE, &new_adfsdir));
  if (new_adfsdir > 255) new_adfsdir = 255;
  if (new_adfsdir == 0) new_adfsdir = 1;
  if (new_adfsdir == ADFS_Default_Buffer) new_adfsdir = 0;

  old_adfsbuf = cmos_read (cmos_ADFS_BUFFERS, &messages);
  throw (numberrange_get_value (0, Window_Obj, Window_ADFS_BUFFERS, &new_adfsbuf));
  if (new_adfsbuf > 255) new_adfsbuf = 255;
  if (new_adfsbuf == 1) new_adfsbuf = 2;
  if (new_adfsbuf == ADFS_Default_Buffer) new_adfsbuf = 1;

  old_cdfsbuf = cmos_read (cmos_CDFS_BUFFERS, &messages);
  throw (numberrange_get_value (0, Window_Obj, Window_CDFS_BUFFERS_ARROWS, &new_cdfsbuf));

  old_idespindown = cmos_read (cmos_IDE_SPINDOWN, &messages);
  throw (numberrange_get_value (0, Window_Obj, Window_IDE_SPINDOWN_ARROWS, &new_idespindown));

  if (old_floppies != new_floppies || old_scsi != new_scsi || old_cdrom != new_cdrom)
  {
    int button;
    _kernel_oserror err = { 0, "" };
    str_cpy (err.errmess, message_lookup_direct(messages,"Err_DiscChange"));
    button = wimp_report_error (&err, Wimp_ReportError_OK | Wimp_ReportError_Cancel | 1u << 8 | 4u << 9,
        message_lookup_direct(messages,"_TaskName"),
        message_lookup_direct(messages,"_ConfigSprite"), (void *) 1, NULL);
    if (button == 2)
    {
      success = FALSE; /* Cancel clicked */
    }
  }

  if (success && (old_adfsdir != new_adfsdir || old_adfsbuf != new_adfsbuf || old_cdfsbuf != new_cdfsbuf))
  {
    int button;
    _kernel_oserror err = { 0, "" };
    str_cpy (err.errmess, message_lookup_direct(messages,"Err_BufChange"));
    button = wimp_report_error (&err, Wimp_ReportError_OK | Wimp_ReportError_Cancel | 1u << 8 | 4u << 9,
        message_lookup_direct(messages,"_TaskName"),
        message_lookup_direct(messages,"_ConfigSprite"), (void *) 1, NULL);
    if (button == 2)
    {
      success = FALSE; /* Cancel clicked */
    }
  }

  /* Now we can set things... */

  if (success)
  {
    BOOL ReInit_ADFS = FALSE;
    BOOL ReInit_CDFS = FALSE;

    _swix (Hourglass_On, 0);

    if (old_adfsdir != new_adfsdir || old_adfsbuf != new_adfsbuf)
    {
      cmos_write (cmos_ADFS_DIR_CACHE, new_adfsdir);
      cmos_write (cmos_ADFS_BUFFERS, new_adfsbuf);
      ReInit_ADFS = TRUE;
    }

    if (old_cdfsbuf != new_cdfsbuf)
    {
      cmos_write (cmos_CDFS_BUFFERS, new_cdfsbuf);
      ReInit_CDFS = TRUE;
    }

    if (old_idespindown != new_idespindown)
    {
      cmos_write (cmos_IDE_SPINDOWN, new_idespindown);
    }

    static_WriteRAMFSSize ();

    static_WriteDiscs (&ReInit_ADFS, &ReInit_CDFS);

    if (ReInit_ADFS)
    {
      _swix (OS_CLI, _IN(0), "RMReInit ADFS");
    }

    if (ReInit_CDFS)
    {
      _swix (OS_CLI, _IN(0), "RMReInit CDFS");
    }

    _swix (Hourglass_Off, 0);
  }

  return success;
}

/******	Settings_UpdateCDFSDisplay() **************************************\

Purpose:	Translates from internal CDFSBuffers number (0-7) to value
		(in K), and updates CDFSBuffers display field appropriately

\**************************************************************************/

void Settings_UpdateCDFSDisplay (void)
{
  int internal;
  char *external;

  throw (numberrange_get_value (0, Window_Obj, Window_CDFS_BUFFERS_ARROWS, &internal));

  switch (internal)
  {
    case 0:
      external = "0";
      break;

    case 1:
      external = "8";
      break;

    case 2:
      external = "16";
      break;

    case 3:
      external = "32";
      break;

    case 4:
      external = "64";
      break;

    case 5:
      external = "128";
      break;

    case 6:
      external = "256";
      break;

    case 7:
      external = "512";
      break;

    default:
      external = "Error";
      break;
  }

  throw (displayfield_set_value (0, Window_Obj, Window_CDFS_BUFFERS_DISPLAY, external));
}

/******	Settings_UpdateSpindownDisplay() **********************************\

Purpose:	Translates from spindown timer period into a human-readable
		string. Based upon Table 30 in IDE document T13/1410D.

\**************************************************************************/

void Settings_UpdateSpindownDisplay (void)
{
  int internal;
  static char external[16];

  throw (numberrange_get_value (0, Window_Obj, Window_IDE_SPINDOWN_ARROWS, &internal));

  switch (internal)
  {
    case 0: /* Maximum value specified in Res file */
    {
      strcpy (external, message_lookup_direct(messages,"SpindownOff"));
      break;
    }
    case 252:
    {
      sprintf (external, "00:21:00");
      break;
    }
    case 253: /* Maximum value specified in Res file */
    {
      strcpy (external, message_lookup_direct(messages,"Spindown8to12"));
      break;
    }
    default:
    {
      int hr, mn, sc = 0;

      if (internal < 241)
        internal = internal * 5;
      else
        internal = (internal - 240) * 30 * 60;

      sc        = internal % 60;
      internal /= 60;
      mn        = internal % 60;
      hr        = internal / 60;
      sprintf (external, "%02u:%02u:%02u", hr, mn, sc);
      break;
    }
  }

  throw (displayfield_set_value (0, Window_Obj, Window_IDE_SPINDOWN_DISPLAY, external));
}

/******	static_ReadRAMFSSize() ********************************************\

Purpose:	Returns currently configured RAM disc size
Out:		Size, in 1/10ths of a megabyte

\**************************************************************************/

static unsigned int static_ReadRAMFSSize (void)
{
  unsigned int value;
  if (misc_fileisunreadable ((char *) StatusFileRO))
  {
    value = 0;
  }
  else
  {
    FILE *handle = fopen (StatusFile, "r");
    if (handle == NULL)
    {
      value = 0;
    }
    else
    {
      char line [100];
      char *compare = "ChangeDynamicArea -RamFsSize ";
      BOOL success;
      success = misc_readline (line, sizeof (line), handle);
      if (success)
      {
        success = (0 == strncmp (line, compare, str_len (compare)));
      }
      if (success)
      {
        if (*(line + str_len (line) - 1) != 'K')
        {
          success = FALSE;
        }
        else
        {
          *(line + str_len (line) - 1) = '\0';
        }
      }
      if (success)
      {
        _kernel_oserror *e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUT(2), 1u<<31, line + str_len (compare), &value);
        if (e != NULL)
        {
          success = FALSE;
        }
      }

      if (!success)
      {
        _kernel_oserror err;
        err.errnum = 0;
        str_cpy (err.errmess, message_lookup_direct(messages,"CantRead"));
        wimp_report_error (&err, Wimp_ReportError_OK | 1u << 8 | 2u << 9,
            message_lookup_direct(messages,"_TaskName"),
            message_lookup_direct(messages,"_ConfigSprite"), (void *) 1, NULL);
        value = 0;
      }

      fclose (handle);
    }
  }

  /* Rescale value */
  value = (unsigned int) (value / 102.4);

  return value;
}

/******	static_WriteRAMFSSize() *******************************************\

Purpose:	Sets and configures RAMFS size from current GUI settings

\**************************************************************************/

static void static_WriteRAMFSSize (void)
{
  int oldval; /* measured in 1/10th MB */
  int newval;

  /* Work out number of kilobytes of RAM disc requested */
  int NewRAMFS_K;
  int PageSize = _swi (OS_ReadMemMapInfo, _RETURN(0)) >> 10; /* in K */
  int CurrentRAMFSSize = _swi (OS_ReadDynamicArea, _IN(0)|_RETURN(1), 5) >> 10; /* in K */

  throw (optionbutton_get_state (0, Window_Obj, Window_RAMFS_ENABLE, &oldval)); /* oldval used temporarily */
  throw (numberrange_get_value (0, Window_Obj, Window_RAMFS_SIZE, &newval));
  if (newval > RAMFS_Limit || /* overflowed? */ newval < 0) newval = RAMFS_Limit;
  if (newval == 0) newval = 1;
  if (oldval == 0) newval = 0;
  oldval = static_ReadRAMFSSize (); /* the currently *configured* value, not necessarily the current one! */

  NewRAMFS_K = newval * 1024; /* start off 10 times too large */
  NewRAMFS_K = (NewRAMFS_K + (10 * PageSize) - 1) / (10 * PageSize); /* now measured in multiples of page size */
  NewRAMFS_K *= PageSize; /* finally, in K  :-) */

  /* Set current RAM disc size - unless it's already that size */
  if (NewRAMFS_K != CurrentRAMFSSize)
  {
    int type;
    _kernel_oserror *e;
    e = _swix (OS_File, _INR(0,1)|_OUT(0), OSFile_ReadWithTypeNoPath, "RAM:$.*", &type);
    if (e != NULL)
    {
      if (e->errnum != ErrorNumber_UnknownFilingSystem)
      {
        throw (e);
      }
    }
    if (e == NULL && type != 0)
    {
      /* Complain that RAMFS is in use */
      char buttons [40];
      _kernel_oserror err = { 0, "" };
      str_cpy (buttons, message_lookup_direct(messages,"ButtDefer"));
      str_cpy (err.errmess, message_lookup_direct(messages,"Err_RAMFSNotEmpty"));
      wimp_report_error (&err, 1u << 8 | 1u << 9,
          message_lookup_direct(messages,"_TaskName"),
          message_lookup_direct(messages,"_ConfigSprite"), (void *) 1, buttons);
    }
    else
    {
      /* Give it a go */
      char command [100];
      sprintf (command, "ChangeDynamicArea -RamFsSize %uK", NewRAMFS_K);
      e = _swix (OS_CLI, _IN(0), command);
      if (e != NULL)
      {
        /* Complain about lack of memory */
        char buttons [40];
        _kernel_oserror err = { 0, "" };
        str_cpy (buttons, message_lookup_direct(messages,"ButtDefer"));
        str_cpy (err.errmess, message_lookup_direct(messages,"Err_RAMFSTooBig"));
        wimp_report_error (&err, 1u << 8 | 1u << 9,
            message_lookup_direct(messages,"_TaskName"),
            message_lookup_direct(messages,"_ConfigSprite"), (void *) 1, buttons);
      }
    }
  }

  /* Write settings file - unless the configured value isn't changing */
  if (newval != oldval)
  {
    char command [100];
    if (newval == 0)
    {
      /* Simply remove the status file - it's not needed */
      _swix (OS_File, _INR(0,1), OSFile_Delete, StatusFile);
    }
    else
    {
      sprintf (command, "ChangeDynamicArea -RamFsSize %uK", NewRAMFS_K);
      /* The file can't be changed so leave it be */
      if (!misc_fileislocked ((char *) StatusFile))
      {
        if (!_swix (OS_FSControl, _INR(0,3), FSControl_Copy, "<DiscSetup$Dir>.Blank", StatusFile, 2))
        {
          FILE *handle;
          /* The blank file copied,let's be sure it's unlocked too */
          (void)_swix (OS_FSControl, _INR(0,2), FSControl_Access, StatusFile, "WR/r");
          /* Append the command string to it */
          if (NULL != (handle = fopen (StatusFile, "a")))
          {
            fprintf (handle, "%s\n", command);
            fclose (handle);
          }
        }
      }
    }
  }
}

/******	static_WriteDiscs() ***********************************************\

Purpose:	Sets and configures floppy, SCSI hard discs and CD-ROM drives from GUI settings
In:		Reference to BOOL to clear if we've already RMReInited ADFS

\**************************************************************************/

static void static_WriteDiscs (BOOL *ReInit_ADFS, BOOL *ReInit_CDFS)
{
  int oldval_adfs; /* floppies */
  int newval_adfs;
  int oldval_scsi; /* SCSI hard discs */
  int newval_scsi;
  int oldval_cdrom; /* CD-ROM drives */
  int newval_cdrom;

  oldval_adfs = cmos_read (cmos_ADFS_FLOPPIES, &messages);
  throw (numberrange_get_value (0, Window_Obj, Window_FLOPPY_DISCS, &newval_adfs));

  oldval_scsi = cmos_read (cmos_SCSI_DISCS, &messages);
  throw (numberrange_get_value (0, Window_Obj, Window_SCSI_DISCS, &newval_scsi));

  oldval_cdrom= cmos_read (cmos_CDROM_DRIVES, &messages);
  throw (numberrange_get_value (0, Window_Obj, Window_CDROM_DRIVES, &newval_cdrom));

  if (oldval_adfs != newval_adfs || oldval_scsi != newval_scsi || oldval_cdrom != newval_cdrom)
  {
    int FilerWorkspace;
    int FilerHandle;
    _kernel_oserror *e;

    /* ADFS */
    if (oldval_adfs != newval_adfs)
    {
      cmos_write (cmos_ADFS_FLOPPIES, newval_adfs);
      _swix (OS_CLI, _IN(0), "RMReInit ADFS");
      _swix (OS_CLI, _IN(0), "RMReInit ADFSFiler");
      *ReInit_ADFS = FALSE;
    }

    /* SCSI */
    if (oldval_scsi != newval_scsi)
    {
      cmos_write (cmos_SCSI_DISCS, newval_scsi);
      _swix (OS_CLI, _IN(0), "RMReInit SCSIFS");
      _swix (OS_CLI, _IN(0), "RMReInit SCSIFiler");
    }

    /* CD-ROM */
    if (oldval_cdrom != newval_cdrom)
    {
      cmos_write (cmos_CDROM_DRIVES, newval_cdrom);
      _swix (OS_CLI, _IN(0), "RMReInit CDFS");
      _swix (OS_CLI, _IN(0), "RMReInit CDFSFiler");
      *ReInit_CDFS = FALSE;
    }

    /* Look up Filer's workspace */
    e = _swix (OS_Module, _INR(0,1)|_OUT(4), ModHandReason_LookupName, "Filer", &FilerWorkspace);
    if (e == NULL && FilerWorkspace > NULL)
    {
      /* Get Filer's task handle from its workspace, and check it has initialised! */
      FilerHandle = * (int *) FilerWorkspace;
      if (FilerHandle > 0)
      {
        int claimed;
        char *command;
        /* Broadcast Service_StartFiler until nobody claims it */
        do
        {
          _swi (OS_ServiceCall, _INR(0,1)|_OUTR(0,1), FilerHandle, 0x4B, &command, &claimed);
          if (claimed == 0)
          {
            _swix (Wimp_StartTask, _IN(0), command);
          }
        }
        while (claimed == 0);
        /* Broadcast Service_StartedFiler to clear up after any non-initialised filers */
        _swi (OS_ServiceCall, _IN(1), 0x4C);
      }
    }
  }
}
