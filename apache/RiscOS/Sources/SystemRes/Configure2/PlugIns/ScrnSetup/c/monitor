/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*---------------------------------------------------------------------------*/
/* File:    c.monitor                                                        */
/* Purpose: Code for reading MDFs.                                           */
/* Author:  Richard Leggett                                                  */
/* History: 26-Nov-97: RML: Begun, borrowing lots of code from the previous  */
/*                          version of Configure.                            */
/*          12-Feb-98: RML: Changed saving of PreDesk config.                */
/*          16-Apr-98: RML: save_monitor_choices now also changes the to the */
/*                          new setup.                                       */
/*          01-May-98: RML: Bug fix.                                         */
/*          21-Jul-98: RML: Bug fix: Monitor name could be displayed wrong   */
/*                          if two very similar filenames existed.           */
/*                                                                           */
/* Copyright © 1998 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "Global/Services.h"
#include "Global/ModHand.h"
#include "Global/FileTypes.h"
#include "Global/VduExt.h"
#include "Interface/HighFSI.h"
#include "toolbox.h"
#include "event.h"
#include "gadgets.h"
#include "menu.h"
#include "common.h"
#include "defines.h"
#include "monitor.h"
#include "screen.h"

#define flags_squarepixel ((unsigned)1<<31)
#define ORIGIN_EDID       2
#define ORIGIN_MDF        1

monitor_ref         *monitors_list = NULL;
static monitor_ref **monitors_list_tail = NULL;

static char *current_monitor_file = NULL;
static int   my_screenmodes_instantiation;
static char *desktop_instantiation;
static int   desktop_monitortype;
static int   nummodes=0;
static char *modes_block = NULL;
static int **modes_index;
static int   res_menu_entries=1;
static int   current_x_res, current_y_res, current_flags;   /* colours are 0-9 as per the menu */

typedef struct
{
    int ncolour;
    int modeflags;
    int log2bpp;
} gv_pixelformat;

typedef struct
{
    gv_pixelformat format;
    char *text,*alttext;
    bool iscolour;
}   colourchoice;

/* These are ordered by menu component index, which is also assumed to be in
   order of increasing number of colours */
static const colourchoice colourchoices[] = {
    { { 1, 0, 0 }, "C2", "G2", false },
    { { 3, 0, 1 }, "C4", "G4", false },
    { { 15, 0, 2 }, "G16", NULL, false },
    { { 15, 0, 2 }, "C16", NULL, true },
    { { 255, ModeFlag_FullPalette, 3 }, "G256", NULL, false },
    { { 255, ModeFlag_FullPalette, 3 }, "C256", NULL, true },
    { { 4095, 0, 4 }, "C4K", "C4T", true },
    { { 65535, 0, 4 }, "C32K", "C32T", true },
    { { 65535, ModeFlag_64k, 4 }, "C64K", "C64T", true },
    { { -1, 0, 5 }, "C16M", NULL, true },
};
#define num_colourchoices (sizeof(colourchoices)/sizeof(colourchoices[0]))

static const char *rgb_alpha_mode[4] = {
    "",
    " LTRGB",
    " LABGR",
    " LARGB",
};

extern int  main_window_id, dpms_window_id, montype_menu_entries, montype_menu_id, res_menu_id, col_menu_id, current_colours, current_res, hz_menu_id, current_hz, hz_menu_entries;
extern bool menus_are_grey, support_edid;
extern void update_montype_tick(ObjectId, ComponentId);
extern int montype_menu_select(int, ToolboxEvent *, IdBlock *, void *);

/*---------------------------------------------------------------------------*
 * find_colours                                                              *
 *                                                                           *
 * Convert NColour, ModeFlags, Log2BPP triplet to colours menu item          *
 *---------------------------------------------------------------------------*/

static int find_colours(const gv_pixelformat format,bool iscolour)
{
    int best = -1;
    int modeflags = format.modeflags & (ModeFlag_FullPalette | ModeFlag_64k); /* Ignore RGB/alpha flags */
    for(int i=0;i<num_colourchoices;i++)
    {
        if((colourchoices[i].format.ncolour == format.ncolour)
        && (colourchoices[i].format.modeflags == modeflags)
        && (colourchoices[i].format.log2bpp == format.log2bpp))
        {
            best = i;
            /* Return this entry if it's an exact match for colour/greyscale
               choice */
            if(colourchoices[i].iscolour == iscolour)
            {
                return i;
            }
        }
    }

    return best;
}


/*---------------------------------------------------------------------------*
 * descriptor_to_pixelformat                                                 *
 *                                                                           *
 * Parse a mode descriptor to extract a gv_pixelformat                       *
 *---------------------------------------------------------------------------*/

static gv_pixelformat descriptor_to_pixelformat(const int *descriptor)
{
    gv_pixelformat format;
    if((descriptor[1] & 0xff) != 1)
    {
        /* New format */
        format.ncolour = descriptor[4];
        format.modeflags = descriptor[5];
        format.log2bpp = descriptor[6];
    }
    else
    {
        /* Old format */
        format.log2bpp = descriptor[4];
        format.modeflags = (format.log2bpp == 3?ModeFlag_FullPalette:0);
        format.ncolour = (1<<(1<<format.log2bpp))-1;
    }
    return format;
}


/*---------------------------------------------------------------------------*
 * descriptor_hz                                                             *
 *                                                                           *
 * Parse a mode descriptor to extract framerate                              *
 *---------------------------------------------------------------------------*/

static int descriptor_hz(const int *descriptor)
{
    if((descriptor[1] & 0xff) != 1)
    {
        /* New format */
        return descriptor[7];
    }
    else
    {
        /* Old format */
        return descriptor[5];
    }
}


/*---------------------------------------------------------------------------*
 * descriptor_name                                                           *
 *                                                                           *
 * Parse a mode descriptor to extract mode name                              *
 *---------------------------------------------------------------------------*/

static char *descriptor_name(const int *descriptor)
{
    if((descriptor[1] & 0xff) != 1)
    {
        /* New format */
        return (char *) (descriptor+8);
    }
    else
    {
        /* Old format */
        return (char *) (descriptor+6);
    }
}


/*---------------------------------------------------------------------------*
 * read_current_mode_settings                                                *
 *                                                                           *
 * Read current MDF and chosen resolution from the choices file in PreDesk.  *
 *---------------------------------------------------------------------------*/

void read_current_mode_settings(int file_to_read)
{
    FILE *fp;
    char *string;
    char  res0[256];
    char  res1[256];
    char  res2[256];
    char  res3[256];
    char  res4[256];
    char  buffer[1024];

    if (current_monitor_file) free(current_monitor_file);
    current_monitor_file=NULL;
    current_x_res = -1;
    current_y_res = -1;
    current_colours = -1;
    current_flags = 0;
    current_hz = -1;

    /* Read in the PreDesk or temporary config file */
    if (file_to_read == FTR_CONFIG)
      fp=fopen(PreDeskConfigFile, "r");
    else
      fp=fopen(ScrapConfigFile, "r");
    if (fp)
    {
        /* Scan forwards until we find the LoadModeFile command */
        do {
            if (!fgets(buffer, 1024, fp))
            {
                fclose(fp);
                return;
            }
        } while (strncmp(buffer, LoadModeCmd, strlen(LoadModeCmd)));
        
        if (buffer[strlen(buffer)-1]==NewLine)
            buffer[strlen(buffer)-1]=0;
        /* Get current selected MDF */
        string=strchr(buffer, ' ');
        if (!string)
        {
            fclose(fp);
            return;
        }
        current_monitor_file=malloc(strlen(string));
        if (!current_monitor_file)
        {
            fclose(fp);
            return;
        }
        strcpy(current_monitor_file, string+1);

        /* Next line should be a WimpMode command */
        fgets(buffer, 1024, fp);
        int offset;
        int count = sscanf(buffer, "%s%n %s %s %s %s", res0, &offset, res1, res2, res3, res4);

        if (strncmp(res0, WimpModeCmd, strlen(WimpModeCmd))==0)
        {
            int modeblock[14];

            /* Use the OS to parse the string if possible */
            if(!_swix(OS_ScreenMode,_INR(0,3),ScreenModeReason_ModeStringToSpecifier,buffer+offset,modeblock,sizeof(modeblock)))
            {
                current_x_res = modeblock[1];
                current_y_res = modeblock[2];
                current_hz = modeblock[4];
                /* Identify pixel format */
                gv_pixelformat format;
                format.log2bpp = modeblock[3];
                error_trap(_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), modeblock, VduExt_NColour, &format.ncolour), 0);
                error_trap(_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), modeblock, VduExt_ModeFlags, &format.modeflags), 0);
                current_colours = find_colours(format,!(format.modeflags & ModeFlag_GreyscalePalette));
            }
            /* Fall back on manual parsing */
            else if(((count == 4) || (count == 5))
                 && (res1[0]=='X')
                 && (res2[0]=='Y')
                 && (res3[0]=='C' || res3[0]=='G') )
            {
                /* Deal with resolution */
                current_x_res=atoi(res1+1);
                current_y_res=atoi(res2+1);
    
                /* Deal with colours */
                for(int i=0;i<num_colourchoices;i++)
                {
                    if (!strcmp(res3,colourchoices[i].text)
                        || (colourchoices[i].alttext && !strcmp(res3,colourchoices[i].alttext)))
                    {
                        current_colours = i;
                        break;
                    }
                }
    
                /* Deal with frame rate */
                if(res4[0]=='F') current_hz = atoi(res4+1);
            }

            /* Find out if selected mode is rectangular or square pixel */
            if ( current_x_res != -1 && current_y_res != -1 && current_colours != -1 )
            {
                int xeig, yeig;
    
                modeblock[0] = 1;
                modeblock[1] = current_x_res;
                modeblock[2] = current_y_res;
                modeblock[3] = colourchoices[current_colours].format.log2bpp;
                modeblock[4] = -1;
                modeblock[5] = VduExt_NColour;
                modeblock[6] = colourchoices[current_colours].format.ncolour;
                modeblock[7] = VduExt_ModeFlags;
                modeblock[8] = colourchoices[current_colours].format.modeflags;
                modeblock[9] = -1;
                error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), modeblock, VduExt_XEigFactor, &xeig), 0);
                error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), modeblock, VduExt_YEigFactor, &yeig), 0);
                if (xeig==yeig) current_flags |= flags_squarepixel;
            }
        }
        else
        {
            /* See if it's a live monitor showing best resolution, for which we emit a WimpModeCmdBest */
            if (strncmp(buffer, WimpModeCmdBest, strlen(WimpModeCmdBest))==0)
            {
                current_x_res = current_y_res = -2;
            }
        }
        fclose(fp);
    }
}


/*---------------------------------------------------------------------------*
 * update_monitor_displayfields                                              *
 *                                                                           *
 * Update all the monitor displayfields (monitor, resolution, colours, frame *
 * rate) according to the current settings.                                  *
 *---------------------------------------------------------------------------*/

void update_monitor_displayfields(void)
{
    monitor_ref *m;
    int          i;
    char         res_string[256];
    char         menu_string[256];
    bool         monitor_set = false;

    if ((current_x_res==-1) || (current_y_res==-1))
        error_trap(displayfield_set_value(0, main_window_id, ResolutionDisplay, messages_lookup("Unk")), 0);

    if (current_colours<0)
        error_trap(displayfield_set_value(0, main_window_id, ColourDisplay, messages_lookup("Unk")), 0);

    if (current_hz<0)
        error_trap(displayfield_set_value(0, main_window_id, FrameRateDisplay, messages_lookup("Unk")), 0);

    if ((current_x_res==-2) && (current_y_res==-2))
    {
        /* Best available */
        error_trap(displayfield_set_value(0, main_window_id, ResolutionDisplay, messages_lookup("Best")), 0);
        error_trap(displayfield_set_value(0, main_window_id, ColourDisplay, messages_lookup("Auto")), 0);
        error_trap(displayfield_set_value(0, main_window_id, FrameRateDisplay, messages_lookup("Auto")), 0);
        grey_gadget(main_window_id, ColourMenu);
        grey_gadget(main_window_id, ColourDisplay);
        grey_gadget(main_window_id, FrameRateMenu);
        grey_gadget(main_window_id, FrameRateDisplay);
        menus_are_grey = true;
   }
   else
   {
        if (!current_monitor_file)
        {
            /* From "Auto" */
            grey_gadget(main_window_id, ColourMenu);
            grey_gadget(main_window_id, ColourDisplay);
            grey_gadget(main_window_id, ResolutionMenu);
            grey_gadget(main_window_id, ResolutionDisplay);
            grey_gadget(main_window_id, FrameRateMenu);
            grey_gadget(main_window_id, FrameRateDisplay);
            menus_are_grey = true;
        }
        else
        {
            /* Manual */
            ungrey_gadget(main_window_id, ColourMenu);
            ungrey_gadget(main_window_id, ColourDisplay);
            ungrey_gadget(main_window_id, ResolutionMenu);
            ungrey_gadget(main_window_id, ResolutionDisplay);
            ungrey_gadget(main_window_id, FrameRateMenu);
            ungrey_gadget(main_window_id, FrameRateDisplay);
            menus_are_grey = false;
        }
   }

    if (current_monitor_file)
    {
        /* Update monitor name display */
        for (m=monitors_list; m; m =m->next)
        {
            if (strncmp(current_monitor_file, m->file_name, strlen(current_monitor_file))==0)
            {
                error_trap(displayfield_set_value(0, main_window_id, MonitorTypeDisplay, m->monitor_name), 0);
                update_montype_tick(m->menu_id, m->menu_entry);
                monitor_set = true;
                break;
            }
        }
    }

    if (!monitor_set)
    {
        error_trap(displayfield_set_value(0, main_window_id, MonitorTypeDisplay, messages_lookup("Auto")), 0);
        update_montype_tick(montype_menu_id, 0);
    }

    if (!current_monitor_file)
    {
        /* Resolution, colours and frame rate are all greyed out */
        return;
    }

    /* Update resolution display */
    for ( i=0; i<nummodes; i++ )
    {
        if (modes_index[i][2]==current_x_res &&
            modes_index[i][3]==current_y_res)
        {
            char *name = descriptor_name(modes_index[i]);
            if (*name=='\0')
            {
                char text[16];
                sprintf(text, "%d x %d", current_x_res, current_y_res);
                error_trap(displayfield_set_value(0, main_window_id, ResolutionDisplay, text), 0);
            }
            else
            {
                error_trap(displayfield_set_value(0, main_window_id, ResolutionDisplay, name), 0);
            }
            break;
        }
    }

    /* Work out which entry in the resolution menu to tick */
    error_trap(displayfield_get_value(0, main_window_id, ResolutionDisplay, res_string, sizeof(res_string), 0), 0);
    for (i=0; i<res_menu_entries; i++)
    {
        error_trap(menu_get_entry_text(0, res_menu_id, i, menu_string, sizeof(menu_string), 0), 0);
        if (strcmp(res_string, menu_string)==0)
        {
            error_trap(menu_set_tick(0, res_menu_id, current_res, 0), 0);
            error_trap(menu_set_tick(0, res_menu_id, i, 1), 0);
            current_res=i;
            break;
        }
    }

    /* Update colours menu */
    for (i=0; i<num_colourchoices; i++)
    {
        /* Untick the whole menu */
        error_trap(menu_set_tick(0, col_menu_id, i, 0), 0);
    }
    if (current_colours>=0)
    {
        /* Tick current,and refresh the display field */
        error_trap(menu_set_tick(0, col_menu_id, current_colours, 1), 0);
        error_trap(menu_get_entry_text(0, col_menu_id, current_colours, menu_string, sizeof(menu_string), 0), 0);
        error_trap(displayfield_set_value(0, main_window_id, ColourDisplay, menu_string), 0);
    }

    /* Update frame rate display */
    if(current_hz>=0)
    {
        char text[16];
        sprintf(text,"%dHz",current_hz);
        error_trap(displayfield_set_value(0, main_window_id, FrameRateDisplay, text), 0);
        /* Tick correct menu entry */
        for (i=0; i<hz_menu_entries; i++)
        {
            error_trap(menu_get_entry_text(0, hz_menu_id, i, menu_string, sizeof(menu_string), 0), 0);
            error_trap(menu_set_tick(0, hz_menu_id, i, (strcmp(text, menu_string)?0:1)), 0);
        }
    }
}


/*---------------------------------------------------------------------------*
 * update_dpms_status                                                        *
 *                                                                           *
 * Update the DPMS state icon for the current monitor file.                  *
 *---------------------------------------------------------------------------*/

void update_dpms_status(void)
{
    monitor_ref *m;
    char         message_tag[16];

    if(!current_monitor_file)
        return;

    /* Find current monitor in our list */
    for (m=monitors_list; m; m =m->next)
    {
        if (strncmp(current_monitor_file, m->file_name, strlen(m->file_name))==0)
        {
            sprintf(message_tag, "DPMS%d", m->dpms_state);
            error_trap(displayfield_set_value(0, dpms_window_id, DPMSStateDisplay, messages_lookup(message_tag)), 0);
            break;
        }
    }
}


/*---------------------------------------------------------------------------*
 * create_screenmodes_instantiation                                          *
 *                                                                           *
 * Create a new instantiation of the ScreenModes module so that we can load  *
 * any newly selected MDF into it.                                           *
 *---------------------------------------------------------------------------*/

void create_screenmodes_instantiation(void)
{
    char tbuf[256];
    int i;

    /* Find highest numeric instantiation currently present */
    for ( i=0; i<1000; i++ )
    {
        sprintf(tbuf, "ScreenModes%%%d", i);
        if (_swix(OS_Module, _IN(0)|_IN(1), ModHandReason_LookupName, tbuf)) break;
    }
    my_screenmodes_instantiation = i;

    /* create new instantiation */
    error_trap(_swix(OS_Module, _IN(0)|_IN(1)|_OUT(5), ModHandReason_LookupName, "ScreenModes", &desktop_instantiation), 0);
    sprintf(tbuf, "ScreenModes%%%d", my_screenmodes_instantiation);
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), ModHandReason_NewIncarnation, tbuf), 0);

#if UseVIDCBandLimitAlias
        /* issue VIDCBandLimit command, if Alias$VIDCBandLimit has been set (should be set by BandLimit app in
           PreDesk.Configure, with VIDCBandwidthLimit parameters as appropriate, eg. for 7500FE with EDO) */
        if (getenv("Alias$VIDCBandLimit")) (void)_swix( OS_CLI, _IN(0), "VIDCBandLimit");
#else
        /* Activate any VIDCBandwidthLimit command if its there */
        (void)_swix( OS_CLI, _IN(0), "IfThere Choices:Boot.PreDesk.BandLimit then /Choices:Boot.PreDesk.BandLimit "
                "else IfThere Boot:Utils.BandLimit then /Boot:Utils.BandLimit" );
            /*Fix bug: JRC 26th Jan 1995*/
#endif

    /* Now load our mode file */
    if (current_monitor_file)
    {
        error_trap(_swix(OS_ReadSysInfo, _IN(0)|_OUT(1), 1, &desktop_monitortype), 0);
        sprintf(tbuf, LoadModeCmd " %s", current_monitor_file);
        /* Only complain if the LoadModeFile doesn't work */
        error_trap(_swix( OS_CLI, _IN(0), tbuf ), 0);
    }

    /* Choose our preferred instantiation */
    sprintf(tbuf, "ScreenModes%%%s", desktop_instantiation);
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), ModHandReason_MakePreferred, tbuf ), 0);
}


/*---------------------------------------------------------------------------*
 * choose_my_screenmodes_instantiation                                       *
 *                                                                           *
 * Choose the newly created screenmodes instantiation as the current one.    *
 *---------------------------------------------------------------------------*/

static void choose_my_screenmodes_instantiation( void )
{
    char tbuf[256];

    /* read current preferred */
    error_trap(_swix(OS_Module, _IN(0)|_IN(1)|_OUT(5), ModHandReason_LookupName, "ScreenModes", &desktop_instantiation), 0);
    /* read current monitortype */
    error_trap(_swix(OS_ReadSysInfo, _IN(0)|_OUT(1), 1, &desktop_monitortype), 0);
    /* switch to mine */
    sprintf(tbuf, "ScreenModes%%%d", my_screenmodes_instantiation);
    error_trap(_swix( OS_Module, _IN(0)|_IN(1), ModHandReason_MakePreferred, tbuf), 0);
}


/*---------------------------------------------------------------------------*
 * return_to_base_screenmodes_instantiation                                  *
 *                                                                           *
 * Choose the original screenmodes instantiation as the current one.         *
 *---------------------------------------------------------------------------*/

static void return_to_base_screenmodes_instantiation( void )
{
    char tbuf[256];

    if (desktop_instantiation == NULL) return;

    error_trap(_swix(OS_ScreenMode, _IN(0)|_IN(1), ScreenModeReason_SelectMonitorType, desktop_monitortype), 0);

    /* switch instantiation */
    sprintf(tbuf, "ScreenModes%%%s", desktop_instantiation);
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), ModHandReason_MakePreferred, tbuf), 0);
}


/*---------------------------------------------------------------------------*
 * discard_screenmodes_instantiation                                         *
 *                                                                           *
 * Get rid of our created screenmodes instantiation.                         *
 *---------------------------------------------------------------------------*/

void discard_screenmodes_instantiation(void)
{
    char tbuf[256];

    sprintf(tbuf, "ScreenModes%%%d", my_screenmodes_instantiation);
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), ModHandReason_Delete, tbuf), 0);
}


/*---------------------------------------------------------------------------*
 * mode_compare2                                                             *
 *                                                                           *
 * The guts of the comparison code, it does everything except the RGB/alpha  *
 * comparison.                                                               *
 *---------------------------------------------------------------------------*/

static int mode_compare2( const int *a, const int *b )
{
    if ( (a[1] & flags_squarepixel) != (b[1] & flags_squarepixel) )
            return (a[1] & flags_squarepixel) ? 1 : -1 ;

    if ( a[2] != b[2] ) return a[2] - b[2];         /* Xres */

    if ( a[3] != b[3] ) return a[3] - b[3];         /* Yres */

    gv_pixelformat format_a = descriptor_to_pixelformat(a);
    gv_pixelformat format_b = descriptor_to_pixelformat(b);

    int colours_a = find_colours(format_a,true);
    int colours_b = find_colours(format_b,true); 

    if ( colours_a != colours_b ) return colours_a - colours_b; /* colours */

    int hz_a = descriptor_hz(a);
    int hz_b = descriptor_hz(b);

    if ( hz_a != hz_b ) return hz_b - hz_a;         /* frame rate */

    return 0;
}


/*---------------------------------------------------------------------------*
 * mode_compare                                                              *
 *                                                                           *
 * Function for qsort to decide when a mode descriptor is higher or lower.   *
 *---------------------------------------------------------------------------*/

static int mode_compare( const void *aa, const void *bb )
{
    const int *a = *(int **)aa;
    const int *b = *(int **)bb;

    int comparison = mode_compare2(a,b);

    if (comparison) return comparison; 

    gv_pixelformat format_a = descriptor_to_pixelformat(a);
    gv_pixelformat format_b = descriptor_to_pixelformat(b);

    return (format_a.modeflags & ModeFlag_DataFormatSub_Mask) - (format_b.modeflags & ModeFlag_DataFormatSub_Mask); /* RGB/alpha flags */ 
}


/*---------------------------------------------------------------------------*
 * create_resolutions_menu                                                   *
 *                                                                           *
 * Given the object ID of the resolution menu, create the menu entries for   *
 * the selected MDF.                                                         *
 *                                                                           *
 * In: menu_handle = object id of resolution menu.                           *
 *---------------------------------------------------------------------------*/

void create_resolutions_menu(void)
{
    MenuTemplateEntry entry;
    static char *bestres;
    int   i, spaceformodes, numdiffmodes, flag, entryno, colourmask = 0;
    char *rover;
    bool  montype_live;

    /* Keep 1 copy of the extra resolution */
    if (bestres == NULL)
    {
        bestres = malloc(strlen(messages_lookup("Best")) + 1);
        if (bestres != NULL) strcpy(bestres, messages_lookup("Best"));
    }

    /* Remove all current menu entries */
    for (i=0; i<res_menu_entries; i++) error_trap(menu_remove_entry(0, res_menu_id, i), 0);
    res_menu_entries=0;
    current_res=0;

    choose_my_screenmodes_instantiation();

    /* Find spaces needed to enumerate the available screen modes */
    error_trap(_swix(OS_ScreenMode, _IN(0)|_IN(2)|_IN(6)|_IN(7)|_OUT(2)|_OUT(7),
                ScreenModeReason_EnumerateModes, 0, 0, 0, &nummodes, &spaceformodes), 0);

    if (modes_block) free(modes_block);
    if (modes_index) free(modes_index);
    modes_block=NULL;
    modes_index=NULL;

    /* Get memory to store mode information */
    modes_block=malloc(-spaceformodes);
    if (!modes_block)
    {
        nummodes = 0;
        return;
    }

    /* Enumerate the available screen modes */
    error_trap(_swix(OS_ScreenMode, _IN(0)|_IN(2)|_IN(6)|_IN(7),
                 ScreenModeReason_EnumerateModes, 0, modes_block, -spaceformodes), 0);
    nummodes=-nummodes;

    return_to_base_screenmodes_instantiation();

    /* Modes index is a list of pointers to each mode in the mode data returned by EnumerateScreenModes */
    modes_index = malloc( sizeof( *modes_index ) * nummodes );
    if (!modes_index)
    {
        nummodes = 0;
        return;
    }

    if (nummodes==0) return;

    /* Go through all the modes and check for square pixel modes (mark these) */
    rover = modes_block;
    int j = 0;
    for ( i=0; i<nummodes; i++ )
    {
        int xeig,yeig;
        int selector[10];

        /* check descriptor format and generate a mode selector */
        int format = (((int *)rover)[1] & 0xff);
        if(format == 1)
        {
            selector[0] = 1;
            selector[1] = ((int *)rover)[2];
            selector[2] = ((int *)rover)[3];
            selector[3] = ((int *)rover)[4];
            selector[4] = ((int *)rover)[5];
            selector[5] = -1;
        }
        else if(format == 3)
        {
            selector[0] = 1;
            selector[1] = ((int *)rover)[2];
            selector[2] = ((int *)rover)[3];
            selector[3] = ((int *)rover)[6];
            selector[4] = ((int *)rover)[7];
            selector[5] = VduExt_NColour;
            selector[6] = ((int *)rover)[4];
            selector[7] = VduExt_ModeFlags;
            selector[8] = ((int *)rover)[5];
            selector[9] = -1;
        }
        else
        {
            /* Unknown format, skip it */
            rover += *((int *)rover);
            continue;
        }

        /* check we recognise the pixel format */
        if(find_colours(descriptor_to_pixelformat((int *)rover),true) == -1)
        {
            rover += *((int *)rover);
            continue;
        }

        /* check for square pixels */
        error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), selector, VduExt_XEigFactor, &xeig), 0);
        error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), selector, VduExt_YEigFactor, &yeig), 0);
        /* naughty, naughty, we're changing mode selector flags! */
        if ( xeig == yeig )
        {
            ((int *)rover)[1] |= flags_squarepixel;
        }
        else
        {
            ((int *)rover)[1] &= ~flags_squarepixel;
        }
        
        /* Store the index for this mode */
        modes_index[j] = (int *)rover;
        rover += *((int *)rover);
        j++;
    }
    nummodes = j;

    /* Sort the modes into resolution order */
    qsort( modes_index, nummodes, 4, mode_compare );

    /* Run through the list again and discard any which are identical apart from RGB/alpha flags - currently the user has no control over RGB/alpha selection, instead we decide for him what the most compatible mode is */
    for(i=0;i<nummodes-1;i++)
    {
        if(!mode_compare2(modes_index[i],modes_index[i+1]))
        {
            /* Ditch the second entry */
            memmove(&modes_index[i+1],&modes_index[i+2],sizeof(int*)*(nummodes-(i+2)));
            nummodes--;
            i--;
        }
    }

    /* We're not bothered about these fields in the menu entry data: */
    entry.click_show=0;
    entry.submenu_show=0;
    entry.submenu_event=0;
    entry.click_event=0;
    entry.help_message=0;
    entry.max_entry_help=0;

    /* Construct menu string */
    flag = modes_index[nummodes-1][1] & flags_squarepixel;
    numdiffmodes=0;

    for (i=nummodes-1; i>=0; i--)
    {
        gv_pixelformat format = descriptor_to_pixelformat(modes_index[i]);
        colourmask |= 1<<find_colours(format,true);
        colourmask |= 1<<find_colours(format,false);

        if ( (i==0 ||
              modes_index[i][2] != modes_index[i-1][2] ||
              modes_index[i][3] != modes_index[i-1][3]) &&
             *descriptor_name(modes_index[i]) )
        {
            numdiffmodes++;

            /* Mark divider between square and rectangular pixel modes */
            entry.flags=0;
            if (flag != (modes_index[i][1] & flags_squarepixel))
            {
                flag = modes_index[i][1] & flags_squarepixel;
                entry.flags = Menu_Entry_DottedLine;
            }

            entry.component_id=res_menu_entries;
            entry.text=descriptor_name(modes_index[i]);
            entry.max_text=256;
            menu_add_entry(0, res_menu_id, -1, (char*)&entry, &entryno);
            res_menu_entries++;
        }
    }

    montype_live = strncmpa(current_monitor_file, MonitorsLive, sizeof(MonitorsLive) - 1) == 0; 
    if (montype_live && (bestres != NULL))
    {
        /* Selected monitor is from live data, include a special "best resolution" entry */
        entry.flags=0;
        entry.component_id=res_menu_entries;
        entry.text=bestres;
        entry.max_text=256;
        menu_add_entry(0, res_menu_id, -1, (char*)&entry, &entryno);
        res_menu_entries++;
    }

    /* Optionally shade the colour menus if some bpp aren't there */
    for(i=0;i<num_colourchoices;i++)
    {
       if(!(colourmask & (1<<i)))
           menu_set_fade(0, col_menu_id, i, 1);
    }
}


/*---------------------------------------------------------------------------*
 * create_hz_menu                                                            *
 *                                                                           *
 * Recreates the framerate menu whenever we change monitor/mode/depth/cols   *
 *---------------------------------------------------------------------------*/

void create_hz_menu(void)
{
    MenuTemplateEntry entry;
    int   i, entryno;
    memset(&entry,0,sizeof(entry));

    /* Remove all current menu entries */
    for (i=0; i<hz_menu_entries; i++) error_trap(menu_remove_entry(0, hz_menu_id, i), 0);
    hz_menu_entries=0;

    /* Add all the new entries for the current mode */
    for (i=0; i<nummodes; i++)
    {
        if ((modes_index[i][2] == current_x_res) &&
            (modes_index[i][3] == current_y_res) &&
            (find_colours(descriptor_to_pixelformat(modes_index[i]), colourchoices[current_colours].iscolour) == current_colours))
        {
            int hz = descriptor_hz(modes_index[i]);
            if(!hz_menu_entries || (hz != descriptor_hz(modes_index[i-1])))
            {
                char text[16];
                sprintf(text,"%dHz",hz);
                /* If the refresh rate is currently unknown (e.g. due to loading a WimpMode line saved by an older version of the plugin) then now is a good time to set the refresh rate to max */
                if(current_hz == -1)
                {
                    current_hz = hz;
                    error_trap(displayfield_set_value(0, main_window_id, FrameRateDisplay, text), 0);
                }
                entry.flags=(hz==current_hz ? Menu_Entry_Ticked : 0);
                entry.component_id=hz_menu_entries;
                entry.text=(char *)text;
                entry.max_text=256;
                menu_add_entry(0, hz_menu_id, hz_menu_entries-1, (char*)&entry, &entryno);
                hz_menu_entries++;
            }
        }
        else if(hz_menu_entries)
        {
            /* As modes_index is sorted, exit early now the resolution has passed */
            break;
        }
    }
    if (!hz_menu_entries)
    {
        /* When colours/resolution is unknown this is an empty menu. Fade it. */
        grey_gadget(main_window_id, FrameRateDisplay);
        grey_gadget(main_window_id, FrameRateMenu);
    }
    else
    {
        ungrey_gadget(main_window_id, FrameRateDisplay);
        ungrey_gadget(main_window_id, FrameRateMenu);
    }
}


/*---------------------------------------------------------------------------*
 * is_duplicate_monitor                                                      *
 *                                                                           *
 * Check if this is a duplicate monitor from another similar MDF             *
 *                                                                           *
 * Out: true if the proposed monitor shouldn't be added to the global list   *
 *---------------------------------------------------------------------------*/

static bool is_duplicate_monitor(char *name, char *file, int origin)
{
    int filelen, namelen;
    monitor_ref *previous, *dup;
        
    filelen = strlen(file) - strlen(get_leafname(file));
    namelen = strlen(name);
    dup = monitors_list;
    previous = NULL;
    while (dup)
    {
        if ((strncmpa(name, dup->monitor_name, namelen) == 0) &&
            (strncmpa(file, dup->file_name, filelen) == 0))
        {
            /* Rules: new = MDF  dup = MDF  -> keep first found
             *        new = MDF  dup = EDID -> keep EDID (ie. first found)
             *        new = EDID dup = MDF  -> keep EDID
             *        new = EDID dup = EDID -> keep first found
             */
            if ((origin == ORIGIN_EDID) && (dup->origin == ORIGIN_MDF))
            {
                /* Unlink the duplicate */
                if (dup->next == NULL)
                {
                    monitors_list_tail = (previous == NULL) ? &monitors_list : &previous->next;
                }
                if (monitors_list == dup)
                {
                    monitors_list = dup->next;
                }
                else
                {
                    previous->next = dup->next;
                }
                free(dup);

                return false; /* Replace it with this */
            }
            return true; /* Keep original, discard this */
        }
        previous = dup;
        dup = dup->next;
    }

    return false; /* No match, do add this */
}


/*---------------------------------------------------------------------------*
 * extract_monitor_name_dpms                                                 *
 *                                                                           *
 * Scan an MDF or EDID block for the monitor name and DPMS value             *
 *                                                                           *
 * Out: priority indication, or -ve on failure                               *
 *---------------------------------------------------------------------------*/

static short extract_monitor_name_dpms(FILE *fp, char *name, int *dpms_state)
{
    char buffer[256];
    static const char edidhdr[] = { 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00 };
    static const char namehdr[] = { 0x00, 0x00, 0x00, 0xFC, 0x00 }; /* Display product name */

    if (fread(buffer, sizeof(edidhdr), 1, fp) != 1)
    {
        /* Give up, since file_format:1 string of an MDF is longer than that */
        return -1;
    }

    /* Default if no DPMS keyword */
    *dpms_state = 0; 

    fseek(fp, 0, SEEK_SET);

    if (memcmp(buffer, edidhdr, sizeof(edidhdr)) == 0)
    {
        size_t i, j;
        char   sum;

        /* Looks like an EDID block */
        if (!support_edid)
        {
            return -1; /* OS can't handle EDID */
        }
        if (fread(buffer, EDIDBaseBlockSize, 1, fp) != 1)
        {
            return -1; /* File too short */
        }
        for (i = 0, sum = 0; i < EDIDBaseBlockSize; i++)
        {
            sum = sum + buffer[i];
        }
        if (sum != 0)
        {
            return -1; /* Bad checksum */
        }

        /* Interpret feature bits for DPMS */
        if (buffer[EDIDFeaturesOffset] & EDIDFeaturesDPMStandbySupported)
        {
            *dpms_state = 1;
        }
        if (buffer[EDIDFeaturesOffset] & EDIDFeaturesDPMSuspendSupported)
        {
            *dpms_state = 2;
        }
        if (buffer[EDIDFeaturesOffset] & EDIDFeaturesDPMActiveOffSupported)
        {
            *dpms_state = 3;
        }

        /* Look for optional name display descriptor */
        for (i = 0; i < 4; i++)
        {
            if (memcmp(&buffer[EDIDDataBlocksOffset + (i * 18)], namehdr, sizeof(namehdr)) == 0)
            {
                const char *desc = &buffer[EDIDDataBlocksOffset + (i * 18) + sizeof(namehdr)];

                /* Copy the name out, replacing unprintables with spaces */
                for (j = 0; j < (18 - sizeof(namehdr)); j++)
                {
                    if (desc[j] == NewLine) break;
                    *name = ((desc[j] < 32) || (desc[j] == 127)) ? ' ' : desc[j];
                    name++;
                }
                *name = '\0';
                return ORIGIN_EDID;
            }
        }

        /* Invent a name */
        strcpy(name, messages_lookup("NoName"));
        return ORIGIN_EDID;
    }
    else
    {
        bool gotfmt = false, gotname = false, gotdpms = false;

        /* Check for a file_format:1 string */
        while (!feof(fp) && !gotfmt)
        {
            fgets(buffer, sizeof(buffer), fp);
            if (strncmpa(buffer, FileFormat, strlen(FileFormat)) == 0) gotfmt = true;
        }
        if (gotfmt)
        {
            while (!feof(fp) && !(gotname && gotdpms))
            {
                fgets(buffer, sizeof(buffer), fp);
                if (strncmpa(buffer, MonitorTitle, strlen(MonitorTitle)) == 0)
                {
                    /* Found monitor_title:xxx string */
                    if (buffer[strlen(buffer) - 1] == NewLine) buffer[strlen(buffer) - 1] = '\0';
                    strcpy(name, &buffer[strlen(MonitorTitle)]);
                    gotname = true;
                }
                if (strncmpa(buffer, DPMSState, strlen(DPMSState)) == 0)
                {
                    /* Found the DPMS_state:xxx string */
                    if (buffer[strlen(buffer) - 1] == NewLine) buffer[strlen(buffer) - 1] = '\0';
                    *dpms_state = atoi(&buffer[strlen(DPMSState)]);
                    gotdpms = true;
                }
            }
        }
        return gotname ? ORIGIN_MDF : -1; /* Require at least a name */
    }
}

/*---------------------------------------------------------------------------*
 * construct_monitors_list                                                   *
 *                                                                           *
 * Build a structure with the details of all available MDFs.                 *
 *---------------------------------------------------------------------------*/

static void construct_monitors_list(char *dirname, char *buffer_end)
{
    _kernel_oserror *e = NULL;
    monitor_ref     *new_ref;
    FILE            *fp;
    char            *dirname_end;
    char             string[256];
    int              pos = 0;
    int              num, type, dpms_state;
    short            origin;

    dirname_end = dirname + strlen(dirname);

    while ((e == NULL) && (pos != -1))
    {
        /* Get next entry from directory */
        e = _swix(OS_GBPB, _INR(0,6)|_OUTR(3,4),
                           OSGBPB_ReadDirEntries, dirname, dirname_end+1, 1, pos,
                           buffer_end - (dirname_end+1), 0,
                           &num, &pos);

        if ((e == NULL) && (num > 0))
        {
            *dirname_end = '.';

            /* Find the type of the entry we've just read */
            e = _swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, dirname, &type);
            if ((e == NULL) && (type == object_directory))
            {
                /* It was a directory, so scan this as well */
                construct_monitors_list(dirname, buffer_end);
            }
            else
            {
                /* It was a file, so try and read monitor information */
                fp = fopen(dirname, "r");
                origin = extract_monitor_name_dpms(fp, string, &dpms_state);
                if ((origin > 0) && !is_duplicate_monitor(string, dirname, origin))
                {
                    char *store;

                    /* Found a monitor title, so store details in a structure */
                    store = malloc(sizeof(monitor_ref) + /* For new_ref */
                                   strlen(dirname)+1 +   /* For new_ref->filename */
                                   strlen(string)+1      /* For new_ref->monitor_name */);
                    if (store == NULL)
                    {
                        error_trap(common_error(messages_lookup("NotEnoughMemory")), 0);
                        fclose(fp);
                        return;
                    }
                    new_ref = (monitor_ref *)&store[0];
                    new_ref->file_name     = &store[0+sizeof(monitor_ref)];
                    new_ref->monitor_name  = &store[0+sizeof(monitor_ref)+strlen(dirname)+1];
                    new_ref->next = NULL;
                    strcpy(new_ref->file_name, dirname);
                    strcpy(new_ref->monitor_name, string);
                    new_ref->dpms_state = dpms_state;
                    new_ref->origin = origin;
                    *monitors_list_tail = new_ref;
                    monitors_list_tail = &new_ref->next;
                }
                fclose(fp);
            }
            e = NULL; /* On error, carry on with the enumeration */
            *dirname_end = '\0';
        }
    }
}


/*---------------------------------------------------------------------------*
 * read_monitors_list                                                        *
 *                                                                           *
 * Read list of MDFs.                                                        *
 *                                                                           *
 *---------------------------------------------------------------------------*/

static void read_monitors_list(void)
{
    char buffer[1024];

    monitors_list=NULL;
    monitors_list_tail=&monitors_list;

    _swix(Hourglass_On, 0);
    strcpy(buffer, MonitorsDirectory);
    construct_monitors_list(buffer, buffer + sizeof(buffer));
    strcpy(buffer, MonitorsLive);
    construct_monitors_list(buffer, buffer + sizeof(buffer));
    _swix(Hourglass_Off, 0);
}


/*---------------------------------------------------------------------------*
 * create_monitors_menu                                                      *
 *                                                                           *
 * Build a menu stucture with the details of all available MDFs.             *
 *                                                                           *
 *---------------------------------------------------------------------------*/

void create_monitors_menu(void)
{
    static char *helpedidtype;
    monitor_ref *ref;
    MenuTemplateEntry entry;
    ComponentId       where;
    bool              live; /* Is this read live via EDID? */
    char     live_entry[128];
    ObjectId last_submenu = montype_menu_id;
    char     last_dirname[128] = "";
    ObjectId this_submenu;
    char     this_dirname[128];

    read_monitors_list();

    /* Keep 1 copy of the extra help */
    if (helpedidtype == NULL)
    {
        helpedidtype = malloc(strlen(messages_lookup("HelpEDIDType")) + 1);
        if (helpedidtype != NULL) strcpy(helpedidtype, messages_lookup("HelpEDIDType"));
    }

    /* Always "Auto" */
    entry.component_id = 0;
    entry.click_show = NULL;
    entry.submenu_show = NULL;
    entry.submenu_event = 0;
    entry.click_event = 0;
    entry.help_message = NULL;
    entry.max_entry_help = 0;
    montype_menu_entries = 1;

    /* Now the other ones */
    ref=monitors_list;
    while (ref)
    {
        *this_dirname = '\0';
        live = true;
        if (strncmp(ref->file_name, MonitorsDirectory, sizeof(MonitorsDirectory) - 1) == 0)
        {
            char *dirstart, *dirend;

            live = false;
            dirstart = &ref->file_name[sizeof(MonitorsDirectory)];
            dirend = strchr(dirstart, '.');
            if (dirend != NULL)
            {
                /* Is in a subdirectory of the MonitorsDirectory */
                strncat(this_dirname, dirstart, dirend - dirstart);
            }
        }

        /* We'll flatten everything below 1 level deep in the MonitorsDirectory, and
         * put everything else ungrouped in the top menu.
         */
        where = Menu_AddEntryAtEnd;
        entry.flags = 0;
        entry.component_id = -1 /* Next free */;
        if (live)
        {
            /* Emphasise the origin */
            sprintf(live_entry, "%s (%s)", messages_lookup("Auto"), ref->monitor_name);
            entry.text = live_entry;
        }
        else
        {
            entry.text = ref->monitor_name;
        }
        entry.max_text = strlen(entry.text) + 1;
        if (strlen(this_dirname) != 0)
        {
            if (strcmp(last_dirname, this_dirname) == 0)
            {
                /* More to add to an existing group */
                this_submenu = last_submenu;
            }
            else
            {
                MenuTemplateEntry group;
                ComponentId       group_id;

                /* Create a new group (submenu) */
                error_trap(toolbox_create_object(0, "MonManuMenu", &this_submenu), 0);
                last_submenu = this_submenu;
                strcpy(last_dirname, this_dirname);
                error_trap(menu_set_title(0, this_submenu, this_dirname), 0);

                /* Add the group to the top menu */
                memcpy(&group, &entry, sizeof(entry));
                group.text = this_dirname;
                group.max_text = strlen(group.text) + 1;
                error_trap(menu_add_entry(0, montype_menu_id, Menu_AddEntryAtEnd, (char *)&group, &group_id), 0);
                montype_menu_entries++;
                error_trap(menu_set_sub_menu_show(0, montype_menu_id, group_id, this_submenu), 0);
                error_trap(event_register_toolbox_handler(this_submenu, Menu_Selection, montype_menu_select, NULL), 0);
            }
        }
        else
        {
            /* Not existing, not new, so back up to top menu */
            *last_dirname = '\0';
            this_submenu = montype_menu_id;
            where = 0; /* After "Auto" */
        }
        entry.help_message = live ? helpedidtype : NULL;
        entry.max_entry_help = live ? strlen(helpedidtype) + 1 : 0;
        error_trap(menu_add_entry(0, this_submenu, where, (char *)&entry, &ref->menu_entry), 0);
        ref->menu_id = this_submenu;
        ref=ref->next;
    }
}


/*---------------------------------------------------------------------------*
 * switch_resolution                                                         *
 *                                                                           *
 * Resolution has been changed - find nearest possible match for other       *
 * settings.                                                                 *
 *---------------------------------------------------------------------------*/

void switch_resolution(void)
{
    char buffer[256];
    int  x_to_find, y_to_find, nbytes, i, bestmatch, bestmatch_colours;

    displayfield_get_value(0, main_window_id, ResolutionDisplay, buffer, sizeof(buffer), &nbytes);

    if (strcmp(buffer, messages_lookup("Best")) == 0)
    {
        current_x_res = current_y_res = -2;
        current_hz = current_colours = -1;
        update_monitor_displayfields();
        return;
    }

    /* Search for the selected resolution string in our mode data */
    for (i=0; i<nummodes; i++)
    {
        if (strcmp(descriptor_name(modes_index[i]), buffer)==0) break;
    }

    /* Make sure we found the entry */
    if (i==nummodes) return;

    x_to_find = modes_index[i][2];
    y_to_find = modes_index[i][3];

    /* Now try and match to current_colours */
    bestmatch = -1;
    bestmatch_colours = -1;
    for (i=0; i<nummodes; i++)
    {
        if (modes_index[i][2]==x_to_find && modes_index[i][3]==y_to_find)
        {
            /* This mode has the right resolution */
            int colours;
            if (current_colours>=0)
            {
                /* Check for going past the current colour depth */
                colours = find_colours(descriptor_to_pixelformat(modes_index[i]),colourchoices[current_colours].iscolour);
                if (colours > current_colours) break;
            }
            else
            {
                /* When 'Unknown' any old port in a storm, preferably colour */
                colours = find_colours(descriptor_to_pixelformat(modes_index[i]),TRUE);
            }

            /* Check if this is a better mode that bestmatch */
            if (bestmatch<0 || colours!=bestmatch_colours)
            {
                bestmatch=i;
                bestmatch_colours = colours;
            }
        }
    }

    /* If didn't find any suitable mode... */
    if (bestmatch<0) return;

    /* Found a bestmatch, so switch to that */
    current_colours = bestmatch_colours;

    current_flags=modes_index[bestmatch][1] & flags_squarepixel;
    current_x_res=modes_index[bestmatch][2];
    current_y_res=modes_index[bestmatch][3];
    current_hz=descriptor_hz(modes_index[bestmatch]);

    create_hz_menu();

    update_monitor_displayfields();
}


/*---------------------------------------------------------------------------*
 * switch_colour                                                             *
 *                                                                           *
 * Colour has been changed - find mode that most matches  resolution.        *
 *---------------------------------------------------------------------------*/

void switch_colour(int menusel)
{
    int i, bestmatch;
    int limit_x_res=current_x_res;
    int limit_y_res=current_y_res;

    /* If unknown resolution, then limit to mode 27 */
    if (limit_x_res<0) limit_x_res=640;
    if (limit_y_res<0) limit_y_res=480;

    /* Try and find the bestmatch */
    bestmatch=-1;
    for (i=0; i<nummodes; i++)
    {
        if (find_colours(descriptor_to_pixelformat(modes_index[i]),colourchoices[menusel].iscolour) == menusel)
        {
            /* This mode has the right colour depth */
            if (bestmatch>=0)
            {
                /* We already have a match, so test for being in menu */
                char c1=*descriptor_name(modes_index[bestmatch]);
                char c2=*descriptor_name(modes_index[i]);

                if ((c1!='\0') && (c2=='\0')) continue;

                if ((c1!='\0') || (c2=='\0'))
                {
                    /* Either both are not in the menu or both are in the menu */
                    int f1=modes_index[bestmatch][1] & flags_squarepixel;
                    int f2=modes_index[i][1] & flags_squarepixel;
                    if (f1==f2)
                    {
                        /* Both the same pixel shape, so test x resolution */
                        if ( (modes_index[i][2] > limit_x_res) || (modes_index[i][2] < modes_index[bestmatch][2]) )
                            continue;
                        /* Test y resolution as well - we didn't always do this, but doing so will make us more consistent with how the display manager does things */
                        if ( (modes_index[i][3] > limit_y_res) || (modes_index[i][3] < modes_index[bestmatch][3]) )
                            continue;
                    }
                    else
                    {
                        if ( f2 != current_flags ) continue;
                    }
                }
            }
            bestmatch=i;
        }
    }

    /* If didn't find any suitable mode... */
    if (bestmatch<0) return;

    /* Found a bestatch, so switch to that */
    current_colours=menusel;
    current_flags=modes_index[bestmatch][1] & flags_squarepixel;
    current_x_res=modes_index[bestmatch][2];
    current_y_res=modes_index[bestmatch][3];
    current_hz=descriptor_hz(modes_index[bestmatch]);

    create_hz_menu();

    update_monitor_displayfields();
}


/*---------------------------------------------------------------------------*
 * switch_monitor                                                            *
 *                                                                           *
 * Monitor has been changed. Try and find mode that most matches colours and *
 * resolution settings.                                                      *
 *---------------------------------------------------------------------------*/

void switch_monitor(const monitor_ref *rover)
{
    char tbuf[256];

    if (current_monitor_file) free(current_monitor_file);
    if (modes_block) free (modes_block);
    if (modes_index) free (modes_index);
    current_monitor_file=NULL;
    modes_block=NULL;
    modes_index=NULL;

    if (rover)
    {
        /* Record the monitor name */
        current_monitor_file=malloc(strlen(rover->file_name)+1);
        if (!current_monitor_file) return;
        strcpy(current_monitor_file, rover->file_name);

        /* Load that file into our ScreenModes instantiation */
        choose_my_screenmodes_instantiation();
        sprintf(tbuf, LoadModeCmd " %s", current_monitor_file);
        error_trap(_swix(OS_CLI, _IN(0), tbuf), 0);
        return_to_base_screenmodes_instantiation();

        if ((current_x_res==-2) && (current_y_res==-2))
        {
            /* If previously best resolution, drop to unknown */
            current_x_res = current_y_res = -1;
        }

        /* Reinform the world that current monitor has changed too. */
        error_trap(_swix(OS_ServiceCall, _IN(1), Service_ModeFileChanged), 0);

        create_resolutions_menu();
        create_hz_menu();
    }

    update_monitor_displayfields();
    update_dpms_status();

    if (rover)
        switch_colour(current_colours);
}


/*---------------------------------------------------------------------------*
 * set_monitor_choices                                                       *
 *                                                                           *
 * Write the monitor choices file.                                           *
 *                                                                           *
 * Out: true on success, false on failure                                    *
 *---------------------------------------------------------------------------*/

bool set_monitor_choices(int file_to_write)
{
    FILE *dest_fp;
    char  line1[256];
    char  line2[256];
    bool  montype_auto = (current_monitor_file == NULL);
    bool  exe_wimpmodecmd = true;

    if (!montype_auto)
    {
        /* Not Auto */
        sprintf(line1, LoadModeCmd " %s", current_monitor_file);
        if ((current_x_res==-2) && (current_y_res==-2))
        {
            /* Best resolution depends on the monitor currently plugged in.
             * This works because ScreenModes notes the manufacturer's preferred
             * mode from the live EDID, then when the Wimp uses OS_ReadSysInfo(1)
             * to set the mode on entering the desktop this sends round
             * Service_MonitorLeadTranslation to ask for that preferred mode.
             */
            strcpy(line2, WimpModeCmdBest);
            _swix(OS_CLI, _IN(0), "Configure WimpMode Auto");
            exe_wimpmodecmd = false;
        }
        else
        {
            if ((current_x_res==-1) || (current_y_res==-1) || (current_colours==-1))
            {
                warning_box(messages_lookup("CantSaveMode"));
                return false;
            }

            /* Find the descriptor entry so we can work out the RGB/alpha settings */
            int rgb_alpha = 0;
            for(int i=0;i<nummodes;i++)
            {
                if((modes_index[i][2] == current_x_res) &&
                   (modes_index[i][3] == current_y_res) &&
                   (descriptor_hz(modes_index[i]) == current_hz))
                {
                    gv_pixelformat format = descriptor_to_pixelformat(modes_index[i]);
                    int colours = find_colours(format,colourchoices[current_colours].iscolour);
                    if(colours == current_colours)
                    {
                        /* Found it! */
                        rgb_alpha = (format.modeflags & ModeFlag_DataFormatSub_Mask) >> 14;
                        break;
                    }
                }
            }
            sprintf(line2, WimpModeCmd " X%d Y%d %s F%d%s", current_x_res, current_y_res, colourchoices[current_colours].text, current_hz, rgb_alpha_mode[rgb_alpha]);
        }
    }
    else
    {
        /* Set auto monitor type (whatever's in CMOS) */
        line1[0]=0;
        line2[0]=0;
        _swix(OS_ScreenMode, _IN(0)|_IN(1), ScreenModeReason_SelectMonitorType, -1);
        exe_wimpmodecmd = false;
    }

    /* If we're not just trying-out the settings, build the new settings file */
    if (file_to_write != FTW_NONE)
    {
        char *filename;
  
        if (file_to_write == FTW_CONFIG)
            filename = PreDeskConfigFile;
        else
            filename = ScrapConfigFile;
  
        _swix(OS_File, _INR(0,1)|_IN(5), OSFile_WriteAttr, filename, read_attribute | write_attribute); /* Ignore error if file not found */
        dest_fp = fopen(filename, "w");
        if (dest_fp == NULL)
        {
            error_trap(common_error(messages_lookup_with_parameter("CantWriteFile", filename)), 0);
            return false;
        }
  
        /* Write the LoadModeFile and WimpMode commands to the file */
        if (!montype_auto)
        {
            fputs(line1, dest_fp);
            fputc(NewLine, dest_fp);
            fputs(line2, dest_fp);
            fputc(NewLine, dest_fp);
        }
  
        fclose(dest_fp);
        error_trap(_swix(OS_File, _INR(0,2), OSFile_SetType, filename, FileType_Obey), 0);
    }

    /* When writing to FTW_CONFIG also tell the base instantiation what's
     * going on so when this plugin finishes the monitor is what's just been set.
     * Since the two then end up in sync there's no need to send a
     * fake Service_ModeFileChanged afterwards.
     */
    if (file_to_write == FTW_CONFIG)
    {
        discard_screenmodes_instantiation();
        if (!montype_auto)
            _swix(OS_CLI, _IN(0), line1); /* LoadModeFile */
        else
            _swix(OS_ScreenMode, _IN(0)|_IN(1), ScreenModeReason_SelectMonitorType, -1); /* Auto from CMOS */
        create_screenmodes_instantiation();
    }

    _swix(OS_CLI, _IN(0), line1);
    if (exe_wimpmodecmd)
    {
        _swix(OS_CLI, _IN(0), line2);
    }
    else
    {
        int mode;

        _swix(OS_ReadSysInfo, _IN(0)|_OUT(0), 1, &mode);
        _swix(Wimp_SetMode, _IN(0), mode);
    }

    return true;
}
