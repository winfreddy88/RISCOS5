/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sigfind.h"

typedef struct
{
  int *sig;
  int sigsize;
  int *new;
  void *found;
  int refc;
  int totalrefc;
  char name[64];
} signature_t;

#define SigInit(s,n) {extern void s##_info(int **, int *, int **); int *x, y, *z; strcpy(sigs[num_sigs].name,n); s##_info(&x, &y, &z); sigs[num_sigs].sig = x; sigs[num_sigs].sigsize = y/sizeof(int); sigs[num_sigs++].new = z;}

static signature_t sigs[6];
static char fname[256];
static int appsize;
static int num_sigs;

void sigfind_init(void)
{
  fname[0]='\0';
  appsize=0;
  memset(sigs, 0, sizeof sigs);

  SigInit(RiscOSLib1, "RISC_OSLib os_swi (variant 1)");
  SigInit(RiscOSLib2, "RISC_OSLib os_swi (variant 2)");
  SigInit(SWIc1,      "Static _kernel_swi_c");
  SigInit(SHuntSWI,   "SWI call (SHunt)");
  SigInit(Dlib,       "Desklib SWI veneer");
  SigInit(OvrMangr,   "Overlay loader");
}

int sigfind_find(char *name, int *image, int image_size)
{
  int a;
  int fnd=0;

  for (a = 0; a<num_sigs; a++) {
    sigs[a].found = NULL;
    sigs[a].refc = 0;
  }
  if (name) {
    a = strlen(name);
    if (a >= sizeof(fname)) {
       /* Elipsis and right trim */
       strcpy(&fname[1], &name[a - sizeof(fname) + 2]);
       fname[0] = 0x8C;
    } else {
       strcpy(fname, name);
    }
  } else {
    fname[0] = 0;
  }
  appsize = image_size;

#if 0
  printf ("%x => %x, %d, %x =>  %x, %d\n",*sigs[0].sig, *sigs[0].new,sigs[0].sigsize,
  	      	     *sigs[1].sig, *sigs[1].new,sigs[1].sigsize);
#endif

 /* note image may not be multiple of four bytes */
 while (image_size > 0) {
   for (a= 0; a<num_sigs; a++) {
     if ((*image == *sigs[a].sig) && (image_size >= (sigs[a].sigsize*sizeof(int)))) {
       int b;
       for (b = 0; b< sigs[a].sigsize; b++) {
          #if 0
          if (image[b] != sigs[a].sig[b]) break;
          #else
          /* Supporting wildcards */
          if (image[b] != sigs[a].sig[b] && sigs[a].sig[b] != -2) break;
          #endif
       }
       if (b == sigs[a].sigsize) {
         sigs[a].found = image;
         sigs[a].refc++;
         sigs[a].totalrefc++;
         fnd = 1;
       }
     }
   }
   image_size -= 4;
   image++;
 }
 return fnd;
}

void sigfind_stats(void)
{
   int a;

   printf("Last application examined: %s (size = %d bytes)\n\n", fname[0] ? fname : "<Unknown>", appsize);

   printf("                              Occurrences\n"
          "Signature                     Last app    Total\n"
          "---------                     --------    -----\n");

   for (a = 0; a<num_sigs;a++)
      printf("%-29.29s%9d%9d\n", sigs[a].name, sigs[a].refc, sigs[a].totalrefc);
}

void sigfind_patch(void)
{
  int a;
  for (a = 0; a<num_sigs;a++) {
    if (sigs[a].found != NULL) {
      if (*sigs[a].new == -1) {
        /* need to fix up found+offset to be branch to new+2
         * assume app, so new address is +ve
         */
        unsigned int new_instr = 0xea000000 + (int) (sigs[a].new - ((int *) sigs[a].found) - sigs[a].new[1]);
        *(((unsigned int *) sigs[a].found) + sigs[a].new[1]) = new_instr;
      }
      else memcpy(sigs[a].found, sigs[a].new, sizeof(int)*sigs[a].sigsize);
    }
  }
  /* Synchronise unnecessary as OS will do it after service call returns */
}
