/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "osbyte.h"
#include "osfile.h"
#include "osfscontrol.h"
#include "wimp.h"
#include "hourglass.h"
#include "TaskManager.h"

#include "ModUtils.h"
#include "Save.h"
#include "Main.h"
#include "Load.h"
#include "AUN.h"
#include "Versions.h"
#include "Gadgets.h"
#include "IfsDbox.h"
#include "Diagnose.h"

#include "sys/types.h"
#include "sys/socket.h"
#include "netdb.h"

#define MIN_RMASIZE (256*1024)
#define MIN_SYSTEMSIZE (8*1024)

static FILE *BootFile, *ConfigureFile;

static void SaveInterface(int, bool);
static void SaveResolve(void);
static void SaveResConf(void);

static os_error *SetupAccess(void)
{
    if (AccessEnabled)
    {
        if (InternetEnabled)
        {
            fprintf(ConfigureFile,
                    "|\n"
            	    "| Access\n"
            	    "|\n"
            	    "IfThere Resources:$.Resources.ShareFS.!Boot then Run Resources:$.Resources.ShareFS.!Boot\n"
            	    "RMFind Freeway %s System:Modules.Network.Freeway\n",
            	    VersionToString(v_Freeway));
            fprintf(ConfigureFile,
            	    "RMFind ShareFS %s System:Modules.Network.Share+\n",
            	    VersionToString(v_ShareFS));
    	    RMInsert("Freeway", v_Freeway);
    	    RMInsert("ShareFS", v_ShareFS);
        }
        else
        {
            bool got_f, got_s;

            got_f=RMInsert("Freeway", v_Freeway);
            got_s=RMInsert("ShareFS", v_ShareFS);
            if (!got_f || !got_s)
            {
            	fprintf(BootFile,
                    	"|\n"
            	    	"| Access\n"
            	    	"|\n"
            	    	"IfThere Resources:$.Resources.ShareFS.!Boot then Run Resources:$.Resources.ShareFS.!Boot\n"
            	    	"RMEnsure Freeway %s RMLoad System:Modules.Network.Freeway\n",
            	    	VersionToString(v_Freeway));
            	fprintf(BootFile,
            	    	"RMEnsure ShareFS %s RMLoad System:Modules.Network.Share+\n",
            	    	VersionToString(v_ShareFS));
            }
        }
        /* The next two are necessary to run Resources:$.Resources.ShareFS.!Boot */
        RMInsert("BootNet", 0);
        RMInsert("AUNMsgs", 0);
    }
    else
    {
        Unplug("ShareFS");
        Unplug("Freeway");
    }

    return 0;
}

static os_error *SetupAUN(void)
{
    int temp;
    extern toolbox_o AUNObject;

    if (AUNObject && (AUNEnabled || HaveEconet))
    	UpdateAUNCMOS();

    if (AUNEnabled)
    {
        if (InternetEnabled)
        {
            fprintf(ConfigureFile,
                    "|\n"
                    "| Econet\n"
                    "|\n"
                    "RMFind NetI %s System:Modules.Network.NetI\n"
                    "Run InetDBase:AUNMap\n"
                    "RMEnsure UtilityModule 3.80 RMEnsure BBCEconet 0 RMReInit BBCEconet\n"
                    "RMEnsure NetFS 0 RMReInit NetFS\n"
                    "RMEnsure NetFS 5.79 RMEnsure NetUtils 0.99 "
                                    "Run System:Modules.Network.NetUtils\n"
                    "RMEnsure NetPrint 0 RMReInit NetPrint\n"
                    "RMEnsure NetFiler 0 RMReInit NetFiler\n",
                    VersionToString(v_NetI));
            temp = readCMOS(osbyte_CONFIGURE_BOOT_NET);
            temp &= ~osbyte_CONFIGURE_BOOT_NET_MASK;
            writeCMOS(osbyte_CONFIGURE_BOOT_NET, temp);
        }
        else
        {
            bool got_n;
            got_n=RMInsert("Net", v_Net);
            temp = readCMOS(osbyte_CONFIGURE_BOOT_NET);
            if (got_n)
            	temp |= osbyte_CONFIGURE_BOOT_NET_MASK;
            else
            	temp &= ~osbyte_CONFIGURE_BOOT_NET_MASK;
            writeCMOS(osbyte_CONFIGURE_BOOT_NET, temp);
            if (!got_n)
            {
            	fprintf(BootFile,
            	        "|\n"
                        "| Econet\n"
                        "|\n"
                        "Set Net$Device %s\n"
                        "Run BootResources:!Internet.utils.BootNet\n",
                        "\"\"");
            }
        }
        RMInsert("BootNet", 0);
        RMInsert("NetFS", 0);
        RMInsert("NetPrint", 0);
        RMInsert("NetFiler", 0);
        RMInsert("NetStatus", 0);
        RMInsert("NetUtils", 0);
        RMInsert("BBCEconet", 0);
    }
    else
    {
        temp = readCMOS(osbyte_CONFIGURE_BOOT_NET);
        temp &= ~osbyte_CONFIGURE_BOOT_NET_MASK;
        writeCMOS(osbyte_CONFIGURE_BOOT_NET, temp);
    }

    return 0;
}

static os_error *SetupInternet(void)
{
    int i;
    bool dhcp_wanted = FALSE;
    bool dhcp_private_fallback = FALSE;

    if (InternetEnabled)
    {
        fputs("|================================================================|\n"
              "| Startup file for !Internet                                     |\n"
              "|                                                                |\n"
              "| This file was automatically generated by !InetSetup. Do not    |\n"
              "| edit it by hand unless you REALLY, REALLY, know what you're    |\n"
              "| doing. Comments and spacing are significant to !InetSetup.     |\n"
              "|                                                                |\n"
              "| If you want to add extra configuration options, place them in  |\n"
              "| the User file.                                                 |\n"
              "|================================================================|\n"
              "\n",
              ConfigureFile);

        /* RG: Load the DHCP module whether it's the primary interface or not */
        for (i=0; i<interfaces; ++i)
        {
            if (interface_addrtype[i] == if_DHCP)
            {
                dhcp_wanted = TRUE;
                dhcp_private_fallback = RMFind("DHCP", "System:Modules.Network.DHCP", v_DHCPPrivNet);
                fprintf(ConfigureFile, "|\n"
                                       "| DHCP pre-interface initialisation\n"
                                       "|\n"
                                       "RMEnsure DHCP %s RMLoad System:Modules.Network.DHCP\n",
                        dhcp_private_fallback ? VersionToString(v_DHCPPrivNet) : VersionToString(v_DHCP));
                break;
            }
        }

        fprintf(ConfigureFile, "|\n"
                               "| Host name\n"
                               "|\n"
                               "Set Inet$HostName %s\n", HostName);
        if (Set(LocalDomain))
            fprintf(ConfigureFile, "Set Inet$LocalDomain %s\n", LocalDomain);

    	if (primary_interface != -1)
    	{

    	  /* Need some kind of PPP special case if there is no IP address for primary interface */
    	  /* Will currently just put 'Set Inet$EtherIPAddr ' into a file if no IP address is specified */
    	    if (interface_filename[primary_interface][0] != '\0')
               fprintf(ConfigureFile, "Set Inet$EtherDevice %s\n",
                                       interface_filename[primary_interface]);
            if (interface_addrtype[primary_interface] == if_Manual ||
                interface_addrtype[primary_interface] == if_FromHostname)
            {
              /* I think this is where we will go if PPP is chosen */
              /* I have chosen to not write anything where an address is not present */
              if (strlen(interface_address[primary_interface]) > 0)
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr %s\n", interface_address[primary_interface]);
              else
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr \"\"\n");

              if (strlen(interface_netmask[primary_interface]) > 0)
                fprintf(ConfigureFile, "Set Inet$EtherIPMask %s\n", interface_netmask[primary_interface]);
              else
                fprintf(ConfigureFile, "Set Inet$EtherIPMask \"\"\n");
            }
            else if (interface_addrtype[primary_interface] == if_FromCMOS)
            {
                fprintf(ConfigureFile, "SetMacro Inet$EtherIPAddr <Inet$CMOSIPAddr>\n"
                                       "Set Inet$EtherIPMask %s\n",
                                       interface_netmask[primary_interface]);
            }
            else
            {
                const char *address_type;
                switch (interface_addrtype[primary_interface])
                {
                        case if_RevARP: address_type = "revarp"; break;
                        case if_DHCP: address_type = "dhcp"; break;
                        default: address_type = "bootp"; break;
                }
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr %s\n"
                                       "Set Inet$EtherIPMask %s\n",
                                       address_type,
                                       "default");
            }


            if (interface_is_pp[primary_interface])
            {
              if (interface_is_pp[primary_interface] == 2 && interface_address[primary_interface][0] == '\0')
              {
                /* The primary interface has no remote IP address */
                fprintf(ConfigureFile, "Set Inet$LinkIPAddr \"\"\n");
              } else
              {
                /* It's ok, either it's a normal PP interface or PPP */
                /* has a remote IP address set, dunno which tho :)   */
                fprintf(ConfigureFile, "Set Inet$LinkIPAddr %s\n", interface_linkaddr[primary_interface]);
              }
            }

            SaveInterface(primary_interface, dhcp_private_fallback);
        }
        fprintf(ConfigureFile, "Set Inet$EtherTypeA <Inet$EtherType>\n");

        for (i=0; i<interfaces; i++)
        {
            if (i==primary_interface)
                continue;

            SaveInterface(i, dhcp_private_fallback);
        }

        fputs("|\n"
              "| Loopback\n"
              "|\n"
              "IfConfig -e lo0 127.0.0.1\n"
              "CheckError\n"
              "Set Inet$EtherType <Inet$EtherTypeA>\n"
              "Unset Inet$EtherTypeA\n",
              ConfigureFile);

    	if (UseResolver)
    	{
    	    int i, count = 0;
    	    struct { char *mod, *fname; int *version; } rmods[RT_Count] =
    	                    { "Resolver",    "Resolver",   &v_Resolver,
    	                      "Resolve",     "Resolve",    &v_Resolve,
    	                      "InetDB",      "InetDB",     &v_InetDB,
    	                      "DNSResolver", "DNSResolve", &v_DNSResolver };

    	    fprintf(ConfigureFile, "|\n"
    	    	    	    	   "| Name resolver\n"
    	    	    	    	   "|\n");

            /* If we're using a resolver,always set the Inet$Resolver variable as this is how we
               remember whether the "Use resolver" icon is ticked and wont do any harm */
            fprintf(ConfigureFile, "If \"<Inet$Resolvers>\" = \"\" Then Set Inet$Resolvers");

    	    for (i=0; i<3; i++)
    	    {
    	        if (Set(Resolver[i]))
    	        {
    	          fprintf(ConfigureFile, " %s", Resolver[i]);
    	          count=1;
    	        }
    	    }
    	    if (count) fprintf(ConfigureFile, "\n");
    	    else       fprintf(ConfigureFile, " \"\"\n");



    	    fprintf(ConfigureFile,
    	            "Set Alias$InetLoadResolver \"If <Boot$OSVersion> > 370 Then X ResolverConfig Else RMEnsure %s %s RMLoad System:Modules.Network.%s\"\n",
    	            rmods[ResolverType].mod,
    	            VersionToString(*rmods[ResolverType].version),
    	            rmods[ResolverType].fname/*,
    	            rmods[ResolverType].mod,
    	            VersionToString(*rmods[ResolverType].version),
    	            rmods[ResolverType].fname*/);

            if (ResolverType == RT_Resolver)
                fprintf(ConfigureFile, "SetEval Inet$TestEval 1\nRMEnsure Resolver %s SetEval Inet$TestEval 0\n"
                	"If Inet$TestEval THEN ResolverConfig\nUnset Inet$TestEval\n",
                	VersionToString(*rmods[ResolverType].version));

    	    if (ResolverType == RT_InetDB || ResolverType == RT_DNSResolver)
    	        SaveResConf();
    	    else if (ResolverType == RT_Resolve)
    	        SaveResolve();

            /* Make sure it's plugged in */
            RMInsert(rmods[ResolverType].mod, *rmods[ResolverType].version);
    	}

    	fprintf(ConfigureFile, "|\n"
    	    	    	       "| Routing\n"
    	    	    	       "|\n");
    	if (Set(Gateway))
    	    fprintf(ConfigureFile, "Route -e add default %s\n"
    	                           "CheckError\n",
    	                           Gateway);

    	fprintf(ConfigureFile, "Run " CONFIGDIR_READ "Routes\n"
    	                       "CheckError\n"
    	                       "Set Inet$IsGateway %s\n"
    	                       "Set Inet$RouteDOptions %s\n",
    	                       AmRouter ? "Yes" : "\"\"",
    	                       UseRouteD ? RouteDoptions : "\"\"");

    	RMInsert("AUNMsgs", v_AUNMsgs);
    	RMInsert("MbufManager", v_MbufManager);
    	if (dhcp_wanted)
    	{
    	    RMInsert("Internet", v_InternetDHCP);
    	    RMInsert("DHCP", dhcp_private_fallback ? v_DHCPPrivNet : v_DHCP);
    	}
    	else
    	{
    	    RMInsert("Internet", v_Internet);
    	}

    	fprintf(BootFile, "Run BootResources:!Internet\n");
    }
    else if (AUNEnabled || AccessEnabled)
    {
        bool got_a, got_m, got_i, got_d = FALSE;

        got_a = RMInsert("AUNMsgs", v_AUNMsgs);
        got_m = RMInsert("MbufManager", v_MbufManager);
        got_i = RMInsert("Internet", v_Internet);

        for (i=0; i<interfaces; i++)
        {
            bool t = RMInsert(interface_module[i], interface_version[i]);
            if (!got_d)
                got_d = t;
        }

        if (!got_a || !got_m || !got_i || !got_d)
        {
            /* Prepare to soft load at least 1 module from !System */
            fprintf(BootFile,
                    "|\n"
              	    "| Internet\n"
              	    "|\n"
              	    "IF \"<BootResources$Path>\" = \"\" THEN Set BootResources$Path <Boot$Dir>.Resources.\n"
                    "IF \"<System$Path>\" = \"\" THEN Run BootResources:!System\n");
        }
        if (!got_m)
        {
            /* MbufManager, required by Internet */
            fprintf(BootFile,
                    "RMEnsure MbufManager %s RMLoad System:Modules.Network.MManager\n",
                    VersionToString(v_MbufManager));
        }
        if (!got_a)
        {
            /* AUNMsgs, required by Internet */
            if (RMFind("Internet", "System:Modules.Network.Internet", v_InternetMsgs) == 0)
            {
                /* The Internet we do have, whether in ROM or in !System, doesn't carry its
                 * own Messages so we must load AUNMsgs too.
                 * Note: when MbufManager was internationalised it carried its own Messages
                 * from the start, so there's no need to consider it here.
                 */
                fprintf(BootFile,
                        "RMEnsure AUNMsgs %s RMLoad System:Modules.Network.AUNMsgs\n",
                        VersionToString(v_AUNMsgs));
            }
        }
        if (!got_i)
        {
            /* Internet, required by AUN and Access */
            fprintf(BootFile,
                    "RMEnsure Internet %s RMLoad System:Modules.Network.Internet\n",
                    VersionToString(v_Internet));
        }
        if (!got_d)
        {
            /* Not got the driver, load primary */
            fprintf(BootFile,
                    "RMEnsure %s %s RMLoad System:Modules.Network.%s\n",
                    interface_module[0],
                    VersionToString(interface_version[0]),
                    interface_filename[0]);
        }
        if (!got_a || !got_m || !got_i || !got_d)
        {
            fprintf(BootFile,
                    "Run Inet:utils.TriggerCBs\n");
        }
    }

    if (!InternetEnabled && !AUNEnabled && !AccessEnabled)
    {
        Unplug("Internet");
        Unplug("AUNMsgs");
        Unplug("MbufManager");
        Unplug("BootNet");
        Unplug("Net");
    }

    return 0;
}

void SaveSetup(void)
{
    int pagesize, size;
    int rmasize, systemsize;
    os_error e, *ep;
    char buts[64];
    int i;

    if (!Diagnose())
    	return;

    Unplug("InternetA");
    Unplug("Netmsgs");
    Unplug("Accmsgs");

    if (InternetEnabled)
    {
        osfile_create_dir(CONFIGDIR_STEM, 0);

        if (!Exists(CONFIGDIR_READ "User"))
            osfscontrol_copy("<InetSetup$Dir>.Blanks.User",
                             CONFIGDIR_WRITE "User",
                             0, 0, 0, 0, 0, 0);

        if (!Exists(CONFIGDIR_READ "Routes"))
            osfscontrol_copy("<InetSetup$Dir>.Blanks.Routes",
                             CONFIGDIR_WRITE "Routes",
                             0, 0, 0, 0, 0, 0);

    	ConfigureFile = fopen(CONFIGDIR_WRITE "Startup", "w");
        if (ConfigureFile == NULL)
        {
            ep = (os_error *) _kernel_last_oserror();
            if (ep)
                report_error(ep);
            else
                make_error("CantSaveSetup");
            return;
        }
    }
    BootFile = fopen("<Boot$ToBeLoaded>.SetUpNet", "w");
    if (BootFile == NULL)
    {
        if (InternetEnabled)
            fclose(ConfigureFile);
        ep = (os_error *) _kernel_last_oserror();
        if (ep)
            report_error(ep);
        else
            make_error("CantSaveSetup");
        return;
    }
    SetupInternet();
    SetupAUN();
    SetupAccess();
    if (InternetEnabled && (AccessEnabled || AUNEnabled))
        fputs("SetEval Inet$KickFiler 1\n", ConfigureFile);
    if (InternetEnabled)
    {
    	fclose(ConfigureFile);
    	osfile_set_type(CONFIGDIR_WRITE "Startup", osfile_TYPE_OBEY);

        /*
         * Sort out memory configurations
         */
        os_read_mem_map_info(&pagesize, 0);

        rmasize = readCMOS(osbyte_CONFIGURE_RMA_SIZE) * pagesize;
        systemsize = readCMOS(osbyte_CONFIGURE_SYSTEM_SIZE) * pagesize;

        if (rmasize < MIN_RMASIZE)
            writeCMOS(osbyte_CONFIGURE_RMA_SIZE, MIN_RMASIZE / pagesize);

        if (systemsize < MIN_SYSTEMSIZE)
            writeCMOS(osbyte_CONFIGURE_SYSTEM_SIZE, MIN_SYSTEMSIZE / pagesize);
    }

    fclose(BootFile);
    osfile_set_type("<Boot$ToBeLoaded>.SetUpNet", osfile_TYPE_OBEY);
    osfile_read_stamped("<Boot$ToBeLoaded>.SetUpNet", 0, 0, &size, 0, 0);
    if (size == 0)
    {
      remove("<Boot$ToBeLoaded>.SetUpNet");
      if (!InternetEnabled && !AccessEnabled && !AUNEnabled)
      {
        /* No networking - so put a blank SetUpNet in */
        osfscontrol_copy("<InetSetup$Dir>.Blanks.SetUpNet",
                         "<Boot$ToBeLoaded>.SetUpNet",
                         0, 0, 0, 0, 0, 0);

        BootFile = fopen("<Boot$ToBeLoaded>.SetUpNet", "a");

        if (BootFile != NULL)
        {
          if (RMFind("ShareFS",     NULL, 0) == 1) fprintf(BootFile, "Unplug ShareFS\n");
          if (RMFind("Freeway",     NULL, 0) == 1) fprintf(BootFile, "Unplug Freeway\n");
          if (RMFind("Net",         NULL, 0) == 1) fprintf(BootFile, "Unplug Net\n");
          if (RMFind("BootNet",     NULL, 0) == 1) fprintf(BootFile, "Unplug BootNet\n");
          if (RMFind("Internet",    NULL, 0) == 1) fprintf(BootFile, "Unplug Internet\n");
          if (RMFind("AUNMsgs",     NULL, 0) == 1) fprintf(BootFile, "Unplug AUNMsgs\n");
          if (RMFind("MbufManager", NULL, 0) == 1) fprintf(BootFile, "Unplug MbufManager\n");
          if (RMFind("DHCP",        NULL, 0) == 1) fprintf(BootFile, "Unplug DHCP\n");

          fclose(BootFile);
        }
      }
    }

    e.errnum = 0;
    strcpy(e.errmess, msgs_lookup("ResetPrompt"));
    strcpy(buts, msgs_lookup("ResetButs"));

    if (WimpVersion >= 322)
        i=wimp_report_error_by_category(&e,
           wimp_ERROR_BOX_CATEGORY_QUESTION << wimp_ERROR_BOX_CATEGORY_SHIFT,
           msgs_lookup("_TaskName"),
           "!inetsetup",
           (osspriteop_area *) 1,
           buts);
    else
        i=wimp_report_error(&e,
             wimp_ERROR_BOX_OK_ICON | wimp_ERROR_BOX_CANCEL_ICON,
             msgs_lookup("_TaskName")) + 2;

    if (i==3)
    {
        /*
         * Nice shutdown - on versions that support it (TaskManager 1.36+)
         * bit 5 causes a reboot to occur after shutdown. If an older TM is in use,
         * the restart prompt will be displayed.
         */
        taskmanager_shutdown(taskmanager_SHUTDOWN_REBOOT | taskmanager_SHUTDOWN_SEND_MESSAGE);
    }
    else
        exit(0);
}

static void SaveInterface(int i, bool dhcp_private_fallback)
{
    bool DynamicNetmask;
    char buffer[200];
    char buffer2[32];
    char *msgtag;
    char *addrtype;

    if (interface_address[i][0] == '\0')
    {
#if 0
    	/* Can't do this - another protocol might need the driver! */
        Unplug(interface_module[i]);
#endif

        /* Exit function if driver has no address, with PPP we want to allow no address a special case is added */
        if (interface_is_pp[i] != 2)
          return;
        else
        {
          if (interface_has_section[i] == 0)
          return;
        }

    }

    RMInsert(interface_module[i], interface_version[i]);

    fprintf(ConfigureFile, "|\n"
                           "| Interface: %s\n"
                           "|\n"
                           "RMEnsure %s %s RMLoad System:Modules.Network.%s\n",
                           interface_name[i],
                           interface_module[i],
                           VersionToString(interface_version[i]),
                           interface_filename[i]);

    if (strcmp(interface_unit[i], "ec0") == 0)
    {
        if (interface_addrtype[i] == if_Manual || interface_addrtype[i] == if_FromHostname)
            fprintf(ConfigureFile, "Set Inet$EcoIPAddr %s\n"
                               	   "Set Inet$EcoIPMask %s\n",
                                   interface_address[i],
                                   interface_netmask[i]);
        else
            fprintf(ConfigureFile, "Set Inet$EcoIPAddr %s\n"
                               	   "Set Inet$EcoIPMask %s\n",
                                   interface_addrtype[i] == if_RevARP ? "revarp" : "bootp",
                                   "default");
    }

    // Yucko!
    DynamicNetmask = strcmp(interface_netmask[i], msgs_lookup("ICMPReq")) == 0;

    switch (interface_addrtype[i])
    {
      case if_FromHostname:
      case if_Manual:

        if (!interface_is_pp[i])
        {
            fprintf(ConfigureFile, "IfConfig -e %s %s netmask %s\n"
                                    "CheckError\n",
                                    interface_unit[i],
                                    interface_address[i],
                                    interface_netmask[i]);
        }
        else
        {
          /* PP interface, PPP doesn't use IfConfig to set it up so skip it */
          if (interface_is_pp[i] == 1)
          {
            fprintf(ConfigureFile, "IfConfig -e %s %s %s netmask %s\n"
                                    "CheckError\n",
                                    interface_unit[i],
                                    interface_address[i],
                                    interface_linkaddr[i],
                                    interface_netmask[i]);
          }
          else
          {
            if (strlen(interface_address[i]) > 0)
              fprintf(ConfigureFile, "Set Inet$%s$IPAddr %s\n",
                                     interface_name[i],
                                     interface_address[i]);
            else
              fprintf(ConfigureFile, "Set Inet$%s$IPAddr \"\"\n",
                                     interface_name[i]);

            if (strlen(interface_linkaddr[i]) > 0)
              fprintf(ConfigureFile, "Set Inet$%s$LinkIPAddr %s\n",
                                     interface_name[i],
                                     interface_linkaddr[i]);
            else
              fprintf(ConfigureFile, "Set Inet$%s$LinkIPAddr \"\"\n",
                                     interface_name[i]);

            if (strlen(interface_netmask[i]) > 0)
              fprintf(ConfigureFile, "Set Inet$%s$IPMask %s\n",
                                     interface_name[i],
                                     interface_netmask[i]);
            else
              fprintf(ConfigureFile, "Set Inet$%s$IPMask \"\"\n",
                                     interface_name[i]);
          }
        }
        break;

      case if_FromCMOS:
        fprintf(ConfigureFile, "Run Inet:utils.ReadCMOSIP\n"
                               "IfConfig -e %s <Inet$CMOSIPAddr> netmask %s\n",
                               interface_unit[i],
                               interface_netmask[i]);
        break;

      case if_DHCP:
        strcpy(buffer2, msgs_lookup("DHCP"));
        sprintf(buffer, msgs_lookup("Contacting"), buffer2, interface_name[i]);
        fprintf(ConfigureFile, "IF \"<Wimp$State>\" = \"commands\" THEN Echo %s\n"
                               "DHCPExecute -e -b -w %s%s\n"
                               "CheckError\n"
                               "If \"<Inet$Gateway>\" <> \"\" Then do /Inet:bin.route -e add default <Inet$Gateway>\n"
                               "CheckError\n"
                               "IF \"<Wimp$State>\" = \"commands\" THEN Echo <11><23><8><5><6><0><0><0><0><0><0><11>\n",
                               buffer,
                               dhcp_private_fallback ? "-p " : "",
                               interface_unit[i]);
        break;

      case if_RevARP:
      case if_BOOTP:
        switch (interface_addrtype[i])
        {
          case if_RevARP: msgtag = "RevARP"; addrtype = "revarp"; break;
          default:        msgtag = "BOOTP";  addrtype = "bootp";  break;
        }
        strcpy(buffer2, msgs_lookup(msgtag));
        sprintf(buffer, msgs_lookup("Contacting"), buffer2, interface_name[i]);
        fprintf(ConfigureFile, "IF \"<Wimp$State>\" = \"commands\" THEN Echo %s\n"
                               "IfRConfig -e %s %s%s\n"
                               "CheckError\n"
                               "IF \"<Wimp$State>\" = \"commands\" THEN "
                                        "Echo <11><23><8><5><6><0><0><0><0><0><0><11>\n",
                               buffer,
                               interface_unit[i],
                               addrtype,
                               DynamicNetmask ? " netmask" : "");
        if (!DynamicNetmask)
            fprintf(ConfigureFile, "If \"%s\" <> \"default\" Then IfConfig -e %s netmask %s\n"
                                   "CheckError\n",
                                   interface_netmask[i],
                                   interface_unit[i],
                                   interface_netmask[i]);
        break;
    }
}

void SaveResolve(void)
{
    FILE *f=fopen("InetDBase:resolve", "w");
    int i;

    if (f)
    {
        fprintf(f, "domain %s\n", LocalDomain);
        for (i = 0; i < 3; i++)
        {
            if (Resolver[i][0])
                fprintf(f, "nameserver %s\n", Resolver[i]);
        }
        fclose(f);
    }
}

void SaveResConf(void)
{
    FILE *f, *old;
    char buffer[256];
    char buf2[256];
    int ns=0;

    xosfile_delete("<Wimp$ScrapDir>.OldResConf", 0, 0, 0, 0, 0);
    xosfscontrol_rename("InetDBase:resconf", "<Wimp$ScrapDir>.OldResConf");

    f=fopen("InetDBase:resconf", "w");
    if (!f)
    {
        xosfscontrol_rename("<Wimp$ScrapDir>.OldResConf", "InetDBase:resconf");
        return;
    }

    old=fopen("<Wimp$ScrapDir>.OldResConf", "r");

    if (old)
    {
        while (fgets(buffer, sizeof buffer, old))
        {
            if (sscanf(buffer, "domain %s", buf2) == 1)
                fprintf(f, "domain     %s.\n", LocalDomain);
            else if (sscanf(buffer, "nameserver %s", buf2) == 1)
            {
                if (ns < 3 && Resolver[ns][0])
                    fprintf(f, "nameserver %s\n", Resolver[ns++]);
            }
            else
                fprintf(f, "%s", buffer);
        }
        fclose(old);
        xosfile_delete("<Wimp$ScrapDir>.OldResConf", 0, 0, 0, 0, 0);
    }
    else
    {
        fprintf(f, "domain     %s.\n", LocalDomain);
        fprintf(f, "cachesize  16k\n"
                   "cacheload  resboot rescache\n"
                   "cachesave  rescache\n"
                   "retry      3\n"
                   "timeout    3 12\n"
                   "lookup     file bind\n");
    }

    for (; ns < 3; ns++)
        if (Resolver[ns][0])
            fprintf(f, "nameserver %s\n", Resolver[ns]);

    fclose(f);

    f=fopen("InetDBase:resboot", "w");
    if (f)
    {
        struct hostent *hp=gethostbyname(HostName);

        fprintf(f, "$ORIGIN %s.\n", LocalDomain);
        fprintf(f, "%-40.40sIN A     %d.%d.%d.%d\n", HostName, hp->h_addr[0],
                                                               hp->h_addr[1],
                                                               hp->h_addr[2],
                                                               hp->h_addr[3]);
        sprintf(buffer, "%d.%d.%d.%d.in-addr.arpa.", hp->h_addr[3], hp->h_addr[2],
                                                     hp->h_addr[1], hp->h_addr[0]);
        fprintf(f, "%-40.40sIN PTR   %s\n", buffer, HostName);
        fclose(f);
    }
}
