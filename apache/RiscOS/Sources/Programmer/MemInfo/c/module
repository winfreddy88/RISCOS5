/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/*                  Copyright 1997 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "module.h"
#include "header.h"

#define STATUS_FILE "<Wimp$ScrapDir>.mem/html"
#define STATUS_URL  "file:/<Wimp$ScrapDir>/mem.html"
#define ENV_VAR	    "Alias$URLOpenCLI_MemInfo"
#define ENV_VAL	    "MemInfo_HTML %*0"

typedef enum {Text,HTML} style_t;

/*
 * module housekeeping globals
 */
void   *workspace_pointer = NULL;
ERROR_STRUCT(NO_FILE,"Could not open status file.");

_kernel_oserror *
url_open(char *url)
{
  _kernel_swi_regs reg;
  _kernel_oserror *err=NULL;
  char msg_block[256];
  int n;

  n = strlen(url);
  n = n>236?236:n;
  memset(msg_block, 0, 256);

  *(int *)msg_block = 256;
  *(int *)(msg_block + 16) = 0x4af80; /* Message_URL */
  strncpy(msg_block + 20, url, n);

  reg.r[0] = 0;
  reg.r[1] = (int)msg_block;
  reg.r[2] = 0;
  reg.r[3] = 0;
  reg.r[4] = 0;
  reg.r[5] = 0;

  ERR_RETURN(err,_kernel_swi(TaskModule_SendMessage, &reg, &reg));

  return(NULL);
}

static char *get_name_cr(const char *in)
{
    char *out;
    int i, len;

    for (i = 0; in[i] >= ' '; i++)
	/* do nothing */;
    len = i;

    out = malloc(len + 1);
    if (out)
    {
	for (i = 0; i < len; i++)
	    out[i] = in[i];
	out[i] = 0;
    }

    return out;
}

_kernel_oserror *
display_memory_info(style_t style)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  FILE *f=NULL;
  int area,size,max_size,lba;
  char desc[26];
  char *term;
  char utctime[8];
  char lcltime[256];
  int total_mem, da_total, app_total, misc_total;
  int da_page_contrib;
  int page_exact;

  *(int *)utctime = 3; 		/* reason code 3, read RTC */
  reg.r[0] = 14;
  reg.r[1] = (int)utctime;
  _kernel_swi(OS_Word, &reg, &reg);

  reg.r[0] = 1;			/* always in english */
  reg.r[1] = (int)utctime;
  reg.r[2] = (int)lcltime;
  reg.r[3] = 256;
  _kernel_swi(Territory_ConvertStandardDateAndTime, &reg, &reg);

  if (style == HTML) {
    if((f = fopen(STATUS_FILE, "w"))==NULL) {
      return (ERROR(NO_FILE));
    }

    fprintf(f,"<html><head>");
    fprintf(f,"<title>Memory distribution</title>");
    fprintf(f,"</head><body BGCOLOR=\"#ffffff\">\n");
    fprintf(f,"<center><p><h1>Memory distribution</h1></p>\n");

    fprintf(f,"<p><b>Time:</b>%s<p>\n",lcltime);

    fprintf(f,"<p><table border=1 width=\"70%%\">\n");
    fprintf(f,"<tr><th>Dynamic area<th>Size&nbsp;(K)<th>Max size<th>Address\n");
  } else {
    printf("  Dynamic area             Size (K) Max size Address\n");
    printf("  ------------             -------- -------- -------\n");
  }

  /* get total mem */
  ERR_GOTO(err, _kernel_swi(OS_ReadMemMapInfo,&reg,&reg));
  total_mem = reg.r[0] * reg.r[1];

  da_total = 0;
  da_page_contrib = 0;

  reg.r[0] = 3; 	/* enumerate dynamic areas */
  reg.r[1] = -1; 	/* start */
  ERR_GOTO(err,_kernel_swi(OS_DynamicArea,&reg,&reg));
  area = reg.r[1];
  while (area != -1) {
    reg.r[0] = 2;	/* info */
    reg.r[1] = area;
    ERR_GOTO(err,_kernel_swi(OS_DynamicArea,&reg,&reg));
    size = reg.r[2];
    lba  = reg.r[3];
    max_size = reg.r[5];

    /* Copy the DA name string into our buffer */
    (void) memcpy(desc, (char *)reg.r[8], 25);

    /* Ensure that the string is zero-terminated */
    desc[25] = '\0';
    term     = desc;
    while (*term > 31) term++;
    *term    = '\0';

    da_total += size;
    if ((int)lba >= 96*1024*1024)
	da_page_contrib += max_size;
    else if ((int)lba + max_size > 96*1024*1024)
	da_page_contrib += (int)lba + max_size - 96*1024*1024;

    if (style == HTML) {
      fprintf(f,"<tr><td>%s<td align=\"right\">%d<td align=\"right\">%d<td align=\"right\">&amp;%08X\n",
    	desc,size/1024, max_size/1024, lba);
    } else {
      printf("  %-25s %6d    %6d &%08X\n",desc,size/1024, max_size/1024, lba);
    }
    reg.r[0] = 3; 	/* enumerate dynamic areas */
    reg.r[1] = area;
    ERR_GOTO(err,_kernel_swi(OS_DynamicArea,&reg,&reg));
    area = reg.r[1];
  }

  /* */
    err = _swix(OS_Memory, _IN(0)|_OUTR(1,3), 16+(1<<8), &lba, &max_size, &size);
    if (err) lba = 0x01f00000, max_size = size = 32*1024;

    if (style == HTML) {
      fprintf(f,"<tr><td>Cursor/System/Sound<td align=\"right\">%d<td align=\"right\">%d<td align=\"right\">&amp;%08X\n",
        size/1024, max_size/1024, lba);
    } else {
      printf("  %-25s %6d    %6d &%08X\n","Cursor/System/Sound",size/1024, max_size/1024, lba);
    }
    misc_total = size/1024;

    err = _swix(OS_Memory, _IN(0)|_OUTR(1,3), 16+(9<<8), &lba, &max_size, &size);
    if (!err)
    {
      if (style == HTML) {
        fprintf(f,"<tr><td>HAL workspace<td align=\"right\">%d<td align=\"right\">%d<td align=\"right\">&amp;%08X\n",
          size/1024, max_size/1024, lba);
      } else {
        printf("  %-25s %6d    %6d &%08X\n","HAL workspace",size/1024, max_size/1024, lba);
      }
      misc_total += size/1024;
    }

    err = _swix(OS_Memory, _IN(0)|_OUTR(1,3), 16+(11<<8), &lba, &max_size, &size);
    if (!err)
    {
      if (style == HTML) {
        fprintf(f,"<tr><td>HAL DMA workspace<td align=\"right\">%d<td align=\"right\">%d<td align=\"right\">&amp;%08X\n",
          size/1024, max_size/1024, lba);
      } else {
        printf("  %-25s %6d    %6d &%08X\n","HAL DMA workspace",size/1024, max_size/1024, lba);
      }
      misc_total += size/1024;
    }

    if (style == HTML) {
      fprintf(f,"<tr><td>System workspace<td align=\"right\">32<td align=\"right\">32<td align=\"right\">&00000000\n");
    } else {
      printf("  %-25s %6d    %6d &%08X\n","System workspace",32,32,0);
    }
    misc_total += 32;

    err = _swix(OS_Memory, _IN(0)|_OUTR(1,3), 16+(10<<8), &lba, &max_size, &size);
    if (!err) {
      if (style == HTML) {
        fprintf(f,"<tr><td>Kernel buffers<td align=\"right\">%d<td align=\"right\">%d<td align=\"right\">&amp;%08X\n",
          size/1024, max_size/1024, lba);
      } else {
        printf("  %-25s %6d    %6d &%08X\n","Kernel buffers",size/1024, max_size/1024, lba);
      }
      misc_total += size/1024;
    }

    err = _swix(OS_Memory, _IN(0)|_OUTR(1,3), 16+(3<<8), &lba, &max_size, &size);
    if (err) lba = 0x01c00000, max_size = size = 8*1024;

    if (style == HTML) {
      fprintf(f,"<tr><td>SVC stack<td align=\"right\">%d<td align=\"right\">%d<td align=\"right\">&amp;%08X\n",
        size/1024, max_size/1024, lba);
    } else {
      printf("  %-25s %6d    %6d &%08X\n","SVC stack",size/1024, max_size/1024, lba);
    }
    misc_total += size/1024;

    err = _swix(OS_Memory, _IN(0)|_OUTR(1,3), 16+(2<<8), &lba, &max_size, &size);
    if (!err) {
      if (style == HTML) {
        fprintf(f,"<tr><td>IRQ stack<td align=\"right\">%d<td align=\"right\">%d<td align=\"right\">&amp;%08X\n",
          size/1024, max_size/1024, lba);
      } else {
        printf("  %-25s %6d    %6d &%08X\n","IRQ stack",size/1024, max_size/1024, lba);
      }
      misc_total += size/1024;
    }

    err = _swix(OS_Memory, _IN(0)|_OUTR(1,3), 16+(4<<8), &lba, &max_size, &size);
    if (!err) {
      if (style == HTML) {
        fprintf(f,"<tr><td>ABT stack<td align=\"right\">%d<td align=\"right\">%d<td align=\"right\">&amp;%08X\n",
          size/1024, max_size/1024, lba);
      } else {
        printf("  %-25s %6d    %6d &%08X\n","ABT stack",size/1024, max_size/1024, lba);
      }
      misc_total += size/1024;
    }

    err = _swix(OS_Memory, _IN(0)|_OUTR(1,3), 16+(5<<8), &lba, &max_size, &size);
    if (err) lba = 0x01e00000, max_size = size = 8*1024;

    if (style == HTML) {
      fprintf(f,"<tr><td>UND stack<td align=\"right\">%d<td align=\"right\">%d<td align=\"right\">&amp;%08X\n",
        size/1024, max_size/1024, lba);
    } else {
      printf("  %-25s %6d    %6d &%08X\n","UND stack",size/1024, max_size/1024, lba);
    }
    misc_total += size/1024;

    err = _swix(OS_Memory, _IN(0)|_OUTR(1,3), 16+(6<<8), &lba, &max_size, &size);
    if (err) {
      size = total_mem/512;
      size = (size + 4095) &~ 4095;
      lba = 0x01e02000;
    }
    if (style == HTML) {
      fprintf(f,"<tr><td>Soft CAM map<td align=\"right\">%d<td align=\"right\">%d<td align=\"right\">&amp;%08X\n", size/1024, size/1024, lba);
    } else {
      printf("  %-25s %6d    %6d &%08X\n","Soft CAM map",size/1024,size/1024,lba);
    }

    misc_total += size/1024;

    err = _swix(OS_Memory, _IN(0)|_OUTR(1,3), 16+(8<<8), &lba, &max_size, &size); /* L2PT */
    if (!err) {
      page_exact = 1;
      size += 16*1024; max_size += 16*1024; /* Assume we know L1PT */
    } else {
      page_exact = 0;
      lba = 0x02c00000;
      max_size = 4*1024*1024;
      _swix(OS_Byte, _INR(0,2) | _OUT(1), 129, 0, 255, &size);
      if (size < 0xA7)
        size = 96*1024;
      else if (size == 0xA7)
        size = 96*1024 - 28*1024 + (total_mem > 28*1024*1024 ? 28*1024 : total_mem/1024);
      else
        size = -1;

      if (size != -1) {
	size += da_page_contrib/1024;
	size = (size + 4095) &~ 4095;
      }
    }

    if (size == -1)
    {
	if (style == HTML) {
	    fprintf(f,"<tr><td>Page tables<td align=\"right\">Unknown<td align=\"right\">Unknown<td align=\"right\">0x02c00000\n");
	} else {
	    printf("  %-25s Unknown   Unknown &%08X\n","Page tables",lba);
	}
    }
    else
    {
	if (style == HTML) {
	    fprintf(f,"<tr><td>Page tables<td align=\"right\">%s%d<td align=\"right\">%d<td align=\"right\">&amp;%08X\n",
	      page_exact?"":"&gt;= ",size/1024, max_size/1024, lba);
	} else {
	    printf("  %-22s %s %6d    %6d &%08X\n","Page tables",page_exact?"  ":">=",size/1024,max_size/1024,lba);
	}

	misc_total += size/1024;
    }

#if 0
  /* application space */
  reg.r[0] = -1;
  ERR_GOTO(err,_kernel_swi(OS_ReadDynamicArea,&reg,&reg));
  lba = reg.r[0];
  size = reg.r[1];
  if (style == HTML) {
    fprintf(f,"<tr><td><br>Current application<td align=\"right\">%d<td align=\"right\">&amp;%08X\n",
     size/1024,lba);
    fprintf(f,"</table><p>\n");
  } else {
    printf("\n  %-25s %6d    &%08X\n","Current application",size/1024,lba);
  }
#endif

  /* tasks */
  app_total = 0;

  if (style == HTML) {
    fprintf(f,"<tr><th>Task<th>Size&nbsp;(K)<th>Handle\n");
  } else {
    printf("\n  Task                     Size (K)   Handle\n");
    printf(  "  ----                     --------   ------\n");
  }

  {
      int context = 0;
      int buffer[64];

      do
      {
	  int *end_ptr;
	  int *ptr;

	  err = _swix(TaskManager_EnumerateTasks, _INR(0,2) | _OUTR(0,1),
		      context, buffer, sizeof(buffer),
		      &context, &end_ptr);

	  if (err && err->errnum == 0x1E6)
	  {
	      if (style == HTML) {
		  fprintf(f,"<tr><td colspan=3>TaskManager not available\n");
	      } else {
		  printf("  TaskManager not available\n");
	      }

	      err = NULL;
	      break; /* taskmanager not fitted */
	  }

	  for (ptr = buffer; ptr < end_ptr; ptr += 4)
	  {
	      char *name = get_name_cr( (const char *)ptr[1] );

	      if (style == HTML) {
		  fprintf(f,"<tr><td>%s<td align=\"right\">%d<td align=\"right\">&amp;%08X\n",
			  name, ptr[2]/1024, ptr[0]);
	      } else {
		  printf("  %-25s %6d    &%08X\n", name, ptr[2]/1024, ptr[0]);
	      }

	      app_total += ptr[2];

	      free(name);
	  }
      }
      while (context >= 0);
  }

  if (style == HTML)
    fprintf(f,"</table></center><p><div align=right>\n");

  /* get total of the DA's */
  if (style == HTML) {
      fprintf(f,"<p>Total dynamic areas %dK<p>\n",da_total/1024);
  } else {
      printf("\n  Total dynamic areas %dK\n",da_total/1024);
  }

  if (style == HTML) {
      fprintf(f,"Total tasks %dK<p>\n",app_total/1024);
  } else {
      printf("  Total tasks %dK\n",app_total/1024);
  }

  if (style == HTML) {
    fprintf(f,"Total system workspace %dK<p>\n", misc_total);
  } else {
    printf("  Total system workspace %dK\n", misc_total);
  }

  if (style == HTML) {
    fprintf(f,"Missing memory %s%dK<p>\n",
      page_exact ? "" : "(probably in page tables) ", (total_mem - da_total - app_total)/1024 - misc_total);
  } else {
    printf("  Missing memory %s%dK\n",
      page_exact ? "" : "(probably in page tables) ", (total_mem - da_total - app_total)/1024 - misc_total);
  }

  /* get total box memory */
  if (style == HTML) {
    fprintf(f,"Total memory %dK<p>\n",total_mem/1024);
  } else {
    printf("  Total memory %dK\n",total_mem/1024);
  }

#if 1
  _swix(Wimp_SlotSize, _INR(0,1) | _OUT(2), -1, -1, &size);
  if (style == HTML) {
      fprintf(f,"Total free memory %dK<p>",size/1024);
  } else {
      printf("  Total free memory %dK\n",size/1024);
  }
#else
  /* get total free memory */
  reg.r[0] = 5;		/* shrinkable reason code */
  reg.r[1] = -1;	/* all */
  if (_kernel_swi(OS_DynamicArea,&reg,&reg)==NULL) {
    size = reg.r[2];
    if (style == HTML) {
      fprintf(f,"Total free memory %dK<p>",size/1024);
    } else {
      printf("  Total free memory %dK\n",size/1024);
    }
  } else {
    if (style == HTML) {
      fprintf(f,"Total free memory info not available on this platform<p>\n");
    } else {
      printf("  Total free memory info not available on this platform\n");
    }
  }
#endif

  if (style == HTML) {
    fprintf(f,"</div><center><a href=\"meminfo:\">Reload</a></center>\n");
    fprintf(f,"</body></html>\n");
    fclose(f);
    url_open(STATUS_URL);
  }

exit_gracefully:
  if (f) {
    fclose(f);
  }

  return (err);
}


/*
 * module finalise
 */
_kernel_oserror *
module_finalise(int fatal, int podule, void *pw)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;

  /* remove variable before exiting */
  reg.r[0] = (int)ENV_VAR;
  reg.r[1] = NULL;
  reg.r[2] = -1;
  reg.r[3] = 0;
  reg.r[4] = 0;
  ERR_RETURN(err,_kernel_swi(OS_SetVarVal,&reg,&reg));

  return (NULL);
}
/*
 * module initialise
 */
_kernel_oserror *
module_initialise(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *err = NULL;
  workspace_pointer = pw;

  /* set variable for browser to use */
  ERR_RETURN(err,_kernel_setenv(ENV_VAR,ENV_VAL));

  return (NULL);
}

_kernel_oserror *
module_cmd_handler(const char *arg_string, int argc, int cmd_no, void *pw)
{
  _kernel_oserror *err = NULL;

  switch (cmd_no) {
    case CMD_MemInfo_HTML :
      ERR_RETURN(err,display_memory_info(HTML));
      break;
    case CMD_MemInfo_Text :
      ERR_RETURN(err,display_memory_info(Text));
      break;
  }
  return (NULL);
}
