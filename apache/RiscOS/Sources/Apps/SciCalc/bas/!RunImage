REM >!SciCalc.!RunImage

REM Copyright 1996 Acorn Computers Ltd
REM
REM Licensed under the Apache License, Version 2.0 (the "License");
REM you may not use this file except in compliance with the License.
REM You may obtain a copy of the License at
REM
REM     http://www.apache.org/licenses/LICENSE-2.0
REM
REM Unless required by applicable law or agreed to in writing, software
REM distributed under the License is distributed on an "AS IS" BASIS,
REM WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
REM See the License for the specific language governing permissions and
REM limitations under the License.
REM
REM Authors: ASmith, CDean, JCoxhead, SForrest, CWraight

REM Conventions
REM ===========
REM
REM Global variables are capitalised (e.g. Block%)
REM Local variables are not (e.g. display$)
REM Constants are in all-caps (e.g. SB_REPLACE%)
REM
REM Most global variables are defined in either
REM PROCcalc_init or PROCwimp_init,
REM with a brief explanation of their function.

REM // Initialise application and load resources //
PROClocale_init
PROCcalc_init
PROCmess_load("<SciCalc$Dir>.Messages")
PROCwimp_init
PROCinfowin_init
END=END+&8000:REM Give back unused sprite memory
PROCcalc_clear
IF Option_Open%=TRUE THEN PROCcalwin_firstopen

REM // Poll loop //
SYS "Wimp_DragBox",,-1
WHILE NOT AppQuit%
 PROCwimp_poll
ENDWHILE
SYS "Wimp_CloseDown"

REM // Tidy up and close //
PROCmess_close
END

REM-----------------------------------------------------------------------------

REM // Iconbar //

REM-----------------------------------------------------------------------------

DEF PROCiconbar_click (button%)
REM Handle clicks on the Iconbar icon
CASE button% OF
 WHEN 4:IF FirstClick%=FALSE THEN
   PROCwimp_openwindow(CalWin%,0,0,0,0,0,0,-1,TRUE)
  ELSE
   PROCcalwin_firstopen
  ENDIF
 WHEN 2:SYS "Wimp_GetPointerInfo",,Block%
  SYS "Wimp_CreateMenu",,InfoMenu%,!Block%-64,(4*44)+96
  MenuOpen%=InfoMenu%
ENDCASE
ENDPROC

REM-----------------------------------------------------------------------------

REM // CalWin //

REM-----------------------------------------------------------------------------

DEF PROCcalwin_redraw
REM Redraw the Calculator window
LOCAL @%,more%,x%,y%,display$,xsize%
@%="+G10"+DecimalPoint$+"10"
IF ErrorFlag% THEN
 display$="Error"
ELSE
 IF NOT NumberComplete% THEN
  display$=Entry$
 ELSE
  display$=FNformat_tobase(Entry)
 ENDIF
ENDIF
SYS "Wimp_RedrawWindow",,Block% TO more%
x%=Block%!4:y%=Block%!16
WHILE more%
 SYS "Wimp_SetColour",0
 RECTANGLE FILL x%+12,y%-20,CalcSize%-26,-46
 SYS "Wimp_SetColour",7
 RECTANGLE x%+12,y%-20,CalcSize%-26,-46
 SYS "Font_SetFont",DisplayFont%
 SYS "Font_ScanString",0,display$,,2500*400,2500*400,,,LEN(display$) TO ,,,xsize%
 xsize%=xsize% DIV 400
 SYS "Wimp_SetFontColours",DisplayFont%,0,7,14
 SYS "Font_Paint",DisplayFont%,display$,16,x%+CalcSize%-20-xsize%,y%-52
 SYS "Wimp_GetRectangle",,Block% TO more%
ENDWHILE
ENDPROC

DEF PROCcalwin_refresh (icon%)
REM Update window layout when Base is changed
LOCAL i%,oldbase%,temp
LOCAL ERROR
ON ERROR LOCAL ErrorFlag%=TRUE:icon%=-1
IF ErrorFlag% THEN
 IF icon%=18 THEN PROCcalc_clear
ELSE
 CASE OldBase% OF
  WHEN BASE_DEC%:oldbase%=10
  WHEN BASE_BIN%:oldbase%=2
  WHEN BASE_OCT%:oldbase%=8
  WHEN BASE_HEX%:oldbase%=16
 ENDCASE
 CASE Base% OF
  WHEN BASE_DEC%
   SYS "Wimp_ForceRedraw",CalWin%,0,-400,800,0
   FOR i%=2 TO 11:PROCwimp_showicon(CalWin%,i%):NEXT
   FOR i%=53 TO 69:PROCwimp_hideicon(CalWin%,i%):NEXT
   FOR i%=27 TO 51:PROCwimp_showicon(CalWin%,i%): NEXT
   FOR i%=76 TO 78:PROCwimp_showicon(CalWin%,i%):NEXT
   FOR i%=76 TO 78:PROCwimp_selecticon(CalWin%,i%,FALSE):NEXT
   PROCwimp_selecticon(CalWin%,75+Trig%,TRUE)
   IF oldbase%<>10 THEN Entry$=FNformat_tobase(Entry)
  WHEN BASE_BIN%
   SYS "Wimp_ForceRedraw",CalWin%,0,-400,800,0
   FOR i%=2 TO 11:PROCwimp_hideicon(CalWin%,i%):NEXT
   FOR i%=27 TO 51:PROCwimp_hideicon(CalWin%,i%):NEXT
   FOR i%=64 TO 69:PROCwimp_hideicon(CalWin%,i%):NEXT
   FOR i%=76 TO 78:PROCwimp_hideicon(CalWin%,i%):NEXT
   IF oldbase%=10 THEN
    FOR i%=53 TO 63:PROCwimp_showicon(CalWin%,i%):NEXT
    PROCformat_round(FNlocale_val(Entry$))
   ELSE
    temp=FNformat_todec(oldbase%,Entry$)
    Entry$=FNformat_tobase(temp)
   ENDIF
  WHEN BASE_OCT%
   SYS "Wimp_ForceRedraw",CalWin%,0,-400,800,0
   FOR i%=2 TO 7:PROCwimp_showicon(CalWin%,i%):NEXT
   FOR i%=8 TO 11:PROCwimp_hideicon(CalWin%,i%):NEXT
   FOR i%=27 TO 51:PROCwimp_hideicon(CalWin%,i%):NEXT
   FOR i%=64 TO 69:PROCwimp_hideicon(CalWin%,i%):NEXT
   FOR i%=76 TO 78:PROCwimp_hideicon(CalWin%,i%):NEXT
   IF oldbase%=10 THEN
    FOR i%=53 TO 63:PROCwimp_showicon(CalWin%,i%):NEXT
    PROCformat_round(FNlocale_val(Entry$))
   ELSE
    temp=FNformat_todec(oldbase%,Entry$)
    Entry$=FNformat_tobase(temp)
   ENDIF
  WHEN BASE_HEX%
   SYS "Wimp_ForceRedraw",CalWin%,0,-400,800,0
   FOR i%=2 TO 11:PROCwimp_showicon(CalWin%,i%):NEXT
   FOR i%=27 TO 51:PROCwimp_hideicon(CalWin%,i%):NEXT
   FOR i%=64 TO 69:PROCwimp_showicon(CalWin%,i%):NEXT
   FOR i%=76 TO 78:PROCwimp_hideicon(CalWin%,i%):NEXT
   PROCwimp_hideicon(CalWin%,10)
   IF oldbase%=10 THEN
    FOR i%=53 TO 63:PROCwimp_showicon(CalWin%,i%):NEXT
    PROCformat_round(FNlocale_val(Entry$))
   ELSE
    temp=FNformat_todec(oldbase%,Entry$)
    Entry$=FNformat_tobase(temp)
   ENDIF
 ENDCASE
 NumberComplete%=TRUE
ENDIF
PROCcalc_summarise("","",SB_BASE%)
ENDPROC

DEF PROCcalwin_resize (xmin%,ymin%,xscroll%)
LOCAL xmax%,ymax%
REM Resizes window when Toggle icon is clicked
IF CalcSize%=CALC_SMALL% THEN
 PROCwimp_settick(ViewMenu%,0,FALSE)
 PROCwimp_settick(ViewMenu%,1,TRUE)
 CalcSize%=CALC_BIG%
ELSE
 PROCwimp_settick(ViewMenu%,0,TRUE)
 PROCwimp_settick(ViewMenu%,1,FALSE)
 OldBase%=Base%:Base%=BASE_DEC%
 FOR i%=71 TO 73:PROCwimp_selecticon(CalWin%,i%,FALSE):NEXT
 PROCwimp_selecticon(CalWin%,70,TRUE)
 xscroll%=CALC_BIG%-CALC_SMALL%
 CalcSize%=CALC_SMALL%
ENDIF
xmax%=xmin%+CalcSize%:ymax%=ymin%+436
Block%!0=CalWin%
Block%!4=xmin%:Block%!8=ymin%
Block%!12=xmax%:Block%!16=ymax%
Block%!20=xscroll%
Block%!28=-1
SYS "Wimp_OpenWindow",,Block%
PROCcalwin_refresh(18)
ENDPROC

DEF PROCcalwin_click (icon%,button%)
REM Handle clicks in Calculator window
PROCwimp_claimcaret(CalWin%,-1,TRUE)
IF button%=2 THEN
 SYS "Wimp_GetPointerInfo",,Block%
 SYS "Wimp_CreateMenu",,CalcMenu%,!Block%-64,Block%!4
 MenuOpen%=CalcMenu%:ENDPROC
ENDIF
big%=&1FFFFFFF
LOCAL ERROR
ON ERROR LOCAL ErrorFlag%=TRUE:icon%=-1
IF ErrorFlag% THEN
 IF icon%=18 PROCcalc_clear
ELSE
 CASE icon% OF
  WHEN 0,1,2,3,4,5,6,7,8,9:PROCcalc_digit(CHR$(icon%+ASC"0"))
  WHEN 64,65,66,67,68,69:PROCcalc_digit(CHR$(icon%+1))
  WHEN 10:PROCcalc_point
  WHEN 11:PROCcalc_binary("/")
  WHEN 12:PROCcalc_binary("×")
  WHEN 13:IF NOT OpStack% THEN PROCcalc_sign
  WHEN 14:PROCcalc_binary("-")
  WHEN 15:PROCcalc_binary("+")
  WHEN 16:PROCcalc_binary("=")
  WHEN 18:PROCcalc_clear
  WHEN 19:PROCcalc_function("CE")
  WHEN 20:PROCcalc_function("MC")
  WHEN 21:PROCcalc_function("Min")
  WHEN 22:PROCcalc_function("MR")
  WHEN 23:IF NOT OpStack% THEN PROCcalc_unary("NOT")
  WHEN 24:IF NOT OpStack% THEN PROCcalc_binary("AND")
  WHEN 25:IF NOT OpStack% THEN PROCcalc_binary("OR")
  WHEN 26:IF NOT OpStack% THEN PROCcalc_binary("EOR")
  WHEN 27:IF NOT OpStack% THEN PROCcalc_unary("%")
  WHEN 28:PROCcalc_function("RND")
  WHEN 29:IF NOT OpStack% THEN PROCcalc_trig("cos")
  WHEN 30:IF NOT OpStack% THEN PROCcalc_trig("tan")
  WHEN 31:IF NOT OpStack% THEN PROCcalc_trig("arcsin")
  WHEN 32:IF NOT OpStack% THEN PROCcalc_trig("arccos")
  WHEN 33:IF NOT OpStack% THEN PROCcalc_trig("arctan")
  WHEN 34:IF NOT OpStack% THEN PROCcalc_unary("fact")
  WHEN 35:IF NOT OpStack% THEN PROCcalc_unary("10x")
  WHEN 36:IF NOT OpStack% THEN PROCcalc_unary("log")
  WHEN 37:IF NOT OpStack% THEN PROCcalc_unary("ln")
  WHEN 38:IF NOT OpStack% THEN PROCcalc_unary("ex")
  WHEN 39:IF NOT OpStack% THEN PROCcalc_binary("nCr")
  WHEN 40:IF NOT OpStack% THEN PROCcalc_binary("nPr")
  WHEN 41:IF NOT OpStack% THEN PROCcalc_unary("sqrt")
  WHEN 42:IF NOT OpStack% THEN PROCcalc_binary("root")
  WHEN 43:IF NOT OpStack% THEN PROCcalc_unary("sqr")
  WHEN 44:IF NOT OpStack% THEN PROCcalc_binary("^")
  WHEN 45:PROCcalc_unary("reci")
  WHEN 46:PROCcalc_digit("E")
  WHEN 48:IF Bracket% PROCcalc_binary(")") ELSE PROCcalc_binary("(")
  WHEN 49:PROCcalc_function("PI")
  WHEN 50:PROCcalc_function("HYP")
  WHEN 51:IF NOT OpStack% THEN PROCcalc_trig("sin")
  WHEN 52:PROCwimp_claimcaret(CalWin%,-1,FALSE)
  WHEN 53:IF NOT OpStack% THEN PROCcalc_binary("DIV")
  WHEN 54:IF NOT OpStack% THEN PROCcalc_binary("NOR")
  WHEN 55:IF NOT OpStack% THEN PROCcalc_binary("MOD")
  WHEN 56:IF NOT OpStack% THEN PROCcalc_binary("NAND")
  WHEN 57:IF NOT OpStack% THEN PROCcalc_binary("EQV")
  WHEN 58:IF NOT OpStack% THEN PROCcalc_binary("<O")
  WHEN 59:IF NOT OpStack% THEN PROCcalc_binary("<<")
  WHEN 60:IF NOT OpStack% THEN PROCcalc_binary("<<")
  WHEN 61:IF NOT OpStack% THEN PROCcalc_binary(">>")
  WHEN 62:IF NOT OpStack% THEN PROCcalc_binary(">>>")
  WHEN 63:IF NOT OpStack% THEN PROCcalc_binary("O>")
  WHEN 70:OldBase%=Base%:Base%=BASE_DEC%:IFBase%<>OldBase% THENPROCcalwin_refresh(0)
  WHEN 71:OldBase%=Base%:Base%=BASE_BIN%:IFBase%<>OldBase% THENPROCcalwin_refresh(0)
  WHEN 72:OldBase%=Base%:Base%=BASE_OCT%:IFBase%<>OldBase% THENPROCcalwin_refresh(0)
  WHEN 73:OldBase%=Base%:Base%=BASE_HEX%:IFBase%<>OldBase% THENPROCcalwin_refresh(0)
  WHEN 76:Trig%=TRIG_RAD%
  WHEN 77:Trig%=TRIG_DEG%
  WHEN 78:Trig%=TRIG_GRAD%
 ENDCASE
ENDIF
IF ((icon%>=70) AND (icon%<=73)) OR ((icon%>=76) AND (icon%<=78)) THEN
 IF button%=1 THEN PROCwimp_selecticon(CalWin%,icon%,TRUE) : REM Adjust click on radio - pop back in
ENDIF
IF icon%<>50 THEN Hyp%=FALSE:PROCwimp_selecticon(CalWin%,50,FALSE)
SYS "Wimp_ForceRedraw",CalWin%,0,-124,800,-16
ENDPROC

DEF PROCcalwin_keypress (char%)
REM Handle keypresses in Calculator window
LOCAL shift%
SYS "OS_Byte",129,&03 EOR &FF,&FF TO ,shift%
IF shift%=&FF THEN shift%=TRUE ELSE shift%=FALSE
IF char%>=ASC("a") AND char%<=ASC("g") THEN char%-=32
LOCAL ERROR
ON ERROR LOCAL ErrorFlag%=TRUE:char%=-1
IF ErrorFlag% THEN
 IF char%=&007F THEN PROCcalc_clear
ELSE
 CASE char% OF
  WHEN &0003:IF shift% THEN PROCcalc_copy(Summary$) ELSE PROCcalc_copy(Entry$)
  WHEN &0013:
   IF CalcSize%=CALC_BIG% THEN
    PROCwimp_settick(ViewMenu%,0,TRUE):PROCwimp_settick(ViewMenu%,1,FALSE)
    Block%!0=CalWin%:SYS "Wimp_GetWindowState",,Block%
    PROCcalwin_resize(Block%!4,Block%!8,460)
   ELSE
    PROCwimp_settick(ViewMenu%,0,FALSE):PROCwimp_settick(ViewMenu%,1,TRUE)
    Block%!0=CalWin%:SYS "Wimp_GetWindowState",,Block%
    PROCcalwin_resize(Block%!4,Block%!8,0)
   ENDIF
  WHEN &0030,&0031:PROCcalc_digit(CHR$(char%))
  WHEN &0032,&0033,&0034,&0035,&0036,&0037:
   IF Base%<>BASE_BIN% THEN PROCcalc_digit(CHR$(char%))
  WHEN &0038,&0039:
   IF Base%=BASE_DEC% OR Base%=BASE_HEX% THEN PROCcalc_digit(CHR$(char%))
  WHEN &0041,&0042,&0043,&0044,&0046:
   IF Base%=BASE_HEX% THEN PROCcalc_digit(CHR$(char%))
  WHEN &0045:
   IF Base%=BASE_DEC% OR Base%=BASE_HEX% THEN PROCcalc_digit("E")
  WHEN &000D,&003D:PROCcalc_binary("=")
  WHEN &002F:
   IF Base%=BASE_DEC% THEN PROCcalc_binary("/") ELSE PROCcalc_binary("DIV")
  WHEN &0028,&0029:
   IF Bracket% THEN PROCcalc_binary(")") ELSE PROCcalc_binary("(")
  WHEN &002A:PROCcalc_binary("×")
  WHEN &002B:PROCcalc_binary("+")
  WHEN &002D:PROCcalc_binary("-")
  WHEN &005E:IF Base%=BASE_DEC% THEN PROCcalc_binary("^")
  WHEN &0025:IF Base%=BASE_DEC% THEN PROCcalc_unary("%")
  WHEN &0021:IF Base%=BASE_DEC% THEN PROCcalc_unary("fact")
  WHEN &0023:PROCcalc_sign
  WHEN &001B,&007F:PROCcalc_clear
  WHEN &0008:PROCcalc_function("CE")
  WHEN &0181:OSCLI "Filer_Run <SciCalc$Dir>.!Help"
  WHEN ASC(DecimalPoint$):
   IF Base%=BASE_DEC% THEN PROCcalc_point ELSE PROCcalc_binary("MOD")
  WHEN &01A2:Block%!0=CalWin%:SYS"Wimp_CloseWindow",,Block%
  OTHERWISE:
   SYS"Wimp_ProcessKey",char%
 ENDCASE
ENDIF
SYS "Wimp_ForceRedraw",CalWin%,0,-124,800,-16
ENDPROC

DEF PROCcalwin_menu (menu%,icon%)
REM Open a menu over Calculator window
LOCAL x%,y%
IF icon%>0 THEN
 Block%!0=CalWin%
 SYS "Wimp_GetWindowState",,Block%
 x%=Block%!4:y%=Block%!16
 Block%!0=CalWin%:Block%!4=icon%
 SYS "Wimp_GetIconState",,Block%
 x%=x%+(Block%!16):y%=y%+Block%!20
ELSE
 SYS "Wimp_GetPointerInfo",,Block%
 x%=Block%!0:y%=Block%!4
ENDIF
SYS "Wimp_CreateMenu",,menu%,x%,y%
MenuOpen%=menu%
ENDPROC

DEF PROCcalwin_firstopen
REM Open Calculator window with correct Start-up options set
LOCAL xmin%,ymin%,xmax%,ymax%,xscroll%
Block%!0=CalWin%:SYS "Wimp_GetWindowState",,Block%
IF Option_WinX%>-1 THEN xmin%=Option_WinX%:ymin%=Option_WinY%
IF Option_WinX%<0 THEN xmin%=Block%!4:ymin%=Block%!8
IF Option_Type%=CALC_BIG% THEN
 CalcSize%=CALC_BIG%:xscroll%=0
 PROCwimp_settick(ViewMenu%,0,FALSE)
 PROCwimp_settick(ViewMenu%,1,TRUE)
 Base%=Option_Base%:Trig%=Option_Trig%
 PROCwimp_selecticon(CalWin%,69+Base%,TRUE)
 PROCwimp_selecticon(CalWin%,75+Trig%,TRUE)
ELSE
 CalcSize%=CALC_SMALL%:xscroll%=CALC_BIG%-CALC_SMALL%
 PROCwimp_settick(ViewMenu%,0,TRUE)
 PROCwimp_settick(ViewMenu%,1,FALSE)
ENDIF
FOR i%=70 TO 73:PROCwimp_selecticon(CalWin%,i%,FALSE):NEXT
PROCwimp_selecticon(CalWin%,Option_Base%+69,TRUE)
FOR i%=76 TO 78:PROCwimp_selecticon(CalWin%,i%,FALSE):NEXT
PROCwimp_selecticon(CalWin%,Option_Base%+75,TRUE)
xmax%=xmin%+CalcSize%:ymax%=ymin%+436
Block%!0=CalWin%
Block%!4=xmin%:Block%!8=ymin%
Block%!12=xmax%:Block%!16=ymax%
Block%!20=xscroll%
Block%!28=-1
SYS "Wimp_OpenWindow",,Block%
FirstClick%=FALSE
PROCwimp_claimcaret(CalWin%,-1,TRUE)
PROCcalwin_refresh(18)
ENDPROC

DEF PROCcalwin_disable (type%)
REM Toggle calculator buttons on/off when error occurs
CASE type% OF
 WHEN TRUE:
  FOR i%=0 TO 73:PROCwimp_shadeicon(CalWin%,i%,TRUE):NEXT
  FOR i%=76 TO 78:PROCwimp_shadeicon(CalWin%,i%,TRUE):NEXT
  PROCwimp_shadeicon(CalWin%,18,FALSE)
 WHEN FALSE:
  FOR i%=0 TO 73:PROCwimp_shadeicon(CalWin%,i%,FALSE):NEXT
  FOR i%=76 TO 78:PROCwimp_shadeicon(CalWin%,i%,FALSE):NEXT
ENDCASE
ENDPROC

DEF PROCcalwin_pos
REM Store the window position
LOCAL obj%,file%,x%,y%
Block%!0=CalWin%
SYS "Wimp_GetWindowState",,Block%
x%=Block%!4
y%=Block%!8
SYS "XOS_File",17,"Choices:SciCalc" TO obj%
IF obj%=0 THEN SYS "XOS_File",8,"<Choices$Write>.SciCalc"
file%=OPENOUT "<Choices$Write>.SciCalc.WinPos"
IF file%<>0 THEN
 BPUT#file%,"# Window Positon choices for SciCalc"
 BPUT#file%,""
 BPUT#file%,"WinX:"+STR$x%
 BPUT#file%,"WinY:"+STR$y%
CLOSE#file%
ENDPROC

REM-----------------------------------------------------------------------------

REM // InfoWin //

REM-----------------------------------------------------------------------------

DEF PROCinfowin_init
REM Initialise Info window
PROCwimp_seticontext(InfoWin%,4,FNmess_get("_Version"))
ENDPROC

REM-----------------------------------------------------------------------------

REM // ChoiceWin //

REM-----------------------------------------------------------------------------

DEF PROCchoicewin_init
REM Initialise Choices window
IF Option_Type%=CALC_SMALL% THEN
 PROCwimp_selecticon(ChoiceWin%,2,TRUE)
 PROCwimp_selecticon(ChoiceWin%,3,FALSE)
 FOR i%=4 TO 9:PROCwimp_shadeicon(ChoiceWin%,i%,TRUE):NEXT
 PROCwimp_seticontext(ChoiceWin%,5,FNmess_get("Dec"))
 PROCwimp_seticontext(ChoiceWin%,8,FNmess_get("Deg"))
ELSE
 PROCwimp_selecticon(ChoiceWin%,2,FALSE)
 PROCwimp_selecticon(ChoiceWin%,3,TRUE)
 FOR i%=4 TO 9:PROCwimp_shadeicon(ChoiceWin%,i%,FALSE):NEXT
 CASE Option_Base% OF
  WHEN BASE_DEC%:PROCwimp_seticontext(ChoiceWin%,5,FNmess_get("Dec"))
  WHEN BASE_BIN%:PROCwimp_seticontext(ChoiceWin%,5,FNmess_get("Bin"))
  WHEN BASE_OCT%:PROCwimp_seticontext(ChoiceWin%,5,FNmess_get("Oct"))
  WHEN BASE_HEX%:PROCwimp_seticontext(ChoiceWin%,5,FNmess_get("Hex"))
 ENDCASE
 FOR i%=0 TO 3:PROCwimp_settick(BaseOptMenu%,i%,FALSE):NEXT
 PROCwimp_settick(BaseOptMenu%,Option_Base%-1,TRUE)
 CASE Option_Trig% OF
  WHEN TRIG_RAD%:PROCwimp_seticontext(ChoiceWin%,8,FNmess_get("Rad"))
  WHEN TRIG_DEG%:PROCwimp_seticontext(ChoiceWin%,8,FNmess_get("Deg"))
  WHEN TRIG_GRAD%:PROCwimp_seticontext(ChoiceWin%,8,FNmess_get("Grad"))
 ENDCASE
 FOR i%=0 TO 2:PROCwimp_settick(TrigOptMenu%,i%,FALSE):NEXT
 PROCwimp_settick(TrigOptMenu%,Option_Trig%-1,TRUE)
ENDIF
IF Option_Theme%=TRUE THEN
 PROCwimp_selecticon(ChoiceWin%,14,TRUE)
 PROCwimp_selecticon(ChoiceWin%,15,FALSE)
ELSE
 PROCwimp_selecticon(ChoiceWin%,14,FALSE)
 PROCwimp_selecticon(ChoiceWin%,15,TRUE)
ENDIF
PROCwimp_selecticon(ChoiceWin%,18,Option_Open%)
SYS "Wimp_GetPointerInfo",,Block%
PROCwimp_openwindow(ChoiceWin%,Block%!0-400,150,Block%!0+178,746+150,0,0,-1,TRUE)
ENDPROC

DEF PROCchoicewin_keypress (char%)
REM Handle keypresses in Choices window
CASE char% OF
 WHEN &001B,&01A2:
  REM Escape and CTRL-F2 is cancel
  PROCchoicewin_click(11,4)
 WHEN &000D:
  REM Return is save and close
  PROCchoicewin_click(10,4)
 OTHERWISE:
  SYS"Wimp_ProcessKey",char%
ENDCASE
ENDPROC

DEF PROCchoicewin_click (icon%,buttons%)
REM Handle clicks in Choices window
LOCAL file%,type$,obj%,theme$,base$,base%,trig$,trig%,open$
CASE icon% OF
 WHEN -1:
  REM Work area
  PROCwimp_claimcaret(ChoiceWin%,-1,FALSE)
 WHEN 2:
  REM Start-up settings 'Standard'
  IF FNwimp_getselect (ChoiceWin%,icon%) THEN
   FOR i%=4 TO 9:PROCwimp_shadeicon(ChoiceWin%,i%,TRUE):NEXT
  ENDIF
 WHEN 3:
  REM Start-up settings 'Scientific'
  IF FNwimp_getselect(ChoiceWin%,icon%) THEN
   FOR i%=4 TO 9:PROCwimp_shadeicon(ChoiceWin%,i%,FALSE):NEXT
  ENDIF
 WHEN 6:PROCchoicewin_menu(BaseOptMenu%,6)
 WHEN 9:PROCchoicewin_menu(TrigOptMenu%,9)
 WHEN 14:
  REM Appearance 'Match' handled by the Wimp
 WHEN 15:
  REM Appearance 'Default' handled by Wimp
 WHEN 18:
  REM Open at start-up handled by Wimp
 WHEN 11:
  REM Action 'Cancel'
  IF (buttons% AND4)=4 THEN Block%!0=ChoiceWin%:SYS "Wimp_CloseWindow",,Block%
 WHEN 10:
  REM Action 'Save'
  IF (buttons% AND5)<>0 THEN
   REM Adjust or select pressed
   IF (buttons% AND4)=4 THEN Block%!0=ChoiceWin%:SYS "Wimp_CloseWindow",,Block%
   IF FNwimp_getselect(ChoiceWin%,14) THEN theme$="Yes"
   IF FNwimp_getselect(ChoiceWin%,15) THEN theme$="No"
   IF FNwimp_getselect(ChoiceWin%,2) THEN type$="Standard"
   IF FNwimp_getselect(ChoiceWin%,3) THEN type$="Scientific"
   IF FNwimp_getselect(ChoiceWin%,18) THEN open$="Yes" ELSE open$="No"
   FOR i%=0 TO 3
    IF FNwimp_gettick(BaseOptMenu%,i%)=TRUE THEN base%=i%
   NEXT
   CASE base% OF
    WHEN 0:base$="Dec"
    WHEN 1:base$="Bin"
    WHEN 2:base$="Oct"
    WHEN 4:base$="Hex"
   ENDCASE
   FOR i%=0 TO 2
    IF FNwimp_gettick(TrigOptMenu%,i%)=TRUE THEN trig%=i%
   NEXT
   CASE trig% OF
    WHEN 0:trig$="Rad"
    WHEN 1:trig$="Deg"
    WHEN 2:trig$="Grad"
   ENDCASE
   SYS "XOS_File",17,"Choices:SciCalc" TO obj%
   IF obj%=0 THEN SYS "XOS_File",8,"<Choices$Write>.SciCalc"
   file%=OPENOUT "<Choices$Write>.SciCalc.Choices"
   IF file%<>0 THEN
    BPUT#file%,"# Choices file for SciCalc"
    BPUT#file%,""
    BPUT#file%,"Type:"+type$
    BPUT#file%,"Base:"+base$
    BPUT#file%,"Trig:"+trig$
    BPUT#file%,"Theme:"+theme$
    BPUT#file%,"Open:"+open$
    CLOSE#file%
   ENDIF
   IF FNwimp_getselect(ChoiceWin%,2) THEN
    Option_Type%=CALC_SMALL%
   ELSE
    Option_Type%=CALC_BIG%
   ENDIF
   Option_Base%=base%+1
   Option_Trig%=trig%+1
   Option_Theme%=FNwimp_getselect(ChoiceWin%,14)
   Option_Open%=FNwimp_getselect(ChoiceWin%,18)
  ENDIF
ENDCASE
ENDPROC

DEF PROCchoicewin_menu (menu%,icon%)
REM Open a menu over Choices window
LOCAL x%,y%
Block%!0=ChoiceWin%
SYS "Wimp_GetWindowState",,Block%
x%=Block%!4:y%=Block%!16
Block%!0=ChoiceWin%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
x%=x%+(Block%!16):y%=y%+Block%!20
SYS "Wimp_CreateMenu",,menu%,x%,y%
MenuOpen%=menu%
ENDPROC

REM-----------------------------------------------------------------------------

REM // Calculator //

REM-----------------------------------------------------------------------------

DEF PROCcalc_init
REM Set global calculator variables and check startup options
LOCAL obj%,file%,command$,value$,flags%
BASE_DEC%=1                      :REM Base Constants
BASE_BIN%=2                      :REM Base Constants
BASE_OCT%=3                      :REM Base Constants
BASE_HEX%=4                      :REM Base Constants
TRIG_RAD%=1                      :REM Trig Constants
TRIG_DEG%=2                      :REM Trig Constants
TRIG_GRAD%=3                     :REM Trig Constants
SB_APPEND%=0                     :REM Constant for Summary Bar
SB_REPLACE%=1                    :REM Constant for Summary Bar
SB_CLEAR%=2                      :REM Constant for Summary Bar
SB_DIGIT%=3                      :REM Constant for Summary Bar
SB_CE%=4                         :REM Constant for Summary Bar
SB_ERROR%=5                      :REM Constant for Summary Bar
SB_BASE%=6                       :REM Constant for Summary Bar
CalcSize%=0                      :REM CalWin size variables
CALC_SMALL%=338:CALC_BIG%=796    :REM CalWin size variables
DIM ConvBuf% 33                  :REM Buffer used for number format conversion
ErrorFlag%=FALSE                 :REM Calculator error flag
Base%=BASE_DEC%                  :REM Number Base
OldBase%=BASE_DEC%               :REM Old Number Base (used when converting)
Trig%=TRIG_DEG%                  :REM Trig type
@%="+G18"+DecimalPoint$+"18"     :REM Display format
Entry=0                          :REM Calculator display value
Entry$=""                        :REM Calculator display string
Summary$=""                      :REM Summary string
NumberComplete%=FALSE            :REM Completed number flag
SummaryComplete%=FALSE           :REM Complete summary string flag
SummaryEntry$=""                 :REM Last atomic summary entry
SummaryBracket%=FALSE            :REM Closing Bracket entered flag
Memory=0                         :REM Value stored in calculator memory
Hyp%=FALSE                       :REM Hyperbolic button is pressed
Bracket%=FALSE                   :REM Brackets are open/closed
LoStack%=0:HiStack%=-1           :REM
OpStack%=FALSE                   :REM
DIM Operator$(20)                :REM
DIM Number(20)                   :REM
REM Constants for mathematical functions
STP=2.50662827465                :REM Constant for factorial calculation
DIM rot% 20
FOR i%=0 TO 2 STEP 2
P%=rot%
[       OPT i%
.rol
        \rol
        RSB     R1, R1, #32
.ror
        \ror
        AND     R1, R1, #31
        MOV     R0, R0, ROR R1
        MOV     PC, R14
]
NEXT i%
DIM cof(6)
cof(1)=76.18009173
cof(2)=-86.50532033
cof(3)=24.01409822
cof(4)=-1.231739516
cof(5)=0.120858003E-2
cof(6)=-0.536382E-5
REM Default start-up Choices
Option_Type%=CALC_SMALL%         :REM Calculator mode to open in
Option_Base%=BASE_DEC%           :REM Calculator base to open with
Option_Trig%=TRIG_DEG%           :REM Calculator trig to open with
Option_WinX%=-1                  :REM Calculator start-up position
Option_WinY%=-1                  :REM Calculator start-up position
Option_Theme%=TRUE               :REM Calculator desktop theme setting
Option_Open%=FALSE               :REM Calculator auto-open setting
REM Read user choices from script in Choices: (if present)
SYS "XOS_Find",%01001111,"Choices:SciCalc.Choices" TO file%;flags%
IF ((flags% AND 1)=0) AND (file%<>0) THEN
 WHILE NOT EOF#file%
  command$=GET$#file%
  IF INSTR(command$,":") THEN
   value$=RIGHT$(command$,LEN(command$)-INSTR(command$,":"))
   command$=LEFT$(command$,INSTR(command$,":")-1)
   CASE command$ OF
    WHEN "Type":
     IF value$="Standard" THEN Option_Type%=CALC_SMALL%
     IF value$="Scientific" THEN Option_Type%=CALC_BIG%
    WHEN "Base":
     IF value$="Dec" THEN Option_Base%=BASE_DEC%
     IF value$="Bin" THEN Option_Base%=BASE_BIN%
     IF value$="Oct" THEN Option_Base%=BASE_OCT%
     IF value$="Hex" THEN Option_Base%=BASE_HEX%
    WHEN "Trig":
     IF value$="Rad" THEN Option_Trig%=TRIG_RAD%
     IF value$="Deg" THEN Option_Trig%=TRIG_DEG%
     IF value$="Grad" THEN Option_Trig%=TRIG_GRAD%
    WHEN "Theme":
     IF value$="Yes" THEN Option_Theme%=TRUE
     IF value$="No" THEN Option_Theme%=FALSE
    WHEN "Open":
     IF value$="Yes" THEN Option_Open%=TRUE
     IF value$="No" THEN Option_Open%=FALSE
   ENDCASE
  ENDIF
 ENDWHILE
 CLOSE#file%
ENDIF
REM Read Window position settings (if present)
SYS "XOS_Find",%01001111,"Choices:SciCalc.WinPos" TO file%;flags%
IF ((flags% AND 1)=0) AND (file%<>0) THEN
 WHILE NOT EOF#file%
  command$=GET$#file%
  IF INSTR(command$,":") THEN
   value$=RIGHT$(command$,LEN(command$)-INSTR(command$,":"))
   command$=LEFT$(command$,INSTR(command$,":")-1)
   CASE command$ OF
    WHEN "WinX":
     IF VAL(value$)>-1 THEN Option_WinX%=VAL(value$)
    WHEN "WinY":
     IF VAL(value$)>-1 THEN Option_WinY%=VAL(value$)
   ENDCASE
  ENDIF
 ENDWHILE
 CLOSE#file%
ENDIF
ENDPROC

DEF PROCcalc_clear
REM Clear calculator display ('C' button)
ErrorFlag%=FALSE
Entry$="0":Entry=0
PROCcalc_summarise("","",SB_CLEAR%)
PROCcalwin_disable(FALSE)
Bracket%=FALSE:PROCwimp_selecticon(CalWin%,48,FALSE)
Hyp%=FALSE:PROCwimp_selecticon(CalWin%,50,FALSE)
NumberComplete%=FALSE:SummaryComplete%=FALSE
LoStack%=0:HiStack%=-1:OpStack%=FALSE
ENDPROC

DEF PROCcalc_error
REM Updates Summary Bar with error information
CASE ERR OF
 WHEN ER_INVALIDOP%:errtext$=FNmess_get("E4"):REM Invalid op
 WHEN ER_NUMBERTOOBIG%:errtext$=FNmess_get("E1"):REM Too big
 WHEN ER_DIVBYZERO%:errtext$=FNmess_get("E5"):REM Divide by zero
 WHEN ER_NUMBERTOOSMALL%:errtext$=FNmess_get("E2"):REM Too small
 WHEN ER_ACCURACYLOST%:errtext$=FNmess_get("E6"):REM Accuracy lost
 OTHERWISE:errtext$=REPORT$
ENDCASE
PROCcalc_summarise(errtext$,"",SB_ERROR%)
PROCcalwin_disable(TRUE)
ENDPROC

DEF PROCcalc_digit (key$)
REM Add a digit to the display
LOCAL exponent%,width%,type%,prefix$
type%=SB_DIGIT%
IF NumberComplete%=TRUE THEN
 Entry$="0"
 IF OpStack%=FALSE AND Bracket%=FALSE THEN type%=SB_REPLACE%
 IF OpStack%=TRUE THEN SummaryEntry$=""
 IF RIGHT$(Summary$,1)="(" AND Bracket%=TRUE THEN SummaryEntry$=""
ENDIF
IF SummaryComplete%=TRUE THEN Summary$="":SummaryEntry$=""
IF Base%=BASE_DEC% THEN
 exponent%=INSTR(Entry$,"E")
 IF exponent%<>0 THEN
  IF key$="E" THEN ENDPROC
  width%=2+exponent%+SGN(INSTR(MID$(Entry$,exponent%),"-"))
 ELSE
  IF key$="E" THEN
   width%=LEN(Entry$)+1
  ELSE
   width%=10+SGN(INSTR(Entry$,"-"))+SGN(INSTR(Entry$,DecimalPoint$))
  ENDIF
 ENDIF
ELSE
 CASE Base% OF
  WHEN BASE_BIN%:width%=32
  WHEN BASE_OCT%:IF VAL(LEFT$(Entry$,1))<4 THEN width%=11 ELSE width%=10
  WHEN BASE_HEX%:width%=8
 ENDCASE
ENDIF
IF LEN(Entry$)<width% THEN
 IF Base%=BASE_DEC% AND Entry$="0" AND key$="E" THEN key$="1E"
 IF Entry$="0" OR Entry$="-0" THEN Entry$=LEFT$(Entry$,LEN(Entry$)-1)
 Entry$+=key$
 Entry=FNformat_getvalue(Entry$)
 NumberComplete%=FALSE:SummaryComplete%=FALSE:OpStack%=FALSE
 IF SummaryEntry$="" THEN key$=FNformat_prefix(key$)
 PROCcalc_summarise("",key$,type%)
ENDIF
ENDPROC

DEF PROCcalc_point
REM Add decimal point to current value
LOCAL zero$
zero$=""
IF Base%<>BASE_DEC% THEN ENDPROC
IF NumberComplete%=TRUE THEN Entry$="0"
IF SummaryComplete%=TRUE THEN Summary$="0":SummaryEntry$="0"
IF NumberComplete%=TRUE AND SummaryComplete%=FALSE THEN
 SummaryEntry$="0"
 zero$="0"
ENDIF
IF INSTR(Entry$,"E") THEN ENDPROC
IF INSTR(Entry$,DecimalPoint$)=0 AND LEN(Entry$)<10 THEN
 Entry$=Entry$+DecimalPoint$
ENDIF
Entry=FNlocale_val(Entry$)
NumberComplete%=FALSE:SummaryComplete%=FALSE:OpStack%=FALSE
PROCcalc_summarise("",zero$+DecimalPoint$,SB_DIGIT%)
ENDPROC

DEF PROCcalc_sign
REM Change the sign of the current value
LOCAL insert%,l$,r$
IF Entry$="0" THEN Entry$=FNformat_tobase(Entry)
IF Base%=BASE_DEC% THEN
 IF (INSTR(Entry$,"E")=0) OR NumberComplete%=TRUE THEN
  IF INSTR(Entry$,"-")=0 THEN
   Entry$="-"+Entry$
  ELSE
   Entry$=RIGHT$(Entry$,LEN(Entry$)-1)
  ENDIF
 ELSE
  insert%=INSTR(Entry$,"E")
  l$=LEFT$(Entry$,insert%)
  r$=MID$(Entry$,insert%+1)
  IF LEFT$(r$,1)="-" THEN
   r$=RIGHT$(r$,LEN(r$)-1)
  ELSE
   r$="-"+r$
  ENDIF
  Entry$=l$+r$
 ENDIF
ELSE
 Entry$=FNformat_tobase(-FNformat_getvalue(Entry$))
ENDIF
IF SummaryComplete%=TRUE THEN Summary$=""
PROCcalc_summarise("",FNformat_prefix(Entry$),SB_REPLACE%)
Entry=FNformat_getvalue(Entry$)
IF OpStack% THEN Number(HiStack%)=Entry
ENDPROC

DEF PROCcalc_unary (key$)
REM Process functions with one argument
IF SummaryComplete%=TRUE THEN
 Summary$=""
 SummaryComplete%=FALSE
ENDIF
CASE key$ OF
 WHEN "sqrt":
  PROCcalc_summarise("sqrt(",Entry$,SB_REPLACE%)
  result=SQR(Entry)
 WHEN "log":
  PROCcalc_summarise("log(",Entry$,SB_REPLACE%)
  result=LOG(Entry)
 WHEN "ln":
  result=LN(Entry)
  PROCcalc_summarise("ln(",Entry$,SB_REPLACE%)
 WHEN "10x":
  result=10^Entry
  PROCcalc_summarise("10^",Entry$,SB_REPLACE%)
 WHEN "ex":
  result=EXP(Entry)
  PROCcalc_summarise("exp(",Entry$,SB_REPLACE%)
 WHEN "reci":
  result=1/Entry
  PROCcalc_summarise("1/",Entry$,SB_REPLACE%)
 WHEN "NOT":
  PROCcalc_summarise("NOT(",FNformat_prefix(Entry$),SB_REPLACE%)
  result=NOT(Entry)
 WHEN "%":
  IF Summary$="" THEN Summary$=Entry$:SummaryEntry$=Entry$
  PROCcalc_summarise("","%",SB_DIGIT%)
  result=Entry/100
  IF HiStack%>=LoStack% THEN result=result*Number(HiStack%)
 WHEN "sqr":
  IF Summary$="" THEN Summary$=Entry$:SummaryEntry$=Entry$
  PROCcalc_summarise("","^2",SB_DIGIT%)
  result=Entry^2
 WHEN "fact":
  IF Entry<0 THEN ERROR 2,FNmess_get("E3"):REM Invalid factorial
  IF Summary$="" THEN Summary$=Entry$:SummaryEntry$=Entry$
  PROCcalc_summarise("","!",SB_DIGIT%)
  IF Entry=INT(Entry) THEN
   factorial=1
   FOR i%=1 TO INT(Entry):factorial=factorial*i%:NEXT
   result=factorial
  ELSE
   result=EXP(FNcalc_factorial(Entry))
  ENDIF
ENDCASE
Entry=result:Entry$=FNformat_tobase(Entry)
Hyp%=FALSE:PROCwimp_selecticon(CalWin%,50,FALSE)
NumberComplete%=TRUE
ENDPROC

DEF PROCcalc_trig (key$)
REM Process trigonometric functions
LOCAL hypsuf$
IF OpStack% THEN ENDPROC
IF SummaryComplete%=TRUE THEN
 Summary$=""
 SummaryComplete%=FALSE
ENDIF
IF Hyp%=TRUE THEN hypsuf$="h" ELSE hypsuf$=""
PROCcalc_summarise(key$+hypsuf$+"(",Entry$,SB_REPLACE%)
CASE key$ OF
 WHEN "sin":
  IF Hyp%=TRUE THEN
   IF ABS(Entry)>1E-3 THEN
    result=EXP(Entry)/2-EXP(-Entry)/2
   ELSE
    result=Entry+Entry^3/6
   ENDIF
  ELSE
   CASE Trig% OF
    WHEN 1:result=SIN(Entry)
    WHEN 2:result=SIN RAD(Entry)
    WHEN 3:result=SIN((PI/200)*Entry)
   ENDCASE
  ENDIF
 WHEN "cos":
  IF Hyp%=TRUE THEN
   result=EXP(Entry)/2+EXP(-Entry)/2
  ELSE
   CASE Trig% OF
    WHEN 1:result=COS(Entry)
    WHEN 2:result=COS RAD(Entry)
    WHEN 3:result=COS((PI/200)*Entry)
   ENDCASE
  ENDIF
 WHEN "tan":
  IF Hyp%=TRUE THEN
   IF ABS(Entry)>37 THEN
    result=SGN(Entry)
   ELSE
    IF ABS(Entry)>1E-3 THEN
     result=EXP(Entry)/2-EXP(-Entry)/2
    ELSE
     result=Entry+Entry^3/6
    ENDIF
    result=result/(EXP(Entry)/2+EXP(-Entry)/2)
   ENDIF
  ELSE
   CASE Trig% OF
    WHEN 1:result=TAN(Entry)
    WHEN 2:result=TAN RAD(Entry)
    WHEN 3:result=TAN((PI/200)*Entry)
   ENDCASE
  ENDIF
 WHEN "arcsin":
  IF Hyp%=TRUE THEN
   IF ABS(Entry)>1E18 THEN result=SGN(Entry)*LN(2*ABS(Entry))
   IF ABS(Entry)<1E-6 THEN result=Entry ELSE result=LN(Entry+SQR(Entry*Entry+1))
  ELSE
   CASE Trig% OF
    WHEN 1:result=ASN(Entry)
    WHEN 2:result=DEG ASN(Entry)
    WHEN 3:result=(200/PI)*ASN(Entry)
   ENDCASE
  ENDIF
 WHEN "arccos":
  IF Hyp%=TRUE THEN
   IF Entry>1E18 THEN
    result=LN(2*Entry)
   ELSE
    result=LN(Entry+SQR(Entry*Entry-1))
   ENDIF
  ELSE
   CASE Trig% OF
    WHEN 1:result=ACS(Entry)
    WHEN 2:result=DEG ACS(Entry)
    WHEN 3:result=(200/PI)*ACS(Entry)
   ENDCASE
  ENDIF
 WHEN "arctan":
  IF Hyp%=TRUE THEN
   IF ABS(Entry)<1E-6 THEN result=Entry ELSE result=LN((1+Entry)/(1-Entry))/2
  ELSE
   CASE Trig% OF
    WHEN 1:result=ATN(Entry)
    WHEN 2:result=DEG ATN(Entry)
    WHEN 3:result=(200/PI)*ATN(Entry)
   ENDCASE
  ENDIF
ENDCASE
Entry=result:Entry$=FNformat_tobase(Entry)
Hyp%=FALSE:PROCwimp_selecticon(CalWin%,50,FALSE)
NumberComplete%=TRUE
ENDPROC

DEF PROCcalc_binary (key$)
REM Process functions with two arguments
IF SummaryComplete%=TRUE THEN
 Summary$=FNformat_prefix(Entry$)
 SummaryComplete%=FALSE
ENDIF
IF Summary$="" THEN Summary$=FNformat_prefix("0")
CASE key$ OF
 WHEN "+","-","/","×":
  IF NOT OpStack% THEN PROCcalc_summarise(" "+key$+" ","",SB_APPEND%)
  IF OpStack% THEN PROCcalc_summarise(" "+key$+" ","",SB_REPLACE%)
  PROCcalc_sum(key$)
 WHEN "AND","OR","EOR","NAND","NOR","EQV","NOR","EQV","NOR","EQV","MOD","DIV","<O","<<",">>",">>>","O>","nCr","nPr":
  IF NOT OpStack% THEN PROCcalc_summarise(" "+key$+" ","",SB_APPEND%)
  IF OpStack% THEN PROCcalc_summarise(" "+key$+" ","",SB_REPLACE%)
  PROCcalc_sum(key$)
 WHEN "root":
  PROCcalc_summarise(" "+key$+" ","",SB_APPEND%)
  PROCcalc_sum(key$)
 WHEN "^":
  PROCcalc_summarise("^","",SB_APPEND%)
  PROCcalc_sum(key$)
 WHEN "(":
  IF Summary$="0" THEN Summary$=""
  PROCcalc_summarise("(","",SB_APPEND%)
  IF NOT OpStack% THEN
   IF HiStack%<0 AND Entry=0 THEN Entry=1
   key$="*":PROCcalc_sum(key$)
  ENDIF
  Bracket%=TRUE
  LoStack%=HiStack%+1:HiStack%=LoStack%-1
  OpStack%=FALSE:result=0
 OTHERWISE:
  PROCcalc_sum(key$)
ENDCASE
Entry=result:Entry$=FNformat_tobase(Entry)
Hyp%=FALSE:PROCwimp_selecticon(CalWin%,50,FALSE)
NumberComplete%=TRUE
ENDPROC

DEF FNcalc_factorial (val)
REM Calculate factorial
LOCAL temp,ser
temp=val+5.5
temp=(val+0.5)*LNtemp-temp
ser=1
FOR i%=1 TO 6
 val+=1
 ser+=cof(i%)/val
NEXT
=temp+LN(STP*ser)

DEF PROCcalc_function (key$)
REM Calculator function keys
LOCAL type%
CASE key$ OF
 WHEN "CE":
  IF OpStack%=FALSE THEN
   Entry=0:Entry$="0"
   IF RIGHT$(Summary$,1)<>"(" THEN
    IF SummaryComplete% THEN Summary$="":SummaryEntry$=""
    SummaryComplete%=FALSE
    PROCcalc_summarise("","",SB_CE%)
   ENDIF
  ENDIF
 WHEN "MC":
  Memory=0
 WHEN "Min":
  Memory=Entry
 WHEN "MR":
  IF OpStack%=TRUE THEN type%=SB_APPEND% ELSE type%=SB_REPLACE%
  IF Bracket%=TRUE THEN type%=SB_APPEND%
  OpStack%=FALSE
  IF Base%<>BASE_DEC% THEN PROCformat_round(Memory) ELSE Entry=Memory
  Entry$=FNformat_tobase(Entry)
  IF SummaryComplete%=TRUE THEN Summary$="":SummaryEntry$=""
  PROCcalc_summarise("",FNformat_prefix(Entry$),type%)
 WHEN "HYP":
  IF FNwimp_getselect(CalWin%,50)=TRUE THEN Hyp%=TRUE ELSE Hyp%=FALSE
 WHEN "RND":
  Entry=RND(1):Entry$=FNformat_tobase(Entry)
  IF OpStack%=TRUE THEN type%=SB_APPEND% ELSE type%=SB_REPLACE%
  IF Bracket%=TRUE THEN type%=SB_APPEND%
  PROCcalc_summarise("RND(1)","",type%)
  SummaryComplete%=FALSE:OpStack%=FALSE
 WHEN "PI":
  Entry=PI:Entry$=FNformat_tobase(Entry)
  IF OpStack%=TRUE THEN type%=SB_APPEND% ELSE type%=SB_REPLACE%
  IF Bracket%=TRUE THEN type%=SB_APPEND%
  IF SummaryComplete%=TRUE THEN Summary$="":SummaryEntry$=""
  PROCcalc_summarise("pi","",type%)
  SummaryComplete%=FALSE:OpStack%=FALSE
ENDCASE
NumberComplete%=TRUE
ENDPROC

DEF PROCcalc_sum (key$)
REM Resolve arithmetic
LOCAL more%,summ$
NumberComplete%=TRUE:summ$=""
IF NOT OpStack% THEN HiStack%+=1
Number(HiStack%)=Entry
IF key$="=" THEN
 Bracket%=FALSE
 PROCwimp_selecticon(CalWin%,48,FALSE)
 LoStack%=0
ENDIF
more%=TRUE
WHILE more%
 IF HiStack%>LoStack% THEN
  more%=(key$="=" OR key$=")" OR FNcalc_position(key$)>=FNcalc_position(Operator$(HiStack%-1)))
 ELSE
  more%=FALSE
 ENDIF
 IF more% THEN
  Number(HiStack%-1)=FNcalc_evaluate(Number(HiStack%-1),Operator$(HiStack%-1),Number(HiStack%))
  HiStack%-=1
 ENDIF
ENDWHILE
result=Number(HiStack%)
CASE key$ OF
 WHEN "=":
  HiStack%=-1:OpStack%=FALSE
  IF NOT SummaryComplete% THEN
   summ$=FNformat_tobase(result)
   IF Base%<>BASE_DEC% THEN
    IF Base%=BASE_BIN% THEN summ$="%"+summ$
    IF Base%=BASE_OCT% THEN summ$="q"+summ$
    IF Base%=BASE_HEX% THEN summ$="&"+summ$
   ENDIF
   PROCcalc_summarise(" = ",summ$,SB_APPEND%)
   SummaryComplete%=TRUE
  ENDIF
 WHEN ")":
  Bracket%=FALSE:PROCwimp_selecticon(CalWin%,48,FALSE)
  HiStack%-=1:OpStack%=FALSE:LoStack%=0
  PROCcalc_summarise(")","",SB_APPEND%)
 OTHERWISE
  Operator$(HiStack%)=key$
  OpStack%=TRUE
ENDCASE
ENDPROC

DEF FNcalc_position (operator$)
REM Get operator priority
LOCAL pos%
CASE operator$ OF
 WHEN "^":pos%=1
 WHEN "nCr","nPr":pos%=2
 WHEN "×","/","DIV","MOD":pos%=3
 WHEN "+","-":pos%=4
 WHEN "<<",">>>",">>","O>","<O":pos%=5
 WHEN "AND","NAND":pos%=6
 WHEN "OR","EOR","NOR","EQV":pos%=7
 OTHERWISE:pos%=0
ENDCASE
=pos%

DEF FNcalc_evaluate (n1,opp$,n2)
REM Evaluate an expression
LOCAL A%,B%,answer
IF opp$="×" THEN opp$="*"
CASE opp$ OF
 WHEN "NAND":answer=NOT(n1 AND n2)
 WHEN "NOR":answer=NOT(n1 OR n2)
 WHEN "EQV":answer=NOT (n1 EOR n2)
 WHEN "root":answer=n1^(1/n2)
 WHEN "O>":A%=n1:B%=n2:answer=USR ror
 WHEN "<O":A%=n1:B%=n2:answer=USR rol
 WHEN "nCr":
  answer=INT(EXP(FNcalc_factorial(n1)-FNcalc_factorial(n2)-FNcalc_factorial(n1-n2))+.5)
 WHEN "nPr":
  answer=INT(EXP(FNcalc_factorial(n1)-FNcalc_factorial(n1-n2))+.5)
 OTHERWISE:answer=EVAL(STR$n1+opp$+STR$n2)
ENDCASE
=answer

DEF PROCcalc_summarise (func$,val$,type%)
REM Adds text to the Summary Bar
LOCAL summlen%,bexp$,bcount%,break%
IF LEN(Summary$)+LEN(func$)+LEN(val$)>255 THEN
 Summary$=RIGHT$(Summary$,LEN(Summary$)-(LEN(func$)+LEN(val$)))
ENDIF
CASE type% OF
 WHEN SB_DIGIT%:
  IF SummaryEntry$="0" OR SummaryEntry$="-0" THEN
   RIGHT$(Summary$,1)=val$
   SummaryEntry$=val$
  ELSE
   Summary$=Summary$+val$
   SummaryEntry$=SummaryEntry$+val$
  ENDIF
  SummaryBracket%=FALSE
 WHEN SB_APPEND%:
  Summary$=Summary$+func$+val$
  SummaryEntry$=func$+val$
  IF func$=")" THEN SummaryBracket%=TRUE ELSE SummaryBracket%=FALSE
 WHEN SB_REPLACE%:
  IF SummaryBracket%=FALSE THEN
   Summary$=LEFT$(Summary$,LEN(Summary$)-LEN(SummaryEntry$))
   summlen%=LEN(func$)+LEN(val$)
   Summary$=Summary$+func$+val$
   IF RIGHT$(func$,1)="(" THEN Summary$=Summary$+")":summlen%+=1
   SummaryEntry$=RIGHT$(Summary$,summlen%)
  ELSE
   bexp$="":bcount%=0:break%=FALSE
   FOR i%=LEN(Summary$) TO 1 STEP -1
    IF break%=FALSE THEN
     IF MID$(Summary$,i%,1)="(" THEN bcount%-=1
     IF MID$(Summary$,i%,1)=")" THEN bcount%+=1
     IF bcount%>0 THEN bexp$=MID$(Summary$,i%,1)+bexp$
     IF bcount%=0 THEN break%=TRUE
    ENDIF
   NEXT
   Summary$=LEFT$(Summary$,LEN(Summary$)-LEN(bexp$)-1)
   Summary$=Summary$+func$+bexp$:SummaryEntry$=func$+bexp$
  ENDIF
  SummaryBracket%=FALSE
 WHEN SB_CE%:
  IF SummaryBracket%=FALSE THEN
   Summary$=LEFT$(Summary$,LEN(Summary$)-LEN(SummaryEntry$))
   SummaryEntry$="":SummaryBracket%=FALSE
  ELSE
   bexp$="":break%=FALSE
   FOR i%=LEN(Summary$) TO 1 STEP -1
    IF MID$(Summary$,i%,1)="(" THEN break%=TRUE
    IF break%=FALSE THEN bexp$=MID$(Summary$,i%,1)+bexp$
   NEXT
   Summary$=LEFT$(Summary$,LEN(Summary$)-LEN(bexp$)-1)
   SummaryEntry$="":SummaryBracket%=FALSE
  ENDIF
 WHEN SB_CLEAR%:
  Summary$="":SummaryEntry$="":SummaryBracket%=FALSE
 WHEN SB_ERROR%:
  Summary$=func$:SummaryEntry$="":SummaryBracket$=""
 WHEN SB_BASE%:
  REM Base/Mode has changed
ENDCASE
PROCwimp_seticontext(CalWin%,75,Summary$)
ENDPROC

DEF PROCcalc_copy (type$)
CopyText$=type$
IF NOT OwnClipboard% THEN
 OwnClipboard%=TRUE
 Block%!0=24
 Block%!12=0
 Block%!16=MESSAGE_CLAIMENTITY%
 Block%!20=4
 SYS "Wimp_SendMessage",17,Block%,0
ENDIF
ENDPROC

REM-----------------------------------------------------------------------------

REM // Format //

REM-----------------------------------------------------------------------------

DEF FNformat_tobin (value$)
REM Convert a value to binary notation
LOCAL dec%,len%,result%
dec%=VAL(value$)
SYS "OS_ConvertBinary4",dec%,ConvBuf%,33 TO ,len%
?len%=13
=FNformat_stripzeros($ConvBuf%)

DEF FNformat_tohex (value$)
REM Convert a value to hexadecimal noation
LOCAL hex%,len%
hex%=VAL(value$)
SYS "OS_ConvertHex8",hex%,ConvBuf%,9 TO ,len%
?len%=13
=FNformat_stripzeros($ConvBuf%)

DEF FNformat_tooct(value$)
REM Convert a value to octal notation
LOCAL buf%,oct%,len%,temp,oct$,i%,temp%
oct%=VAL(value$)
SYS "OS_ConvertBinary4",oct%,ConvBuf%,33 TO ,len%
?len%=13
value$="0"+$ConvBuf%
oct$=""
FOR i%=1 TO 31 STEP 3
 temp%=EVAL("%"+MID$(value$,i%,3))
 oct$+=STR$temp%
NEXT
=FNformat_stripzeros(oct$)

DEF FNformat_todec (base%,value$)
REM Convert a value to decimal notation
LOCAL result%
SYS "OS_ReadUnsigned",base%,value$ TO ,,result%
=result%

DEF FNformat_tobase (decimal)
REM Converts a value to a string formatted to the current base
LOCAL @%
@%="+G10"+DecimalPoint$+"10"
IF INSTR(STR$(decimal),"?")<>0 THEN ERROR 1,FNmess_get("E7"):REM FP Exception
IF Base%<>1 AND decimal>&7FFFFFFF THEN ERROR 1,FNmess_get("E1"):REM Too big
IF Base%<>1 AND decimal<&80000000 THEN ERROR 1,FNmess_get("E2"):REM Too small
CASE Base% OF
 WHEN 1:temp$=STR$(decimal)
 WHEN 2:temp$=FNformat_tobin(STR$(decimal))
 WHEN 3:temp$=FNformat_tooct(STR$(decimal))
 WHEN 4:temp$=FNformat_tohex(STR$(decimal))
ENDCASE
=temp$

DEF FNformat_stripzeros (value$)
REM Strip leading zeros from a number string
WHILE LEFT$(value$,1)="0"
 value$=RIGHT$(value$,LEN(value$)-1)
ENDWHILE
IF value$="" THEN value$="0"
=value$

DEF PROCformat_round (temp)
REM Rounds value up/down to make whole number prior to conversion
LOCAL temp%
IF temp<0 THEN temp-=0.5 ELSE IF temp>0 temp+=0.5
IF temp>=2147483648 THEN ERROR 1,FNmess_get("E1"):REM Too big
IF temp<=-2147483649 THEN ERROR 1,FNmess_get("E2"):REM Too small
temp%=temp:Entry=temp%
CASE Base% OF
 WHEN BASE_BIN%:Entry$=FNformat_tobin(STR$(Entry))
 WHEN BASE_OCT%:Entry$=FNformat_tooct(STR$(Entry))
 WHEN BASE_HEX%:Entry$=FNformat_tohex(STR$(Entry))
ENDCASE
IF OpStack% THEN Number(HiStack%)=Entry
ENDPROC

DEF FNformat_getvalue(value$)
REM Gets the value of the Entry string
LOCAL result
CASE Base% OF
 WHEN BASE_DEC%:result=FNlocale_val(value$)
 WHEN BASE_BIN%:result=FNformat_todec(2,value$)
 WHEN BASE_OCT%:result=FNformat_todec(8,value$)
 WHEN BASE_HEX%:result=FNformat_todec(16,value$)
ENDCASE
=result

DEF FNformat_prefix (digit$)
REM Add a Base prefix symbol to digits in the summary bar
CASE Base% OF
 WHEN BASE_BIN%:digit$="%"+digit$
 WHEN BASE_OCT%:digit$="q"+digit$
 WHEN BASE_HEX%:digit$="&"+digit$
ENDCASE
=digit$

REM-----------------------------------------------------------------------------

REM // Locale functions //

REM-----------------------------------------------------------------------------

DEF PROClocale_init
REM Choose suitable decimal point character
LOCAL point%
SYS "Territory_ReadSymbols",-1,0 TO point%
DecimalPoint$=CHR$?point%
ENDPROC

DEF FNlocale_val(number$)
REM Gets value of number$, taking account of decimal point character
LOCAL i%
IF DecimalPoint$=".":=VALnumber$
i%=INSTR(number$,DecimalPoint$)
IF i%<>0:=VAL(LEFT$(number$,i%-1)+"."+MID$(number$,i%+1))
=VALnumber$

REM-----------------------------------------------------------------------------

REM // Messages //

REM-----------------------------------------------------------------------------

DEF PROCmess_load (name$)
REM Loads Message file
LOCAL ERROR
ON ERROR LOCAL RESTORE ERROR:ERROR 3,REPORT$
SYS "MessageTrans_FileInfo",,name$
SYS "OS_Module",6,,,17+LEN(name$) TO ,,MessDesc%
$(MessDesc%+16)=name$
SYS "MessageTrans_OpenFile",MessDesc%,MessDesc%+16
ENDPROC

DEF PROCmess_close
REM Close message file and free memory
SYS "XMessageTrans_CloseFile",MessDesc%
SYS "XOS_Module",7,,MessDesc%
ENDPROC

DEF FNmess_get (tag$)
REM Retrieves a Message string from a tag
=FNmess_getargs(tag$,"","")

DEF FNmess_getargs (tag$,arg1$,arg2$)
REM Retrieves a Message string with arguments
LOCAL flags%,args%
SYS "XMessageTrans_Lookup",MessDesc%,tag$,MessText%,256,arg1$,arg2$ TO ,,,args%;flags%
IF flags% AND 1 THEN args%=0
MessText%?args%=13
=$MessText%

REM-----------------------------------------------------------------------------

REM // Wimp //

REM-----------------------------------------------------------------------------

DEF PROCwimp_init
REM Initialise the task, set global variables and load resources
LOCAL sprite$
WimpVersion%=0                         :REM Wimp Version
DIM Block% &1500                       :REM General Wimp Buffer
DIM ErrorBlock% 1280                   :REM Error Buffer
DIM TaskID% 20:$(TaskID%)="TASK"       :REM Task Name Buffer
DIM MessText% 256                      :REM Messages buffer
MessType%=0                            :REM Message type
DIM WindowName% 12                     :REM Buffer for Window title
DIM WindowFonts% 255                   :REM Buffer for Outline fonts
BootPath$=""                           :REM Pathname for <SciCalc$Dir>
MESSAGE_QUIT%=0                        :REM Message constants
MESSAGE_HELPREQUEST%=&502              :REM Message constants
MESSAGE_HELPREPLY%=&503                :REM Message constants
MESSAGE_CLAIMENTITY%=&F                :REM Message constants
MESSAGE_DATAREQUEST%=&10               :REM Message constants
MESSAGE_DATASAVE%=&1                   :REM Message constants
MESSAGE_DATASAVEACK%=&2                :REM Message constants
MESSAGE_DATALOAD%=&3                   :REM Message constants
MESSAGE_SAVEDESKTOP%=&A                :REM Message constants
ER_INVALIDOP%=&80000200                :REM Error constants
ER_NUMBERTOOBIG%=&80000201             :REM Error constants
ER_DIVBYZERO%=&80000202                :REM Error constants
ER_NUMBERTOOSMALL%=&80000203           :REM Error constants
ER_ACCURACYLOST%=&80000204             :REM Error constants
MenuOpen%=0                            :REM Handle of current menu
AppHandle%=0                           :REM Application Task Handle
IconHandle%=0                          :REM Iconbar icon handle
AppQuit%=FALSE                         :REM Poll release variable
OwnFocus%=FALSE                        :REM Application owns caret
OwnClipboard%=FALSE                    :REM Application owns clipboard
FirstClick%=TRUE                       :REM Logs first click on Iconbar icon
DIM Filename% 255                      :REM Buffer for copied text string
CopyText$=""                           :REM Stores text to be copied
i%=0                                   :REM General counter
DIM endbuf% -1:curbuf%=ErrorBlock%
DIM indbuf% 128
ind=indbuf%
IF VAL STR$(1<<31)<>(1<<31) THEN ERROR EXT 1,FNmess_get("E8"):END:REM Need BASIC 64
Block%!0=&10:Block%!4=&502:Block%!8=&F:Block%!12=&1:Block%!16=&2
Block%!20=&A:Block%!24=0
SYS "Wimp_Initialise",300,!TaskID%,FNmess_get("_TaskName"),Block% TO WimpVersion%,AppHandle%
Block%!0=-1:Block%!4=0:Block%!8=0:Block%!12=68:Block%!16=68
Block%!20=&3002:$(Block%+24)="!scicalc"
SYS "Wimp_CreateIcon",,Block% TO IconHandle%
ON ERROR PROCwimp_error
PROCwimp_sprites
WindowArea%=FNwimp_opentemplates("<SciCalc$Dir>.Templates")
FOR i%=0 TO 255 STEP 4:WindowFonts%!i%=0:NEXT
CalWin%=FNwimp_loadtemplate("Calculator",WindowArea%)
InfoWin%=FNwimp_loadtemplate("Info",WindowArea%)
ChoiceWin%=FNwimp_loadtemplate("Choices",WindowArea%)
PROCwimp_menus
SYS "Font_FindFont",,"Homerton.Medium",12*16,12*16,0,0 TO DisplayFont%
SYS "Font_SetFontColours",DisplayFont%,0,7
IF Option_Type%=0 THEN CalcSize%=CALC_SMALL% ELSE CalcSize%=CALC_BIG%
ENDPROC

DEF PROCwimp_poll
REM Main poll loop
LOCAL reason%
SYS "Wimp_Poll",1,Block% TO reason%
CASE reason% OF
 WHEN 1:REM Window Redraw
  IF Block%!0=CalWin% THEN
   PROCcalwin_redraw
  ENDIF
 WHEN 2:REM Window Open
  PROCwimp_openwindow(Block%!0,Block%!4,Block%!8,Block%!12,Block%!16,Block%!20,Block%!24,Block%!28,FALSE)
 WHEN 3:REM Window Close
  SYS "Wimp_CloseWindow",,Block%
 WHEN 6:REM Mouse Click
  CASE Block%!12 OF
   WHEN CalWin%:
    PROCcalwin_click(Block%!16,Block%!8)
    IF ErrorFlag% THEN PROCcalc_error
   WHEN ChoiceWin%:
    PROCchoicewin_click(Block%!16,Block%!8)
   WHEN -2:
    PROCiconbar_click(Block%!8)
  ENDCASE
 WHEN 8:REM Key pressed
  CASE Block%!0 OF
   WHEN CalWin%:
    PROCcalwin_keypress(Block%!24)
    IF ErrorFlag% THEN PROCcalc_error
   WHEN ChoiceWin%:
    PROCchoicewin_keypress(Block%!24)
  ENDCASE
 WHEN 9:REM Menu selection
  PROCwimp_menuselect(Block%)
 WHEN 17,18:REM Wimp messages
  PROCwimp_messages(Block%)
ENDCASE
ENDPROC

DEF PROCwimp_error
REM Report fatal errors and close
SYS "Wimp_DragBox",,-1
!ErrorBlock%=ERR
$(ErrorBlock%+4)=REPORT$+" "+FNmess_getargs("EL",STR$ ERL,"")+CHR$(0)
SYS "Wimp_ReportError",ErrorBlock%,1,FNmess_get("_TaskName")
SYS "Wimp_CloseDown":END
ENDPROC

DEF PROCwimp_menuselect (Block%)
REM Handle menu selections and tick/untick selections
CASE MenuOpen% OF
 WHEN InfoMenu%:
  IF Block%!0=1 THEN OSCLI "Filer_Run <SciCalc$Dir>.!Help"
  IF Block%!0=2 THEN PROCchoicewin_init
  IF Block%!0=3 THEN AppQuit%=TRUE
 WHEN TrigOptMenu%:
  FOR i%=0 TO 2:PROCwimp_settick(TrigOptMenu%,i%,FALSE):NEXT
  PROCwimp_settick(TrigOptMenu%,Block%!0,TRUE)
  CASE Block%!0 OF
   WHEN 0:PROCwimp_seticontext(ChoiceWin%,8,FNmess_get("Rad"))
   WHEN 1:PROCwimp_seticontext(ChoiceWin%,8,FNmess_get("Deg"))
   WHEN 2:PROCwimp_seticontext(ChoiceWin%,8,FNmess_get("Grad"))
  ENDCASE
 WHEN BaseOptMenu%:
  FOR i%=0 TO 3:PROCwimp_settick(BaseOptMenu%,i%,FALSE):NEXT
  PROCwimp_settick(BaseOptMenu%,Block%!0,TRUE)
  CASE Block%!0 OF
   WHEN 0:PROCwimp_seticontext(ChoiceWin%,5,FNmess_get("Dec"))
   WHEN 1:PROCwimp_seticontext(ChoiceWin%,5,FNmess_get("Bin"))
   WHEN 2:PROCwimp_seticontext(ChoiceWin%,5,FNmess_get("Oct"))
   WHEN 3:PROCwimp_seticontext(ChoiceWin%,5,FNmess_get("Hex"))
  ENDCASE
 WHEN CalcMenu%:
  IF Block%!0=0 AND Block%!4=0 AND CalcSize%=CALC_BIG% THEN
   PROCwimp_settick(ViewMenu%,0,TRUE):PROCwimp_settick(ViewMenu%,1,FALSE)
   Block%!0=CalWin%:SYS "Wimp_GetWindowState",,Block%
   PROCcalwin_resize(Block%!4,Block%!8,460)
  ENDIF
  IF Block%!0=0 AND Block%!4=1 AND CalcSize%=CALC_SMALL% THEN
   PROCwimp_settick(ViewMenu%,0,FALSE):PROCwimp_settick(ViewMenu%,1,TRUE)
   Block%!0=CalWin%:SYS "Wimp_GetWindowState",,Block%
   PROCcalwin_resize(Block%!4,Block%!8,0)
  ENDIF
  IF Block%!0=1 AND Block%!4=0 THEN PROCcalc_copy(Entry$)
  IF Block%!0=1 AND Block%!4=1 THEN PROCcalc_copy(Summary$)
  IF Block%!0=0 AND Block%!4=2 THEN PROCcalwin_pos
  IF Block%!0=2 THEN OSCLI "Filer_Run <SciCalc$Dir>.!Help"
ENDCASE
SYS "Wimp_GetPointerInfo",,Block%
IF Block%!8 AND 1 THEN SYS "Wimp_CreateMenu",,MenuOpen%
ENDPROC

DEF PROCwimp_settick (menu%,item%,type%)
REM Ticks or unticks a menu item
LOCAL menuptr%
menuptr%=menu%+28+(item%*24)
IF type%=TRUE THEN menuptr%?0=menuptr%?0 OR (1<<0)
IF type%=FALSE THEN menuptr%?0=menuptr%?0 AND NOT (1<<0)
ENDPROC

DEF PROCwimp_messages(Block%)
REM Handle Wimp Messages
LOCAL helptext$,target%,file%
CASE Block%!16 OF
 WHEN MESSAGE_QUIT%:
  AppQuit%=TRUE
 WHEN MESSAGE_HELPREQUEST%:
  helptext$=FNwimp_gethelp
  IF LEN(helptext$)>0 THEN
   Block%!0=256
   Block%!12=Block%!8
   Block%!16=MESSAGE_HELPREPLY%
   $(Block%+20)=helptext$+CHR$0
   SYS "Wimp_SendMessage",17,Block%,Block%!4
  ENDIF
 WHEN MESSAGE_CLAIMENTITY%:
  IF Block%!4<>AppHandle% THEN
   IF Block%!20 AND (1<<0) THEN OwnFocus%=FALSE
   IF Block%!20 AND (1<<1) THEN OwnFocus%=FALSE
   IF Block%!20 AND (1<<2) THEN OwnClipboard%=FALSE
  ENDIF
 WHEN MESSAGE_DATAREQUEST%:
  IF (Block%!36 AND (1<<2)) AND OwnClipboard% THEN
   target%=Block%!4
   Block%!12=Block%!8 
   Block%!16=MESSAGE_DATASAVE%
   Block%!36=LEN(CopyText$)
   Block%!40=&FFF
   $(Block%+44)="CopyText"+CHR$(0)
   SYS "Wimp_SendMessage",17,Block%,target%
  ENDIF
 WHEN MESSAGE_DATASAVEACK%:
  $(Filename%)=CopyText$+CHR$(0)
  SYS "OS_File",10,"<Wimp$Scrap>",Block%!40,,Filename%,Filename%+LEN(CopyText$)
  target%=Block%!4
  Block%!12=Block%!8
  Block%!16=MESSAGE_DATALOAD%
  SYS "Wimp_SendMessage",17,Block%,target%
 WHEN MESSAGE_SAVEDESKTOP%:
  file%=Block%!20
  SYS "XOS_ReadVarVal","SciCalc$Dir",Block%,256,0,3 TO ,,len%
  Block%?len%=13
  BPUT#file%,"Run "+$(Block%)
ENDCASE
ENDPROC

DEF FNwimp_gethelp
LOCAL text$
text$=""
CASE Block%!32 OF
 WHEN -2:
  IF Block%!36=IconHandle% THEN text$=FNmess_get("H1")
 WHEN InfoWin%:
  text$=FNmess_get("H2")
 WHEN CalWin%:
  IF ErrorFlag% THEN
   text$=FNmess_get("H6")
  ELSE
   CASE Block%!36 OF
    WHEN 0,1,2,3,4,5,6,7,8,9:
     text$=FNmess_getargs("K"+STR$(Block%!36),STR$(Block%!36),"")
    WHEN 70,71,72,73:
     text$=FNmess_getargs("K"+STR$(Block%!36),FNmess_get("B"+STR$(Base%)),"")
    WHEN 76,77,78:
     text$=FNmess_getargs("K"+STR$(Block%!36),FNmess_get("T"+STR$(Trig%)),"")
    WHEN 48:
     text$=FNmess_get("D"+STR$(-Bracket%))
    WHEN 64,65,66,67,68,69:
     text$=FNmess_getargs("K"+STR$(Block%!36),STR$(Block%!36-54),"")
   OTHERWISE:
     IF Block%!36>0 THEN text$=FNmess_get("K"+STR$(Block%!36))
   ENDCASE
  ENDIF
  IF text$="" THEN text$=FNmess_get("H3")
 WHEN ChoiceWin%:
  CASE Block%!36 OF
   WHEN 2,3,5,6,8,9,14,15,18,11,10:
    text$=FNmess_getargs("C"+STR$(Block%!36),STR$(Block%!36),"")
  ENDCASE
 OTHERWISE:
  SYS "Wimp_GetMenuState",1,ErrorBlock%,Block%!32,Block%!36
  CASE MenuOpen% OF
   WHEN InfoMenu%:
    text$=FNmess_getargs("M"+STR$(!ErrorBlock%),STR$(!ErrorBlock%),"")
   WHEN CalcMenu%:
    IF ErrorBlock%!0>-1 THEN text$=FNmess_getargs("M"+STR$(!ErrorBlock%+4),STR$(!ErrorBlock%+4),"")
    IF ErrorBlock%!4>-1 THEN
     IF ErrorBlock%!0=0 THEN text$=FNmess_getargs("M"+STR$(ErrorBlock%!4+7),STR$(!ErrorBlock%+6),"")
     IF ErrorBlock%!0=1 THEN text$=FNmess_getargs("M"+STR$(ErrorBlock%!4+10),STR$(!ErrorBlock%+6),"")
    ENDIF
   WHEN BaseOptMenu%:
    text$=FNmess_getargs("M"+STR$(!ErrorBlock%+11),STR$(!ErrorBlock%+12),"")
   WHEN TrigOptMenu%:
    text$=FNmess_getargs("M"+STR$(!ErrorBlock%+15),STR$(!ErrorBlock%+16),"")
  ENDCASE
ENDCASE
=text$

DEF PROCwimp_sprites
REM Load application sprites
LOCAL spritefile%,spritesize%,spritepath$,obj%,type%
LOCAL squashsize%,work%,source%,result%
spritepath$="<SciCalc$Dir>.Sprites"
IF Option_Theme%=TRUE THEN
 REM See if there are sprites for the currently configured theme
 SYS "XOS_File",17,"<SciCalc$Dir>.<Wimp$IconTheme>Sprites" TO obj%
 IF obj%=1 THEN spritepath$="<SciCalc$Dir>.<Wimp$IconTheme>Sprites"
ENDIF
SYS "XOS_File",23,spritepath$ TO,,,,,,type%
spritefile%=OPENIN spritepath$
SYS "OS_GBPB",4,spritefile%,Block%,8
IF (type%=&FCA) AND (!Block%=&48535153) THEN
 REM Squashed sprites
 spritesize%=Block%!4
 squashsize%=EXT#spritefile% - 20:REM Omit header
ELSE
 spritesize%=EXT#spritefile%
 CLOSE#spritefile%
ENDIF
DIM SpriteArea% spritesize%+4
!SpriteArea%=spritesize%+4:SpriteArea%!8=1
IF (type%=&FCA) AND (!Block%=&48535153) THEN
 SYS "Squash_Decompress",8,-1 TO work%
 SYS "OS_Module",6,,,work% TO ,,work%
 SYS "OS_Module",6,,,squashsize% TO ,,source%
 REM Load and decompress it in one gulp
 SYS "OS_GBPB",3,spritefile%,source%,squashsize%,20
 SYS "XSquash_Decompress",4,work%,source%,squashsize%,SpriteArea%+4,spritesize% TO result%
 SYS "OS_Module",7,,source%
 SYS "OS_Module",7,,work%
 CLOSE#spritefile%
 IF result%<>0 THEN ERROR EXT 1,FNmess_get("E9"):END:REM Can't unsquash sprites
ELSE
 SYS "OS_SpriteOp",&109,SpriteArea%
 SYS "OS_SpriteOp",&10A,SpriteArea%,spritepath$
ENDIF
ENDPROC

DEF FNwimp_opentemplates (path$)
REM Opens a Template file and creates buffer for total indirected data
LOCAL size%,largest%,next%,indarea%,indsize%,totalindsize%
SYS "Wimp_OpenTemplate",,path$
largest%=0:totalindsize%=0
$WindowName%="*"
SYS "Wimp_LoadTemplate",,0,,,,WindowName%,0 TO ,size%,indsize%,,,,next%
IF size%>largest% THEN largest%=size%
IF indsize%>0 THEN totalindsize%=totalindsize%+indsize%
WHILE next%<>0
 $WindowName%="*"
 SYS "Wimp_LoadTemplate",,0,,,,WindowName%,next% TO ,size%,indsize%,,,,next%
 IF next%<>0 THEN
  IF size%>largest% THEN largest%=size%
  IF indsize%>0 THEN totalindsize%=totalindsize%+indsize%
 ENDIF
ENDWHILE
DIM indarea% totalindsize%+16
DIM WindowBlock% largest%+16
WindowIndPtr%=indarea%
=indarea%

DEF FNwimp_loadtemplate (name$,indarea%)
REM Loads a window definition from a Template file
LOCAL indsize%
$WindowName%=name$
SYS "Wimp_LoadTemplate",,0,,,,WindowName% TO ,,indsize%
SYS "Wimp_LoadTemplate",,WindowBlock%,WindowIndPtr%,WindowIndPtr%+indsize%,WindowFonts%,WindowName% TO ,,WindowIndPtr%
WindowBlock%!64=SpriteArea%
SYS "Wimp_CreateWindow",,WindowBlock% TO window%
=window%

DEF PROCwimp_menus
REM Create menus
DIM InfoMenu% 28+(24*4)
PROCwimp_makemenu(InfoMenu%,FNmess_get("_TaskName"))
PROCwimp_additem(InfoMenu%,0,0,InfoWin%,FNmess_get("Info"))
PROCwimp_additem(InfoMenu%,1,0,-1,FNmess_get("HelpIB")):REM No focus for this menu, so can't accept F1 for help
PROCwimp_additem(InfoMenu%,2,0,-1,FNmess_get("Choices"))
PROCwimp_additem(InfoMenu%,3,128,-1,FNmess_get("Quit"))
DIM BaseOptMenu% 28+(24*4)
PROCwimp_makemenu(BaseOptMenu%,FNmess_get("Base"))
PROCwimp_additem(BaseOptMenu%,0,0,-1,FNmess_get("Dec"))
PROCwimp_additem(BaseOptMenu%,1,0,-1,FNmess_get("Bin"))
PROCwimp_additem(BaseOptMenu%,2,0,-1,FNmess_get("Oct"))
PROCwimp_additem(BaseOptMenu%,3,128,-1,FNmess_get("Hex"))
DIM TrigOptMenu% 28+(24*3)
PROCwimp_makemenu(TrigOptMenu%,FNmess_get("Trig"))
PROCwimp_additem(TrigOptMenu%,0,0,-1,FNmess_get("Rad"))
PROCwimp_additem(TrigOptMenu%,1,0,-1,FNmess_get("Deg"))
PROCwimp_additem(TrigOptMenu%,2,128,-1,FNmess_get("Grad"))
DIM ViewMenu% 28+(24*3)
PROCwimp_makemenu(ViewMenu%,FNmess_get("View"))
PROCwimp_additem(ViewMenu%,0,0,-1,FNmess_get("Standard"))
PROCwimp_additem(ViewMenu%,1,2,-1,FNmess_get("Scientific"))
PROCwimp_additem(ViewMenu%,2,128,-1,FNmess_get("WinPos"))
DIM EditMenu% 28+(24*2)
PROCwimp_makemenu(EditMenu%,FNmess_get("Edit"))
PROCwimp_additem(EditMenu%,0,0,-1,FNmess_get("CopyV"))
PROCwimp_additem(EditMenu%,1,128,-1,FNmess_get("CopyS"))
DIM CalcMenu% 28+(24*3)
PROCwimp_makemenu(CalcMenu%,FNmess_get("_TaskName"))
PROCwimp_additem(CalcMenu%,0,0,ViewMenu%,FNmess_get("View"))
PROCwimp_additem(CalcMenu%,1,2,EditMenu%,FNmess_get("Edit"))
PROCwimp_additem(CalcMenu%,2,128,-1,FNmess_get("Help"))
ENDPROC

DEF PROCwimp_makemenu (menu%,title$)
REM Create a menu
$(menu%)=title$
menu%!12=&00070207:menu%!16=0:menu%!20=44:menu%!24=0
ENDPROC

DEF PROCwimp_additem (menu%,item%,flags%,link%,text$)
LOCAL max%,buf%
REM Add a menu item
menu%!(28+(item%*24))=flags%:menu%!(28+(item%*24)+4)=link%
IF LEN(text$)>12 THEN
 REM Indirected with empty validation
 DIM buf% LEN(text$)+1
 menu%!(28+(item%*24)+8)=&07000121
 menu%!(28+(item%*24)+12)=buf%
 menu%!(28+(item%*24)+16)=buf%+LEN(text$):REM Point at the CR
 menu%!(28+(item%*24)+20)=LEN(text$)+1
 $buf%=text$
ELSE
 menu%!(28+(item%*24)+8)=&07000021
 $(menu%+28+(item%*24)+12)=text$
ENDIF
REM Update max width for old Wimp in system font
max%=16*(1+LEN(text$))
IF menu%!16<max% THEN menu%!16=max%
ENDPROC

DEF PROCwimp_openwindow (window%,xmin%,ymin%,xmax%,ymax%,xscroll%,yscroll%,bhandle%,focus%)
REM Respond to an OpenWindow event from the Desktop
Block%!0=window%
SYS "Wimp_GetWindowState",,Block%
IF window%=CalWin% AND (Block%!32 AND 1<<19) THEN
 xmin%=Block%!4:ymin%=Block%!8
 PROCcalwin_resize(xmin%,ymin%,xscroll%)
ELSE
 IF xmin%<>0 THEN
  Block%!0=window%
  Block%!4=xmin%:Block%!8=ymin%
  Block%!12=xmax%:Block%!16=ymax%
  Block%!20=xscroll%:Block%!24=yscroll%
 ELSE
  Block%!0=window%
  SYS "Wimp_GetWindowState",,Block%
 ENDIF
 Block%!28=bhandle%
 SYS "Wimp_OpenWindow",,Block%
ENDIF
IF focus%=TRUE THEN SYS "Wimp_SetCaretPosition",window%,-1,0,0,-1,-1
ENDPROC

DEF PROCwimp_claimcaret (window%,icon%,visible%)
REM Claim the OS caret
IF visible%=TRUE THEN visible%=1 ELSE visible%=0
SYS "Wimp_SetCaretPosition",window%,icon%,0,0,1<<25
IF OwnFocus%=FALSE THEN
 Block%!0=24:Block%!12=0:Block%!16=MESSAGE_CLAIMENTITY%:Block%!20=3
 SYS "Wimp_SendMessage",17,Block%,0
ENDIF
OwnFocus%=TRUE
ENDPROC

DEF PROCwimp_showicon (window%,icon%)
REM Make an icon visible
PROCwimp_updateicon(window%,icon%,0,&00800080)
ENDPROC

DEF PROCwimp_hideicon (window%,icon%)
REM Make an icon invisible
PROCwimp_updateicon(window%,icon%,&00800080,&00800080)
ENDPROC

DEF PROCwimp_updateicon (window%,icon%,eor%,clr%)
REM Perform an action on an icon block
Block%!0=window%:Block%!4=icon%:Block%!8=eor%:Block%!12=clr%
SYS "Wimp_SetIconState",,Block%
ENDPROC

DEF PROCwimp_seticontext (window%,icon%,text$)
REM Set the indirected text label in an icon
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
$(Block%!28)=text$
Block%!8=0:Block%!12=0
SYS "Wimp_SetIconState",,Block%
ENDPROC

DEF PROCwimp_selecticon (window%,icon%,action%)
REM Selects icon
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
CASE action% OF
 WHEN FALSE:IF (Block%!24 AND (1<<21)) THEN
   Block%!8=0:Block%!12=1<<21
   SYS "Wimp_SetIconState",,Block%
  ENDIF
 WHEN TRUE:IF NOT(Block%!24 AND (1<<21)) THEN
   Block%!8=1<<21:Block%!12=1<<21
   SYS "Wimp_SetIconState",,Block%
  ENDIF
ENDCASE
ENDPROC

DEF FNwimp_getselect (window%,icon%)
REM Returns TRUE if icon is selected, FALSE if not
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
IF (Block%!24 AND (1<<21)) THEN =TRUE ELSE =FALSE

DEF PROCwimp_shadeicon (window%,icon%,action%)
REM Shades icon
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
CASE action% OF
 WHEN FALSE:IF (Block%!24 AND (1<<22)) THEN
   Block%!8=0:Block%!12=1<<22
   SYS "Wimp_SetIconState",,Block%
  ENDIF
 WHEN TRUE:IF NOT(Block%!24 AND (1<<22)) THEN
   Block%!8=1<<22:Block%!12=1<<22
   SYS "Wimp_SetIconState",,Block%
  ENDIF
ENDCASE
ENDPROC

DEF FNwimp_gettick (menu%,item%)
REM Returns whether a menu item is ticked
LOCAL menuptr%
menuptr%=menu%+28:menuptr%+=item%*24
IF menuptr%?0 AND (1<<0) THEN =TRUE ELSE =FALSE

