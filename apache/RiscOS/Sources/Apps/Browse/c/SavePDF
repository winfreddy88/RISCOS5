/* Copyright 2006 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    SavePDF.c                                         */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Save a web page in PDF format.                    */
/*                                                            */
/* Author:  A.D.Hodgkinson, including various functions from  */
/*          original Customer browser by Merlyn Kline.       */
/*                                                            */
/* History: 25-Jan-2006 (ADH): Created from SaveDraw.c.       */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include <kernel.h>
#include <swis.h>
#include <tboxlibs/flex.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <Unicode/charsets.h>
#include <Unicode/encoding.h>

#include <ZLib/zlib.h>

#include "Global.h"
#include "FromROSLib.h"
#include "MiscDefs.h"
#include "Utils.h"

#include "Arrays.h"
#include "Browser.h"
#include "ChoiceDefs.h"
#include "FileTypes.h"
#include "FontManage.h"
#include "Images.h"
#include "Object.h"
#include "Redraw.h"
#include "Reformat.h"
#include "Save.h"
#include "SaveDraw.h"
#include "Scale.h"

#include "SavePDF.h"

/* Avoid repeating the same string (it'll only get put in the compiler */
/* string table once, but it's just a pain to copy it around).         */

#define SAVEPDF_ZLIB_ERROR "Internal error - the ZLib compression library was unable to complete a requested operation"

/* PDF hard-coded object numbers */

#define PDF_OBJ_INFORMATION 1
#define PDF_OBJ_PAGE_TABLE  2
#define PDF_OBJ_FONTS_START 3 /* After this, objects are numbered consecutively */

/* PDF strings are either UTF-16 or in Adobe's unregistered PDF Document */
/* Encoding, very similar to Windows 1252 but with a few extra and a few */
/* moved characters, and no definition of hard space because Adobe says  */
/* it's typographically identical to a standard space. The string writer */
/* function has a magic encoding destination to handle this mapping - it */
/* encodes to Windows 1252 then uses the table to map to PDF encoding.   */

#define SAVEPDF_PDF_DOC_ENCODING -1

/* The table maps as per the PDF specification v1.3, but since we start  */
/* with CP1252 any characters missing from that which are present in PDF */
/* encoding will never get represented in the output and vice versa. Any */
/* 1252 character missing in PDF encoding gets turned into "?". Hard     */
/* spaces are mapped to normal spaces.                                   */

static char savepdf_win1252_to_pdf_map[256] =
{
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, /* 00 to 07 */
  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 08 to 0F */
  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, /* 10 to 17 */
  0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, /* 18 to 1F */

  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, /* 20 to 27 */
  0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, /* 28 to 2F */
  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, /* 30 to 37 */
  0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, /* 38 to 3F */

  0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, /* 40 to 47 */
  0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, /* 48 to 4F */
  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, /* 50 to 57 */
  0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, /* 58 to 5F */

  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, /* 60 to 67 */
  0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, /* 68 to 6F */
  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, /* 70 to 77 */
  0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x3F, /* 78 to 7F */

  0xA0, 0x3F, 0x91, 0x86, 0x8C, 0x83, 0x81, 0x82, /* 80 to 87 */
  0x1A, 0x8B, 0x97, 0x88, 0x96, 0x3F, 0x99, 0x3F, /* 88 to 8F */
  0x3F, 0x8F, 0x90, 0x8D, 0x8E, 0x80, 0x85, 0x84, /* 90 to 97 */
  0x1F, 0x92, 0x9D, 0x89, 0x9C, 0x3F, 0x9E, 0x98, /* 98 to 9F */

  0x20, 0xA1, 0xA2, 0xA3, 0x3F, 0xA5, 0xA6, 0xA7, /* A0 to A7 */
  0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0x3F, 0xAE, 0xAF, /* A8 to AF */
  0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, /* B0 to B7 */
  0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, /* B8 to BF */

  0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, /* C0 to C7 */
  0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, /* C8 to CF */
  0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, /* D0 to D7 */
  0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, /* D8 to DF */

  0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, /* E0 to E7 */
  0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, /* E8 to EF */
  0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, /* F0 to F7 */
  0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, /* F8 to FF */
};

/* Flag indicating that the encoding callback function should do */
/* the character mapping before writing anything out.            */

static unsigned int savepdf_win1252_to_pdf_flag = 0;

/* Global file information */

static FILE         * outfile  = NULL; /* Output file structure       */
static char         * outpath  = NULL; /* Output pathname             */
static browser_data * outbrow  = NULL; /* Output browser              */

static size_t         objctr   = 0;    /* Indirect object counter     */
static array_t      * objaddr  = NULL; /* Object address array        */
static size_t         pagectr  = 0;    /* Page counter                */
static array_t      * pageobj  = NULL; /* Page object numberes        */

/* Current page information */

static long int       pstart   = 0;    /* Offset of page start        */
static int            pwidth   = 0;    /* Width in millipoints        */
static int            pheight  = 0;    /* Height in millipoints       */
static int            poriginx = 0;    /* X origin in PDF user space  */
static int            poriginy = 0;    /* Y origin in PDF user space  */

/* Structure to hold mapping details between RISC OS font names and */
/* PDF font names.                                                  */

typedef struct savepdf_font_map
{
  const char * riscos_name;
  const char * adobe_name;
}
savepdf_font_map_t;

/* The PDF writer only supports a hard-coded list of the standard   */
/* fonts described in the PDF 1.3 specification, excluding the two  */
/* symbol fonts. Applications like xpdf only have built in support  */
/* for the standard fonts. Font embedding isn't supported in this   */
/* version of the PDF writing code.                                 */

static const savepdf_font_map_t font_name_map[] =
{
  /* Note the ordering of items here is not important. */

     { "Trinity.Medium",               "Times-Roman"                  },
     { "Trinity.Medium.Italic",        "Times-Italic"                 },
     { "Trinity.Bold",                 "Times-Bold"                   },
     { "Trinity.Bold.Italic",          "Times-BoldItalic"             },
     { "Homerton.Medium",              "Helvetica"                    },
     { "Homerton.Medium.Oblique",      "Helvetica-Oblique"            },
     { "Homerton.Bold",                "Helvetica-Bold"               },
     { "Homerton.Bold.Oblique",        "Helvetica-BoldOblique"        },
     { "Corpus.Medium",                "Courier"                      },
     { "Corpus.Medium.Oblique",        "Courier-Oblique"              },
     { "Corpus.Bold",                  "Courier-Bold"                 },
     { "Corpus.Bold.Oblique",          "Courier-BoldOblique"          }

  /* The PostScript driver includes the following extra mappings, but as */
  /* these are not PDF standard fonts they're not currently used.        */
  /*                                                                     */
  /* { "Clare.Medium",                 "AvantGarde-Book"              }, */
  /* { "Clare.Medium.Oblique",         "AvantGarde-BookOblique"       }, */
  /* { "Clare.Demi",                   "AvantGarde-Demi"              }, */
  /* { "Clare.Demi.Oblique",           "AvantGarde-DemiOblique"       }, */
  /* { "Robinson.Demi",                "Bookman-Demi"                 }, */
  /* { "Robinson.Demi.Italic",         "Bookman-DemiItalic"           }, */
  /* { "Robinson.Light",               "Bookman-Light"                }, */
  /* { "Robinson.Light.Italic",        "Bookman-LightItalic"          }, */
  /* { "Homerton.Narrow",              "Helvetica-Narrow"             }, */
  /* { "Homerton.Narrow.Bold",         "Helvetica-Narrow-Bold"        }, */
  /* { "Homerton.Narrow.Bold.Oblique", "Helvetica-Narrow-BoldOblique" }, */
  /* { "Homerton.Narrow.Oblique",      "Helvetica-Narrow-Oblique"     }, */
  /* { "NewHall.Bold",                 "NewCenturySchlbk-Bold"        }, */
  /* { "NewHall.Bold.Italic",          "NewCenturySchlbk-BoldItalic"  }, */
  /* { "NewHall.Medium.Italic",        "NewCenturySchlbk-Italic"      }, */
  /* { "NewHall.Medium",               "NewCenturySchlbk-Roman"       }, */
  /* { "Pembroke.Bold",                "Palatino-Bold"                }, */
  /* { "Pembroke.Bold.Italic",         "Palatino-BoldItalic"          }, */
  /* { "Pembroke.Medium.Italic",       "Palatino-Italic"              }, */
  /* { "Pembroke.Medium",              "Palatino-Roman"               }, */
  /* { "Churchill.Medium.Italic",      "ZapfChancery-MediumItalic"    }  */
};

/* Internal mapping table - nasty global approach assumes we're only */
/* ever writing one file at a time, but since the process is single  */
/* tasking it's very unlikely this will be wrong in the near future! */
/*                                                                   */
/* The mapping table relates a font number for a token from 0 to 11  */
/* into an index in the font_name_map array (see above).             */
/*                                                                   */
/* Use the number as an index into the font_token_map array. That    */
/* will contain a number which is an index into the font_name_map    */
/* array, leading to both the full font name in RISC OS or PDF       */
/* form, and a number that can be used to generate a "F0" to "F11"   */
/* name for the named fonts within the actual output PDF file. The   */
/* table of fonts assigned to names "F0" through to "F11" is built   */
/* up in order of appearance in the names array above, so the order  */
/* can be changed and PDF files will still work. If adding new       */
/* mappings, check through the code - some areas make hard-coded     */
/* assumptions about the 3 groups of 4 weights arrangements.         */
/*                                                                   */
/* The values below are sensible defaults, but you should call       */
/* savepdf_get_font_mappings to properly initialise the table.       */

static char font_token_map[12] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };

/* Name dictionary: An array of all named anchors in the document */
/* and the page on which they appear. Eventually sorted by name   */
/* before being output in a suitable form in the PDF file.        */
/*                                                                */
/* The name dictionary is used for destinations named by string.  */

typedef struct savepdf_name
{
  const char * name;
  BBox         bounds;
  size_t       page_object_number;
}
savepdf_name_t;

static array_t * name_dictionary = NULL;

/* Annotation dictionaries: An array of all links found in each page. */

typedef struct savepdf_annotation
{
  unsigned int   uri;           /* 1 = external URI, 0 = internal named anchor   */
  const char   * link;          /* Link text = URI or name (without leading "#"  */
  BBox           bounds;        /* In PDF user-space inclusive coords            */
  unsigned int   object_number; /* No. of /Annot object, set when writing it out */
}
savepdf_annotation_t;

static array_t * annotation_dictionary = NULL;

/* Outline: An array of inferred document sections in order of discovery */
/* starting with the first page and the document title as a minimum. If  */
/* at the end of "printing" there's only that entry, the outline is not  */
/* output to the PDF file.                                               */

typedef struct savepdf_outline_item
{
  const char * title;
  size_t       page_object_number;
}
savepdf_outline_item_t;

static array_t * outline_item_dictionary = NULL;

/* Image information - each page that gets output may include images or */
/* sprites. Two records are kept: One of which images the page used,    */
/* one of which images have been output to the PDF file so far. New     */
/* images/sprites are output after each page.                           */

typedef enum savepdf_image_type
{
  savepdf_image_type_IMAGE,
  savepdf_image_type_SPRITE
}
savepdf_image_type_t;

typedef struct savepdf_image_info
{
  unsigned int         pdf_object_number;
  savepdf_image_type_t type;

  union
  {
    int  image_number;
    char sprite_name[Limits_OS_SpriteName];
  }
  data;
}
savepdf_image_info_t;

static array_t * images_in_page = NULL;
static array_t * images_output  = NULL;

/* When converting Draw files, sprites are read into a big flex block   */
/* that is used as a large sprite area. There may be multiple additions */
/* for multiple sprites in as many Draw files as the page includes. For */
/* each image the counter is incremented and the image name in the PDF  */
/* is based on that counter. No attempt is made to work out if the same */
/* sprite might be cached in RAM more than once or therefore sent to    */
/* the PDF file more than once (since the Draw files include no such    */
/* hints themselves).                                                   */

static int          * draw_sprite_pool  = NULL;
static unsigned int   draw_sprite_count = 0;

/* Prefixes for names used in the PDF file for various kinds of images. */

#define SAVEPDF_IMAGE_XOBJECT_FILE_PREFIX "image_"
#define SAVEPDF_IMAGE_XOBJECT_NAME_PREFIX "sprite_"
#define SAVEPDF_IMAGE_XOBJECT_DRAW_PREFIX "draw_sprite_"

/* Default palettes for converting sprites into PDF file images */

static unsigned int   default_palette_2  [2]   =
                      {
                        0xFFFFFF00, 0x00000000
                      };
static unsigned int   default_palette_4  [4]   =
                      {
                        0xFFFFFF00, 0xBBBBBB00, 0x77777700, 0x00000000
                      };
static unsigned int   default_palette_16 [16]  =
                      {
                        0xFFFFFF00, 0xDDDDDD00, 0xBBBBBB00, 0x99999900,
                        0x77777700, 0x55555500, 0x33333300, 0x00000000,
                        0x99440000, 0x00EEEE00, 0x00CC0000, 0x0000DD00,
                        0xBBEEEE00, 0x00885500, 0x00BBFF00, 0xFFBB0000
                      };

/* Annotation streams lie outside the main page so they don't get clipped. */
/* The redraw region during printing a page may leave annotations that     */
/* 'spill' over the area they were meant to cover as a result, which can,  */
/* in particular at the bottom of pages, cause 'phantom' links. By keeping */
/* a local copy of the current clipping rectangle in user-points we can    */
/* work around this by clipping the annotations internally.                */

static int  current_clip_known = 0;
static BBox current_clip_region;

/* Static function prototypes */

static const char      * savepdf_itoa                        (int number);
static _kernel_oserror * savepdf_write_colour                (unsigned int c, unsigned int stroke);
static _kernel_oserror * savepdf_rectangle_fill              (int x, int y, int w, int h, unsigned int c);
static _kernel_oserror * savepdf_triangle_fill               (int x1, int y1, int x2, int y2, int x3, int y3, unsigned int c);
static _kernel_oserror * savepdf_deflate
                         (
                           FILE     * f,
                           z_stream * stream,
                           Byte     * inbuf,
                           size_t     insize,
                           Byte     * outbuf,
                           size_t     outsize
                         );

static _kernel_oserror * savepdf_draw_to_pdf_bbox
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           int                           x,
                           int                           y,
                           unsigned int                  width,
                           unsigned int                  height
                         );

static _kernel_oserror * savepdf_draw_to_pdf_fonts
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           char               * restrict fontmap,
                           long int                      end_at
                         );

static _kernel_oserror * savepdf_draw_to_pdf_text
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           const char         * restrict fontmap,
                           const BBox         *          ext_bounds,
                           const int          *          ext_matrix,
                           size_t                        size
                         );

static _kernel_oserror * savepdf_draw_to_pdf_text_transformed
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           const char         * restrict fontmap,
                           size_t                        size
                         );

static _kernel_oserror * savepdf_draw_to_pdf_cap_triangle
                         (
                           FILE * pdf,
                           int x1,    int y1,
                           int x2,    int y2,
                           int width, int length,
                           unsigned int colour
                         );

static _kernel_oserror * savepdf_draw_to_pdf_path
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           long int                      end_at
                         );

static _kernel_oserror * savepdf_draw_to_pdf_sprite
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           const BBox         *          ext_bounds,
                           const int          *          ext_matrix,
                           size_t                        size
                         );

static _kernel_oserror * savepdf_draw_to_pdf_sprite_transformed
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           size_t                        size
                         );

static _kernel_oserror * savepdf_record_new_object_address   (void);
static void              savepdf_update_object_address       (size_t objnum, long int address);
static long int          savepdf_read_object_address         (size_t objnum);
static _kernel_oserror * savepdf_record_page_object_number   (size_t page_object_number);
static size_t            savepdf_read_page_object_number     (size_t pagenum);
static _kernel_oserror * savepdf_record_image_in_page
                         (
                           savepdf_image_type_t            type,
                           int                             image_number,
                           const char           * restrict sprite_name
                         );

static int               savepdf_find_image_in_page_array
                         (
                           savepdf_image_type_t            type,
                           int                             image_number,
                           const char           * restrict sprite_name
                         );

static _kernel_oserror * savepdf_record_output_image
                         (
                           unsigned int                    pdf_object_number,
                           savepdf_image_type_t            type,
                           int                             image_number,
                           const char           * restrict sprite_name
                         );

static int               savepdf_find_image_in_output_array
                         (
                           savepdf_image_type_t            type,
                           int                             image_number,
                           const char           * restrict sprite_name
                         );

static _kernel_oserror * savepdf_add_name                    (const char * name, BBox * bounds);
static void              savepdf_update_name                 (unsigned int content_number, unsigned int description_number);
static int               savepdf_name_sort_function          (const void * first, const void * second);
static void              savepdf_sort_names                  (void);
static void              savepdf_delete_names                (void);
static _kernel_oserror * savepdf_add_annotation              (unsigned int uri, const char * link, const BBox * bounds);
static void              savepdf_delete_annotations          (void);
static void              savepdf_update_inferred_section     (unsigned int content_number, unsigned int description_number);
static _kernel_oserror * savepdf_add_outline_item            (const char * title, size_t page_object_number);
static void              savepdf_delete_outline_items        (void);

static int               savepdf_encoding_callback           (void * handle, UCS4 c);
static _kernel_oserror * savepdf_write_string                (const char * restrict s, int encnum_dst);
static _kernel_oserror * savepdf_write_current_date_and_time (void);

/* PDF output redraw primitives */

static _kernel_oserror * savepdf_jmptbl_line
                         (
                           const browser_data * restrict b,
                           const BBox         * restrict ends,
                           unsigned int                  colour,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savepdf_jmptbl_rectangle
                         (
                           const browser_data * restrict b,
                           const BBox         * restrict rect,
                           unsigned int                  colour,
                           unsigned int                  border,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savepdf_jmptbl_triangle
                         (
                           const browser_data * restrict b,
                           int                           x1,
                           int                           y1,
                           int                           x2,
                           int                           y2,
                           int                           x3,
                           int                           y3,
                           unsigned int                  colour,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savepdf_jmptbl_text
                         (
                           const browser_data * restrict b,
                           fm_face                       handle,
                           int                           x,
                           int                           y,
                           const char         * restrict string,
                           unsigned int                  numbytes,
                           unsigned int                  fgcolour,
                           unsigned int                  bgcolour,
                           unsigned int                  blend,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savepdf_jmptbl_image
                         (
                           const browser_data * restrict b,
                           unsigned int                  image,
                           int                           x,
                           int                           y,
                           unsigned int                  width,
                           unsigned int                  height,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savepdf_jmptbl_sprite
                         (
                           const browser_data * restrict b,
                           const char         * restrict name,
                           int                           x,
                           int                           y,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savepdf_jmptbl_clipping
                         (
                           const browser_data * restrict b,
                           const BBox         * restrict desired,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savepdf_jmptbl_section_cb
                         (
                           const browser_data * restrict b,
                           const char         * restrict section,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savepdf_jmptbl_name_cb
                         (
                           const browser_data * restrict b,
                           const char         * restrict name,
                           const BBox         * restrict bounds,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savepdf_jmptbl_link_cb
                         (
                           const browser_data * restrict b,
                           const char         * restrict link,
                           const BBox         * restrict bounds,

                           size_t             * restrict r_size
                         );

/* PDF output redraw table */

static redrawcore_function_table_t rtable_pdf =
                                   {
                                     savepdf_jmptbl_line,
                                     savepdf_jmptbl_rectangle,
                                     savepdf_jmptbl_triangle,
                                     NULL, /* Don't need circles - used for debug only */

                                     savepdf_jmptbl_text,

                                     savepdf_jmptbl_image,
                                     savepdf_jmptbl_sprite,

                                     savepdf_jmptbl_clipping,

                                     savepdf_jmptbl_section_cb,
                                     savepdf_jmptbl_name_cb,
                                     savepdf_jmptbl_link_cb
                                   };

/**************************************************************/
/* savepdf_itoa()                                             */
/*                                                            */
/* Convert an integer in milli-user-space for PDF into a      */
/* string suitable for a PDF file - divide by 1000 and        */
/* express the result as "x.abc" with an appropriate sign.    */
/*                                                            */
/* Parameters: Number to convert.                             */
/*                                                            */
/* Returns:    Pointer to an internal buffer holding the NUL- */
/*             terminated result. Eight rotating buffers are  */
/*             used so up to eight calls may be made in a     */
/*             single go before output gets overwritten.      */
/**************************************************************/

static const char * savepdf_itoa(int number)
{
  static char   buffers[8][20];
  static int    buffer = 0;
  int           div, mod;
  size_t        len;
  char        * r;

  /* Work around CC 5.55 to 5.64 compilation bug where */
  /* "a / 1000, a % 1000" (computing the result in two */
  /* consecutive function arguments) results in the    */
  /* wrong answer for the second calculation, by       */
  /* computing the results into individual variables   */
  /* before passing those to the function call.        */

  if (number < 0)
  {
    div = (-number) / 1000;
    mod = (-number) % 1000;

    sprintf(buffers[buffer], "-%d.%03d", div, mod);
  }
  else
  {
    div = number / 1000;
    mod = number % 1000;

    sprintf(buffers[buffer], "%d.%03d", div, mod);
  }

  /* Trim off trailing zeros */

  len = strlen(buffers[buffer]);
  r   = buffers[buffer] + len - 1;

  while (*r == '0')
  {
    *r-- = '\0';
  }

  /* Trim off a trailing decimal point */

  if (*r == '.') *r = '\0';

  /* Write out the result */

  r = buffers[buffer];
  buffer++;
  if (buffer > 7) buffer = 0;

  return r;
}

/**************************************************************/
/* savepdf_write_colour()                                     */
/*                                                            */
/* Output a fill or line (AKA stroke) colour to the open PDF  */
/* file in 'outfile' followed by a single space.              */
/*                                                            */
/* Parameters: RISC OS colour word, &BBGGRRAA;                */
/*                                                            */
/*             Zero for fill colour, else line colour.        */
/**************************************************************/

static _kernel_oserror * savepdf_write_colour(unsigned int c, unsigned int stroke)
{
  int   r;
  float red, green, blue;

  if (outfile == NULL) return NULL;

  /* Dodgy odd casting arrangements to try and work around */
  /* pointless CC warnings.                                */

  red   = ((float) ((unsigned char) ((c & 0x0000ff00) >>  8))) / 255;
  green = ((float) ((unsigned char) ((c & 0x00ff0000) >> 16))) / 255;
  blue  = ((float) ((unsigned char) ((c & 0xff000000) >> 24))) / 255;

  r = fprintf(outfile,
              "%f %f %f %s ",

              red,
              green,
              blue,
              stroke ? "RG" : "rg");

  if (r < 0) RetLastE;
  return NULL;
}

/**************************************************************/
/* savepdf_rectangle_fill()                                   */
/*                                                            */
/* Output a filled rectangle.                                 */
/*                                                            */
/* Parameters: x position of the item in PDF user space;      */
/*                                                            */
/*             y position of the item in PDF user space;      */
/*                                                            */
/*             Item's width in PDF user space;                */
/*                                                            */
/*             Item's height in PDF user space;               */
/*                                                            */
/*             Colour of the rectangle.                       */
/**************************************************************/

static _kernel_oserror * savepdf_rectangle_fill(int x, int y, int w, int h, unsigned int c)
{
  int r;

  if (outfile == NULL) return NULL;

  RetError(savepdf_write_colour(c, 0));

  /* Set line width to zero. The line shouldn't be stroked  */
  /* but zero width ensures this and makes sure that viewer */
  /* apps don't get worried about bounding boxes including  */
  /* the line width, or similar. Then move to the bottom    */
  /* left corner.                                           */

  r = fprintf(outfile,
              "0 w %s %s m ",

              savepdf_itoa(x), savepdf_itoa(y));

  if (r < 0) RetLastE;

  /* Line to top left */

  r = fprintf(outfile,
              "%s %s l ",

              savepdf_itoa(x), savepdf_itoa(y + h - 1));

  if (r < 0) RetLastE;

  /* Line to the top right */

  r = fprintf(outfile,
              "%s %s l ",

              savepdf_itoa(x + w - 1), savepdf_itoa(y + h - 1));

  if (r < 0) RetLastE;

  /* Line to the bottom right and close the path */

  r = fprintf(outfile,
              "%s %s l h ",

              savepdf_itoa(x + w - 1), savepdf_itoa(y));

  if (r < 0) RetLastE;

  /* Fill the path to finis */

  r = fprintf(outfile, "f\n");
  if (r < 0) RetLastE;

  return NULL;
}

/**************************************************************/
/* savepdf_triangle_fill()                                    */
/*                                                            */
/* Output a filled triangle.                                  */
/*                                                            */
/* Parameters: x and y coordinates of the three vertices, in  */
/*             PDF user space;                                */
/*                                                            */
/*             Colour of the triangle.                        */
/**************************************************************/

static _kernel_oserror * savepdf_triangle_fill(int x1, int y1, int x2, int y2, int x3, int y3, unsigned int c)
{
  int r;

  if (outfile == NULL) return NULL;

  RetError(savepdf_write_colour(c, 0));

  /* Set line width to zero. The line shouldn't be stroked  */
  /* but zero width ensures this and makes sure that viewer */
  /* apps don't get worried about bounding boxes including  */
  /* the line width, or similar. Move to the first corner.  */
  /* Draw lines between all three and fill the result.      */

  r = fprintf(outfile,
              "0 w %s %s m %s %s l %s %s l h f\n",

              savepdf_itoa(x1), savepdf_itoa(y1),
              savepdf_itoa(x2), savepdf_itoa(y2),
              savepdf_itoa(x3), savepdf_itoa(y3));

  if (r < 0) RetLastE;

  return NULL;
}

/**************************************************************/
/* savepdf_deflate()                                          */
/*                                                            */
/* Compress a block of data using ZLib. Send the result to    */
/* the given file. A temporary output buffer is used for the  */
/* compressed data, which can be of arbitrary size, though    */
/* a size similar to or larger than the input buffer is       */
/* recommended for best performance.                          */
/*                                                            */
/* Parameters: Pointer to a FILE * for the output file;       */
/*                                                            */
/*             Pointer to a z_stream structure to use - it is */
/*             assumed that the ZLib library has already      */
/*             initialised this because the caller has made   */
/*             an earlier call to deflateInit;                */
/*                                                            */
/*             Pointer to the input buffer;                   */
/*                                                            */
/*             Amount of data in input buffer - when you have */
/*             finished with all data, make a final call with */
/*             the input size set to zero to ensure ZLib is   */
/*             told to flush any remaining data out;          */
/*                                                            */
/*             Pointer to the temporary output buffer;        */
/*                                                            */
/*             Size of temporary output buffer.               */
/**************************************************************/

static _kernel_oserror * savepdf_deflate
                         (
                           FILE     * f,
                           z_stream * stream,
                           Byte     * inbuf,
                           size_t     insize,
                           Byte     * outbuf,
                           size_t     outsize
                         )
{
  int    error;
  size_t write, written;

  stream->next_in  = inbuf;
  stream->avail_in = insize;

  do
  {
    stream->next_out  = outbuf;
    stream->avail_out = outsize;

    /* If we've read nothing, we're at the end of the input stream so */
    /* start telling deflate to finish up with Z_FINISH rather than   */
    /* Z_NO_FLUSH                                                     */

    error = deflate(stream, insize ? Z_NO_FLUSH : Z_FINISH);
    if (error != 0 && error != Z_STREAM_END) return make_general_error(SAVEPDF_ZLIB_ERROR, NULL);

    /* Write the compressed data to the given output file. */

    write   = outsize - stream->avail_out;
    written = fwrite(outbuf, 1, write, f);

    if (written != write) RetLastE;

    /* Loop termination conditions are: If we're *not* trying to flush */
    /* out remaining data (non-zero insize), keep going until there is */
    /* no more available input data, provided there is no error. If we */
    /* *are* trying to flush, keep going until Z_STREAM_END is given.  */
  }
  while (
          (insize  > 0 && error == 0 && stream->avail_in > 0) ||
          (insize == 0 && error != Z_STREAM_END)
        );

  return NULL;
}

/**************************************************************/
/* savepdf_sprite_file_to_pdf()                               */
/*                                                            */
/* Write a sprite file into a PDF file as an XObject (subtype */
/* Image) in 24bpp with ZLib compression.                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the sprite to be translated;                   */
/*                                                            */
/*             Filename of the sprite;                        */
/*                                                            */
/*             The Images.c image array number for the parent */
/*             image that was used to dump out the sprite;    */
/*                                                            */
/*             Pointer to a size_t, which if non-NULL will be */
/*             updated with the amount of data that *would*   */
/*             be written without writing anything, else if   */
/*             NULL produces normal output to a file.         */
/*             (NOT YET IMPLEMENTED).                         */
/**************************************************************/

_kernel_oserror * savepdf_sprite_file_to_pdf
                  (
                    const browser_data * restrict b,
                    const char         * restrict file_name,
                    int                           image,
                    size_t             * restrict r_size
                  )
{
  static int      * sprite_flex_data = NULL;

  _kernel_oserror * e;
  FILE            * f;
  size_t            size, got;
  int               ok, oldbudge;

  size_t            name_len;
  char              name[Limits_OS_SpriteName];

  if (r_size != NULL)
  {
    *r_size = 0; // NOT YET IMPLEMENTED
    return NULL;
  }

  if (outfile == NULL) return NULL;

  /* Allocate space for the sprite in the Flex heap */
  /* plus 4 bytes for an extra word at the start    */

  f = fopen(file_name, "rb");
  if (f == NULL) RetLastE;

  fseek(f, 0, SEEK_END);
  size = (size_t) ftell(f);
  fseek(f, 0, SEEK_SET);

  if (sprite_flex_data != NULL)
  {
    flex_free((flex_ptr) &sprite_flex_data);
    sprite_flex_data = NULL;
  }

  ok = flex_alloc((flex_ptr) &sprite_flex_data, size + 4);
  if (!ok) return make_no_memory_error(46);

  /* Load the file at an offset of 1 word into the */
  /* block, then close it                          */

  oldbudge = flex_set_budge(0);
  got      = fread(sprite_flex_data + 1, 1, size, f);

  if (got != size)
  {
    flex_set_budge(oldbudge);
    flex_free((flex_ptr) &sprite_flex_data);
    sprite_flex_data = NULL;

    RetLastE;
  }

  fclose(f);

  /* Set the first word to the total area size to create */
  /* a properly defined sprite area                      */

  sprite_flex_data[0] = size + 4;

  /* Get the name of the first sprite in the pool */

  e = _swix(OS_SpriteOp,
            _INR(0,4) | _OUT(3),

            0x10D,
            sprite_flex_data,
            name,
            sizeof(name),
            1,

            &name_len);

  if (e == NULL)
  {
    name[name_len] = '\0';

    /* Write the data to the PDF file */

    e = savepdf_sprite_name_to_pdf(b,
                                   sprite_flex_data,
                                   name,
                                   r_size);
  }

  /* Tidy up flex data */

  flex_set_budge(oldbudge);
  flex_free((flex_ptr) &sprite_flex_data);
  sprite_flex_data = NULL;

  /* All done */

  return e;
}

/**************************************************************/
/* savepdf_sprite_name_to_pdf()                               */
/*                                                            */
/* Write a sprite into a PDF file as an XObject (subtype      */
/* Image) in 24bpp with ZLib compression.                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the sprite to be translated;                   */
/*                                                            */
/*             Pointer to the sprite area holding the sprite; */
/*                                                            */
/*             Pointer to the NUL-terminated sprite name;     */
/*                                                            */
/*             Pointer to a size_t, which if non-NULL will be */
/*             updated with the amount of data that *would*   */
/*             be written without writing anything, else if   */
/*             NULL produces normal output to a file.         */
/*             (NOT YET IMPLEMENTED).                         */
/**************************************************************/

_kernel_oserror * savepdf_sprite_name_to_pdf
                  (
                    const browser_data * restrict b,
                    const void         * restrict sprite_area,
                    const char         * restrict sprite_name,
                    size_t             * restrict r_size
                  )

{
  _kernel_oserror * e;
  int               r;

  unsigned int      w, h, mask, mode, log2bpp, use_tint = 0;
  unsigned int      x, y, colour, tint, red, green, blue;
  unsigned int    * addr;
  unsigned int      palette [256];

  Byte              inbuf   [12288]; /* Must be a multiple of 3 */
  Byte              outbuf  [12424]; /* Arbitrary, but insize + 0.1% + 12 is fairly optimal - see ZLib.h */
  z_stream          stream;
  int               zlib_ok = 0;
  int               error;
  int               index;

  if (r_size != NULL)
  {
    *r_size = 0; // NOT YET IMPLEMENTED
    return NULL;
  }

  if (outfile == NULL) return NULL;

  /* Find the named sprite's address */

  e = _swix(OS_SpriteOp,
            _INR(0,2) | _OUT(2),

            0x118,
            sprite_area,
            sprite_name,

            &addr);

  if (e != NULL) goto savepdf_sprite_name_to_pdf_error;

  /* Read basic sprite information */

  e = _swix(OS_SpriteOp,
            _INR(0,2) | _OUTR(3,6),

            0x228,
            sprite_area,
            addr,

            &w, &h, &mask, &mode);

  if (e != NULL) goto savepdf_sprite_name_to_pdf_error;

  /* Read the sprite colour depth */

  e = _swix(OS_ReadModeVariable,
            _INR(0,1) | _OUT(2),

            mode,
            BBC_Log2BPP, /* FromROSLib.h */

            &log2bpp);

  if (e != NULL) goto savepdf_sprite_name_to_pdf_error;

  /* Image header */

  e = savepdf_record_new_object_address();
  if (e != NULL) goto savepdf_sprite_name_to_pdf_error;

  r = fprintf(outfile,

              "%%\n"
              "%% Bitmap image\n"
              "%%\n"
              "\n"
              "%d 0 obj\n"
              "<<\n"
              "  /Type             /XObject\n"
              "  /Subtype          /Image\n"
              "  /Width            %u\n"
              "  /Height           %u\n"
              "  /BitsPerComponent 8\n"
              "  /ColorSpace       /DeviceRGB\n"
              "  /Filter           /FlateDecode\n"
              "  /Length           %u 0 R\n",

              objctr,
              w, h,
              objctr + 1);

  if (r < 0)
  {
    StrLastE;
    e = &erb;
    goto savepdf_sprite_name_to_pdf_error;
  }

  /* Is there a mask? */

  if (mask)
  {
    r = fprintf(outfile, "  /Mask             %u 0 R\n",
                         objctr + 2);

    if (r < 0)
    {
      StrLastE;
      e = &erb;
      goto savepdf_sprite_name_to_pdf_error;
    }
  }

  /* End the dictionary and start the stream */

  r = fprintf(outfile, ">>\n"
                       "stream\n");

  if (r < 0)
  {
    StrLastE;
    e = &erb;
    goto savepdf_sprite_name_to_pdf_error;
  }

  /* Read the sprite palette - it will have up to 256 */
  /* entries, so palette[] is a 256 word array.       */

  if (log2bpp < 4)
  {
    int entries;

    /* First, does the sprite have a true colour palette? */

    e = _swix(OS_SpriteOp,
              _INR(0,3) | _OUT(3),

              0x225,
              sprite_area,
              addr,
              -1,

              &entries);

    if (e != NULL) goto savepdf_sprite_name_to_pdf_error;

    /* If we have 0, there's no palette. If we have 64,  */
    /* there is an old-style 256 colour palette. In both */
    /* cases we use a default Wimp-style/old 256 fixed   */
    /* table. Otherwise, we ask ColourTrans to read the  */
    /* full palette information for us.                  */

    if (entries == 0 || entries == 64)
    {
      switch (log2bpp)
      {
        case 3: use_tint = 1; break; /* Note that 256 colour sprites will return 2-bit RGB plus tint data */
        case 2: memcpy(palette, default_palette_16, sizeof(default_palette_16)); break;
        case 1: memcpy(palette, default_palette_4,  sizeof(default_palette_4));  break;
        case 0: memcpy(palette, default_palette_2,  sizeof(default_palette_2));  break;
      }
    }
    else
    {
      e = _swix(ColourTrans_ReadPalette,
                _INR(0,4),

                sprite_area,
                addr,
                palette,
                sizeof(palette),
                (1u<<0)); /* Flag indicates a sprite address in R1 rather than a name */

      if (e != NULL) goto savepdf_sprite_name_to_pdf_error;
    }
  }

  /* Wake up ZLib */

  stream.zalloc = Z_NULL;
  stream.zfree  = Z_NULL;
  stream.opaque = Z_NULL;

  /* Initialise the deflate engine */

  error = deflateInit(&stream, Z_DEFAULT_COMPRESSION);

  if (error)
  {
    e = make_general_error(SAVEPDF_ZLIB_ERROR, NULL);
    goto savepdf_sprite_name_to_pdf_error;
  }
  else
  {
    zlib_ok = 1;
  }

  /* Image data */

  index = 0;

  for (y = 0; y < h; y++)
  {
    for (x = 0; x < w; x++)
    {
      /* Read the pixel colour in a sprite-dependent form */

      e = _swix(OS_SpriteOp,
                _INR(0,4) | _OUTR(5,6),

                0x229,
                sprite_area,
                addr,
                x,
                h - y - 1, /* Sprites put (0,0) bottom left; PDF images, top left */

                &colour,
                &tint);

      if (e != NULL) goto savepdf_sprite_name_to_pdf_error;

      switch (log2bpp)
      {
        case 3: /* Drop through */
        case 2: /* Drop through */
        case 1: /* Drop through */
        case 0:
        {
          if (use_tint == 0)
          {
            int max;

            /* Look up a palette entry */

            switch (log2bpp)
            {
              default:
              case 3: max = 255; break;
              case 2: max = 15;  break;
              case 1: max = 3;   break;
              case 0: max = 1;   break;
            }

            if (colour > max) colour = max;

            red   = (palette[colour] & 0xFF00)     >> 8;
            green = (palette[colour] & 0xFF0000)   >> 16;
            blue  = (palette[colour] & 0xFF000000) >> 24;
          }
          else
          {
            /* Old-style 2-bit red, green, blue plus tint */

            red   = (((colour & 3)  << 2) + tint) * 17;
            green = (((colour & 12))      + tint) * 17;
            blue  = (((colour & 48) >> 2) + tint) * 17;
          }
        }
        break;

        case 4:
        {
          /* Grotty 5 bits/channel to 8 bits/channel conversion */

          red   = (((colour & 0x1f))         * 255) / 31;
          green = (((colour & 0x3e0)  >> 5)  * 255) / 31;
          blue  = (((colour & 0x7c00) >> 10) * 255) / 31;
        }
        break;

        default:
        case 5:
        {
          /* Simple packed RGB */

          red   = (colour & 0xff);
          green = (colour & 0xff00)   >> 8;
          blue  = (colour & 0xff0000) >> 16;
        }
        break;
      }

      /* Paranoid RGB limiting */

      if (red   > 255) red   = 255;
      if (green > 255) green = 255;
      if (blue  > 255) blue  = 255;

      /* Store the R, G and B bytes */

      inbuf[index++] = red;
      inbuf[index++] = green;
      inbuf[index++] = blue;

      /* If we've filled up a chunk, compress it */

      if (index >= sizeof(inbuf))
      {
        e = savepdf_deflate(outfile,
                            &stream,
                            inbuf,
                            sizeof(inbuf),
                            outbuf,
                            sizeof(outbuf));

        if (e != NULL) goto savepdf_sprite_name_to_pdf_error;
        else index = 0;
      }
    }
  }

  /* Compress any remaining buffered data */

  if (index > 0)
  {
    e = savepdf_deflate(outfile,
                        &stream,
                        inbuf,
                        index,
                        outbuf,
                        sizeof(outbuf));

    if (e != NULL) goto savepdf_sprite_name_to_pdf_error;
    else index = 0;
  }

  /* Flush any remaining compressed information out */

  e = savepdf_deflate(outfile,
                      &stream,
                      inbuf,
                      0,
                      outbuf,
                      sizeof(outbuf));

  if (e != NULL) goto savepdf_sprite_name_to_pdf_error;
  else index = 0;

  /* Image trailer */

  r = fprintf(outfile,
              "\n"
              "endstream\n"
              "endobj\n\n");

  if (r < 0)
  {
    StrLastE;
    e = &erb;
    goto savepdf_sprite_name_to_pdf_error;
  }

  /* Length of the image stream data */

  e = savepdf_record_new_object_address();
  if (e != NULL) goto savepdf_sprite_name_to_pdf_error;

  r = fprintf(outfile, "%%\n"
                       "%% Length of bitmap data\n"
                       "%%\n\n"
                       "%d 0 obj\n"
                       "%u\n"
                       "endobj\n\n",

                       objctr,
                       (size_t) stream.total_out);

  if (r < 0) RetLastE;

  /* Well, that was hard enough - but what about the mask? */

  if (mask)
  {
    Byte byte;

    /* Shut down ZLib */

    if (zlib_ok)
    {
      (void) deflateEnd(&stream);
      zlib_ok = 0;
    }

    /* Mask image header */

    e = savepdf_record_new_object_address();
    if (e != NULL) goto savepdf_sprite_name_to_pdf_error;

    r = fprintf(outfile,

                "%%\n"
                "%% Image mask\n"
                "%%\n"
                "\n"
                "%d 0 obj\n"
                "<<\n"
                "  /Type             /XObject\n"
                "  /Subtype          /Image\n"
                "  /Width            %u\n"
                "  /Height           %u\n"
                "  /BitsPerComponent 1\n"
                "  /ImageMask        true\n"
                "  /Filter           /FlateDecode\n"
                "  /Length           %u 0 R\n"
                ">>\n"
                "stream\n",

                objctr,
                w, h,
                objctr + 1);

    if (r < 0)
    {
      StrLastE;
      e = &erb;
      goto savepdf_sprite_name_to_pdf_error;
    }

    /* Wake ZLib up again */

    stream.zalloc = Z_NULL;
    stream.zfree  = Z_NULL;
    stream.opaque = Z_NULL;

    /* Initialise the deflate engine */

    error = deflateInit(&stream, Z_BEST_COMPRESSION);

    if (error)
    {
      e = make_general_error(SAVEPDF_ZLIB_ERROR, NULL);
      goto savepdf_sprite_name_to_pdf_error;
    }
    else
    {
      zlib_ok = 1;
    }

    /* Mask data */

    index = 0;
    byte  = 0;

    for (y = 0; y < h; y++)
    {
      for (x = 0; x < w; x++)
      {
        /* Read the mask state at the current coordinates */

        e = _swix(OS_SpriteOp,
                  _INR(0,4) | _OUT(5),

                  0x22B,
                  sprite_area,
                  addr,
                  x,
                  h - y - 1, /* Sprites put (0,0) bottom left; PDF images, top left */

                  &colour); /* 0 = transparent, 1 = solid */

        if (e != NULL) goto savepdf_sprite_name_to_pdf_error;

        /* To keep to the PDF default decode for masks to increase */
        /* the chances of viewers working OK, we have to swap the  */
        /* meaning of transparent and solid.                       */

        if (colour == 0) byte |= (1u << (7 - (x % 8)));

        /* Shuffle the byte into the store? */

        if (x % 8 == 7)
        {
          inbuf[index++] = byte;
          byte           = 0;

          /* If we've filled up a chunk, compress it */

          if (index >= sizeof(inbuf))
          {
            e = savepdf_deflate(outfile,
                                &stream,
                                inbuf,
                                sizeof(inbuf),
                                outbuf,
                                sizeof(outbuf));

            if (e != NULL) goto savepdf_sprite_name_to_pdf_error;
            else index = 0;
          }
        }
      }

      /* End of a row. If it wasn't a multiple of 8 bits, push the last */
      /* trailing byte out.                                             */

      if (w % 8 != 0)
      {
        inbuf[index++] = byte;
        byte           = 0;

        /* If we've filled up a chunk, compress it */

        if (index >= sizeof(inbuf))
        {
          e = savepdf_deflate(outfile,
                              &stream,
                              inbuf,
                              sizeof(inbuf),
                              outbuf,
                              sizeof(outbuf));

          if (e != NULL) goto savepdf_sprite_name_to_pdf_error;
          else index = 0;
        }
      }
    }

    /* Compress any remaining buffered data */

    if (index > 0)
    {
      e = savepdf_deflate(outfile,
                          &stream,
                          inbuf,
                          index,
                          outbuf,
                          sizeof(outbuf));

      if (e != NULL) goto savepdf_sprite_name_to_pdf_error;
      else index = 0;
    }

    /* Flush any remaining compressed information out */

    e = savepdf_deflate(outfile,
                        &stream,
                        inbuf,
                        0,
                        outbuf,
                        sizeof(outbuf));

    if (e != NULL) goto savepdf_sprite_name_to_pdf_error;
    else index = 0;

    /* Image trailer */

    r = fprintf(outfile,
                "\n"
                "endstream\n"
                "endobj\n\n");

    if (r < 0)
    {
      StrLastE;
      e = &erb;
      goto savepdf_sprite_name_to_pdf_error;
    }

    /* Length of the image stream data */

    e = savepdf_record_new_object_address();
    if (e != NULL) goto savepdf_sprite_name_to_pdf_error;

    r = fprintf(outfile, "%%\n"
                         "%% Length of mask data\n"
                         "%%\n\n"
                         "%d 0 obj\n"
                         "%u\n"
                         "endobj\n\n",

                         objctr,
                         (size_t) stream.total_out);

    if (r < 0) RetLastE;
  }

  /* Drop through to common exit code with no error */

  e = NULL;

savepdf_sprite_name_to_pdf_error:

  /* Shut down ZLib */

  if (zlib_ok) (void) deflateEnd(&stream);

  /* Finished */

  return e;
}

/**************************************************************/
/* savepdf_draw_to_pdf_bbox()                                 */
/*                                                            */
/* Push the PDF graphics context onto the stack and output a  */
/* transformation matrix to position and scale a Draw file on */
/* the page. The file pointer in the Draw file must be        */
/* positioned to just before the overall file bounding box.   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Draw and PDF files;                        */
/*                                                            */
/*             Pointer to a FILE * for the output PDF file;   */
/*                                                            */
/*             Pointer to a FILE * for the input Draw file;   */
/*                                                            */
/*             X coordinate for Draw file on PDF output page, */
/*             user-points;                                   */
/*                                                            */
/*             Y coordinate, user-points;                     */
/*                                                            */
/*             Width to which to scale Draw file on PDF       */
/*             output page, user-points;                      */
/*                                                            */
/*             Height, user-points.                           */
/**************************************************************/

static _kernel_oserror * savepdf_draw_to_pdf_bbox
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           int                           x,
                           int                           y,
                           unsigned int                  width,
                           unsigned int                  height
                         )
{
  int    r;
  BBox   overall;
  double xscale, yscale;

  if (fread(&overall, 1, 16, draw) != 16) RetLastE;

  scale_box_draw_to_user (b, &overall, &overall);
  scale_box_user_to_pdf  (b, &overall, &overall);

  /* Write a graphics context that will scale and translate the */
  /* Draw object to the correct location                        */

  scale_pair_user_to_pdf (b, x,     y,      &x,             &y);
  scale_pair_user_to_pdf (b, width, height, (int *) &width, (int *) &height);

  if (width == 0  || overall.xmax - overall.xmin == 0) xscale = 1;
  else                                                 xscale = (double) width  / ((double) overall.xmax - (double) overall.xmin);

  if (height == 0 || overall.ymax - overall.ymin == 0) yscale = 1;
  else                                                 yscale = (double) height / ((double) overall.ymax - (double) overall.ymin);

  r = fprintf(pdf, "q %f 0 0 %f %s %s cm\n",

                   xscale,
                   yscale,
                   savepdf_itoa((int) (x - (overall.xmin * xscale))),
                   savepdf_itoa((int) (y - (overall.ymin * yscale))));

  if (r < 0) RetLastE;
  else return NULL;
}

/**************************************************************/
/* savepdf_draw_to_pdf_fonts()                                */
/*                                                            */
/* Read a Draw font list object and use it to construct a map */
/* between PDF and Draw font numbers. The file pointer in the */
/* Draw file must be positioned to just after the type and    */
/* size word for the font list object.                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Draw and PDF files;                        */
/*                                                            */
/*             Pointer to a FILE * for the output PDF file;   */
/*                                                            */
/*             Pointer to a FILE * for the input Draw file;   */
/*                                                            */
/*             Pointer to a 256-element char array holding    */
/*             mappings to PDF font numbers - this will be    */
/*             updated so that if a Draw font number is used  */
/*             as an index, the element at that index gives   */
/*             the equivalent PDF font number. Unrecognised   */
/*             Draw fonts are ignored. Initialise the map     */
/*             before entry with whatever mapping you want as */
/*             a default for unaltered entries due to unused  */
/*             or otherwise unmapped Draw fonts;              */
/*                                                            */
/*             File pointer giving offset of next object      */
/*             immediately after the font list object.        */
/**************************************************************/

static _kernel_oserror * savepdf_draw_to_pdf_fonts
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           char               * restrict fontmap,
                           long int                      end_at
                         )
{
  char name[256]; /* Hmmm, arbitrary limit alert */

  (void) b; /* Not used at the moment */

  while (ftell(draw) < end_at)
  {
    /* Read the font number byte */

    int    fontnum = fgetc(draw);

    /* Read the font name */

    char * nameptr = name;
    char   got;

    do
    {
      got          = fgetc(draw);
      *(nameptr++) = got;
    }
    while (got && nameptr - name < sizeof(name));

    /* Find the name in the font map and set the index into */
    /* the font name array in the map if it is found.       */

    for (
          int i = 0;
          i < sizeof(font_name_map) / sizeof(*font_name_map);
          i++
        )
    {
      if (!strcmp(font_name_map[i].riscos_name, name))
      {
        fontmap[fontnum] = i;
        break;
      }
    }
  }

  return NULL;
}

/**************************************************************/
/* savepdf_draw_to_pdf_text()                                 */
/*                                                            */
/* Read a Draw text object and write the equivalent to a      */
/* PDF file. The file pointer in the Draw file must be        */
/* positioned to just after the type and size word for the    */
/* text object or, if a bounding box is supplied, just before */
/* the text foreground colour field in the text object.       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Draw and PDF files;                        */
/*                                                            */
/*             Pointer to a FILE * for the output PDF file;   */
/*                                                            */
/*             Pointer to a FILE * for the input Draw file;   */
/*                                                            */
/*             Pointer to a 256-element char array holding    */
/*             mappings to PDF font numbers - a Draw font     */
/*             number is used as an index, the element at     */
/*             that index giving the equivalent PDF font      */
/*             number - this is either constructed from a     */
/*             font table in the Draw file or initialised to  */
/*             some default mapping;                          */
/*                                                            */
/*             NULL to read a bounding box from the Draw file */
/*             else use the supplied bounding box pointer for */
/*             the information;                               */
/*                                                            */
/*             NULL for no transformation matrix, else a      */
/*             pointer to the 6-word matrix with 16.16 fixed  */
/*             point multipliers and the X and Y offset in    */
/*             the last two words converted to user-points;   */
/*                                                            */
/*             Total size in bytes of the text object that is */
/*             being converted.                               */
/**************************************************************/

static _kernel_oserror * savepdf_draw_to_pdf_text
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           const char         * restrict fontmap,
                           const BBox         *          ext_bounds,
                           const int          *          ext_matrix,
                           size_t                        size
                         )
{
  int            r;
  BBox           local_bounds;
  const BBox   * bounds;
  unsigned int   fg_colour;
  unsigned int   bg_colour;
  unsigned int   font;
  unsigned int   x_size;
  unsigned int   y_size;
  unsigned int   scale;
  int            x;
  int            y;
  char         * strptr;
  char           got;

  /* Read the bounding box, or use the supplied pointer. */
  /* At the moment we don't actually use it though!      */

  if (ext_bounds == NULL)
  {
    if (fread(&local_bounds, 1, 16, draw) != 16) RetLastE;
    bounds = &local_bounds;
  }
  else
  {
    bounds = ext_bounds;
  }

  /* Read general information */

  if (fread(&fg_colour, 1, 4, draw) != 4) RetLastE;
  if (fread(&bg_colour, 1, 4, draw) != 4) RetLastE;
  if (fread(&font,      1, 4, draw) != 4) RetLastE;
  if (fread(&x_size,    1, 4, draw) != 4) RetLastE;
  if (fread(&y_size,    1, 4, draw) != 4) RetLastE;
  if (fread(&x,         1, 4, draw) != 4) RetLastE;
  if (fread(&y,         1, 4, draw) != 4) RetLastE;

  /* Get the string. 52 = 24 bytes object header plus the 28 */
  /* bytes of information read above.                        */

  char string[size - 52]; /* Woo, yay, C99 */

  strptr = string;

  do
  {
    got         = fgetc(draw);
    *(strptr++) = got;
  }
  while (got && strptr - string < sizeof(string));

  /* Work out the width scaling */

  scale = (100 * x_size) / y_size;

  /* Convert the Y size and plot coordinates to PDF user space */

  y_size = scale_draw_to_user (b, y_size);
  x      = scale_draw_to_user (b, x);
  y      = scale_draw_to_user (b, y);

  if (ext_matrix)
  {
    x += ext_matrix[4];
    y += ext_matrix[5];
  }

  y_size = scale_user_to_pdf  (b, y_size);
  x      = scale_user_to_pdf  (b, x);
  y      = scale_user_to_pdf  (b, y);

  /* Start the text object and set the font and font size, */
  /* then state the plot coordinates.                      */

  if (ext_matrix == NULL)
  {
    r = fprintf(outfile, "BT\n"
                         "  /F%d %s Tf %d Tz %s %s Td\n"
                         "  ",

                         fontmap[font],
                         savepdf_itoa(y_size),
                         scale,
                         savepdf_itoa(x),
                         savepdf_itoa(y));
  }
  else
  {
    r = fprintf(outfile, "BT\n"
                         "  /F%d %s Tf %d Tz %f %f %f %f %s %s Tm\n"
                         "  ",

                         fontmap[font],
                         savepdf_itoa(y_size),
                         scale,
                         (double) ext_matrix[0] / 65536,
                         (double) ext_matrix[1] / 65536,
                         (double) ext_matrix[2] / 65536,
                         (double) ext_matrix[3] / 65536,
                         savepdf_itoa(x),
                         savepdf_itoa(y));
  }

  if (r < 0) RetLastE;

  /* Set the colour */

  RetError(savepdf_write_colour(fg_colour, 0));

  /* Output the string just after the colour specifier */

  RetError(savepdf_write_string(string, csWindows1252));

  /* Write the painting operator and close the text object */

  r = fprintf(outfile, " Tj\n"
                       "ET\n");

  if (r < 0) RetLastE;
  else return NULL;
}

/**************************************************************/
/* savepdf_draw_to_pdf_text_transformed()                     */
/*                                                            */
/* Read a Draw transformed text object and write the          */
/* equivalent to a PDF file. The file pointer in the Draw     */
/* file must be positioned to just after the type and size    */
/* word for the transformed text object.                      */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Draw and PDF files;                        */
/*                                                            */
/*             Pointer to a FILE * for the output PDF file;   */
/*                                                            */
/*             Pointer to a FILE * for the input Draw file;   */
/*                                                            */
/*             Pointer to a 256-element char array holding    */
/*             mappings to PDF font numbers - a Draw font     */
/*             number is used as an index, the element at     */
/*             that index giving the equivalent PDF font      */
/*             number - this is either constructed from a     */
/*             font table in the Draw file or initialised to  */
/*             some default mapping;                          */
/*                                                            */
/*             Total size in bytes of the text object that is */
/*             being converted.                               */
/**************************************************************/

static _kernel_oserror * savepdf_draw_to_pdf_text_transformed
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           const char         * restrict fontmap,
                           size_t                        size
                         )
{
  BBox         bounds;
  int          matrix[6];
  unsigned int font_flags;

  /* Read general information */

  if (fread(&bounds,     1, 16, draw) != 16) RetLastE;
  if (fread(&matrix,     1, 24, draw) != 24) RetLastE;
  if (fread(&font_flags, 1, 4,  draw) != 4)  RetLastE;

  scale_pair_draw_to_user (b, matrix[4], matrix[5], &matrix[4], &matrix[5]);
  scale_pair_user_to_pdf  (b, matrix[4], matrix[5], &matrix[4], &matrix[5]);

  /* Do the text part of the object, adjusting the 'size' value */
  /* for the extra data for the transformation information and  */
  /* giving the transformation matrix adjustments in passing.   */

  return savepdf_draw_to_pdf_text(b,
                                  pdf,
                                  draw,
                                  fontmap,
                                  &bounds,
                                  matrix,
                                  size - 28);
}

/**************************************************************/
/* savepdf_draw_to_pdf_cap_triangle()                         */
/*                                                            */
/* Draw a triangular cap at the end of a line going from a    */
/* given point, to a given point (the cap drawn at this last  */
/* point).                                                    */
/*                                                            */
/* Parameters: X and Y coordinate of line start in PDF user   */
/*             space;                                         */
/*                                                            */
/*             X and Y coordinate of line end in PDF user     */
/*             space;                                         */
/*                                                            */
/*             Width in PDF user space units of the back edge */
/*             of the triangular cap, as a distance from the  */
/*             line middle to the back corners;               */
/*                                                            */
/*             Length in PDF user space units of the point of */
/*             the triangle, as a distance from the end point */
/*             of the line;                                   */
/*                                                            */
/*             Colour of cap in &BBGGRRAA format.             */
/**************************************************************/

static _kernel_oserror * savepdf_draw_to_pdf_cap_triangle
                         (
                           FILE * pdf,
                           int x1,    int y1,
                           int x2,    int y2,
                           int width, int length,
                           unsigned int colour
                         )
{
  /* We need to work out the angle of the line from its start to its */
  /* end point. If we draw the line as follows, we can form a right- */
  /* angled triangle around it with the line forming the hypotenuse. */
  /* We can then use the arctangent of the lengths of the two other  */
  /* sides to get at the angle of the line around its start point.   */
  /* Handily, math.h provides the "atan2" function which is designed */
  /* exactly for this purpose and uses the sign of the arguments to  */
  /* work out the angle over a full circle (otherwise we'd have to   */
  /* determine which quadrant of the circle the line lay in).        */

  int    r;

  double theta;
  int    anglew = x2 - x1;
  int    angleh = y2 - y1;

  double tipx,   tipy;
  double backx1, backy1;
  double backx2, backy2;

  /* If the line has no length, it has no direction, so we cannot do */
  /* the triangle cap.                                               */

  if (anglew == 0 && angleh == 0) return NULL;
  else theta = atan2((double) angleh, (double) anglew);

  /* The point of the triangle extends from the line by the triangle */
  /* length value. Its coordinates are given by (cos, sin) of theta, */
  /* which produces an answer based on a unit circle centred around  */
  /* (0,0) - so scale and translate this result.                     */

  tipx = ((double) length * cos(theta)) + x2;
  tipy = ((double) length * sin(theta)) + y2;

  /* The triangular cap's straight back edge runs perpendicular to   */
  /* the line; add 90 degrees = PI/2 radians to get its angle.       */

  theta += SAVEPDF_PI / 2;

  /* Find one end of the back edge in the same way as for its point; */
  /* then add another 180 degrees (PI radians) to get the other.     */

  backx1 = ((double) width * cos(theta)) + x2;
  backy1 = ((double) width * sin(theta)) + y2;

  theta += SAVEPDF_PI;

  backx2 = ((double) width * cos(theta)) + x2;
  backy2 = ((double) width * sin(theta)) + y2;

  /* To try and be sure we anchor the tip in the right place the cap */
  /* is formed from four sections - from line end to back edge first */
  /* corner, then to the tip, then to the other corner, then back to */
  /* the line end (this last phase implicit, by closing the path at  */
  /* the point it is filled).                                        */

  r = fprintf(pdf, "  q 0 w ");
  if (r < 0) RetLastE;

  RetError(savepdf_write_colour(colour, 0));

  r = fprintf(pdf, "%s %s m %s %s l %s %s l %s %s l f Q\n",
                   savepdf_itoa(x2),           savepdf_itoa(y2),
                   savepdf_itoa((int) backx1), savepdf_itoa((int) backy1),
                   savepdf_itoa((int) tipx),   savepdf_itoa((int) tipy),
                   savepdf_itoa((int) backx2), savepdf_itoa((int) backy2));

  if (r < 0) RetLastE;
  else return NULL;
}

/**************************************************************/
/* savepdf_draw_to_pdf_path()                                 */
/*                                                            */
/* Read a Draw path object and write the equivalent to a      */
/* PDF file. The file pointer in the Draw file must be        */
/* positioned to just after the type and size word for the    */
/* path object.                                               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Draw and PDF files;                        */
/*                                                            */
/*             Pointer to a FILE * for the output PDF file;   */
/*                                                            */
/*             Pointer to a FILE * for the input Draw file;   */
/*                                                            */
/*             File pointer giving offset of next object      */
/*             immediately after the path object.             */
/**************************************************************/

static _kernel_oserror * savepdf_draw_to_pdf_path
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           long int                      end_at
                         )
{
  int          r;
  BBox         bounds;
  unsigned int fill_colour;
  unsigned int line_colour;
  unsigned int line_width;
  unsigned int path_style;
  unsigned int dash_offset;
  unsigned int dash_elements = 0;
  unsigned int pdf_join;
  unsigned int pdf_startcap;
  unsigned int pdf_endcap;
  unsigned int pdf_cap;
  long int     path_start;
  int          do_triangles = 1;
  int          triangle_width;
  int          triangle_length;

  /* Read basic information */

  if (fread(&bounds,      1, 16, draw) != 16) RetLastE;
  if (fread(&fill_colour, 1, 4,  draw) != 4)  RetLastE;
  if (fread(&line_colour, 1, 4,  draw) != 4)  RetLastE;
  if (fread(&line_width,  1, 4,  draw) != 4)  RetLastE;
  if (fread(&path_style,  1, 4,  draw) != 4)  RetLastE;

  /* If line and fill colours are invisible, don't bother! */

  if (line_colour == 0xffffffff && fill_colour == 0xffffffff) return NULL;

  /* Convert line width to PDF user space */

  line_width = scale_draw_to_user (b, line_width);
  line_width = scale_user_to_pdf  (b, line_width);

  /* Work out the triangle cap length and width in PDF space */

  triangle_width  = (path_style & DRAW_TRIANGLEWIDTH_MASK)  >> DRAW_TRIANGLEWIDTH_SHIFT;
  triangle_length = (path_style & DRAW_TRIANGLELENGTH_MASK) >> DRAW_TRIANGLELENGTH_SHIFT;

  /* Triangle dimensions are expressed in 16ths of the line width */

  triangle_width  = (triangle_width  * line_width) / 16;
  triangle_length = (triangle_length * line_width) / 16;

  if (line_width == 0)
  {
    /* Don't allow zero line width for visible lines */

    if (line_colour != 0xffffffff) line_width = 400; /* Roughly equivalent to 1 OS unit at 1:1 scaling */

    /* Don't draw triangle end caps for zero width lines */

    do_triangles = 0;
  }

  /* Don't try and draw triangle caps if the width and length */
  /* are both zero, either.                                   */

  if (triangle_width == 0 && triangle_length == 0) do_triangles = 0;

  /* Is there a dash pattern? */

  if ((path_style & DRAW_DASHFLAG_MASK) == DRAW_DASHFLAG_PRESENT)
  {
    if (fread(&dash_offset,   1, 4, draw) != 4) RetLastE;
    if (fread(&dash_elements, 1, 4, draw) != 4) RetLastE;

    /* Convert dash offset to PDF user space */

    dash_offset = scale_draw_to_user (b, dash_offset);
    dash_offset = scale_user_to_pdf  (b, dash_offset);
  }

  unsigned int dash_pattern[dash_elements]; /* C99's great */

  for (int i = 0; i < dash_elements; i++)
  {
    if (fread(&dash_pattern[i], 1, 4, draw) != 4) RetLastE;

    /* Convert the dash length to PDF user space */

    dash_pattern[i] = scale_draw_to_user (b, dash_pattern[i]);
    dash_pattern[i] = scale_user_to_pdf  (b, dash_pattern[i]);
  }

  /* Get the PDF equivalent of the join style */

  switch (path_style & DRAW_JOINSTYLE_MASK)
  {
    default:
    case DRAW_JOINSTYLE_MITRED:   pdf_join     = PDF_JOIN_MITRED;   break;
    case DRAW_JOINSTYLE_ROUND:    pdf_join     = PDF_JOIN_ROUND;    break;
    case DRAW_JOINSTYLE_BEVELLED: pdf_join     = PDF_JOIN_BEVELLED; break;
  }

  /* Get PDF numbers equivalent to the end cap types */

  switch (path_style & DRAW_STARTCAP_MASK)
  {
    default:
    case DRAW_STARTCAP_BUTT:
    case DRAW_STARTCAP_TRIANGLE:  pdf_startcap = PDF_CAP_BUTT;      break;
    case DRAW_STARTCAP_ROUND:     pdf_startcap = PDF_CAP_ROUND;     break;
    case DRAW_STARTCAP_SQUARE:    pdf_startcap = PDF_CAP_SQUARE;    break;
  }

  switch (path_style & DRAW_ENDCAP_MASK)
  {
    default:
    case DRAW_ENDCAP_BUTT:
    case DRAW_ENDCAP_TRIANGLE:    pdf_endcap   = PDF_CAP_BUTT;      break;
    case DRAW_ENDCAP_ROUND:       pdf_endcap   = PDF_CAP_ROUND;     break;
    case DRAW_ENDCAP_SQUARE:      pdf_endcap   = PDF_CAP_SQUARE;    break;
  }

  /* PDF seems to only support setting end caps for start and */
  /* end of lines, not each independently. We will choose the */
  /* end cap by preference, but if either end has a triangle  */
  /* this may hide the cap, so choose the other cap instead.  */

  if ((path_style & DRAW_ENDCAP_MASK) == DRAW_ENDCAP_TRIANGLE)
  {
    pdf_cap = pdf_startcap;
  }
  else
  {
    pdf_cap = pdf_endcap;
  }

  /* Remember the file pointer marking the start of the Draw */
  /* path data.                                              */

  path_start = ftell(draw);

  /* Since PDF cannot fill an object without closing it, we have */
  /* two passes. The first outputs information relevant for a    */
  /* filled path with no stroked line. The second outputs an     */
  /* overlaid stroked path. This is how a PostScript conversion  */
  /* gets around the problem, so may as well copy it here.       */

  for (int pass = 0; pass < 2; pass++)
  {
    int have_first_1 = 0;
    int have_last_1  = 0;
    int have_first_2 = 0;
    int have_last_2  = 0;
    int first_x1     = 0, first_y1 = 0;
    int first_x2     = 0, first_y2 = 0;
    int last_x1      = 0, last_y1  = 0;
    int last_x2      = 0, last_y2  = 0;

    /* Do we bother with this pass? */

    if (pass == 0 && fill_colour == 0xffffffff) continue;
    if (pass == 1 && line_colour == 0xffffffff) continue;

    /* Push the PDF graphics context onto the stack then set up */
    /* some of the path parameters.                             */

    r = fprintf(pdf, "q\n  ");
    if (r < 0) RetLastE;

    /* Colours */

    if (pass == 0) /* Fill-only pass */
    {
      /* Fill colour (we must have one to have got this far) */

      RetError(savepdf_write_colour(fill_colour, 0));

      /* Zero line width for invisible lines */

      r = fprintf(pdf, "0 w\n");
      if (r < 0) RetLastE;
    }
    else /* Lines-only pass */
    {
      /* Line colour (we must have one to have got this far) */

      RetError(savepdf_write_colour(line_colour, 1));

      /* Wpecify line width, join and end styles, then open the */
      /* dash array.                                            */

      r = fprintf(pdf, "%s w %u J %u j [",

                       savepdf_itoa(line_width),
                       pdf_cap,
                       pdf_join);

      if (r < 0) RetLastE;

      /* Fill in the dash array (if any) */

      for (int i = 0; i < dash_elements; i++)
      {
        r = fprintf(pdf, "%s%s",

                         i == 0 ? "" : " ",
                         savepdf_itoa(dash_pattern[i]));

        if (r < 0) RetLastE;
      }

      /* Finish off the dash definition */

      r = fprintf(pdf, "] %s d\n",
                       savepdf_itoa(dash_elements == 0 ? 0 : dash_offset));

      if (r < 0) RetLastE;
    }

    /* Seek to the start of the path data and parse it */

    fseek(draw, path_start, SEEK_SET);

    while (ftell(draw) < end_at)
    {
      unsigned int tag_id;
      int          x1, y1;
      int          x2, y2;
      int          x3, y3;

      if (fread(&tag_id, 1, 4, draw) != 4) RetLastE;

      switch (tag_id & DRAW_TAGID_MASK)
      {
        /* Close and maybe stroke and/or fill the path */

        case draw_PathTERM:
        {
          if (pass == 0)
          {
            /* Fill and implicitly close the path */

            if ((path_style & DRAW_WINDRULE_MASK) == DRAW_WINDRULE_NONZERO)
            {
              r = fprintf(pdf, "  f\n");
            }
            else /* Even-odd */
            {
              r = fprintf(pdf, "  f*\n");
            }
          }
          else
          {
            /* Stroke line without closing path */

            r = fprintf(pdf, "  S\n");

            /* Draw triangular end caps? */

            if (do_triangles)
            {
              if (
                   (path_style & DRAW_STARTCAP_MASK) == DRAW_STARTCAP_TRIANGLE &&
                   have_first_1                                                &&
                   have_first_2
                 )
              {
                RetError(savepdf_draw_to_pdf_cap_triangle(pdf,
                                                          first_x2, first_y2,
                                                          first_x1, first_y1,
                                                          triangle_width,
                                                          triangle_length,
                                                          line_colour));
              }

              if (
                   (path_style & DRAW_ENDCAP_MASK) == DRAW_ENDCAP_TRIANGLE &&
                   have_last_1                                             &&
                   have_last_2
                 )
              {
                RetError(savepdf_draw_to_pdf_cap_triangle(pdf,
                                                          last_x2, last_y2,
                                                          last_x1, last_y1,
                                                          triangle_width,
                                                          triangle_length,
                                                          line_colour));
              }
            }
          }
        }
        break;

        /* Pointer to continuation of path (skip - not supported) */

        case draw_PathPTR:
        {
          int parameter_ignore;
          if (fread(&parameter_ignore, 1, 4, draw) != 4) RetLastE;
        }

        /* Move to a new point */

        case draw_PathMOVE:
        case draw_PathMOVENOWIND:
        case draw_PathGAP:
        {
          if (fread(&x1, 1, 4, draw) != 4) RetLastE;
          if (fread(&y1, 1, 4, draw) != 4) RetLastE;

          scale_pair_draw_to_user (b, x1, y1, &x1, &y1);
          scale_pair_user_to_pdf  (b, x1, y1, &x1, &y1);

          if (!have_first_1) first_x1 = x1, first_y1 = y1, have_first_1 = 1;
          else if (!have_first_2) first_x2 = x1, first_y2 = y1, have_first_2 = 1;
          if (have_last_1) last_x2 = last_x1, last_y2 = last_y1, have_last_2 = 1;
          last_x1 = x1, last_y1 = y1, have_last_1 = 1;

          r = fprintf(pdf, "  %s %s m\n",

                           savepdf_itoa(x1),
                           savepdf_itoa(y1));
        }
        break;

        /* Include a line */

        case draw_PathLINE:
        {
          if (fread(&x1, 1, 4, draw) != 4) RetLastE;
          if (fread(&y1, 1, 4, draw) != 4) RetLastE;

          scale_pair_draw_to_user (b, x1, y1, &x1, &y1);
          scale_pair_user_to_pdf  (b, x1, y1, &x1, &y1);

          if (!have_first_1) first_x1 = x1, first_y1 = y1, have_first_1 = 1;
          else if (!have_first_2) first_x2 = x1, first_y2 = y1, have_first_2 = 1;
          if (have_last_1) last_x2 = last_x1, last_y2 = last_y1, have_last_2 = 1;
          last_x1 = x1, last_y1 = y1, have_last_1 = 1;

          r = fprintf(pdf, "  %s %s l\n",

                           savepdf_itoa(x1),
                           savepdf_itoa(y1));
        }
        break;

        /* Include a cubic bezier curve */

        case draw_PathCURVE:
        {
          if (fread(&x1, 1, 4, draw) != 4) RetLastE;
          if (fread(&y1, 1, 4, draw) != 4) RetLastE;
          if (fread(&x2, 1, 4, draw) != 4) RetLastE;
          if (fread(&y2, 1, 4, draw) != 4) RetLastE;
          if (fread(&x3, 1, 4, draw) != 4) RetLastE;
          if (fread(&y3, 1, 4, draw) != 4) RetLastE;

          scale_pair_draw_to_user (b, x1, y1, &x1, &y1);
          scale_pair_user_to_pdf  (b, x1, y1, &x1, &y1);
          scale_pair_draw_to_user (b, x2, y2, &x2, &y2);
          scale_pair_user_to_pdf  (b, x2, y2, &x2, &y2);
          scale_pair_draw_to_user (b, x3, y3, &x3, &y3);
          scale_pair_user_to_pdf  (b, x3, y3, &x3, &y3);

          r = fprintf(pdf, "  %s %s %s %s %s %s c\n",

                           savepdf_itoa(x1),
                           savepdf_itoa(y1),
                           savepdf_itoa(x2),
                           savepdf_itoa(y2),
                           savepdf_itoa(x3),
                           savepdf_itoa(y3));
        }
        break;

        /* Close the sub-path */

        case draw_PathCLOSE:
        case draw_PathCLOSEGAP:
        {
          r = fprintf(pdf, "  h\n");
        }
        break;
      }

      if (r < 0) RetLastE;
    }

    /* Pop the path's graphics context */

    r = fprintf(pdf, "Q\n");
    if (r < 0) RetLastE;

  } /* Close 'for' loop doing two-pass path parsing */

  return NULL;
}

/**************************************************************/
/* savepdf_draw_to_pdf_sprite()                               */
/*                                                            */
/* Read a Draw sprite object and write the equivalent to a    */
/* PDF file. The file pointer in the Draw file must be        */
/* positioned to just after the type and size word for the    */
/* sprite object or, if a bounding box is supplied, just      */
/* before the sprite data in the object.                      */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Draw and PDF files;                        */
/*                                                            */
/*             Pointer to a FILE * for the output PDF file;   */
/*                                                            */
/*             Pointer to a FILE * for the input Draw file;   */
/*                                                            */
/*             NULL to read a bounding box from the Draw file */
/*             else use the supplied bounding box pointer for */
/*             the information;                               */
/*                                                            */
/*             NULL for no transformation matrix, else a      */
/*             pointer to the 6-word matrix with 16.16 fixed  */
/*             point multipliers and the X and Y offset in    */
/*             the last two words converted to user-points;   */
/*                                                            */
/*             Total size in bytes of the sprite object that  */
/*             is being converted.                            */
/**************************************************************/

static _kernel_oserror * savepdf_draw_to_pdf_sprite
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           const BBox         *          ext_bounds,
                           const int          *          ext_matrix,
                           size_t                        size
                         )
{
  int            r;
  BBox           local_bounds;
  const BBox   * bounds;
  int            x, y, width, height;
  int            ok, oldbudge;
  int            offset;
  size_t         needed, got, data_size;

  /* Read the bounding box, or use the supplied pointer. */
  /* At the moment we don't actually use it though!      */

  if (ext_bounds == NULL)
  {
    if (fread(&local_bounds, 1, 16, draw) != 16) RetLastE;
    bounds = &local_bounds;
  }
  else
  {
    bounds = ext_bounds;
  }

  /* Allocate space for the sprite data */

  data_size = size - 24; /* Object size minus object header size */

  if (draw_sprite_count == 0)
  {
    offset = 16;
    needed = offset + data_size; /* Sprite area header plus sprite size */
    ok     = flex_alloc((flex_ptr) &draw_sprite_pool, needed);
  }
  else
  {
    offset = flex_size((flex_ptr) &draw_sprite_pool);
    needed = offset + data_size; /* Existing pool size plus new sprite size */
    ok     = flex_extend((flex_ptr) &draw_sprite_pool, needed);
  }

  if (ok == 0) return make_no_memory_error(43);

  /* Lock flex, try to read the sprite data and unlock, then check for errors */

  oldbudge = flex_set_budge(0);
  got      = fread(((char *) draw_sprite_pool) + offset, 1, data_size, draw);

  flex_set_budge(oldbudge);

  if (got != data_size) RetLastE;

  /* Update the sprite area header */

  draw_sprite_pool[0] = needed;
  draw_sprite_pool[1] = ++draw_sprite_count;
  draw_sprite_pool[2] = 16;
  draw_sprite_pool[3] = needed;

  /* Patch up the sprite name - want to ensure they're unique */
  /* (technically the sprite area may be valid anyway, but it */
  /* is safer to be sure and means we can use other bits of   */
  /* code here that require sprite names safely).             */

  memset  (((char *) draw_sprite_pool) + offset + 4, '\0', 12);
  sprintf (((char *) draw_sprite_pool) + offset + 4, "%d", draw_sprite_count - 1);

  /* Work out the image positioning in user-points */

  scale_pair_draw_to_user(b, bounds->xmin,                bounds->ymin,                &x,     &y);
  scale_pair_draw_to_user(b, bounds->xmax - bounds->xmin, bounds->ymax - bounds->ymin, &width, &height);

  /* Convert to PDF user space */

  scale_pair_user_to_pdf(b, x,     y,      &x,     &y);
  scale_pair_user_to_pdf(b, width, height, &width, &height);

  /* Store the graphics context */

  r = fprintf(outfile, "q\n");
  if (r < 0) RetLastE;

  /* I can't find much information on the nature of the transformation */
  /* matrix for sprites. Certainly, it's not the same as for text. In  */
  /* the sprite case, we seem to have to ignore the bounding box and   */
  /* just use the matrix. A scale factor is needed on the multipliers; */
  /* by trial and error on some test images in a Draw file "27.18" has */
  /* been found to be pretty close to spot on, but I don't understand  */
  /* the reason for this particular number, and therefore do not have  */
  /* a more accurate figure based on some formula.                     */
  /*                                                                   */
  /* At least the non-transformed case is simple enough!               */

  if (ext_matrix)
  {
    r = fprintf(outfile, "  %f %f %f %f %s %s cm\n",

                         27.18 * ((double) ext_matrix[0] / 65536),
                         27.18 * ((double) ext_matrix[1] / 65536),
                         27.18 * ((double) ext_matrix[2] / 65536),
                         27.18 * ((double) ext_matrix[3] / 65536),
                         savepdf_itoa(scale_user_to_pdf(b, ext_matrix[4])),
                         savepdf_itoa(scale_user_to_pdf(b, ext_matrix[5])));
  }
  else
  {
    r = fprintf(outfile, "  %s 0 0 %s %s %s cm\n",

                         savepdf_itoa(width),
                         savepdf_itoa(height),
                         savepdf_itoa(x),
                         savepdf_itoa(y));
  }

  if (r < 0) RetLastE;

  /* Plot the image and restore the previous graphics context */

  r = fprintf(outfile, "  /%s%d Do\n"
                       "Q\n",

                       SAVEPDF_IMAGE_XOBJECT_DRAW_PREFIX,
                       draw_sprite_count - 1);

  if (r < 0) RetLastE;
  else return NULL;
}

/**************************************************************/
/* savepdf_draw_to_pdf_sprite_transformed()                   */
/*                                                            */
/* Read a Draw transformed sprite object and write the        */
/* equivalent to a PDF file. The file pointer in the Draw     */
/* file must be positioned to just after the type and size    */
/* word for the transformed sprite object.                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Draw and PDF files;                        */
/*                                                            */
/*             Pointer to a FILE * for the output PDF file;   */
/*                                                            */
/*             Pointer to a FILE * for the input Draw file;   */
/*                                                            */
/*             Total size in bytes of the sprite object that  */
/*             is being converted.                            */
/**************************************************************/

static _kernel_oserror * savepdf_draw_to_pdf_sprite_transformed
                         (
                           const browser_data * restrict b,
                           FILE               *          pdf,
                           FILE               *          draw,
                           size_t                        size
                         )
{
  BBox bounds;
  int  matrix[6];

  /* Read general information */

  if (fread(&bounds, 1, 16, draw) != 16) RetLastE;
  if (fread(&matrix, 1, 24, draw) != 24) RetLastE;

  scale_pair_draw_to_user (b, matrix[4], matrix[5], &matrix[4], &matrix[5]);
  scale_pair_user_to_pdf  (b, matrix[4], matrix[5], &matrix[4], &matrix[5]);

  /* Do the sprite part of the object, adjusting the 'size' value */
  /* for the extra data for the transformation information and    */
  /* giving the transformation matrix adjustments in passing.     */

  return savepdf_draw_to_pdf_sprite(b,
                                    pdf,
                                    draw,
                                    &bounds,
                                    matrix,
                                    size - 24);
}

/**************************************************************/
/* savepdf_draw_file_to_pdf()                                 */
/*                                                            */
/* Convert a Draw file into a set of content stream data for  */
/* the PDF file. Call during page content stream output. If   */
/* an error occurs, the file pointer in the output is set     */
/* back to its position before any conversion was attempted.  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Draw and PDF files;                        */
/*                                                            */
/*             Pointer to NUL-terminated filename for input;  */
/*                                                            */
/*             X coordinate, user-points;                     */
/*                                                            */
/*             Y coordinate, user-points;                     */
/*                                                            */
/*             Width, user-points;                            */
/*                                                            */
/*             Height, user-points;                           */
/*                                                            */
/*             Pointer to a size_t, which if non-NULL will be */
/*             updated with the amount of data that *would*   */
/*             be written without writing anything, else if   */
/*             NULL produces normal output to a file.         */
/*             (NOT YET IMPLEMENTED).                         */
/**************************************************************/

_kernel_oserror * savepdf_draw_file_to_pdf
                  (
                    const browser_data * restrict b,
                    const char         * restrict file_name,
                    int                           x,
                    int                           y,
                    unsigned int                  width,
                    unsigned int                  height,

                    size_t             * restrict r_size
                  )

{
  _kernel_oserror * e = NULL;
  FILE            * draw;
  unsigned int      type;
  unsigned int      size;
  long int          next;
  long int          started_at;
  int               r;
  char              fontmap[256];

  if (outfile == NULL) return NULL;

  /* Remember the file pointer before we do anything */

  started_at = ftell(outfile);

  /* Clear the font mappings so to begin with, all text goes */
  /* to font number zero.                                    */

  memset(fontmap, '\0', sizeof(fontmap));

  draw = fopen(file_name, "rb");

  if (draw == NULL)
  {
    StrLastE;
    e = &erb;
  }

  if (e == NULL)
  {
    /* Seek to the overall bounding box */

    fseek(draw, 24, SEEK_SET);

    /* Set up a transformation matrix to size and position the Draw */
    /* file to match the given coordinates and size.                */

    e = savepdf_draw_to_pdf_bbox(b,
                                 outfile,
                                 draw,
                                 x,
                                 y,
                                 width,
                                 height);
  }

  /* Skip to just after the header */

  if (e == NULL) fseek(draw, 40, SEEK_SET);

  /* Start processing objects */

  while (e == NULL && feof(draw) != EOF)
  {
    if (fread(&type, 1, 4, draw) != 4) break;
    if (fread(&size, 1, 4, draw) != 4)
    {
      StrLastE;
      e = &erb;
      break;
    }

    next = ftell(draw) + size - 8;

    switch (type)
    {
      /* Handle a font list object */

      case draw_OBJFONTLIST:
      {
        /* Fill in the 'fontmap' array */

        e = savepdf_draw_to_pdf_fonts(b,
                                      outfile,
                                      draw,
                                      fontmap,
                                      next);
      }
      break;

      /* Handle a text object */

      case draw_OBJTEXT:
      {
        /* Write an equivalent PDF text object */

        e = savepdf_draw_to_pdf_text(b,
                                     outfile,
                                     draw,
                                     fontmap,
                                     NULL,
                                     NULL,
                                     size);
      }
      break;

      /* Transformed text objects */

      case draw_OBJTEXTTRFM:
      {
        /* Write an equivalent PDF transformation and text object */

        e = savepdf_draw_to_pdf_text_transformed(b,
                                                 outfile,
                                                 draw,
                                                 fontmap,
                                                 size);
      }
      break;

      /* Handle path objects */

      case draw_OBJPATH:
      {
        /* Write an equivalent PDF path or set of paths */

        e = savepdf_draw_to_pdf_path(b,
                                     outfile,
                                     draw,
                                     next);
      }
      break;

      /* Sprite objects */

      case draw_OBJSPRITE:
      {
        /* Write a reference into the PDF file and store the sprite */
        /* in the local temporary pool.                             */

        e = savepdf_draw_to_pdf_sprite(b,
                                       outfile,
                                       draw,
                                       NULL,
                                       NULL,
                                       size);
      }
      break;

      /* Handle transformed sprites */

      case draw_OBJSPRITRFM:
      {
        /* Write an equivalent transformation and a reference into the */
        /* PDF file and store the sprite in the local temporary pool.  */

        e = savepdf_draw_to_pdf_sprite_transformed(b,
                                                   outfile,
                                                   draw,
                                                   size);
      }
      break;

      /* Handle a group object */

      case draw_OBJGROUP:
      {
        /* Rewind the 'next' pointer to just after the */
        /* size of this complete object                */

        next -= ((long int) size - 8);

        /* Skip past the bounding box and group name to */
        /* 'resync' to the start of the first object    */
        /* within that group. Afterwards, we just carry */
        /* on reading in the normal object stream.      */

        next += 28;
      }
      break;
    }

    /* Move to the next object */

    if (e == NULL) fseek(draw, next, SEEK_SET);
  }

  /* Close the input file */

  fclose(draw);

  /* Pop the outermost graphics context */

  if (e == NULL)
  {
    r = fprintf(outfile, "Q\n");

    if (r < 0)
    {
      StrLastE;
      e = &erb;
    }
  }

  /* If there was an error, rewind... */

  if (e != NULL) fseek(outfile, started_at, SEEK_SET);

  return e;
}

/**************************************************************/
/* savepdf_replace_redraw_table()                             */
/*                                                            */
/* Set up the redraw core routines to output to a PDF file.   */
/**************************************************************/

void savepdf_replace_redraw_table(void)
{
  redrawcore_replace_table(&rtable_pdf);
}

/**************************************************************/
/* savepdf_restore_redraw_table()                             */
/*                                                            */
/* Restore default redraw core routine behaviour.             */
/**************************************************************/

void savepdf_restore_redraw_table(void)
{
  redrawcore_default_table();
}

/**************************************************************/
/* savepdf_start_session()                                    */
/*                                                            */
/* Start a PDF output session by creating the output file and */
/* storing details on the associated browser and pathname.    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page to save as a PDF file;                */
/*                                                            */
/*             Pointer to the pathname to save to.            */
/**************************************************************/

_kernel_oserror * savepdf_start_session(browser_data * b, const char * pathname)
{
  /* Call the 'end session' function in case anyone forgot */
  /* or didn't manage to tidy up before, for any reason    */

  (void) savepdf_end_session();

  /* Record the source browser for the PDF file */

  outbrow = b;

  /* Only proceed if we've got a pathname */

  if (pathname && *pathname)
  {
    /* Tell the saving system about the latest used path */

    save_record_path(pathname);

    /* Create the object array */

    objaddr = arrays_create(0, sizeof(long int));
    if (objaddr == NULL) return make_no_memory_error(43);

    /* Duplicate the pathname */

    outpath = utils_strdup(pathname);

    if (outpath == NULL)
    {
      (void) savepdf_end_session();
      return make_no_memory_error(44);
    }

    /* Create the page object number array */

    pageobj = arrays_create(0, sizeof(size_t));

    if (pageobj == NULL)
    {
      (void) savepdf_end_session();
      return make_no_memory_error(43);
    }

    /* Create the output image information array */

    images_output = arrays_create(0, sizeof(savepdf_image_info_t));

    if (images_output == NULL)
    {
      (void) savepdf_end_session();
      return make_no_memory_error(43);
    }

    /* Create the name dictionary array */

    name_dictionary = arrays_create(0, sizeof(savepdf_name_t));

    if (name_dictionary == NULL)
    {
      (void) savepdf_end_session();
      return make_no_memory_error(43);
    }

    /* Create the outline item dictionary array */

    outline_item_dictionary = arrays_create(0, sizeof(savepdf_outline_item_t));

    if (outline_item_dictionary == NULL)
    {
      (void) savepdf_end_session();
      return make_no_memory_error(43);
    }

    /* Open the file */

    outfile = fopen(pathname, "wb");

    if (outfile == NULL)
    {
      (void) savepdf_end_session();
      RetLastE;
    }
  }

  return NULL;
}

/**************************************************************/
/* savepdf_end_session()                                      */
/*                                                            */
/* Close the output file opened by, and shut down the session */
/* started by savepdf_start_session.                          */
/*                                                            */
/* It is safe to call this function to tidy up sessions that  */
/* are incomplete / partially started / partially ended.      */
/**************************************************************/

_kernel_oserror * savepdf_end_session(void)
{
  _kernel_oserror * e = NULL;

  if (outfile != NULL)
  {
    /* Close the file */

    fclose(outfile);
    outfile = NULL;

    /* Set the filetype */

    e = _swix(OS_File,
              _INR(0,2),

              18,
              outpath,
              FileType_PDF);
  }

  /* Reset other related data and return the result of the */
  /* attempt to set the filetype.                          */

  outbrow = NULL;

  if (outpath)
  {
    free(outpath);
    outpath = NULL;
  }

  if (draw_sprite_pool)
  {
    flex_free((flex_ptr) &draw_sprite_pool);
    draw_sprite_count = 0;
  }

  if (objaddr)        arrays_destroy(&objaddr);
  if (pageobj)        arrays_destroy(&pageobj);
  if (images_output)  arrays_destroy(&images_output);
  if (images_in_page) arrays_destroy(&images_in_page);

  objctr  = 0;
  pagectr = 0;

  savepdf_delete_names();
  savepdf_delete_annotations();
  savepdf_delete_outline_items();

  return e;
}

/**************************************************************/
/* savepdf_get_font_mappings()                                */
/*                                                            */
/* Ensure that the fonts defined in the Choices can be mapped */
/* to standard PDF fonts. Stores the mapping internally.      */
/*                                                            */
/* Returns:    1 if the table could be constructed, 0 if the  */
/*             global configuration includes fonts that do    */
/*             not have direct equivalents in the standard    */
/*             PDF set.                                       */
/**************************************************************/

unsigned int savepdf_get_font_mappings(void)
{
  const fm_typeface * tfptr;
  const char        * name;
  int                 font, map, entry;
  int                 found = 0;

  /* Fail immediately if system font is configured */

  if (fm_system_font()) return 0;

  /* Run through the three typeface entries - serif, sans and fixed */

  for (entry = 0; entry < 3; entry++)
  {
    switch(entry)
    {
      case 0:  name = "serif"; break;
      case 1:  name = "sans";  break;
      default: name = "fixed"; break;
    }

    /* Ask the font manager routines for the corresponding typeface */

    tfptr = fm_find_typeface((char *) name);
    if (tfptr == NULL) return 0;

    /* Run through all RISC OS font names stored within the typeface */

    for (
          font = 0;
          font < sizeof(tfptr->fontnames) / sizeof(*tfptr->fontnames);
          font ++
        )
    {
      /* We're trying to be flexible by not hard-coding sizes, but in */
      /* practice we expect 3 tables of 4 fonts. If we go beyond the  */
      /* fourth font skip to the next table. There's no room to store */
      /* any more details in the token map anyway.                    */

      if (font >= 4) break;

      /* Compare the typeface against each entry in the name map */

      for (
            map = 0;
            map < sizeof(font_name_map) / sizeof(*font_name_map);
            map ++
          )
      {
        /* If the name map's RISC OS name matches the name in the typeface */
        /* note that we've found something, store the index into the name  */
        /* map within the token map, and break out early to get onto the   */
        /* next RISC OS font name. Here we have to hard-code the way that  */
        /* the token map is set up because the token map array dimensions  */
        /* are already set up, and assume 3 entries with 4 names each.     */

        if (!strcmp(tfptr->fontnames[font], font_name_map[map].riscos_name))
        {
          found++;
          font_token_map[(entry * 4) + font] = map;
          break;
        }

      } /* End of loop searching through font name map entries */
    }   /* End of loop running through typeface font names     */
  }     /* End of loop running through typeface entries        */

  /* We expect to have found exactly 12 matches */

  if (found == 12) return 1;
  else             return 0;
}

/**************************************************************/
/* savepdf_record_new_object_address()                        */
/*                                                            */
/* When the file pointer is at the place where a new indirect */
/* object is about to be started, call this function. The     */
/* object address array is extended, the current file pointer */
/* written, and the object counter incremented.               */
/*                                                            */
/* The function assumes objects are written in numerical      */
/* order starting at 1, with indices of addresses as object   */
/* number minus 1. If you skip an object, call this function  */
/* to insert a dummy address for that object which you can    */
/* update later with savepdf_update_object_address.           */
/**************************************************************/

static _kernel_oserror * savepdf_record_new_object_address(void)
{
  long int * entry;

  RetError(arrays_extend(objaddr, 1));

  entry = arrays_read(objaddr, objctr);
  if (entry != NULL) *entry = ftell(outfile);

  objctr++;

  return NULL;
}

/**************************************************************/
/* savepdf_update_object_address()                            */
/*                                                            */
/* Update the address for an object stored in the object      */
/* address array.                                             */
/*                                                            */
/* Parameters: Object number (from 1 to 'objctr');            */
/*                                                            */
/*             New address (offset from start of file in      */
/*             bytes).                                        */
/**************************************************************/

static void savepdf_update_object_address(size_t objnum, long int address)
{
  long int * entry = arrays_read(objaddr, (int) objnum - 1);

  if (entry != NULL) *entry = address;
  return;
}

/**************************************************************/
/* savepdf_read_object_address()                              */
/*                                                            */
/* Read the address for an object stored in the object        */
/* address array.                                             */
/*                                                            */
/* Parameters: Object number (from 1 to 'objctr').            */
/*                                                            */
/* Returns:    Object address (offset from start of file in   */
/*             bytes). If the object number was invalid, zero */
/*             will be returned. Since PDF files always start */
/*             with at least the version number comment, zero */
/*             cannot be a legitimate address of an object.   */
/**************************************************************/

static long int savepdf_read_object_address(size_t objnum)
{
  long int * entry = arrays_read(objaddr, (int) objnum - 1);

  if (entry != NULL) return *entry;
  else               return 0;
}

/**************************************************************/
/* savepdf_record_page_object_number()                        */
/*                                                            */
/* Add a new page object's object number to the page object   */
/* array, at the end. Increment the page counter.             */
/*                                                            */
/* Parameters: Page object's object number.                   */
/**************************************************************/

static _kernel_oserror * savepdf_record_page_object_number(size_t page_object_number)
{
  size_t * entry;

  RetError(arrays_extend(pageobj, 1));

  entry = arrays_read(pageobj, pagectr);
  if (entry != NULL) *entry = page_object_number;

  pagectr++;

  return NULL;
}

/**************************************************************/
/* savepdf_read_page_object_number()                          */
/*                                                            */
/* Read the object number of the page object for the given    */
/* page number (page numbers starting at 1).                  */
/*                                                            */
/* Parameters: Page number (from 1 to 'pagectr').             */
/*                                                            */
/* Returns:    Object address (offset from start of file in   */
/*             bytes). If the object number was invalid, zero */
/*             will be returned. Since PDF files always start */
/*             with at least the version number comment, zero */
/*             cannot be a legitimate address of an object.   */
/**************************************************************/

static size_t savepdf_read_page_object_number(size_t pagenum)
{
  size_t * entry = arrays_read(pageobj, (int) pagenum - 1);

  if (entry != NULL) return *entry;
  else               return 0;
}

/**************************************************************/
/* savepdf_record_image_in_page()                             */
/*                                                            */
/* Record the use of an image or sprite in a page. Only       */
/* one record is made of any unique image number or sprite    */
/* name.                                                      */
/*                                                            */
/* Parameters: Type of image (...IMAGE or ...SPRITE);         */
/*                                                            */
/*             Image number for images, else ignored;         */
/*                                                            */
/*             Pointer to NUL-terminated sprite name for      */
/*             sprites, else ignored.                         */
/**************************************************************/

static _kernel_oserror * savepdf_record_image_in_page
                         (
                           savepdf_image_type_t            type,
                           int                             image_number,
                           const char           * restrict sprite_name
                         )
{
  savepdf_image_info_t * entry;

  /* We only record parent images since only parents end up */
  /* being output to the PDF file.                          */

  if (type == savepdf_image_type_IMAGE) image_number = image_parent(image_number);

  /* If this image is already recorded, do nothing */

  if (
       savepdf_find_image_in_page_array(type,
                                        image_number,
                                        sprite_name)
       >= 0
     )
     return NULL;

  /* Extend the array and find the new entry */

  RetError(arrays_extend(images_in_page, 1));
  entry = arrays_read(images_in_page, arrays_size(images_in_page) - 1);

  /* If found, fill in the details. PDF object numbers are */
  /* always zero for in-page images since they don't get   */
  /* output - the images_output array records those.       */

  if (entry != NULL)
  {
    entry->pdf_object_number = 0;
    entry->type              = type;

    switch (type)
    {
      case savepdf_image_type_SPRITE:
      {
        StrNCpy0(entry->data.sprite_name, sprite_name);
      }
      break;

      case savepdf_image_type_IMAGE:
      {
        entry->data.image_number = image_number;
      }
      break;
    }
  }

  return NULL;
}

/**************************************************************/
/* savepdf_find_image_in_page_array()                         */
/*                                                            */
/* Look up an image or sprite file in the array of images     */
/* used by a page.                                            */
/*                                                            */
/* Parameters: Type of image to find (...IMAGE or ...SPRITE); */
/*                                                            */
/*             Image number for images, else ignored;         */
/*                                                            */
/*             Pointer to NUL-terminated sprite name for      */
/*             sprites, else ignored.                         */
/*                                                            */
/* Returns:    Index of found image or -1 if not found.       */
/**************************************************************/

static int savepdf_find_image_in_page_array
           (
             savepdf_image_type_t            type,
             int                             image_number,
             const char           * restrict sprite_name
           )
{
  savepdf_image_info_t * entry;
  int                    index;
  int                    size = arrays_size(images_in_page);

  for (index = 0; index < size; index++)
  {
    entry = arrays_read(images_in_page, index);
    if (entry == NULL) continue;

    if (entry->type == type)
    {
      switch (type)
      {
        case savepdf_image_type_SPRITE:
        {
          if (!strcmp(entry->data.sprite_name, sprite_name)) return index;
        }
        break;

        case savepdf_image_type_IMAGE:
        {
          if (entry->data.image_number == image_number) return index;
        }
        break;
      }
    }
  }

  return -1;
}

/**************************************************************/
/* savepdf_record_output_image()                              */
/*                                                            */
/* Record details of a sprite or image about to be converted  */
/* and output to the PDF file.                                */
/*                                                            */
/* Parameters: PDF object number for the main image XObject   */
/*             that will be produced;                         */
/*                                                            */
/*             Type of image (...IMAGE or ...SPRITE);         */
/*                                                            */
/*             Image number for images, else ignored;         */
/*                                                            */
/*             Pointer to NUL-terminated sprite name for      */
/*             sprites, else ignored.                         */
/**************************************************************/

static _kernel_oserror * savepdf_record_output_image
                         (
                           unsigned int                    pdf_object_number,
                           savepdf_image_type_t            type,
                           int                             image_number,
                           const char           * restrict sprite_name
                         )
{
  savepdf_image_info_t * entry;

  /* If this image is already recorded, do nothing */

  if (
       savepdf_find_image_in_output_array(type,
                                          image_number,
                                          sprite_name)
       >= 0
     )
     return NULL;

  /* Extend the array and find the new entry */

  RetError(arrays_extend(images_output, 1));
  entry = arrays_read(images_output, arrays_size(images_output) - 1);

  /* If found, fill in the details */

  if (entry != NULL)
  {
    entry->pdf_object_number = pdf_object_number;
    entry->type              = type;

    switch (type)
    {
      case savepdf_image_type_SPRITE:
      {
        StrNCpy0(entry->data.sprite_name, sprite_name);
      }
      break;

      case savepdf_image_type_IMAGE:
      {
        entry->data.image_number = image_number;
      }
      break;
    }
  }

  return NULL;
}

/**************************************************************/
/* savepdf_find_image_in_output_array()                       */
/*                                                            */
/* Look up an image or sprite in the array of images output   */
/* to the PDF file.                                           */
/*                                                            */
/* Parameters: Type of image to find (...IMAGE or ...SPRITE); */
/*                                                            */
/*             Image number for images, else ignored;         */
/*                                                            */
/*             Pointer to NUL-terminated sprite name for      */
/*             sprites, else ignored.                         */
/*                                                            */
/* Returns:    Index of found image or -1 if not found.       */
/**************************************************************/

static int savepdf_find_image_in_output_array
           (
             savepdf_image_type_t            type,
             int                             image_number,
             const char           * restrict sprite_name
           )
{
  savepdf_image_info_t * entry;
  int                    index;
  int                    size = arrays_size(images_output);

  for (index = 0; index < size; index++)
  {
    entry = arrays_read(images_output, index);
    if (entry == NULL) continue;

    if (entry->type == type)
    {
      switch (type)
      {
        case savepdf_image_type_SPRITE:
        {
          if (!strcmp(entry->data.sprite_name, sprite_name)) return index;
        }
        break;

        case savepdf_image_type_IMAGE:
        {
          if (entry->data.image_number == image_number) return index;
        }
        break;
      }
    }
  }

  return -1;
}

/**************************************************************/
/* savepdf_add_name()                                         */
/*                                                            */
/* Add a name to the name dictionary array. The name is       */
/* assumed to be present on the currently output content      */
/* stream - so objctr is the object number of that content    */
/* stream object. You must call savepdf_update_name later to  */
/* tell the system the number of the page description object  */
/* for that content stream.                                   */
/*                                                            */
/* Parameters: Pointer to the name (a copy will be taken);    */
/*                                                            */
/*             Pointer to a bounding box describing the area  */
/*             covered by the name in PDF inclusive coords.   */
/**************************************************************/

static _kernel_oserror * savepdf_add_name
                         (
                           const char * name,
                           BBox       * bounds
                         )
{
  int              index;
  savepdf_name_t * entry;
  const char     * name_copy;

  /* Find the name - if found, don't add another */

  for (index = 0; index < arrays_size(name_dictionary); index++)
  {
    entry = arrays_read(name_dictionary, index);
    if (entry == NULL) continue;

    if (!strcmp(entry->name, name)) return NULL;
  }

  /* Extend the array and copy the string */

  RetError(arrays_extend(name_dictionary, 1));

  name_copy = utils_strdup(name);

  if (name_copy == NULL)
  {
    (void) arrays_extend(name_dictionary, -1);
    return make_no_memory_error(44);
  }

  /* Fill in the entry details */

  entry = arrays_read(name_dictionary, arrays_size(name_dictionary) - 1);

  if (entry != NULL)
  {
    entry->name               = name_copy;
    entry->bounds             = *bounds;
    entry->page_object_number = objctr;
  }

  return NULL;
}

/**************************************************************/
/* savepdf_update_name()                                      */
/*                                                            */
/* Named destination information is stored with an object     */
/* number for a page's content stream. Later, when the page   */
/* description object number is known, call back here to      */
/* update all entries using the content stream number with    */
/* the new page description object number.                    */
/*                                                            */
/* If there is more than one entry matching the given content */
/* stream object number, all will be updated.                 */
/*                                                            */
/* Parameters: Page content stream object number to find;     */
/*                                                            */
/*             Page description object number to use as a     */
/*             replacement.                                   */
/**************************************************************/

static void savepdf_update_name
            (
              unsigned int content_number,
              unsigned int description_number
            )
{
  int              index;
  savepdf_name_t * entry;

  for (index = 0; index < arrays_size(name_dictionary); index++)
  {
    entry = arrays_read(name_dictionary, index);

    if (entry != NULL && entry->page_object_number == content_number)
    {
      entry->page_object_number = description_number;
    }
  }
}

/**************************************************************/
/* savepdf_name_sort_function()                               */
/*                                                            */
/* Comparison function for savepdf_sort_names.                */
/*                                                            */
/* Parameters: Pointer to the first savepdf_name_t entry,     */
/*             cast to void *;                                */
/*                                                            */
/*             Pointer to the second savepdf_name_t entry,    */
/*             cast to void *.                                */
/*                                                            */
/* Returns:    0 if the name for the first entry is the same  */
/*             as the second; < 0 if the first is lexically   */
/*             less than the second; or > 0 if vice versa.    */
/**************************************************************/

static int savepdf_name_sort_function
           (
             const void * first,
             const void * second
           )
{
  return strcmp(((savepdf_name_t *) first)->name,
                ((savepdf_name_t *) second)->name);
}

/**************************************************************/
/* savepdf_sort_names()                                       */
/*                                                            */
/* Arrange the name dictionary array in ascending lexical     */
/* order of names.                                            */
/**************************************************************/

static void savepdf_sort_names(void)
{
  if (name_dictionary != NULL)
  {
    arrays_sort(name_dictionary,
                savepdf_name_sort_function);
  }
}

/**************************************************************/
/* savepdf_delete_names()                                     */
/*                                                            */
/* Delete the name dictionary, freeing all names and the      */
/* array.                                                     */
/**************************************************************/

static void savepdf_delete_names(void)
{
  savepdf_name_t * entry;
  int              i;

  if (name_dictionary != NULL)
  {
    for (i = 0; i < arrays_size(name_dictionary); i++)
    {
      entry = arrays_read(name_dictionary, i);
      if (entry != NULL) free((void *) entry->name);
    }

    arrays_destroy(&name_dictionary);
  }
}

/**************************************************************/
/* savepdf_add_annotation()                                   */
/*                                                            */
/* Add an annotation to the annotation dictionary array.      */
/*                                                            */
/* Parameters: 1 if this is URI, 0 for internal named anchor; */
/*                                                            */
/*             Pointer to the annotation URI (full URL or     */
/*             link to named anchor without leading "#" - a   */
/*             copy will be taken);                           */
/*                                                            */
/*             Pointer to a BBox describing the link's        */
/*             dimensions in user-points (min inclusive, max  */
/*             exclusive), NOT corrected for plotting origin  */
/*             in poriginx and poriginy (that will be done    */
/*             internally).                                   */
/**************************************************************/

static _kernel_oserror * savepdf_add_annotation
                         (
                           unsigned int   uri,
                           const char   * link,
                           const BBox   * bounds
                         )
{
  savepdf_annotation_t * entry;
  const char           * link_copy;
  BBox                   clipped_bounds;

  /* Work out if the annotation boundary falls in the clipping rectangle; */
  /* if not, exit immediately.                                            */

  if (current_clip_known)
  {
    if (
         !utils_intersection(bounds,
                             &current_clip_region,
                             &clipped_bounds)
       )
       return NULL;
  }
  else /* Default/whole page/unknown - assume annotation fits completely */
  {
    clipped_bounds = *bounds;
  }

  /* Convert the boundary region to origin-translated inclusive PDF */
  /* user-space.                                                    */

  scale_box_pdf_to_user(outbrow, &clipped_bounds, &clipped_bounds);

  clipped_bounds.xmin += poriginx;
  clipped_bounds.ymin += poriginy;
  clipped_bounds.xmax += poriginx - 1;
  clipped_bounds.ymax += poriginy - 1;

  /* Extend the array and copy the string */

  RetError(arrays_extend(annotation_dictionary, 1));

  link_copy = utils_strdup(link);

  if (link_copy == NULL)
  {
    (void) arrays_extend(annotation_dictionary, -1);
    return make_no_memory_error(44);
  }

  /* Fill in the entry details */

  entry = arrays_read(annotation_dictionary, arrays_size(annotation_dictionary) - 1);

  if (entry != NULL)
  {
    entry->uri    = uri;
    entry->link   = link_copy;
    entry->bounds = clipped_bounds;
  }

  return NULL;
}

/**************************************************************/
/* savepdf_delete_annotations()                               */
/*                                                            */
/* Delete the annotation dictionary, freeing all links and    */
/* the array.                                                 */
/**************************************************************/

static void savepdf_delete_annotations(void)
{
  savepdf_annotation_t * entry;
  int                    i;

  if (annotation_dictionary != NULL)
  {
    for (i = 0; i < arrays_size(annotation_dictionary); i++)
    {
      entry = arrays_read(annotation_dictionary, i);
      if (entry != NULL) free((void *) entry->link);
    }

    arrays_destroy(&annotation_dictionary);
  }
}

/**************************************************************/
/* savepdf_new_inferred_section()                             */
/*                                                            */
/* Store a new inferred section with the given title. The     */
/* page containing the section is assumed to be *just about*  */
/* to be output, but not written yet, so the object number of */
/* the page content stream will be objctr + 1. You must call  */
/* savepdf_update_inferred_section later to tell the system   */
/* the number of the page description object for that page.   */
/*                                                            */
/* Parameters: Pointer to NUL-terminated section title.       */
/**************************************************************/

_kernel_oserror * savepdf_new_inferred_section(const char * title)
{
  return savepdf_add_outline_item(title, objctr + 1);
}

/**************************************************************/
/* savepdf_update_inferred_section()                          */
/*                                                            */
/* Inferred section information is stored with an object      */
/* number for a page's content stream. Later, when the page   */
/* description object number is known, call back here to      */
/* update all entries using the content stream number with    */
/* the new page description object number.                    */
/*                                                            */
/* If there is more than one entry matching the given content */
/* stream object number, all will be updated.                 */
/*                                                            */
/* Parameters: Page content stream object number to find;     */
/*                                                            */
/*             Page description object number to use as a     */
/*             replacement.                                   */
/**************************************************************/

static void savepdf_update_inferred_section
            (
              unsigned int content_number,
              unsigned int description_number
            )
{
  int                      index;
  savepdf_outline_item_t * entry;

  for (index = 0; index < arrays_size(outline_item_dictionary); index++)
  {
    entry = arrays_read(outline_item_dictionary, index);

    if (entry != NULL && entry->page_object_number == content_number)
    {
      entry->page_object_number = description_number;
    }
  }
}

/**************************************************************/
/* savepdf_add_outline_item()                                 */
/*                                                            */
/* Add a new section title to the outline item dictionary     */
/* array.                                                     */
/*                                                            */
/* Parameters: Pointer to the title string (a copy will be    */
/*             taken);                                        */
/*                                                            */
/*             Object number of the page object in which the  */
/*             new section began.                             */
/**************************************************************/

static _kernel_oserror * savepdf_add_outline_item
                         (
                           const char * title,
                           size_t       page_object_number
                         )

{
  savepdf_outline_item_t * entry;
  const char             * title_copy;

  /* Extend the array and copy the string */

  RetError(arrays_extend(outline_item_dictionary, 1));

  title_copy = utils_strdup(title);

  if (title_copy == NULL)
  {
    (void) arrays_extend(outline_item_dictionary, -1);
    return make_no_memory_error(44);
  }

  /* Fill in the entry details */

  entry = arrays_read(outline_item_dictionary, arrays_size(outline_item_dictionary) - 1);

  if (entry != NULL)
  {
    entry->title              = title_copy;
    entry->page_object_number = page_object_number;
  }

  return NULL;
}

/**************************************************************/
/* savepdf_delete_outline_items()                             */
/*                                                            */
/* Delete the outline item dictionary, freeing all titles and */
/* the array.                                                 */
/**************************************************************/

static void savepdf_delete_outline_items(void)
{
  savepdf_outline_item_t * entry;
  int                    i;

  if (outline_item_dictionary != NULL)
  {
    for (i = 0; i < arrays_size(outline_item_dictionary); i++)
    {
      entry = arrays_read(outline_item_dictionary, i);
      if (entry != NULL) free((void *) entry->title);
    }

    arrays_destroy(&outline_item_dictionary);
  }
}

/**************************************************************/
/* savepdf_encoding_callback()                                */
/*                                                            */
/* Callback function for the Unicode library encoding system. */
/* Takes UCS4 characters and writes equivalents to 'outfile'  */
/* in a character set determined by the 'handle' parameter.   */
/*                                                            */
/* Parameters: Handle, which must be a pointer to the         */
/*             Encoding structure used for writing, cast to   */
/*             void *;                                        */
/*                                                            */
/*             UCS4 character to output.                      */
/*                                                            */
/* Returns:    0 if successful; 1 if unsuccessful - global    */
/*             error block 'erb' will be updated.             */
/**************************************************************/

static int savepdf_encoding_callback(void * handle, UCS4 c)
{
  Encoding * encod_write = (Encoding *) handle;
  char     * outbuf      = NULL;
  int        outsize     = 0;

  /* First call with no buffer space. The encoding_write call */
  /* should return 0 indicating insufficient buffer space and */
  /* "outsize" should be updated to a negative value holding  */
  /* the space required. Otherwise, the implication is that   */
  /* the input required no space at all - zero output.        */

  if (
       encoding_write(encod_write,
                      c,
                      &outbuf,
                      &outsize) == 0

       && outsize < 0
     )
  {
    char   * first_free;
    int      remaining;
    size_t   written;

    /* Allocate room based on the absolute value of outsize */

    outsize = (-outsize) + 1;
    outbuf  = malloc(outsize);

    if (outbuf == NULL)
    {
      make_no_memory_error(46);
      return 1; /* Failed, no memory */
    }

    /* Second call with provided buffer space */

    first_free = outbuf;
    remaining  = outsize;

    encoding_write(encod_write,
                   c,
                   &first_free,
                   &remaining);

    /* Convert the (assumed) CP1252 data to PDF encoding? */

    if (savepdf_win1252_to_pdf_flag)
    {
      for (int i = 0; i < outsize - remaining; i++)
      {
        outbuf[i] = savepdf_win1252_to_pdf_map[outbuf[i]];
      }
    }

    /* Write as much as was used in the buffer */

    written = fwrite(outbuf,
                     sizeof(char),
                     outsize - remaining,
                     outfile);

    /* Free the buffer and check for write failures */

    free(outbuf);

    if (written != outsize - remaining)
    {
      erb = *_kernel_last_oserror();
      return 1;
    }
  }

  /* All is OK - we either output something or the call to */
  /* encoding_write at the start indicated that the input  */
  /* produced no output.                                   */

  return 0;
}

/**************************************************************/
/* savepdf_write_string()                                     */
/*                                                            */
/* Write a text string to outfile by enclosing the given      */
/* text in parentheses and converting to the given encoding.  */
/* UTF-16 is recommended for any string objects outside the   */
/* content stream. For strings inside the content stream, the */
/* encoding will depend upon the way that the font encodings  */
/* are specified.                                             */
/*                                                            */
/* The file pointer is left immediately after the closing     */
/* ")" character - no characters whatsoever are output before */
/* or after the text object.                                  */
/*                                                            */
/* Parameters: Pointer to NUL-terminated input text;          */
/*                                                            */
/*             UnicodeLib encoding number (e.g. 'csUnicode11' */
/*             for UTF-16/UCS-2/ISO-10646-UCS-2/UNICODE-1-1/  */
/*             UNICODE-2-0, or 'csWindows1252' for Windows    */
/*             CP1252 encoding - 'WinAnsiEncoding' in PDF).   */
/*             SPECIAL VALUE: Use 'SAVEPDF_PDF_DOC_ENCODING'  */
/*             for strings outside of the content stream, if  */
/*             you want them converted to PDF document        */
/*             encoding. The input is converted to Windows    */
/*             1252 using UnicodeLib then to PDF encoding     */
/*             through a simple lookup table (so a few of the */
/*             characters in PDF encoding that are absent in  */
/*             Windows 1252 will get dropped). Hard spaces    */
/*             are converted to soft spaces before encoding.  */
/**************************************************************/

static _kernel_oserror * savepdf_write_string(const char * restrict s, int encnum_dst)
{
  int            r;
  char           buf[3];
  unsigned int   processed;
  Encoding     * encod_read;
  Encoding     * encod_write;

  /* Encode from the current character set to the requested set; */
  /* the definition of 'current' depends on HTMLLib, not the     */
  /* browser. The browser tells HTMLLib about the document       */
  /* encoding so that HTMLLib can convert everything into UTF-8  */
  /* or Acorn Latin-1.                                           */

  #ifdef UNIFONT
    /* HTMLLib outputs UTF-8 */
    int encnum_src = csUTF8;
  #else
    /* HTMLLib outputs Acorn Latin-1 */
    int encnum_src = csAcornLatin1;
  #endif

  /* If wanting PDF encoding, start with Windows 1252 */

  if (encnum_dst == SAVEPDF_PDF_DOC_ENCODING)
  {
    encnum_dst                  = csWindows1252;
    savepdf_win1252_to_pdf_flag = 1;
  }
  else
  {
    savepdf_win1252_to_pdf_flag = 0;
  }

  encod_read  = encoding_new(encnum_src, encoding_READ);
  encod_write = encoding_new(encnum_dst, encoding_WRITE);

  /* In the very unlikely event that the Unicode library says */
  /* UTF-16 isn't a known encoding name, the encoding number  */
  /* it returns is zero; encoding_new will fail and this will */
  /* get reported as an out of memory condition.              */

  if (encod_read == NULL || encod_write == NULL)
  {
    encoding_delete(encod_read);
    encoding_delete(encod_write);

    return make_no_memory_error(46);
  }

  /* Open the string object */

  r = fprintf(outfile, "(");
  if (r < 0) RetLastE;

  /* Run through source character by source character; this is    */
  /* valid for any source encoding type because HTMLLib converted */
  /* everything to UTF-8 or Acorn Latin-1 and the characters to   */
  /* be mapped are the same per byte in either case.              */

  while (*s != '\0')
  {
    /* Escape special characters */

    switch (*s)
    {
      case '(':  strcpy(buf, "\\(");  break;
      case ')':  strcpy(buf, "\\)");  break;
      case '\n': strcpy(buf, "\\n");  break;
      case '\r': strcpy(buf, "\\r");  break;
      case '\t': strcpy(buf, "\\t");  break;
      case '\b': strcpy(buf, "\\b");  break;
      case '\\': strcpy(buf, "\\\\"); break;

      default:
      {
        buf[0] = *s;
        buf[1] = '\0';
      }
      break;
    }

    /* Output the escaped result in the destination character set */

    processed = encoding_read(encod_read,
                              savepdf_encoding_callback,
                              buf,
                              strlen(buf),
                              (void *) encod_write);

    if (processed < strlen(buf))
    {
      /* Encoding failed */

      encoding_delete(encod_read);
      encoding_delete(encod_write);

      return &erb;
    }

    /* OK, get the next source character */

    s++;
  }

  /* Flush the output */

  if (savepdf_encoding_callback(NULL, NULL_UCS4) != 0)
  {
    /* Flushing failed */

    encoding_delete(encod_read);
    encoding_delete(encod_write);

    return &erb;
  }

  /* Free the encoding structures */

  encoding_delete(encod_read);
  encoding_delete(encod_write);

  /* Close the string object */

  r = fprintf(outfile, ")");
  if (r < 0) RetLastE;

  /* All done */

  return NULL;
}

/**************************************************************/
/* savepdf_write_current_date_and_time()                      */
/*                                                            */
/* Output a PDF date specifier ("D:YYYYMMDDhhmmss") to        */
/* outfile, using the current date and time.                  */
/**************************************************************/

static _kernel_oserror * savepdf_write_current_date_and_time(void)
{
  char block  [5];
  char buffer [15];
  int  r;

  block[0] = 3; /* OS_Word 14 sub-reason code, read soft-copy of CMOS clock as 5-byte integer */

  RetError(_swix(OS_Word,
                 _INR(0,1),

                 14, /* 14 - read CMOS clock */
                 block));

  RetError(_swix(OS_ConvertDateAndTime,
                 _INR(0,3),

                 block,
                 buffer,
                 sizeof(buffer),
                 "%CE%YR%MN%DY%24%MI%SE"));

  r = fprintf(outfile, "(D:%s)", buffer);
  if (r < 0) RetLastE;

  return NULL;
}

/**************************************************************/
/* savepdf_write_header()                                     */
/*                                                            */
/* Write the start of a PDF file based on locals outfile and  */
/* outbrow set up using savepdf_start_session.                */
/*                                                            */
/* Creates the following -                                    */
/*                                                            */
/*  Header                                                    */
/*  Document info                                             */
/*  Font table and naming dictionary                          */
/**************************************************************/

_kernel_oserror * savepdf_write_header(void)
{
  if (outfile != NULL)
  {
    char * title;
    int    r;

    /* Work out the document title */

    title = browser_current_title(outbrow);
    if (title == NULL) title = lookup_token("PDFTitle:Converted Web page", 0, 0);

    /* PDF version and comment with high bit set characters */

    r = fprintf(outfile, "%%PDF-1.3\n%%\n\n");
    if (r < 0) RetLastE;

    /* Comment to introduce document information */

    r = fprintf(outfile, "%%\n"
                         "%% Document information\n"
                         "%%\n\n");

    if (r < 0) RetLastE;

    /* Document information */

    RetError(savepdf_record_new_object_address()); /* Start object 1 */

    {
      char user_agent[Limits_UserAgent];

      utils_build_user_agent_string(choices.clone, user_agent, sizeof(user_agent));

      r = fprintf(outfile, "%d 0 obj\n"
                           "<<\n"
                           "  /Producer     ",

                           PDF_OBJ_INFORMATION);

      if (r < 0) RetLastE;

      RetError(savepdf_write_string(user_agent, SAVEPDF_PDF_DOC_ENCODING));

      r = fprintf(outfile, "\n"
                           "  /Creator      ");
      if (r < 0) RetLastE;

      RetError(savepdf_write_string(user_agent, SAVEPDF_PDF_DOC_ENCODING));

      r = fprintf(outfile, "\n"
                           "  /CreationDate ");

      if (r < 0) RetLastE;

      RetError(savepdf_write_current_date_and_time());

      r = fprintf(outfile, "\n"
                           "  /ModDate      ");

      if (r < 0) RetLastE;

      RetError(savepdf_write_current_date_and_time());

      r = fprintf(outfile, "\n"
                           "  /Title        ");

      if (r < 0) RetLastE;

      #ifdef UNIFONT
        RetError(savepdf_write_string(title, csUnicode11));
      #else
        RetError(savepdf_write_string(title, SAVEPDF_PDF_DOC_ENCODING));
      #endif

      r = fprintf(outfile, "\n"
                           ">>\n"
                           "endobj\n\n");

      if (r < 0) RetLastE;
    }

    /* Skip over the page table - pages need to know the object number */
    /* for this up-front. So, allocate object 2 for that.              */

    RetError(savepdf_record_new_object_address()); /* Skip object 2 */

    /* Comment to introduce font names dictionary */

    r = fprintf(outfile, "%%\n"
                         "%% Dictionary assigning names (\"F0\", \"F1\" etc.) to fonts\n"
                         "%%\n\n");

    if (r < 0) RetLastE;

    /* Font names dictionary */

    RetError(savepdf_record_new_object_address()); /* Start object 3 */

    /* This indirected object's number is needed in page descriptions */
    /* so record it for use later.                                    */

    r = fprintf(outfile, "%d 0 obj\n"
                         "<<\n",

                         PDF_OBJ_FONTS_START);

    if (r < 0) RetLastE;

    for (
          int i = 0;
          i < sizeof(font_name_map) / sizeof(*font_name_map);
          i++
        )
    {
      r = fprintf(outfile, "  /F%d %d 0 R\n", i, PDF_OBJ_FONTS_START + i + 1);
      if (r < 0) RetLastE;
    }

    r = fprintf(outfile, ">>\n"
                         "endobj\n\n");

    if (r < 0) RetLastE;

    /* Comment to introduce font dictionaries */

    r = fprintf(outfile, "%%\n"
                         "%% Standard set of 12 fonts - 3 variants each with 4 weights\n"
                         "%%\n\n");

    if (r < 0) RetLastE;

    /* Font dictionaries */

    for (
          int i = 0;
          i < sizeof(font_name_map) / sizeof(*font_name_map);
          i++
        )
    {
      RetError(savepdf_record_new_object_address()); /* Start object 4 upwards */

      /* We use Windows CP1252 encoding in the PDF as it has a pretty */
      /* wide range of characters and widespread support. UnicodeLib  */
      /* converts from the system encoding, which is assumed to be    */
      /* the one in which the page has been produced, to CP1252.      */

      r = fprintf(outfile, "%d 0 obj\n"
                           "<<\n"
                           "  /Type     /Font\n"
                           "  /Subtype  /Type1\n"
                           "  /BaseFont /%s\n"
                           "  /Encoding /WinAnsiEncoding\n"
                           ">>\n"
                           "endobj\n",

                           PDF_OBJ_FONTS_START + i + 1,
                           font_name_map[i].adobe_name);
    }

    fprintf(outfile, "\n");
    if (r < 0) RetLastE;

    /* Store an outline item based on the title. The next thing */
    /* that gets output MUST be the first document page (see    */
    /* savepdf_start_page).                                     */
    /*                                                          */
    /* We have to look up 'title' again in case it was NULL and */
    /* lookup_token was used - the buffer it writes into may be */
    /* overwritten, e.g. by the user agent string call earlier. */

    title = browser_current_title(outbrow);
    if (title == NULL) title = lookup_token("PDFTitle:Converted Web page", 0, 0);

    RetError(savepdf_new_inferred_section(title));

  } /* 'if (outfile != NULL)' */

  return NULL;
}

/**************************************************************/
/* savepdf_start_page()                                       */
/*                                                            */
/* Output constructs to start a new page so graphics commands */
/* can be written.                                            */
/*                                                            */
/* Parameters: Page width in millipoints;                     */
/*                                                            */
/*             Page height in millipoints.                    */
/**************************************************************/

_kernel_oserror * savepdf_start_page(int width, int height)
{
  int r;

  if (outfile == NULL) return NULL;

  pwidth   = width;
  pheight  = height;
  poriginx = 0;
  poriginy = 0;

  /* Clear the record of the current clipping rectangle */

  current_clip_known = 0;

  /* Reset the record of used images and sprites */

  images_in_page = arrays_create(0, sizeof(savepdf_image_info_t));
  if (images_in_page == NULL) return make_no_memory_error(43);

  /* Reset the record of links used within this page */

  annotation_dictionary = arrays_create(0, sizeof(savepdf_annotation_t));
  if (annotation_dictionary == NULL) return make_no_memory_error(43);

  /* Comment to introduce page contents object */

  r = fprintf(outfile, "%%\n"
                       "%% Page %d: Page contents\n"
                       "%%\n\n",

                       pagectr + 1);

  if (r < 0) RetLastE;

  /* Page contents object start */

  RetError(savepdf_record_new_object_address());

  r = fprintf(outfile, "%d 0 obj\n"
                       "<<\n"
                       "  /Length %d 0 R\n"
                       ">>\n"
                       "stream\n",

                       objctr,
                       objctr + 1);

  if (r < 0) RetLastE;

  pstart = ftell(outfile);

  /* Push the existing graphics context onto the stack three times. */
  /* Once preserves the original so we can pop down back to it to   */
  /* clear translations and clipping rectangles. The next holds the */
  /* print offset translation. The next holds the clipping region.  */
  /* It's all set up by savepdf_give_rectangle or through the       */
  /* RedrawCore clipping function.                                  */

  r = fprintf(outfile, "q\nq\nq\n");
  if (r < 0) RetLastE;

  return NULL;
}

/**************************************************************/
/* savepdf_give_rectangle()                                   */
/*                                                            */
/* Set the given body region as a base clipping rectangle     */
/* and set up coordinate translation to the given origin.     */
/*                                                            */
/* Parameters: Pointer to a BBox describing the body region   */
/*             in OS units, min inclusive, max exclusive;     */
/*                                                            */
/*             Pointer to a BBox where the 'min' coordinates  */
/*             hold the plotting origin in millipoints.       */
/**************************************************************/

_kernel_oserror * savepdf_give_rectangle
                  (
                    const BBox * restrict os_body,
                    const BBox * restrict mp_origin
                  )
{
  BBox user_body, user_origin;
  BBox            pdf_origin;
  int             r;

  if (outfile == NULL) return NULL;

  /* Get the coordinates in PDF user space */

  scale_box_os_to_user          (outbrow, os_body,      &user_body);
  scale_box_millipoints_to_user (outbrow, mp_origin,    &user_origin);
  scale_box_user_to_pdf         (outbrow, &user_origin, &pdf_origin);

  poriginx = pdf_origin.xmin;
  poriginy = pdf_origin.ymin;

  r = fprintf(outfile, "Q\nQ\nQ\n"          /* Pop contexts from a previous rectangle or page start */
                       "q\n"                /* Store the untranslated, unclipped outermost context  */
                       "1 0 0 1 %s %s cm\n" /* Set up the translation in the current context        */
                       "q\n",               /* Push this translated context onto the stack          */

                       savepdf_itoa(poriginx),
                       savepdf_itoa(poriginy));

  if (r < 0) RetLastE;

  /* Set up a basic clipping rectangle. This call will pop to the   */
  /* translated graphics context first, set the rectangle, and push */
  /* the result.                                                    */

  RetError(savepdf_jmptbl_clipping(outbrow, &user_body, NULL));

  /* Now push the context again, so that we're saving this clipping */
  /* region as a master copy for any general redraw clipping.       */

  r = fprintf(outfile, "q\n");
  if (r < 0) RetLastE;

  return NULL;

}

/**************************************************************/
/* savepdf_end_page()                                         */
/*                                                            */
/* Output constructs to end a new page after a stream of      */
/* graphics commands has been written.                        */
/**************************************************************/

_kernel_oserror * savepdf_end_page(void)
{
  if (outfile != NULL)
  {
    unsigned int contents_objnum;
    unsigned int draw_sprite_objnums[draw_sprite_count]; /* C99 */
    long int     pend;
    int          r, size;

    /* Restore the original outermost graphics context */

    r = fprintf(outfile, "Q\nQ\nQ");
    if (r < 0) RetLastE;

    /* Page contents object end - PDF doesn't include the last "\n" */
    /* as part of the stream length.                                */

    pend = ftell(outfile);

    r = fprintf(outfile, "\n"
                         "endstream\n"
                         "endobj\n\n");

    if (r < 0) RetLastE;

    /* Record the object number of the content stream so */
    /* that the page description object can use it later */

    contents_objnum = objctr;

    /* Comment to introduce page contents length object */

    r = fprintf(outfile, "%%\n"
                         "%% Page %d: Length of page contents\n"
                         "%%\n\n",

                         pagectr + 1);

    if (r < 0) RetLastE;

    /* Page contents length object start */

    RetError(savepdf_record_new_object_address());

    r = fprintf(outfile, "%d 0 obj\n"
                         "%d\n"
                         "endobj\n\n",

                         objctr,
                         (int) (pend - pstart));

    if (r < 0) RetLastE;

    /* Before we output the page description, output any images */
    /* that were used by the page and have not already been     */
    /* converted and written to the PDF file.                   */

    for (int index = 0; index < arrays_size(images_in_page); index++)
    {
      savepdf_image_info_t * entry = arrays_read(images_in_page, index);
      if (entry == NULL) continue;

      /* Has this image been output before? */

      if (
           savepdf_find_image_in_output_array(entry->type,
                                              entry->data.image_number,
                                              entry->data.sprite_name)
           < 0
         )
      {
        /* This image has not previously been written out */

        RetError(savepdf_record_output_image(objctr + 1,
                                             entry->type,
                                             entry->data.image_number,
                                             entry->data.sprite_name));

        switch (entry->type)
        {
          case savepdf_image_type_SPRITE:
          {
            /* Local sprites we can do ourselves. */

            RetError(savepdf_sprite_name_to_pdf(outbrow,
                                                (void *) sprite_block,
                                                entry->data.sprite_name,
                                                NULL));
          }
          break;

          case savepdf_image_type_IMAGE:
          {
            /* For images, we have to call the Images.c routines, */
            /* which will eventually call back with a sprite.     */

            RetError(image_send_to_pdf(outbrow,
                                       entry->data.image_number,
                                       NULL));
          }
          break;
        }
      }
    }

    /* Sprites from Draw files */

    for (int image = 0; image < draw_sprite_count; image++)
    {
      int               oldbudge = flex_set_budge(0);
      char              name[Limits_OS_SpriteName];
      _kernel_oserror * e;

      draw_sprite_objnums[image] = objctr + 1;
      sprintf(name, "%d", image);

      e = savepdf_sprite_name_to_pdf(outbrow,
                                     (void *) draw_sprite_pool,
                                     name,
                                     NULL);

      flex_set_budge(oldbudge);

      if (e != NULL) return e;
    }

    /* Before the page description, also output a list of all the */
    /* annotations (links) used by that page.                     */

    if (arrays_size(annotation_dictionary) > 0)
    {
     /* Comment to introduce annotation objects */

      r = fprintf(outfile, "%%\n"
                           "%% Page %d: Annotations (hyperlinks)\n"
                           "%%\n"
                           "\n",

                           pagectr + 1);

      if (r < 0) RetLastE;
    }

    for (int index = 0; index < arrays_size(annotation_dictionary); index++)
    {
      savepdf_annotation_t * entry = arrays_read(annotation_dictionary, index);
      if (entry == NULL) continue;

      RetError(savepdf_record_new_object_address());
      entry->object_number = objctr;

      /* Object header */

      r = fprintf(outfile, "%d 0 obj\n"
                           "<<\n"
                           "  /Type    /Annot\n"
                           "  /Subtype /Link\n"
                           "  /Border  [ 0 0 0 ]\n"
                           "  /Rect    [ %s %s %s %s ]\n"
                           "  /A       <<\n"
                           "             /Type /Action\n",

                           objctr,
                           savepdf_itoa(entry->bounds.xmin),
                           savepdf_itoa(entry->bounds.ymin),
                           savepdf_itoa(entry->bounds.xmax),
                           savepdf_itoa(entry->bounds.ymax));

      if (r < 0) RetLastE;

      /* The action section varies for in-document or external links */

      if (entry->uri)
      {
        r = fprintf(outfile, "             /S    /URI\n"
                             "             /URI  ");

        if (r < 0) RetLastE;
      }
      else
      {
        r = fprintf(outfile, "             /S    /GoTo\n"
                             "             /D    ");

        if (r < 0) RetLastE;
      }

      /* Write out the link text and finish off the object */

      RetError(savepdf_write_string(entry->link, csWindows1252));

      r = fprintf(outfile, "\n"
                           "           >>\n"
                           ">>\n"
                           "endobj\n\n");

      if (r < 0) RetLastE;
    }

    /* Tell the section inference system about the object number */
    /* we're about to use for the page description object. Do    */
    /* the same for the named destination system.                */

    savepdf_update_inferred_section (contents_objnum, objctr + 1);
    savepdf_update_name             (contents_objnum, objctr + 1);

    /* Comment to introduce page description object. */

    r = fprintf(outfile, "%%\n"
                         "%% Page %d: Page description\n"
                         "%%\n\n",

                         pagectr + 1);

    if (r < 0) RetLastE;

    RetError(savepdf_record_new_object_address());
    RetError(savepdf_record_page_object_number(objctr));

    r = fprintf(outfile, "%d 0 obj\n"
                         "<<\n"
                         "  /Type      /Page\n"
                         "  /Parent    %d 0 R\n"
                         "  /MediaBox  [\n"
                         "               0\n"
                         "               0\n"
                         "               %s\n"
                         "               %s\n"
                         "             ]\n"
                         "  /Rotate    0\n"
                         "  /Contents  %d 0 R\n"
                         "  /Resources <<\n"
                         "               /Font %d 0 R\n",
                         objctr,
                         PDF_OBJ_PAGE_TABLE,
                         savepdf_itoa(pwidth),
                         savepdf_itoa(pheight),
                         contents_objnum,
                         PDF_OBJ_FONTS_START);

    if (r < 0) RetLastE;

    /* We may need to name some images here */

    if ((size = arrays_size(images_in_page)) > 0 || draw_sprite_count > 0)
    {
      int                    index;
      int                    output_image_index;
      savepdf_image_info_t * entry;
      savepdf_image_info_t * output_image;

      r = fprintf(outfile, "               /XObject <<\n");
      if (r < 0) RetLastE;

      if (size > 0)
      {
        /* Go through all images output for this page */

        for (index = 0; index < size; index++)
        {
          entry = arrays_read(images_in_page, index);
          if (entry == NULL) continue;

          /* Find this image in the output images array */

          output_image_index = savepdf_find_image_in_output_array(entry->type,
                                                                  entry->data.image_number,
                                                                  entry->data.sprite_name);

          if (output_image_index < 0) continue;
          output_image = arrays_read(images_output, output_image_index);
          if (output_image == NULL) continue;

          /* Use the written image information for the XObject sub-dictionary */

          switch (output_image->type)
          {
            case savepdf_image_type_SPRITE:
            {
              r = fprintf(outfile, "                          /%s%s %d 0 R\n",

                                   SAVEPDF_IMAGE_XOBJECT_NAME_PREFIX,
                                   output_image->data.sprite_name,
                                   output_image->pdf_object_number);
            }
            break;

            case savepdf_image_type_IMAGE:
            {
              r = fprintf(outfile, "                          /%s%d %d 0 R\n",

                                   SAVEPDF_IMAGE_XOBJECT_FILE_PREFIX,
                                   output_image->data.image_number,
                                   output_image->pdf_object_number);
            }
            break;
          }

          if (r < 0) RetLastE;
        }
      }

      if (draw_sprite_count > 0)
      {
        int image;

        /* Go through all of the Draw file images */

        for (image = 0; image < draw_sprite_count; image++)
        {
          r = fprintf(outfile, "                          /%s%d %d 0 R\n",

                               SAVEPDF_IMAGE_XOBJECT_DRAW_PREFIX,
                               image,
                               draw_sprite_objnums[image]);

          if (r < 0) RetLastE;
        }

        /* Delete the now-redundant pool and reset the counter */

        flex_free((flex_ptr) &draw_sprite_pool);
        draw_sprite_count = 0;
      }

      r = fprintf(outfile, "                        >>\n");
      if (r < 0) RetLastE;
    }

    /* Close the resource sub-dictionary */

    r = fprintf(outfile, "             >>\n");
    if (r < 0) RetLastE;

    /* We might need to list some annotations too */

    if ((size = arrays_size(annotation_dictionary)) > 0)
    {
      int                    index;
      savepdf_annotation_t * entry;

      r = fprintf(outfile, "  /Annots    [\n");
      if (r < 0) RetLastE;

      for (index = 0; index < size; index++)
      {
        entry = arrays_read(annotation_dictionary, index);
        if (entry == NULL) continue;

        r = fprintf(outfile, "               %d 0 R\n",
                             entry->object_number);

        if (r < 0) RetLastE;
      }

      r = fprintf(outfile, "             ]\n");
      if (r < 0) RetLastE;
    }

    /* Finish off the outer object */

    r = fprintf(outfile, ">>\n"
                         "endobj\n\n");

    if (r < 0) RetLastE;
  }

  /* Delete the record of images used in the page */

  if (images_in_page) arrays_destroy(&images_in_page);

  /* Delete the record of links used in the page too */

  if (annotation_dictionary) arrays_destroy(&annotation_dictionary);

  return NULL;
}

/**************************************************************/
/* savepdf_write_trailer()                                    */
/*                                                            */
/* Finish off the document, including -                       */
/*                                                            */
/*   Page table                                               */
/*   Named annotations                                        */
/*   Outlines                                                 */
/*   Catalog                                                  */
/*   Cross-reference table                                    */
/*   PDF trailer                                              */
/*                                                            */
/* The output file is not closed nor is its filetype set.     */
/* Please see savepdf_end_session for more.                   */
/**************************************************************/

_kernel_oserror * savepdf_write_trailer(void)
{
  if (outfile != NULL)
  {
    long int xref_start;
    size_t   catalog_number;
    size_t   outlines_number;
    size_t   destinations_start;
    size_t   names_number = 0;
    int      r;

    /* Comment to introduce the page table */

    r = fprintf(outfile, "%%\n"
                         "%% Page table\n"
                         "%%\n\n");

    if (r < 0) RetLastE;

    /* Page table */

    savepdf_update_object_address(PDF_OBJ_PAGE_TABLE, ftell(outfile));

    r = fprintf(outfile, "%d 0 obj\n"
                         "<<\n"
                         "  /Type  /Pages\n"
                         "  /Kids  [\n",

                         PDF_OBJ_PAGE_TABLE);

    if (r < 0) RetLastE;

    for (int i = 1; i <= pagectr; i++)
    {
      r = fprintf(outfile, "           %d 0 R\n",
                           savepdf_read_page_object_number(i));

      if (r < 0) RetLastE;
    }

    r = fprintf(outfile, "         ]\n"
                         "  /Count %d\n"
                         ">>\n"
                         "endobj\n\n",

                         pagectr);

    if (r < 0) RetLastE;

    /* Annotations - named destinations */

    if (arrays_size(name_dictionary) > 0)
    {
      savepdf_name_t * item;
      int              i;

      /* PDF requires the names to be sorted alphabetically */

      savepdf_sort_names();

      /* Comment to introduce the list of destinations */

      r = fprintf(outfile, "%%\n"
                           "%% Destinations\n"
                           "%%\n\n");

      if (r < 0) RetLastE;
      else destinations_start = objctr + 1;

      for (i = 0; i < arrays_size(name_dictionary); i++)
      {
        item = arrays_read(name_dictionary, i);
        if (item == NULL) continue;

        RetError(savepdf_record_new_object_address());

        r = fprintf(outfile, "%d 0 obj\n"
                             "<<\n"
                             "  /D [ %d 0 R /XYZ null %s null ]\n"
                             ">>\n"
                             "endobj\n\n",

                             objctr,
                             item->page_object_number,
                             savepdf_itoa(item->bounds.ymax));

        if (r < 0) RetLastE;
      }

      /* Name the destinations - object header */

      RetError(savepdf_record_new_object_address());
      names_number = objctr;

      r = fprintf(outfile, "%%\n"
                           "%% Destination names\n"
                           "%%\n"
                           "\n"
                           "%d 0 obj\n"
                           "<<\n"
                           "  /Names  [\n",

                           objctr);

      if (r < 0) RetLastE;

      /* Names and object numbers */

      for (i = 0; i < arrays_size(name_dictionary); i++)
      {
        item = arrays_read(name_dictionary, i);
        if (item == NULL) continue;

        r = fprintf(outfile, "            ");
        if (r < 0) RetLastE;

        RetError(savepdf_write_string(item->name, csWindows1252));

        r = fprintf(outfile, " %d 0 R\n",
                             destinations_start + i);

        if (r < 0) RetLastE;
      }

      /* First and last strings - if for some reason we cannot read one of */
      /* the required array entries, output an empty string and hope that  */
      /* the PDF viewer the user's going to run doesn't mind!              */

      r = fprintf(outfile, "          ]\n"
                           "  /Limits [\n"
                           "            ");

      if (r < 0) RetLastE;

      item = arrays_read(name_dictionary, 0);
      RetError(savepdf_write_string(item == NULL ? "" : item->name, csWindows1252));

      r = fprintf(outfile, "\n"
                           "            ");

      if (r < 0) RetLastE;

      item = arrays_read(name_dictionary, arrays_size(name_dictionary) - 1);
      RetError(savepdf_write_string(item == NULL ? "" : item->name, csWindows1252));

      /* Finish off the object */

      r = fprintf(outfile, "\n"
                           "          ]\n"
                           ">>\n"
                           "endobj\n\n");

      if (r < 0) RetLastE;

      /* PDF allows quite complex sets of names, so there's an intermediate */
      /* object required as part of the name tree even in this simple case. */

      RetError(savepdf_record_new_object_address());

      r = fprintf(outfile, "%%\n"
                           "%% Destination name tree information\n"
                           "%%\n"
                           "\n"
                           "%d 0 obj\n"
                           "<<\n"
                           "  /Kids [ %d 0 R ]\n"
                           ">>\n"
                           "endobj\n\n",

                           objctr,
                           names_number);

      if (r < 0) RetLastE;

      /* Identify the name tree as a set of named destinations to finish. */
      /* All that remains is to place an entry in the document catalogue  */
      /* referring back to this last object.                              */

      RetError(savepdf_record_new_object_address());

      r = fprintf(outfile, "%%\n"
                           "%% Identify the name tree object\n"
                           "%%\n"
                           "\n"
                           "%d 0 obj\n"
                           "<<\n"
                           "  /Dests %d 0 R\n"
                           ">>\n"
                           "endobj\n\n",

                           objctr,
                           names_number + 1);

      if (r < 0) RetLastE;
    }

    /* Outlines */

    outlines_number = 0;

    /* If there is only one item in the outline dictionary, this is */
    /* because the document title got in there but no other section */
    /* titles were inferred during 'redraw'. Don't output the       */
    /* outline table in such cases. Otherwise, build the table.     */

    if (arrays_size(outline_item_dictionary) > 1)
    {
      /* Comment to introduce outlines objects */

      r = fprintf(outfile, "%%\n"
                           "%% Document outlines\n"
                           "%%\n\n");

      if (r < 0) RetLastE;

      /* Outline dictionary */

      RetError(savepdf_record_new_object_address());
      outlines_number = objctr;

      r = fprintf(outfile, "%d 0 obj\n"
                           "<<\n"
                           "  /Type  /Outlines\n"
                           "  /First %d 0 R\n"
                           "  /Last  %d 0 R\n"
                           "  /Count %d\n"
                           ">>\n"
                           "endobj\n\n",

                           outlines_number,
                           outlines_number + 1,
                           outlines_number + arrays_size(outline_item_dictionary),
                           arrays_size(outline_item_dictionary));

      if (r < 0) RetLastE;

      /* Outline item dictionaries. If for any reason there is a problem */
      /* reading from the dictionary array, we still have to output some */
      /* kind of entry because the previous object gives a count of how  */
      /* many there must be. In such cases we give an empty title string */
      /* and (attempt to) link to the first page object - look for the   */
      /* "item == NULL" checks for how.                                  */
      /*                                                                 */
      /* First up the initial entry - document title. Use this as a node */
      /* so that real inferred sections appear below it.                 */

      RetError(savepdf_record_new_object_address());

      {
        savepdf_outline_item_t * item = arrays_read(outline_item_dictionary, 0);

        r = fprintf(outfile, "%d 0 obj\n"
                             "<<\n"
                             "  /Title  ",

                             outlines_number + 1);

        if (r < 0) RetLastE;

        /* See above for rationale of "item == NULL" check */

        #ifdef UNIFONT
          RetError(savepdf_write_string(item == NULL ? "" : item->title, csUnicode11));
        #else
          RetError(savepdf_write_string(item == NULL ? "" : item->title, SAVEPDF_PDF_DOC_ENCODING));
        #endif

        r = fprintf(outfile, "\n"
                             "  /Parent %d 0 R\n"
                             "  /First  %d 0 R\n"
                             "  /Last   %d 0 R\n"
                             "  /Count  %d\n"
                             "  /Dest   [\n"
                             "            %d 0 R\n"
                             "            /XYZ\n"
                             "            null null null\n"
                             "          ]\n"
                             ">>\n"
                             "endobj\n\n",

                             outlines_number,
                             outlines_number + 2,
                             outlines_number + arrays_size(outline_item_dictionary),
                             arrays_size(outline_item_dictionary) - 1,

                             /* See above for rationale of "item == NULL" check */

                             item == NULL ? savepdf_read_page_object_number(1) : item->page_object_number);

        if (r < 0) RetLastE;
      }

      /* Now the rest of the outline items */

      for (int i = 1; i < arrays_size(outline_item_dictionary); i++)
      {
        savepdf_outline_item_t * item = arrays_read(outline_item_dictionary, i);

        RetError(savepdf_record_new_object_address());

        r = fprintf(outfile, "%d 0 obj\n"
                             "<<\n"
                             "  /Title  ",

                             outlines_number + 1 + i);

        if (r < 0) RetLastE;

        /* See above for rationale of "item == NULL" check */

        #ifdef UNIFONT
          RetError(savepdf_write_string(item == NULL ? "" : item->title, csUnicode11));
        #else
          RetError(savepdf_write_string(item == NULL ? "" : item->title, SAVEPDF_PDF_DOC_ENCODING));
        #endif

        r = fprintf(outfile, "\n"
                             "  /Parent %d 0 R\n",

                             outlines_number + 1);

        if (r < 0) RetLastE;

        if (i > 1)
        {
          /* "outlines_number + i" =           */
          /* "(outlines_number + 1) + (i - 1)" */

          r = fprintf(outfile, "  /Prev   %d 0 R\n", outlines_number + i);
          if (r < 0) RetLastE;
        }

        if (i < arrays_size(outline_item_dictionary) - 1)
        {
          /* "outlines_number + i + 2" =       */
          /* "(outlines_number + 1) + (i + 1)" */

          r = fprintf(outfile, "  /Next   %d 0 R\n", outlines_number + i + 2);
          if (r < 0) RetLastE;
        }

        r = fprintf(outfile, "  /Dest   [\n"
                             "            %d 0 R\n"
                             "            /XYZ\n"
                             "            null null null\n"
                             "          ]\n"
                             ">>\n"
                             "endobj\n\n",

                             /* See above for rationale of "item == NULL" check */

                             item == NULL ? savepdf_read_page_object_number(1) : item->page_object_number);

        if (r < 0) RetLastE;
      }
    }

    /* Comment to introduce catalog object */

    r = fprintf(outfile, "%%\n"
                         "%% Document catalogue\n"
                         "%%\n\n");

    if (r < 0) RetLastE;

    /* Catalog */

    RetError(savepdf_record_new_object_address());
    catalog_number = objctr;

    r = fprintf(outfile, "%d 0 obj\n"
                         "<<\n"
                         "  /Type       /Catalog\n"
                         "  /Pages      %d 0 R\n"
                         "  /PageLayout /TwoColumnRight\n",

                         catalog_number,
                         PDF_OBJ_PAGE_TABLE);

    if (r < 0) RetLastE;

    /* Are there any named destinations? */

    if (names_number != 0)
    {
      r = fprintf(outfile, "  /Names      %d 0 R\n", names_number + 2);
      if (r < 0) RetLastE;
    }

    /* Don't mention outlines unless there are some to show */

    if (arrays_size(outline_item_dictionary) > 1)
    {
      r = fprintf(outfile, "  /Outlines   %d 0 R\n"
                           "  /PageMode   /UseOutlines\n",

                           outlines_number);

      if (r < 0) RetLastE;
    }

    /* End the object */

    r = fprintf(outfile, ">>\n" "endobj\n\n");
    if (r < 0) RetLastE;

    /* Comment to introduce cross reference table and trailer */

    r = fprintf(outfile, "%%\n"
                         "%% Cross reference table and trailer\n"
                         "%%\n\n");

    if (r < 0) RetLastE;

    /* Cross reference table */

    xref_start = ftell(outfile);

    r = fprintf(outfile, "xref\n"
                         "0 %d\n"
                         "0000000000 65535 f \n", /* We didn't define object zero */

                         objctr + 1);

    if (r < 0) RetLastE;

    for (int i = 1; i <= objctr; i++)
    {
      r = fprintf(outfile, "%010d 00000 n \n", (int) savepdf_read_object_address(i));
      if (r < 0) RetLastE;
    }

    /* Trailer - then we're finished! */

    r = fprintf(outfile, "\ntrailer\n"
                         "<<\n"
                         "  /Size %d\n"
                         "  /Root %d 0 R\n"
                         "  /Info %d 0 R\n"
                         ">>\n"
                         "startxref\n"
                         "%d\n"
                         "%%%%EOF\n",

                         objctr + 1,
                         catalog_number,
                         PDF_OBJ_INFORMATION,
                         (int) xref_start);

    if (r < 0) RetLastE;
  }

  return NULL;
}

/**************************************************************/
/* savepdf_jmptbl_line()                                      */
/*                                                            */
/* Veneer function for the redraw table. Writes a PDF file    */
/* converting user-points to PDF user space.                  */
/*                                                            */
/* Parameters: See redraw_line_fn_ptr_t, RedrawCore.h.        */
/*                                                            */
/* Returns:    See redraw_line_fn_ptr_t, RedrawCore.h.        */
/**************************************************************/

static _kernel_oserror * savepdf_jmptbl_line
                         (
                           const browser_data * restrict b,
                           const BBox         * restrict ends,
                           unsigned int                  colour,

                           size_t             * restrict r_size
                         )
{
  if (r_size == NULL)
  {
    BBox pdf;
    int  width, r;

    if (outfile == NULL) return NULL;

    RetError(savepdf_write_colour(colour, 1));

    scale_box_user_to_pdf(b, ends, &pdf);
    width = scale_user_to_pdf(b, scale_os_to_user(b, 1)); /* 2 OS units looks too think, so use 1 instead */

    /* Set the line width, move to the line start, draw to the */
    /* line end and stroke the path, closing it.               */

    r = fprintf(outfile,
                "%s w %s %s m %s %s l s\n",

                savepdf_itoa(width),
                savepdf_itoa(pdf.xmin),
                savepdf_itoa(pdf.ymin),
                savepdf_itoa(pdf.xmax),
                savepdf_itoa(pdf.ymax));

    if (r < 0) RetLastE;
  }
  else
  {
    *r_size = 0; // NOT YET IMPLEMENTED
  }

  return NULL;
}

/**************************************************************/
/* savepdf_jmptbl_rectangle()                                 */
/*                                                            */
/* Veneer function for the redraw table. Writes a PDF file    */
/* converting user-points to PDF user space.                  */
/*                                                            */
/* Parameters: See redraw_rectangle_fn_ptr_t, RedrawCore.h.   */
/*                                                            */
/* Returns:    See redraw_rectangle_fn_ptr_t, RedrawCore.h.   */
/**************************************************************/

static _kernel_oserror * savepdf_jmptbl_rectangle
                         (
                           const browser_data * restrict b,
                           const BBox         * restrict rect,
                           unsigned int         colour,
                           unsigned int         border,

                           size_t             * restrict r_size
                         )
{
  if (r_size == NULL)
  {
    BBox         draw;
    unsigned int width, height;

    if (outfile == NULL) return NULL;

    scale_box_user_to_pdf(b, rect, &draw);

    width  = draw.xmax - draw.xmin;
    height = draw.ymax - draw.ymin;

    if (border != 0)
    {
      unsigned int thickness = scale_user_to_pdf(b, border);

      if (thickness == 0) thickness = 1;

      RetError(savepdf_rectangle_fill(draw.xmin,             draw.ymin,             width,     thickness, colour));
      RetError(savepdf_rectangle_fill(draw.xmin,             draw.ymin,             thickness, height,    colour));
      RetError(savepdf_rectangle_fill(draw.xmin,             draw.ymax - thickness, width,     thickness, colour));
      return   savepdf_rectangle_fill(draw.xmax - thickness, draw.ymin,             thickness, height,    colour);
    }
    else
    {
      return   savepdf_rectangle_fill(draw.xmin, draw.ymin, width, height, colour);
    }
  }
  else
  {
    if (border != 0) *r_size = 0; // NOT YET IMPLEMENTED
    else             *r_size = 0; // NOT YET IMPLEMENTED

    return NULL;
  }
}

/**************************************************************/
/* savepdf_jmptbl_triangle()                                  */
/*                                                            */
/* Veneer function for the redraw table. Writes a PDF file    */
/* converting user-points to PDF user space.                  */
/*                                                            */
/* Parameters: See redraw_triangle_fn_ptr_t, RedrawCore.h.    */
/*                                                            */
/* Returns:    See redraw_triangle_fn_ptr_t, RedrawCore.h.    */
/**************************************************************/

static _kernel_oserror * savepdf_jmptbl_triangle
                         (
                           const browser_data * restrict b,
                           int                           x1,
                           int                           y1,
                           int                           x2,
                           int                           y2,
                           int                           x3,
                           int                           y3,
                           unsigned int                  colour,

                           size_t             * restrict r_size
                         )
{
  if (r_size == NULL)
  {
    int draw_x1, draw_y1;
    int draw_x2, draw_y2;
    int draw_x3, draw_y3;

    if (outfile == NULL) return NULL;

    scale_pair_user_to_pdf(b, x1, y1, &draw_x1, &draw_y1);
    scale_pair_user_to_pdf(b, x2, y2, &draw_x2, &draw_y2);
    scale_pair_user_to_pdf(b, x3, y3, &draw_x3, &draw_y3);

    return savepdf_triangle_fill(draw_x1,
                                 draw_y1,
                                 draw_x2,
                                 draw_y2,
                                 draw_x3,
                                 draw_y3,
                                 colour);
  }
  else
  {
    *r_size = 0; // NOT YET IMPLEMENTED
    return NULL;
  }
}

/**************************************************************/
/* savepdf_jmptbl_text()                                      */
/*                                                            */
/* Veneer function for the redraw table. Writes a PDF file    */
/* converting user-points to PDF user space.                  */
/*                                                            */
/* Parameters: See redraw_text_fn_ptr_t, RedrawCore.h.        */
/*                                                            */
/* Returns:    See redraw_text_fn_ptr_t, RedrawCore.h.        */
/**************************************************************/

static _kernel_oserror * savepdf_jmptbl_text
                         (
                           const browser_data * restrict b,
                           fm_face                       handle,
                           int                           x,
                           int                           y,
                           const char         * restrict string,
                           unsigned int                  numbytes,
                           unsigned int                  fgcolour,
                           unsigned int                  bgcolour,
                           unsigned int                  blend,

                           size_t             * restrict r_size
                         )
{
  if (r_size == NULL)
  {
    _kernel_oserror * e;
    char            * copy;
    int               r,         index;
    int               pdf_x,     pdf_y;
    int               pdf_sizex, pdf_sizey;
    int               mp_sizex,  mp_sizey;
    int               pdf_scale;

    if (outfile == NULL) return NULL;

    /* Always work with length-limited output herein */

    if (numbytes == 0) numbytes = strlen(string);

    /* Make sure no trailing control characters are included */

    while (numbytes > 0 && string[numbytes - 1] < ' ') numbytes--;
    if (numbytes == 0) return NULL;

    /* Find the font - the call returns sizes in 16ths of a point */

    index = fm_find_font_index_by_handle(handle, &mp_sizex, &mp_sizey);
    if (index < 0) return NULL;
    if (index >= sizeof(font_token_map) / sizeof(*font_token_map)) index = 0;

    /* "62" is to convert 16ths of a point into millipoints (1000/16=62) */

    mp_sizex *= 62;
    mp_sizey *= 62;

    /* Convert to user-points then back to PDF user space */

    scale_pair_millipoints_to_user (b, mp_sizex,  mp_sizey,  &pdf_sizex, &pdf_sizey);
    scale_pair_user_to_pdf         (b, pdf_sizex, pdf_sizey, &pdf_sizex, &pdf_sizey);

    /* Convert the plotting coordinates too */

    scale_pair_user_to_pdf         (b, x,         y,         &pdf_x,     &pdf_y);

    /* Work out the width scaling */

    pdf_scale = (100 * pdf_sizex) / pdf_sizey;

    /* Start the text object and set the font and font size, */
    /* then state the plot coordinates.                      */

    r = fprintf(outfile, "BT\n"
                         "  /F%d %s Tf %d Tz %s %s Td\n"
                         "  ",

                         font_token_map[index],
                         savepdf_itoa(pdf_sizey),
                         pdf_scale,
                         savepdf_itoa(pdf_x),
                         savepdf_itoa(pdf_y));

    if (r < 0) RetLastE;

    /* Set up the colour; the prevailing graphics colour may be just about */
    /* anything depending on table cells etc. that were recently drawn.    */

    e = savepdf_write_colour(fgcolour, 0);
    if (e != NULL) return e;

    /* Copy as much of the string as needed */

    copy = malloc(numbytes + 1);
    if (copy == NULL) return make_no_memory_error(44);

    memcpy(copy, string, numbytes);
    copy[numbytes] = '\0';

    /* Output the string just after the colour specifier */

    e = savepdf_write_string(copy, csWindows1252);

    free(copy);

    if (e != NULL) return e;

    /* Write the painting operator and close the text object */

    r = fprintf(outfile, " Tj\n"
                         "ET\n");

    if (r < 0) RetLastE;
  }
  else
  {
    *r_size = 0; // NOT YET IMPLEMENTED
  }

  return NULL;
}

/**************************************************************/
/* savepdf_jmptbl_image()                                     */
/*                                                            */
/* Veneer function for the redraw table. Writes a PDF file    */
/* converting user-points to PDF user space.                  */
/*                                                            */
/* Parameters: See redraw_image_fn_ptr_t, RedrawCore.h.       */
/*                                                            */
/* Returns:    See redraw_image_fn_ptr_t, RedrawCore.h.       */
/**************************************************************/

static _kernel_oserror * savepdf_jmptbl_image
                         (
                           const browser_data * restrict b,
                           const unsigned int            image,
                           int                           x,
                           int                           y,
                           unsigned int                  width,
                           unsigned int                  height,

                           size_t             * restrict r_size
                         )
{
  if (r_size == NULL)
  {
    int r, ok;
    int pdf_x, pdf_y;
    int pdf_w, pdf_h;

    if (outfile == NULL) return NULL;

    /* Is this a Draw image we can place inline? */

    ok = 0;

    RetError(image_draw_to_pdf(b,
                               image,
                               x,
                               y,
                               width,
                               height,
                               &ok,
                               r_size));

    if (ok) return NULL;

    /* We have to treat this as an external image instead. */
    /* Record its use on the page.                         */

    RetError(savepdf_record_image_in_page(savepdf_image_type_IMAGE,
                                          image_parent(image),
                                          NULL));

    /* Scale the coordinates and dimensions */

    scale_pair_user_to_pdf(b, x,     y,      &pdf_x, &pdf_y);
    scale_pair_user_to_pdf(b, width, height, &pdf_w, &pdf_h);

    /* Store graphics context, set up the translation and  */
    /* scaling matrix, output the image paint command then */
    /* restore the old graphics context.                   */

    r = fprintf(outfile, "q\n"
                         "  %s 0 0 %s %s %s cm\n"
                         "  /%s%d Do\n"
                         "Q\n",

                         savepdf_itoa(pdf_w),
                         savepdf_itoa(pdf_h),
                         savepdf_itoa(pdf_x),
                         savepdf_itoa(pdf_y),
                         SAVEPDF_IMAGE_XOBJECT_FILE_PREFIX,
                         image_parent(image));

    if (r < 0) RetLastE;
  }
  else
  {
    *r_size = 0; // NOT YET IMPLEMENTED
  }

  return NULL;
}

/**************************************************************/
/* savepdf_jmptbl_sprite()                                    */
/*                                                            */
/* Veneer function for the redraw table. Writes a PDF file    */
/* converting user-points to PDF user space.                  */
/*                                                            */
/* Parameters: See redraw_sprite_fn_ptr_t, RedrawCore.h.      */
/*                                                            */
/* Returns:    See redraw_sprite_fn_ptr_t, RedrawCore.h.      */
/**************************************************************/

static _kernel_oserror * savepdf_jmptbl_sprite
                         (
                           const browser_data * restrict b,
                           const char         * restrict name,
                           int                           x,
                           int                           y,

                           size_t             * restrict r_size
                         )
{
  if (r_size == NULL)
  {
    int r;
    int width, height;
    int pdf_x, pdf_y;
    int pdf_w, pdf_h;

    if (outfile == NULL) return NULL;

    /* Read the sprite width and height */

    RetError(utils_read_sprite_size(name, &width, &height));

    /* Record use of this sprite */

    RetError(savepdf_record_image_in_page(savepdf_image_type_SPRITE,
                                          0,
                                          name));

    /* Scale the coordinates and dimensions */

    scale_pair_os_to_user (b, width, height, &width, &height);
    scale_pair_user_to_pdf(b, width, height, &pdf_w, &pdf_h);
    scale_pair_user_to_pdf(b, x,     y,      &pdf_x, &pdf_y);

    /* Store graphics context, set up the translation and  */
    /* scaling matrix, output the image paint command then */
    /* restore the old graphics context.                   */

    r = fprintf(outfile, "q\n"
                         "  %s 0 0 %s %s %s cm\n"
                         "  /%s%s Do\n"
                         "Q\n",

                         savepdf_itoa(pdf_w),
                         savepdf_itoa(pdf_h),
                         savepdf_itoa(pdf_x),
                         savepdf_itoa(pdf_y),
                         SAVEPDF_IMAGE_XOBJECT_NAME_PREFIX,
                         name);

    if (r < 0) RetLastE;
  }
  else
  {
    *r_size = 0; // NOT YET IMPLEMENTED
  }

  return NULL;
}

/**************************************************************/
/* savepdf_jmptbl_clipping()                                  */
/*                                                            */
/* Veneer function for the redraw table. Writes a PDF file    */
/* converting user-points to PDF user space.                  */
/*                                                            */
/* Parameters: See redraw_clipping_fn_ptr_t, RedrawCore.h.    */
/*                                                            */
/* Returns:    See redraw_clipping_fn_ptr_t, RedrawCore.h.    */
/**************************************************************/

static _kernel_oserror * savepdf_jmptbl_clipping
                         (
                           const browser_data * restrict b,
                           const BBox         * restrict desired,

                           size_t             * restrict r_size
                         )
{
  /* Record the rectangle for the annotation system */

  current_clip_known  = 1;
  current_clip_region = *desired;

  if (r_size == NULL)
  {
    int  r;
    BBox pdf;

    if (outfile == NULL) return NULL;

    /* We know that the page start routine will have pushed graphics   */
    /* context onto the stack. Because of the way that PDF establishes */
    /* a clipping region, we must pop that old context back to restore */
    /* the clipping region to the whole page, then define a path for   */
    /* the new rectangle.                                              */

    r = fprintf(outfile, "Q\n");
    if (r < 0) RetLastE;

    scale_box_user_to_pdf(b, desired, &pdf);

    pdf.xmax--, pdf.ymax--;

    /* Start the new context and move to the bottom left hand corner */

    r = fprintf(outfile,
                "q\n"
                "%s %s m ",

                savepdf_itoa(pdf.xmin),
                savepdf_itoa(pdf.ymin));

    if (r < 0) RetLastE;

    /* Draw to the top left */

    r = fprintf(outfile,
                "%s %s l ",

                savepdf_itoa(pdf.xmin),
                savepdf_itoa(pdf.ymax));

    if (r < 0) RetLastE;

    /* Draw to the top right corner */

    r = fprintf(outfile,
                "%s %s l ",

                savepdf_itoa(pdf.xmax),
                savepdf_itoa(pdf.ymax));

    if (r < 0) RetLastE;

    /* Draw to the bottom right corner corner and close the path. */
    /* Set the clipping rectangle using a no-op path painting     */
    /* operator and the clipping operator.                        */

    r = fprintf(outfile,
                "%s %s l h W n\n",

                savepdf_itoa(pdf.xmax),
                savepdf_itoa(pdf.ymin));

    if (r < 0) RetLastE;
  }
  else
  {
    *r_size = 0; // NOT YET IMPLEMENTED
  }

  return NULL;
}

/**************************************************************/
/* savepdf_jmptbl_section_cb()                                */
/*                                                            */
/* Veneer function for the redraw table. Writes a PDF file    */
/* converting user-points to PDF user space.                  */
/*                                                            */
/* Parameters: See redraw_section_cb_fn_ptr_t, RedrawCore.h.  */
/*                                                            */
/* Returns:    See redraw_section_cb_fn_ptr_t, RedrawCore.h.  */
/**************************************************************/

static _kernel_oserror * savepdf_jmptbl_section_cb
                         (
                           const browser_data * restrict b,
                           const char         * restrict section,

                           size_t             * restrict r_size
                         )
{
  if (r_size == NULL)
  {
    (void) b;
    (void) section;
  }
  else
  {
    *r_size = 0; // NOT YET IMPLEMENTED
  }

  return NULL;
}

/**************************************************************/
/* savepdf_jmptbl_name_cb()                                   */
/*                                                            */
/* Veneer function for the redraw table. Writes a PDF file    */
/* converting user-points to PDF user space.                  */
/*                                                            */
/* Parameters: See redraw_name_cb_fn_ptr_t, RedrawCore.h.     */
/*                                                            */
/* Returns:    See redraw_name_cb_fn_ptr_t, RedrawCore.h.     */
/**************************************************************/

static _kernel_oserror * savepdf_jmptbl_name_cb
                         (
                           const browser_data * restrict b,
                           const char         * restrict name,
                           const BBox         * restrict bounds,

                           size_t             * restrict r_size
                         )
{
  if (r_size == NULL)
  {
    BBox pdf_bounds;

    /* Convert the bounding box to inclusive PDF coordinates */

    scale_box_user_to_pdf(b, bounds, &pdf_bounds);

    pdf_bounds.xmax--;
    pdf_bounds.ymax--;

    /* Translate using the current origin */

    pdf_bounds.xmin += poriginx;
    pdf_bounds.ymin += poriginy;
    pdf_bounds.xmax += poriginx;
    pdf_bounds.ymax += poriginy;

    /* Add the name */

    return savepdf_add_name(name, &pdf_bounds);
  }
  else
  {
    /* This function never directly writes to the PDF file */

    *r_size = 0;
  }

  return NULL;
}

/**************************************************************/
/* savepdf_jmptbl_link_cb()                                   */
/*                                                            */
/* Veneer function for the redraw table. Writes a PDF file    */
/* converting user-points to PDF user space.                  */
/*                                                            */
/* Parameters: See redraw_link_cb_fn_ptr_t, RedrawCore.h.     */
/*                                                            */
/* Returns:    See redraw_link_cb_fn_ptr_t, RedrawCore.h.     */
/**************************************************************/

static _kernel_oserror * savepdf_jmptbl_link_cb
                         (
                           const browser_data * restrict b,
                           const char         * restrict link,
                           const BBox         * restrict bounds,

                           size_t             * restrict r_size
                         )
{
  if (r_size == NULL)
  {
    url_description * local;

    /* Is this a new URL or a local in-page link? */

    local = browser_check_local_reference(link,
                                          browser_current_url(b));

    if (local == NULL && b->urlbdata)
    {
      local = browser_check_local_reference(link,
                                            browser_base_url(b));
    }

    if (local)
    {
      /* Local link - store just the fragment (the part after the '#') */
      /* assuming it's not an empty string.                            */

      if (local->fragment && *local->fragment)
      {
        _kernel_oserror * e = savepdf_add_annotation(0,
                                                     local->fragment,
                                                     bounds);

        urlutils_free_description(local);
        return e;
      }
    }
    else if (link && *link)
    {
      /* Full URL - store the whole thing. */

      return savepdf_add_annotation(1,
                                    link,
                                    bounds);
    }
  }
  else
  {
    /* This function never directly writes to the PDF file */

    *r_size = 0;
  }

  return NULL;
}
