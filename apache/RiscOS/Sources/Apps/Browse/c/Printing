/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File   : Printing.c                                        */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Printing functions for the browser.               */
/*                                                            */
/*          This source is fairly closely tied to             */
/*          PrintStyle.c, as the Print dialogue can open and  */
/*          close the Print Style dialogue.                   */
/*                                                            */
/* Author : A.D.Hodgkinson                                    */
/*                                                            */
/* History: 27-Jan-1997 (ADH): Created.                       */
/*          25-Aug-1997 (ADH): Overhaul (read rewrite) to the */
/*                             new dialogue handling model,   */
/*                             as for Open URL and so-on.     */
/*          24-Feb-2000 (ADH): Headers and footers nearly     */
/*                             done, 64-wide comments with    */
/*                             Pace (C) started.              */
/*          24-May-2000 (ADH): 64-wide comments finished.     */
/**************************************************************/

#include <signal.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/printdbox.h>

#include "Global.h"
#include "FromROSLib.h"
#include "Utils.h"

#include "Browser.h"
#include "ChoiceDefs.h"
#include "FontManage.h"
#include "Images.h"
#include "Markers.h"
#include "Memory.h"
#include "Protocols.h"
#include "PrintStyle.h"
#include "Redraw.h"
#include "RedrawCore.h"
#include "Reformat.h"
#include "SaveFile.h"
#include "SavePDF.h"
#include "Scale.h"
#include "Toolaction.h"
#include "Toolbars.h"
#include "Windows.h"

#include "Printing.h"

/* Local structures.                                           */
/*                                                             */
/* Holds info on the Print dialogue's contents; small enough   */
/* to hold as a static, as the code to dynamically allocate it */
/* would occupy more room than the structure itself.           */

#define End_Whole   0
#define End_Visible 1
#define End_Many    2

typedef struct
{
  int            copies;          /* Number of copies to print.                                                  */
  int            pages;           /* If 'end' is 2, the number of pages to fill.                                 */
  unsigned int   end          :2; /* 0 = whole page, 1 = to bottom of visible area, 2 = for 'pages' pages.       */
  unsigned int   start        :1; /* 1 = whole page, 0 = top of visible area.                                    */
  unsigned int   reformat     :1; /* 1 = reformat to fit page (if start is not 0 and end is not -1), else don't. */
  unsigned int   print_to_pdf :1; /* 1 = print to PDF file instead of paper, 0 = print normally.                 */
  unsigned int   orientation  :1; /* 1 = portrait, 0 = landscape.                                                */

} print_contents;

/* The following stores the four basic display type settings */
/* (underline links, show images etc.) for the browser to be */
/* printed. This is so that the settings may be restored     */
/* after a print.                                            */

typedef struct
{
  unsigned int underline_links :1;
  unsigned int use_source_cols :1;
  unsigned int show_foreground :1;
  unsigned int show_background :1;

} print_restorable;

/* Local variables */

static int              globaljob        = 0;
static int              globalold_job    = 0;

static int              defaults_set     = 0;

static ObjectId         self_id          = 0;
static ObjectId         window_id        = 0;
static ObjectId         ancestor_id      = 0;
static browser_data   * ancestor_browser = NULL;

static print_contents   contents;
static print_restorable restore;

/* Static function prototypes */

static _kernel_oserror * print_read_contents           (ObjectId dialogue, print_contents * contents);
static _kernel_oserror * print_set_contents            (ObjectId dialogue, print_contents * contents);

static int               print_start                   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               print_cancel                  (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static int               print_check_contents          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static _kernel_oserror * print_page                    (browser_data * b, int copies, int from, int end, int to, int reformat, int orientation, const char * path);

static void              print_prepare_browser         (browser_data * source, browser_data * store, int lmarg, int rmarg, int tmarg, int bmarg);
static void              print_restore_browser         (browser_data * original, browser_data * copy);
static _kernel_oserror * print_reformat_for_printing   (browser_data * b, int from);
static _kernel_oserror * print_reformat_to_restore     (browser_data * b, int from);
static _kernel_oserror * print_find_window_edges       (browser_data * b, int from, int * r_top, int * r_bottom);
static _kernel_oserror * print_declare_fonts           (void);

static char            * print_roman                   (char * temp, unsigned int value, int isupper);
static char            * print_alpha                   (char * temp, unsigned int value, int isupper);
static char            * print_date                    (const char * source, char * buffer, unsigned int buflen);
static char            * print_build_formatted         (browser_data * b, unsigned int pages, unsigned int page, const char * section, char * buffer, size_t buflen, const char * format);
static void              print_header_and_footer_sizes (browser_data * b, unsigned int pages, unsigned int page, const char * section, int * header, int * footer);
static _kernel_oserror * print_header                  (browser_data * b, unsigned int pages, unsigned int page, const char * section, int header_y, int width);
static _kernel_oserror * print_footer                  (browser_data * b, unsigned int pages, unsigned int page, const char * section, int footer_y, int width);

static unsigned int      print_count_pages             (browser_data * b, int end, int to, int lmarg, int rmarg, int tmarg, int bmarg, int top, int bottom);

static unsigned int      print_set_hourglass_by_area   (BBox * redraw_rect, BBox * last_rect, unsigned int pages, unsigned int page, unsigned int page_area, unsigned int completed_area);

/**************************************************************/
/* print_open_for()                                           */
/*                                                            */
/* Creates and opens a Print dialogue for a given browser,    */
/* opening near the pointer.                                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct which is the  */
/*             ancestor of the dialogue;                      */
/*                                                            */
/*             Object ID to use as a parent, or 0 for none.   */
/**************************************************************/

_kernel_oserror * print_open_for(browser_data * b, ObjectId parent)
{
  ObjectId id;

  /* Create the object - if it is already created, this will */
  /* just return the ID of the existing object.              */

  RetError(toolbox_create_object(0,
                                 "PrintDbox",
                                 &id));

  RetError(toolbox_show_object(0,
                               id,
                               Toolbox_ShowObject_Centre,
                               NULL,
                               parent,
                               -1));

  return NULL;
}

/**************************************************************/
/* print_read_contents()                                      */
/*                                                            */
/* Reads the contents of the Print dialogue into a            */
/* print_contents structure.                                  */
/*                                                            */
/* Parameters: Object ID of the dialogue;                     */
/*                                                            */
/*             Pointer to the structure to write to.          */
/**************************************************************/

static _kernel_oserror * print_read_contents(ObjectId dialogue, print_contents * contents)
{
  int state, selected;

  /* Start at top of visible area (0) or whole page (1) radios */

  RetError(radiobutton_get_state(0, dialogue, PStartWhole, &state, NULL));
  contents->start = !!state;

  /* End radios - bottom of page, of visible area, or stop after */
  /* pages defined in the 'PEndManyNum' number range gadget      */

  RetError(radiobutton_get_state(0, dialogue, PEndWhole, NULL, &selected));
  RetError(numberrange_get_value(0, dialogue, PEndManyNum, &contents->pages));

  /* Note that PEndVisible etc. are component IDs defined in */
  /* Print.h, whilst End_Visible (with the underscore) etc.  */
  /* are option values defined at the top of this file.      */

  switch (selected)
  {
    default:
    case PEndWhole:   contents->end = End_Whole;
    break;

    case PEndVisible: contents->end = End_Visible;
    break;

    case PEndMany:    contents->end = End_Many;
    break;
  }

  /* Reformat page to fit */

  RetError(optionbutton_get_state(0, dialogue, PReformatToFit, &state));
  contents->reformat = !!state;

  /* Print to PDF file */

  if (optionbutton_get_state(0, dialogue, PPrintToPDF, &state))
  {
    contents->print_to_pdf = 0;
  }
  else
  {
    contents->print_to_pdf = !!state;
  }

  /* Orientation radios; portrait (1) or landscape (0) */

  RetError(radiobutton_get_state(0, dialogue, POriUpright, &state, NULL));
  contents->orientation = !!state;

  /* Read the 'Number of copies' number range gadget */

  RetError(numberrange_get_value(0, dialogue, PCopiesNum, &contents->copies));

  return NULL;
}

/**************************************************************/
/* print_set_contents()                                       */
/*                                                            */
/* Sets the contents of the Print dialogue from a             */
/* print_contents structure.                                  */
/*                                                            */
/* Parameters: Object ID of the dialogue;                     */
/*                                                            */
/*             Pointer to the structure to read from.         */
/**************************************************************/

static _kernel_oserror * print_set_contents(ObjectId dialogue, print_contents * contents)
{
  /* Start position */

  if (!contents->start) RetError(radiobutton_set_state(0, dialogue, PStartVisible, 1));
  else                  RetError(radiobutton_set_state(0, dialogue, PStartWhole,   1));

  /* End position, including the 'number of pages to fill' number range */

  switch (contents->end)
  {
    default:
    case End_Whole:     RetError(radiobutton_set_state(0, dialogue, PEndWhole,   1));
    break;
    case End_Visible:   RetError(radiobutton_set_state(0, dialogue, PEndVisible, 1));
    break;
    case End_Many:      RetError(radiobutton_set_state(0, dialogue, PEndMany,    1));
    break;
  }

  RetError(numberrange_set_value(0, dialogue, PEndManyNum, contents->pages));

  /* The reformat option, including greying / ungreying it */

  RetError(optionbutton_set_state(0, dialogue, PReformatToFit, contents->reformat));

  /* The print to PDF file option, including greying / ungreying it */

  (void) optionbutton_set_state(0, dialogue, PPrintToPDF, contents->print_to_pdf);

  /* As well as greying / ungreying the reformat option, this handles */
  /* the label text on the 'pages to fill' number range.              */

  print_check_contents(0, NULL, NULL, NULL);

  /* Orientation */

  if (!contents->orientation) RetError(radiobutton_set_state(0, dialogue, POriSideways, 1));
  else                        RetError(radiobutton_set_state(0, dialogue, POriUpright,  1));

  /* Number of copies */

  RetError(numberrange_set_value(0, dialogue, PCopiesNum, contents->copies));

  return NULL;
}

/**************************************************************/
/* print_set_defaults()                                       */
/*                                                            */
/* Fills in the local print_contents structure with the       */
/* default values to put in a Print dialogue, if they have    */
/* not already been filled in.                                */
/*                                                            */
/* If the dialogue is open, the contents are updated.         */
/*                                                            */
/* Returns:    1 if the structure was filled in, else 0.      */
/**************************************************************/

int print_set_defaults(void)
{
  if (!defaults_set)
  {
    /* Number of copies */

    contents.copies = choices.print_copies;

    /* Check it is within bounds */

    if (contents.copies < Limits_Lower_Copies) contents.copies = Limits_Lower_Copies;
    if (contents.copies > Limits_Upper_Copies) contents.copies = Limits_Upper_Copies;

    /* Start position - 'start' or 'visible', though in fact any */
    /* non-'visible' string defaults as 'start'.                 */

    if      (choices.print_start == 0)  contents.start = 1; /* Start   */
    else if (choices.print_start == -1) contents.start = 0; /* Visible */
    else                                contents.start = 1; /* Undef.  */

    /* End position - print the whole page, down to the bottom of the */
    /* visible area, or fill up as many sheets as specified in the    */
    /* 'pages' field of the print_contents structure (see below).     */

    if      (choices.print_end == 0)  contents.end = End_Whole,   contents.pages = 0;
    else if (choices.print_end == -1) contents.end = End_Visible, contents.pages = 0;
    else                              contents.end = End_Many,    contents.pages = choices.print_end;

    /* Check it is within bounds */

    if (contents.pages < Limits_Lower_Sheets) contents.pages = Limits_Lower_Sheets;
    if (contents.pages > Limits_Upper_Sheets) contents.pages = Limits_Upper_Sheets;

    /* Reformat - 'yes' or 'no', default to 'yes'; print to PDF - */
    /* 'yes' or 'no', default to 'no', no representation in the   */
    /* Choices at the moment.                                     */

    contents.reformat     = choices.print_reform;
    contents.print_to_pdf = 0;

    /* Orientation - 'upright' or 'sideways', though in fact any */
    /* non-'sideways' string defaults as 'upright'.              */

    if (choices.print_orient == Choices_PrintOrient_Upright) contents.orientation = 1;
    else                                                     contents.orientation = 0;

    defaults_set = 1;

    if (window_id) print_set_contents(window_id, &contents);

    return 1;
  }

  else return 0;
}

/**************************************************************/
/* print_to_be_shown()                                        */
/*                                                            */
/* Called before a print dialogue opens. Deals with setting   */
/* this up with default values and filling in print_old as    */
/* appropriate, so that if the dialogue is cancelled its      */
/* contents may be correctly restored.                        */
/*                                                            */
/* Parameters are as standard for a Toolbox event hander.     */
/**************************************************************/

int print_to_be_shown(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int      was_open = 0;
  ObjectId ps_window;
  ObjectId ps_ancestor;

  /* If the stored dialogue ID is non-zero on entry, the dialogue */
  /* was reopened without closing - so get rid of the various     */
  /* event handlers before we reregister them.                    */

  if (window_id)
  {
    /* Was the Print Style window open too? */

    printstyle_return_dialogue_info(&ps_window, &ps_ancestor);

    if (ps_window) was_open = 1;

    /* This will close the Print window and Print Style (if open) */

    print_close(0, 1);
  }

  /* Record the dialogue ID, the ancestor ID, and if this is */
  /* non-zero, the browser to which that ID refers.          */

  self_id     = idb->self_id;
  ancestor_id = idb->ancestor_id;

  if (ancestor_id) ChkError(toolbox_get_client_handle(0, ancestor_id, (void *) &ancestor_browser));

  /* If this is for an ancestor browser, use whatever frame is selected */
  /* instead - allows toolbar buttons and keyboard shortcuts to work in */
  /* a sensible fashion...                                              */

  if (ancestor_browser->selected_frame)
  {
    ancestor_browser = ancestor_browser->selected_frame;
    ancestor_id      = ancestor_browser->self_id;
  }

  /* If we have a browser, remember its restorable details. */

  if (ancestor_browser)
  {
    restore.underline_links = ancestor_browser->underline_links;
    restore.use_source_cols = ancestor_browser->use_source_cols;
    restore.show_foreground = ancestor_browser->show_foreground;
    restore.show_background = ancestor_browser->show_background;

    /* If required, force background images off */

    if (choices.print_plain) browser_set_look(ancestor_browser,
                                              window_id,
                                              -1,
                                              -1,
                                              -1,
                                              0);
  }

  /* Get the underlying window ID */

  ChkError(printdbox_get_window_id(0, self_id, &window_id));

  /* The Print Style dialogue may be open, too. We could take the lazy route */
  /* and just close it, but instead, we will ask it for its window details,  */
  /* and then recall its close code and ToBeShown code with the right info.  */

  if (was_open)
  {
    IdBlock  ps_id;

    ps_id.self_id = ps_window;

    /* (Make sure the Print Style routines ask the Print routines for the (new) ancestor) */

    ps_id.ancestor_id = NULL;

    printstyle_to_be_shown(0, NULL, &ps_id, NULL);
  }
  /* Register handlers for alternate Print/Cancel buttons */

  ChkError(event_register_toolbox_handler(window_id,
                                          EPStartPrint,
                                          print_start,
                                          (void *) ancestor_id));

  ChkError(event_register_toolbox_handler(window_id,
                                          EPCancelPrint,
                                          print_cancel,
                                          (void *) ancestor_id));

  /* Various alterations of icons / buttons for different UI styles */

  if (!strcmp(lookup_control("AlterNumranges:no",0,0),"yes"))
  {
    _kernel_oserror       * e;
    WimpGetIconStateBlock   icon;
    int                     iconlist [Limits_NRangeIcons];
    char                    buffer   [Limits_Message];

    /* Get the object's window handle and the icon handle for the given component */

    e = window_get_wimp_handle(0, window_id, &icon.window_handle);

    if (!e)
    {
      ComponentId writable;
      int         loop;

      for (loop = 0; loop < 2; loop ++)
      {
        /* Get the number range's writable component ID */

        e = numberrange_get_components(NumberRange_GetComponents_ReturnNumericalField,
                                      window_id,
                                      loop == 1 ? PCopiesNum : PEndManyNum,
                                      &writable,
                                      NULL,
                                      NULL,
                                      NULL);

        /* Turn this into an icon handle */

        if (!e) e = gadget_get_icon_list(0, window_id, writable, iconlist, sizeof(iconlist), NULL);

        if (!e)
        {
          icon.icon_handle = iconlist[0];

          /* Get the icon state and set the icon flags with the */
          /* programming text defined in the Messages file      */

          e = wimp_get_icon_state(&icon);

          if (!e)
          {
            strncpy(buffer, lookup_control("AlterWith",1,0), sizeof(buffer) - 1);
            buffer[sizeof(buffer) - 1] = 0;

            windows_process_icon_text(&icon, buffer, 0);
          }
        }
      }
    }
  }

  /* Register a handler to cope with the pages number range changing */

  ChkError(event_register_toolbox_handler(window_id,
                                          NumberRange_ValueChanged,
                                          print_check_contents,
                                          (void *) window_id));

  /* Similarly, the same function is called to ensure things are greyed */
  /* or ungreyed as required when the radio buttons that affect the     */
  /* 'Reformat page to fit paper' option are activated.                 */

  ChkError(event_register_toolbox_handler(window_id,
                                          EPEnableReformat,
                                          print_check_contents,
                                          (void *) window_id));

  /* Install an animation handler, if there's an appropriate gadget */

  if (
       controls.dbox_anims &&
       !gadget_get_type(0, window_id, StatusBarAnimAnim, NULL)
     )
     register_null_claimant(Wimp_ENull,
                            toolbars_animate_slow,
                            (void *) window_id);

  /* If defaults have never been set before, set them now,
   * otherwise ensure the dialogue box contents are set up
   * again.
   */

  if (!defaults_set)
  {
    print_set_defaults();
  }
  else if (window_id != 0)
  {
    ChkError(print_set_contents(window_id, &contents));
  }

  /* Make sure the Print Style dialogue is set up, too */

  printstyle_set_defaults();

  /* Done! */

  return 1;
}

/**************************************************************/
/* print_start()                                              */
/*                                                            */
/* Handles clicks on the 'OK' (or 'Print', etc.) button in    */
/* the Print dialogue.                                        */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int print_start(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  /* First, make sure we effectively OK the contents of the */
  /* Print Style dialogue.                                  */

  printstyle_ok(0, NULL, NULL, NULL);

  /* Because the printing starts from reception of an external message, */
  /* can't use a local copy of the print_contents structure and allow   */
  /* Adjust-clicks on Print/OK/Whatever. So always close the window.    */

  ChkError(print_read_contents(window_id, &contents));
  ChkError(print_close(0, 0));

  /* If we're printing to a PDF file, check the font mappings first */

  if (contents.print_to_pdf != 0)
  {
    if (savepdf_get_font_mappings() == 0)
    {
      erb.errnum = Utils_Error_Custom_Message;

      StrNCpy0(erb.errmess,
               lookup_token("CantMap:Cannot print to a PDF file because the current font choices do not map to standard PDF fonts. Only Trinity, Homerton and Corpus are supported.",
                            0,
                            0));

      show_error_ret(&erb);
      return 1;
    }

    /* Open the Save As dialogue box */

    ChkError(savefile_open_for(ancestor_browser, save_as_pdf));
  }
  else
  {
    /* First stage of printing protocol: Broadcast a PrintSave message */

    ChkError(protocols_pp_send_print_save());
  }

  return 1;
}

/**************************************************************/
/* print_cancel()                                             */
/*                                                            */
/* Handles clicks on the 'Cancel' button in the Print         */
/* dialogue.                                                  */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int print_cancel(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  WimpGetPointerInfoBlock info;

  /* Restore the old contents */

  ChkError(print_set_contents(window_id, &contents));

  /* If Select was pressed, the dialogue should close. */
  /* (No button => Escape was pressed).                */

  ChkError(wimp_get_pointer_info(&info));

  if ((info.button_state & Wimp_MouseButtonSelect) || !info.button_state)
  {
    ChkError(print_close(0, 0));

    /* If we forced background images off, put them back again */

    if (choices.print_plain) browser_set_look(ancestor_browser,
                                              window_id,
                                              -1,
                                              -1,
                                              -1,
                                              restore.show_background);
  }

  return 1;
}

/**************************************************************/
/* print_close()                                              */
/*                                                            */
/* If the Print dialogue is opened, this will close it,       */
/* deregistering any associated event handlers.               */
/*                                                            */
/* Parameters: An object ID, or 0. If not zero, the ID must   */
/*             match the ancestor recorded when the dialogue  */
/*             was opened or no action is taken.              */
/*                                                            */
/*             0 to close the dialogue, 1 to do everything    */
/*             except that.                                   */
/**************************************************************/

_kernel_oserror * print_close(ObjectId ancestor, int do_not_close)
{
  _kernel_oserror * e = NULL;

  if (ancestor && ancestor != ancestor_id) return NULL;

  /* If the Print Style window is open, this will close it */

  printstyle_close(ancestor_id, do_not_close);

  if (window_id)
  {
    /* Deregister associated event handlers */

    e = event_deregister_toolbox_handlers_for_object(window_id);
    if (e) goto print_close_exit;

    /* If there was a null handler, remove it */

    if (
         controls.dbox_anims &&
         !gadget_get_type(0, window_id, StatusBarAnimAnim, NULL)
       )
       deregister_null_claimant(Wimp_ENull,
                                toolbars_animate_slow,
                                (void *) window_id);

    if (!do_not_close)
    {
      /* Restore input focus to the browser window, if the */
      /* print dialogue still had it.                      */

      if (ancestor_id != NULL_ObjectId)
      {
        WimpGetCaretPositionBlock caret_b;
        int                       caret_w;

        /* Do we have the input focus? */

        e = wimp_get_caret_position(&caret_b);

        if (!e)
        {
          e = window_get_wimp_handle(0,
                                     window_id,
                                     &caret_w);

          if (caret_w == caret_b.window_handle)
          {
            e = browser_give_general_focus(ancestor_browser);
            if (e) goto print_close_exit;
          }
        }
      }

      /* Close the dialogue */

      e = toolbox_hide_object(0, self_id);
    }
  }

print_close_exit:

  self_id = window_id = 0;

  return e;
}

/**************************************************************/
/* print_check_contents()                                     */
/*                                                            */
/* If the state of the various radio buttons changes, this    */
/* may be called to see if the Reformat option in the Print   */
/* dialogue should be enabled (ungreyed) or disabled          */
/* (greyed). Similarly, if the contents of the number of      */
/* sheets to fill number range changes, this should be called */
/* to ensure the label has the correct pluralisation applied. */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int print_check_contents(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int          state1, state2, pages;
  unsigned int flags;

  /* Get the radio button states */

  ChkError(radiobutton_get_state(0, window_id, PStartWhole, NULL, &state1));
  ChkError(radiobutton_get_state(0, window_id, PEndWhole,   NULL, &state2));

  /* If the PStartVisible and PEndVisible radios are not selected, */
  /* can enable the Reformat option; else disable it. But only     */
  /* change it's state (don't grey it if already greyed, say).     */

  ChkError(gadget_get_flags(0, window_id, PReformatToFit, &flags));

  if (state2 != PEndVisible) // state1 != PStartVisible && state2 != PEndVisible)
  {
    if (flags & Gadget_Faded)
    {
      ChkError(gadget_set_flags(0, window_id, PReformatToFit, flags & ~Gadget_Faded));
    }
  }
  else
  {
    if (!(flags & Gadget_Faded))
    {
      ChkError(gadget_set_flags(0, window_id, PReformatToFit, flags | Gadget_Faded));
    }
  }

  /* Check the pages number range, and update the label if necessary. */

  {
    char text[Limits_PEndManyLabel];

    ChkError(numberrange_get_value(0, window_id, PEndManyNum, &pages));

    ChkError(button_get_value(0, window_id, PEndManyLabel, text, Limits_PEndManyLabel, NULL));
    text[sizeof(text) - 1] = 0;

    if (pages == 1)
    {
      /* If the existing text isn't what we intend to change it to, then change it; */
      /* i.e. don't set the same thing twice, as this will flicker badly.           */

      if (strcmp(text, lookup_token("PagesSingle:sheet is filled",0,0)))
      {
        ChkError(button_set_value(0, window_id, PEndManyLabel, lookup_token("PagesSingle:sheet is filled",0,0)));
      }
    }
    else
    {
      /* Again, only change the text - don't set the same thing twice. */

      if (strcmp(text, lookup_token("PagesMany:sheets are filled",0,0)))
      {
        ChkError(button_set_value(0, window_id, PEndManyLabel, lookup_token("PagesMany:sheets are filled",0,0)));
      }
    }
  }

  return 1;
}

/**************************************************************/
/* print_print()                                              */
/*                                                            */
/* Calls the printing engine with parameters specified in the */
/* local static print_info structure 'print_current'.         */
/*                                                            */
/* Entry point is typically from a handler dealing with the   */
/* printing message protocol (see handle_messages).           */
/*                                                            */
/* THIS FUNCTION IS UNUSUAL in that it reports any errors     */
/* encountered internally directly, then continues. The       */
/* returned value is for the caller to know if an error was   */
/* raised BUT THE CALLER SHOULD NOT REPORT THAT ERROR.        */
/*                                                            */
/* Parameters: Pointer to pathname to print to, or NULL to go */
/*             straight to the 'printer:' device.             */
/**************************************************************/

_kernel_oserror * print_print(const char * path)
{
  _kernel_oserror * e;

  /* Must have a browser to print */

  if (!ancestor_browser) return NULL;

  /* Do the printing */

  if (contents.end == End_Visible) printing = 2;
  else                             printing = 1;

  e = print_page(ancestor_browser,
                 contents.copies,
                 contents.start,
                 contents.end,
                 contents.pages,
                 contents.reformat,
                 contents.orientation,
                 path);

  printing = 0;

  if (e) show_error_ret(e);

  /* On completion, with or without error (as e.g. Escape may */
  /* be pressed and you'd still want the following), restore  */
  /* the basic browser display characteristics, if the Print  */
  /* dialogue was closed (i.e. Print activated with Select).  */

  if (!window_id)
  {
    show_error_ret(browser_set_look(ancestor_browser,
                                    0,
                                    restore.underline_links,
                                    restore.use_source_cols,
                                    restore.show_foreground,
                                    restore.show_background));
  }

  return e;
}

/**************************************************************/
/* print_page()                                               */
/*                                                            */
/* MAINTENANCE WARNING - ANY ALTERATIONS HERE WILL NEED       */
/* ECHOING IN PRINT_COUNT_PAGES IF IN AN ANALOGOUS CODE       */
/* SECTION.                                                   */
/*                                                            */
/* Prints out a page, assuming that all the relevant protocol */
/* stuff to ensure it's OK to proceed has been done already.  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page to print;                             */
/*                                                            */
/*             The number of copies to print;                 */
/*                                                            */
/*             1 to start at the top of the web page, else    */
/*             start from the top of the visible area in the  */
/*             window;                                        */
/*                                                            */
/*             Where to end - End_Whole, End_Visible or       */
/*             End_Many (as defined at the top of the file);  */
/*                                                            */
/*             For End_Many, how many sheets to fill;         */
/*                                                            */
/*             1 to reformat to fit the page width            */
/*             (orientation is taken into account), else 0 to */
/*             keep the width of the window (if it falls off  */
/*             the page, tough...!);                          */
/*                                                            */
/*             1 = portrait, 0 = landscape;                   */
/*                                                            */
/*             Pointer to pathname to print to, or NULL to go */
/*             straight to the 'printer:' device.             */
/**************************************************************/

static _kernel_oserror * print_page
                         (
                           browser_data * b,
                           int            copies,
                           int            from,
                           int            end,
                           int            to,
                           int            reformat,
                           int            is_portrait,
                           const char   * path
                         )
{
  _kernel_oserror       * e = NULL;

  WimpRedrawWindowBlock   redraw;

  BBox                    redraw_rect;
  BBox                    last_rect;

  BBox                    body_rect,      body_origin;
  BBox                    header_rect,    header_origin;
  BBox                    footer_rect,    footer_origin;

  int                     must_restore,   rect_id;
  int                     job,            old_job;
  int                     more;
  unsigned int            page,           pages;
  unsigned int            page_area,      area_completed;

  int                     paper_width,    paper_height;
  int                     lmarg,          bmarg;
  int                     rmarg,          tmarg;
  int                     unrot_lmarg,    unrot_bmarg;
  int                     unrot_rmarg,    unrot_tmarg;
  int                     top,            bottom;
  int                     header_size,    footer_size;
  int                     mp_header_size, mp_footer_size;
  int                     next_line,      temp;

  unsigned int            features;
  char                  * stored_section    = NULL;

  /* While there is no standard, GhostScript and many other packages treat */
  /* "landscape" to mean a 90 degree clockwise rotation of the *paper* in  */
  /* order to view the document correctly. The left edge of the paper is   */
  /* now the top edge. This makes sense for things like left edge binding, */
  /* if a printer was set for wider left margins, should someone print to  */
  /* such a printer in landscape mode, thus leaving the bound edge running */
  /* along the top of the document rather than the bottom.                 */
  /*                                                                       */
  /* With PDriver the paper doesn't move, so we produce a matrix for a 90  */
  /* degree *anticlockwise* rotation of the *content*, meaning that the    */
  /* final printed sheets of paper would be rotated 90 degrees clockwise   */
  /* in order to correctly view them - which is the required result.       */

  int                     portrait  [2] [2] = { {0x10000, 0}, {0,  0x10000} };
  int                     landscape [2] [2] = { {0, 0x10000}, {-0x10000, 0} };

  browser_data            localbrowser;

  void (*old_sigint_handler) (int);

  /* Check to see if there is a printer driver ready */

  e = _swix(PDriver_Info,
            _OUT(3),

            &features);

  if (e) return e;

  /* Find the current page margins (and therefore, page size, */
  /* as all margins are expressed as offsets from the bottom  */
  /* left hand corner of the paper).                          */

  e = _swix(PDriver_PageSize,
            _OUTR(1,6),

            &paper_width,
            &paper_height,
            &lmarg,
            &bmarg,
            &rmarg,
            &tmarg);

  if (e) return e;

  /* Remember the 'unrotated' margin values */

  unrot_lmarg = lmarg;
  unrot_bmarg = bmarg;
  unrot_rmarg = rmarg;
  unrot_tmarg = tmarg;

  /* Rotate the margins for landscape mode so that the margins are still */
  /* correct relative to the content.                                    */

  if (!is_portrait)
  {
    /* Remember that lmarg etc. are all offsets from the bottom left  */
    /* corner, so be careful with the rotation.                       */

    int ol =                lmarg;
    int ob =                bmarg;
    int or = paper_width  - rmarg;
    int ot = paper_height - tmarg;

    /* The notion of paper width and height swaps over for landscape. */

    Swap(paper_width, paper_height);

    if (contents.print_to_pdf)
    {
      /* For PDF printing, the content is not rotated during output,  */
      /* unlike with PDriver. We set up a wide page and draw on it so */
      /* rotate the argins 90 degrees clockwise.                      */
      /*                                                              */
      /*    T     90deg     l                                         */
      /* L     R   -->   b     t                                      */
      /*    B     clock     r                                         */

      lmarg =                ob;
      bmarg =                or;
      rmarg = paper_width  - ot;
      tmarg = paper_height - ol;
    }
    else
    {
      /* For printing, we perform an anticlockwise rotation so that   */
      /* after printing to an upright sheet the viewer rotates that   */
      /* sheet clockwise to see the content the right way up.         */
      /*                                                              */
      /*    T     90deg     r                                         */
      /* L     R   -->   t     b                                      */
      /*    B     anti.     l                                         */
      /*                                                              */

      lmarg =                ot;
      bmarg =                ol;
      rmarg = paper_width  - ob;
      tmarg = paper_height - or;
    }
  }

  /* Work out header and footer sizes (the height is currently unaffected */
  /* by contents, just whether or not there is any content, so we don't   */
  /* bother doing this per-page).                                         */

  print_header_and_footer_sizes(b,
                                1,
                                1,
                                NULL,
                                &header_size,
                                &footer_size);

  /* Convert to millipoints and modify the top/bottom margins accordingly */

  convert_pair_to_points(header_size, footer_size, &mp_header_size, &mp_footer_size);

  tmarg -= mp_header_size;
  bmarg += mp_footer_size;

  if (is_portrait)
  {
    unrot_tmarg -= mp_header_size;
    unrot_bmarg += mp_footer_size;
  }
  else
  {
    unrot_lmarg += mp_header_size;
    unrot_rmarg -= mp_footer_size;
  }

  /* Start the hourglass, this could take a while.              */
  /*                                                            */
  /* Using Hourglass_Start as otherwise the first percentage    */
  /* setting may be missed, since the hourglass isn't actually  */
  /* on yet (there's a default delay before appearance with     */
  /* calling Hourglass_On).                                     */

  _swix(Hourglass_Start, _IN(0), 1);

  /* If the user specified printing to or from something that */
  /* depends upon the visible area, can't then reformat. We   */
  /* can, however, use markers to try and preserve the offset */
  /* for printing from the top of the visible area.           */

  if (reformat && end != End_Visible)
  {
    print_prepare_browser(b, &localbrowser, lmarg, rmarg, tmarg, bmarg);
    must_restore = 1;

    print_reformat_for_printing(b, from);
  }
  else must_restore = 0;

  /* Now things diverge for PDF or real printing */

  if (contents.print_to_pdf == 0)
  {
    /* Open up the output stream */

    e = _swix(OS_Find,
              _INR(0,1) | _OUT(0),

              0x8F,
              path ? path : "printer:",

              &job);

    if (e) goto out3;

    globaljob = job;

    /* Stop the C library intercepting Escape, since */
    /* this should be left to the print SWIs.        */

    old_sigint_handler = signal(SIGINT, SIG_IGN);

    /* Start up the printing system */

    e = _swix(PDriver_SelectJob,
              _INR(0,1) | _OUT(0),

              job,
              lookup_token("PJobName:Web page",0,0),

              &old_job);

    if (e) goto out1;

    globalold_job = old_job;

    /* Declare fonts that have been used */

    if (features & Browser_Printer_DeclareFont)
    {
      e = print_declare_fonts();
      if (e) goto out2;
    }
  }
  else
  {
    /* Stop compiler warning about this being unset before use */

    old_sigint_handler = NULL;

    /* PDF printing - ask the PDF system to do the preamble */

    e = savepdf_start_session(b, path);
    if (e) goto out3;

    /* Start the PDF output. */

    if (contents.print_to_pdf)
    {
      e = savepdf_write_header();
      if (e) goto out2;
    }
  }

  /* Set 'top' to the offset from the top of the document to get  */
  /* to the top of the currently visible portion, and 'bottom'    */
  /* to the offset to get to the bottom of the currently visible  */
  /* portion. The positive direction is downwards (so they should */
  /* both be positive numbers).                                   */

  e = print_find_window_edges(b, from, &top, &bottom);
  if (e) goto out2;

  /* Clear any stored inferred section title for headers/footers. */

  free(b->inferred_section), b->inferred_section = NULL;

  /* Work out how many pages we have. The only reliable way to do */
  /* this is to run a dummy redraw loop with an empty redraw core */
  /* table and count the split points arising. It's not as slow   */
  /* as you might expect!                                         */

  pages = print_count_pages(b,
                            end,
                            to,
                            lmarg,
                            rmarg,
                            tmarg,
                            bmarg,
                            top,
                            bottom);

  /* Clear any sections which the above counting session may have */
  /* inadvertently discovered.                                    */

  free(b->inferred_section), b->inferred_section = NULL;

  /* Loop round for all pages */

  page           = 0;
  next_line      = 0;
  redraw.xscroll = 0;
  redraw.yscroll = -top;

  while (
          (
            end == End_Many &&
            page < to
          )
          ||
          (
            end != End_Many
          )
        )
  {
    /* Set the *current* page number in 'page' */

    page++;

    /* Check to see if we've a new section heading */

    if (b->inferred_section != NULL)
    {
      int ok = 0;

      if (stored_section != NULL)
      {
        if (strcmp(b->inferred_section, stored_section) != 0)
        {
          free(stored_section);
          ok = 1;
        }
      }
      else ok = 1;

      if (ok == 1)
      {
        stored_section      = b->inferred_section;
        b->inferred_section = NULL;

        if (contents.print_to_pdf)
        {
          e = savepdf_new_inferred_section(stored_section);
          if (e) goto out2;
        }
      }
    }

    /* For PDF files, output the start of the page object (must do */
    /* this *after* checking for new section headings).            */

    if (contents.print_to_pdf)
    {
      e = savepdf_start_page(paper_width, paper_height);
      if (e) goto out2;
    }

    /* Set up this page's area bounding box and origin. The plot origin is */
    /* for the bottom left of the print rectangle *before* application of  */
    /* the transformation matrix. The printer driver transforms the print  */
    /* rectangle but still bases it on our unchanged origin. The landscape */
    /* transformation matrix rotates the page 90 degrees but cannot effect */
    /* a translation too - so the box is rotated around the bottom left    */
    /* corner and disappears off the visible page. We have to correct our  */
    /* origin so that the box is in the right place *after* it is rotated. */
    /*                                                                     */
    /* For PDF printing, things are simpler as there's no rotation.        */

    if (is_portrait || contents.print_to_pdf)
    {
      body_origin.xmin = lmarg;
      body_origin.ymin = bmarg;
    }
    else /* Landscape paper printing */
    {
      body_origin.xmin = unrot_rmarg;
      body_origin.ymin = unrot_bmarg;
    }

    /* The body rectangle is actually simpler than the origin, since the */
    /* transformation matrix takes care of most aspects of this for us.  */

    body_rect.xmax   = rmarg - lmarg;
    body_rect.xmin   = 0;

    convert_to_os(body_rect.xmax, &body_rect.xmax);

    /* Vertical margins are complicated by the user settings. For printing    */
    /* down to the bottom of the web page, want to use a full page rectangle; */
    /* for printing down to the bottom of the visible area, want to use the   */
    /* 'bottom' variable worked out above. Note the checking to work out      */
    /* pagination - it *could* be possible that the visible area is taller    */
    /* than a single sheet of paper for the current printer.                  */

    convert_to_os(tmarg - bmarg, &temp); /* 'temp' now holds the printable page height in OS units */

    if (end != End_Visible)
    {
      body_rect.ymax = temp,
      body_rect.ymin = 0;
    }
    else
    {
      /* Need to subtract an amount from 'bottom' to mark that a page has been  */
      /* done, but must do that after the page rendering so the redraw routines */
      /* have filled in next_line with the y-coordinate of the top of the next  */
      /* line to draw. Without this, we can't tell how much of the web page was */
      /* actually used. Remember that next_line and yscroll are negative;       */
      /* next_line gives the vertical offset at which to start the next page    */
      /* and yscroll holds the offset at which the most recent page started.    */

      if (next_line != 0 && bottom) bottom -= (redraw.yscroll - next_line);

      if (bottom - top > temp) /* And *not* '>= temp'! See 'else' code below */
      {
        body_rect.ymax = temp;
      }
      else
      {
        body_rect.ymax = bottom - top;
        bottom = 0;

        /* Since this rectangle is at most a full page in height but probably */
        /* less, must shift the bottom left hand coordinate of it up an       */
        /* appropriate amount to print the page fragment at the top of the    */
        /* paper rather than the bottom.                                      */

        temp -= body_rect.ymax; /* (Page height minus rectangle height in OS units) */

        convert_to_points(temp, &temp);

        if (is_portrait) body_origin.ymin += temp;
        else             body_origin.xmin += temp;
      }

      body_rect.ymin = 0;
    }

    /* next_line gives the y-coordinate of the top of the next line */
    /* to print when it exits, through the next_line variable. Note */
    /* this must not be assigned to redraw.yscroll until AFTER the  */
    /* code calculating 'bottom' (see above).                       */

    if (next_line != 0) redraw.yscroll = next_line;

    /* Set the "visible area" to the whole of the page body so that */
    /* the redraw routines know what they're doing. This stays the  */
    /* same during page printing - the redraw area changes, the     */
    /* visible area stays the same.                                 */

    redraw.visible_area = body_rect;

    /* Set the draw rectangles. We use three - the main page,   */
    /* the header and the footer. Tell the printer driver about */
    /* each or store the information for the PDF routines.      */

    if (contents.print_to_pdf == 0)
    {
      e = _swix(PDriver_GiveRectangle,
                _INR(0,4),

                0, /* Use zero for the main page */
                &body_rect,
                is_portrait ? &portrait : &landscape,
                &body_origin,
                Redraw_Colour_White);
    }
    else
    {
      e = savepdf_give_rectangle(&body_rect, &body_origin);
    }

    if (e) goto out2;

    if (choices.print_headers_from > 0)
    {
      header_rect.xmin = body_rect.xmin;
      header_rect.xmax = body_rect.xmax;
      header_rect.ymin = 0;
      header_rect.ymax = header_size;

      /* Similar logic here as for printing the body; see comments above */
      /* for details of how that's worked out.                           */

      if (is_portrait || contents.print_to_pdf)
      {
        header_origin.xmin = lmarg;
        header_origin.ymin = tmarg;
      }
      else /* Landscape paper printing */
      {
        header_origin.xmin = unrot_lmarg; /* Header height is already included in unrot_lmarg */
        header_origin.ymin = unrot_bmarg;
      }

      if (contents.print_to_pdf == 0)
      {
        e = _swix(PDriver_GiveRectangle,
                  _INR(0,4),

                  1, /* Use 1 for the header */
                  &header_rect,
                  is_portrait ? &portrait : &landscape,
                  &header_origin,
                  Redraw_Colour_White);

        if (e) goto out2;
      }
    }

    if (choices.print_footers_from > 0)
    {
      footer_rect.xmin = body_rect.xmin;
      footer_rect.xmax = body_rect.xmax;
      footer_rect.ymin = 0;
      footer_rect.ymax = footer_size;

      /* Similar logic here as for printing the body; see comments above */
      /* for details of how that's worked out.                           */

      if (is_portrait || contents.print_to_pdf)
      {
        footer_origin.xmin = lmarg;
        footer_origin.ymin = bmarg - mp_footer_size;
      }
      else /* Landscape paper printing */
      {
        footer_origin.xmin = unrot_rmarg + mp_footer_size;
        footer_origin.ymin = unrot_bmarg;
      }

      if (contents.print_to_pdf == 0)
      {
        e = _swix(PDriver_GiveRectangle,
                  _INR(0,4),

                  2, /* Use 2 for the footer */
                  &footer_rect,
                  is_portrait ? &portrait : &landscape,
                  &footer_origin,
                  Redraw_Colour_White);

        if (e) goto out2;
      }
    }

    /* Get the first rectangle to print, or simulate the whole page */
    /* for PDF output.                                              */

    if (contents.print_to_pdf == 0)
    {
      e = _swix(PDriver_DrawPage,
                _INR(0,3) | _OUT(0) | _OUT(2),

                (copies) | ((features & Browser_Printer_PreScansRectangles) ? (1<<24) : (0)),
                &redraw_rect,
                page,
                NULL,

                &more,
                &rect_id);

      if (e) goto out2;
    }
    else
    {
      redraw_rect = body_rect;
    }

    /* Give an indication of progress */

    utils_hourglass_percent(page, pages);

    /* Calculate the area in OS units of the whole page, used for the */
    /* hourglass percentage when printing strips of the page body.    */

    page_area = (body_rect.xmax - body_rect.xmin) *
                (body_rect.ymax - body_rect.ymin);

    /* The redraw loop itself */

    last_rect.xmin = last_rect.xmax = last_rect.ymin = last_rect.ymax = 0;
    area_completed = 0;
    next_line      = 0;

    if (contents.print_to_pdf == 0)
    {
      while (more)
      {
        switch (rect_id)
        {
          default: /* Always default to printing the body of the page */
          {
            /* Ensure images are correct for the current mode */

            image_mode_change();

            /* Do the redraw */

            redraw.redraw_area = redraw_rect;

            e = redraw_draw(b,
                            &redraw,
                            &next_line,
                            0,
                            0);

            /* Don't alter hourglass setting if this is just a prescan */

            if (
                 ((features & Browser_Printer_PreScansRectangles) == 0) ||
                 ((more     & 1<<24)                              == 0)
               )
            {
              area_completed = print_set_hourglass_by_area(&redraw_rect,
                                                           &last_rect,
                                                           pages,
                                                           page,
                                                           page_area,
                                                           area_completed);

              last_rect = redraw_rect;
            }
          }
          break;

          case 1:
          {
            e = print_header(b,
                             pages,
                             page,
                             stored_section,
                             header_size,
                             redraw_rect.xmax - redraw_rect.xmin);
          }
          break;

          case 2:
          {
            e = print_footer(b,
                             pages,
                             page,
                             stored_section,
                             footer_size,
                             redraw_rect.xmax - redraw_rect.xmin);
          }
          break;
        }

        if (e) goto out2;

        /* Get the next rectangle */

        e = _swix(PDriver_GetRectangle,
                  _IN(1) | _OUT(0) | _OUT(2),

                  &redraw_rect,

                  &more,
                  &rect_id);

        if (e) goto out2;
      }
    }
    else /* From 'if (contents.print_to_pdf == 0)' */
    {
      for (rect_id = 0; rect_id < 3; rect_id++)
      {
        savepdf_replace_redraw_table();

        switch (rect_id)
        {
          default: /* Always default to printing the body of the page */
          {
            /* Ensure images are correct for the current mode */

            image_mode_change();

            /* Do the redraw */

            redraw.redraw_area = redraw_rect;

            e = redraw_draw(b,
                            &redraw,
                            &next_line,
                            0,
                            0);
          }
          break;

          case 1:
          {
            if (choices.print_headers_from > 0)
            {
              e = savepdf_give_rectangle(&header_rect, &header_origin);
              if (e) break;

              e = print_header(b,
                               pages,
                               page,
                               stored_section,
                               header_size,
                               redraw_rect.xmax - redraw_rect.xmin);
            }
            else e = NULL;
          }
          break;

          case 2:
          {
            if (choices.print_footers_from > 0)
            {
              e = savepdf_give_rectangle(&footer_rect, &footer_origin);
              if (e) break;

              e = print_footer(b,
                               pages,
                               page,
                               stored_section,
                               footer_size,
                               redraw_rect.xmax - redraw_rect.xmin);
            }
            else e = NULL;
          }
          break;
        }

        savepdf_restore_redraw_table();
        if (e) goto out2;
      }

      /* Finish the page information */

      e = savepdf_end_page();
      if (e) goto out2;

    } /* From 'else' of 'if (contents.print_to_pdf ==0)' */

    /* If we should print down to the bottom of the visible */
    /* area of the page, this is flagged with 'end' set to  */
    /* End_Visible; if 'bottom' is zero as well, there's    */
    /* nothing more to print.                               */

    if (end == End_Visible && !bottom) break;

    /* If next_line is 0, redraw_draw must not have found any */
    /* more lines to print. So there are no more pages.       */

    if (next_line == 0) break;

    /* Otherwise, close the outer while loop - which */
    /* may mean we loop for another page.            */
  }

  /* Finished, so end the job, close the output stream, */
  /* turn off the hourglass and restore the previous    */
  /* job.                                               */

  if (contents.print_to_pdf == 0)
  {
    e = _swix(PDriver_EndJob,
              _IN(0),

              job);

    if (e) goto out2;
  }
  else
  {
    e = savepdf_write_trailer();
    if (e) goto out2;

    e = savepdf_end_session();
    if (e) goto out3;
  }

  /* Ensure images are restored to the correct mode and clear any */
  /* stored section title                                         */

  image_mode_change();
  free(stored_section);
  free(b->inferred_section), b->inferred_section = NULL;

  if (contents.print_to_pdf == 0)
  {
    /* Restore the old Escape handler */

    signal(SIGINT, old_sigint_handler);

    /* Close the output stream */

    globaljob = 0;

    e = _swix(OS_Find,
              _INR(0,1),

              0x00,
              job);

    if (e) goto out3;
  }

  /* Remove the hourglass percentage indicator */

  _swix(Hourglass_Percentage,
        _IN(0),

        100);

  /* Now we have to put the page back where it was... */

  if (must_restore)
  {
    print_restore_browser(b, &localbrowser);
    (void) print_reformat_to_restore(b, from);
    must_restore = 0;
  }

  /* Turn off the hourglass */

  _swix(Hourglass_Off, 0);

  if (contents.print_to_pdf == 0)
  {
    /* Restore the previous print job */

    globalold_job = 0;

    return _swix(PDriver_SelectJob,
                 _INR(0,1),

                 old_job,
                 0);
  }
  else
  {
    return NULL;
  }

out1: /* 'Emergency exit' if PDriver_SelectJob fails */

  if (contents.print_to_pdf == 0)
  {
    signal(SIGINT, old_sigint_handler);
    globaljob = 0;

    /* Close the output stream */

    _swix(OS_Find,
          _INR(0,1),

          0x00,
          job);
  }
  else
  {
    (void) savepdf_end_session();
  }

  /* Flag that printing has finished */

  printing = 0;

  /* Force the hourglass off */

  _swix(Hourglass_Smash, 0);

  /* Put the browser back together again */

  if (must_restore)
  {
    print_restore_browser(b, &localbrowser);
    (void) reformat_format_from(b, -1, 1, -1);
    if (!from) markers_forget_position(b);
  }

  /* Ensure images are restored to the correct mode and clear any */
  /* stored section title                                         */

  image_mode_change();
  free(stored_section);
  free(b->inferred_section), b->inferred_section = NULL;

  return e;

out2: /* 'Emergency exit' for errors whilst printing */

  if (contents.print_to_pdf == 0)
  {
    signal(SIGINT, old_sigint_handler);
    print_abort_print();
  }
  else
  {
    (void) savepdf_end_session();
    printing = 0;
  }

  if (must_restore)
  {
    print_restore_browser(b, &localbrowser);
    (void) reformat_format_from(b, -1, 1, -1);
    if (!from) markers_forget_position(b);
  }

  image_mode_change();
  free(stored_section);
  free(b->inferred_section), b->inferred_section = NULL;

  return e;

out3: /* 'Emergency exit' for errors after printing */

  _swix(Hourglass_Smash, 0);
  printing = 0;

  if (must_restore)
  {
    print_restore_browser(b, &localbrowser);
    (void) reformat_format_from(b, -1, 1, -1);
    if (!from) markers_forget_position(b);
  }

  image_mode_change();
  free(stored_section);
  free(b->inferred_section), b->inferred_section = NULL;

  return e;
}

/**************************************************************/
/* print_abort_print()                                        */
/*                                                            */
/* Forcibly aborts a print job.                               */
/**************************************************************/

void print_abort_print(void)
{
  if (printing)
  {
    /* Clear the printing flag */

    printing = 0;

    /* Abort the current print job */

    _swix(PDriver_AbortJob,
          _IN(0),

          globaljob);

    /* Close the output stream */

    _swix(OS_Find,
          _INR(0,1),

          0x00,
          globaljob);

    globaljob = 0;

    /* Restore the previous print job */

    _swix(PDriver_SelectJob,
          _INR(0,1),

          globalold_job,
          0);

    globalold_job = 0;

    /* Force the hourglass off */

    _swix(Hourglass_Smash, 0);
  }
}

/**************************************************************/
/* print_prepare_browser()                                    */
/*                                                            */
/* Prepares a browser for internal reformatting prior to      */
/* printing a page, storing various overwritten values into   */
/* an alternative given structure.                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page to print;                             */
/*                                                            */
/*             Pointer to the browser_data struct to copy     */
/*             into;                                          */
/*                                                            */
/*             Left hand page margin, in millipoints;         */
/*                                                            */
/*             Right hand page margin, in millipoints.        */
/**************************************************************/

static void print_prepare_browser(browser_data * source, browser_data * store, int lmarg, int rmarg, int tmarg, int bmarg)
{
  store->previous        = source->previous;
  store->next            = source->next;
  source->previous       = source->next = NULL;

  store->display_width   = source->display_width;
  source->display_width  = rmarg - lmarg;

  convert_to_os(source->display_width, &source->display_width);

  store->display_height  = source->display_height;
  source->display_height = bmarg - tmarg;

  convert_to_os(source->display_height, &source->display_height);

  store->display_extent  = source->display_extent;
  source->display_extent = source->display_width;

  store->fetch_status    = source->fetch_status;
  source->fetch_status   = BS_IDLE;
  store->fetch_handle    = source->fetch_handle;
  source->fetch_handle   = source->display_handle;
}

/**************************************************************/
/* print_restore_browser()                                    */
/*                                                            */
/* Puts back the bits and pieces replaced in the browser_data */
/* struct given to the print routines, copied out because a   */
/* reformat was required on the page.                         */
/*                                                            */
/* Parameters: Pointer to the browser_data struct given to    */
/*             the print routines;                            */
/*                                                            */
/*             Pointer to the browser_data struct used to     */
/*             store the over- written values from the        */
/*             original copy in print_prepare_browser.        */
/**************************************************************/

static void print_restore_browser(browser_data * original, browser_data * copy)
{
  original->previous       = copy->previous;
  original->next           = copy->next;
  original->display_width  = copy->display_width;
  original->display_extent = copy->display_extent;
  original->display_height = copy->display_height;
  original->fetch_status   = copy->fetch_status;
  original->fetch_handle   = copy->fetch_handle;
}

/**************************************************************/
/* print_reformat_for_printing()                              */
/*                                                            */
/* Reformat a page ready for printing. YOU MUST HAVE CALLED   */
/* print_prepare_browser FIRST!                               */
/*                                                            */
/* Parameters: Pointer to the browser_data struct relevant to */
/*             the page being printed and formatted;          */
/*                                                            */
/*             1 to start at the top of the web page, else    */
/*             start from the top of the visible area in the  */
/*             window;                                        */
/**************************************************************/

static _kernel_oserror * print_reformat_for_printing(browser_data * b, int from)
{
  _kernel_oserror * e;
  int               leds = 1;

  _swix(Hourglass_Start, _IN(0), 1);

  /* Reformat the page ready for printing. It used to be possible to do all of */
  /* this in a separate browser_data structure and, being careful about flex,  */
  /* reformat in that 'virtual' browser. This enabled reformatting internally  */
  /* not to affect the main browser page.                                      */
  /*                                                                           */
  /* Tables, however, screwed this up big time. Table cells were malloc'd, but */
  /* no record of this was kept, in the first cut of the code. So in the end,  */
  /* the address of the cell array was kept in the HStream defining the table. */
  /* However, you can only have one user of that at any one time...            */
  /*                                                                           */
  /* Four solutions to this (where NA = Not Acceptable):                       */
  /*                                                                           */
  /* 1. Get rid of the 'reformat to fit page' option (NA)                      */
  /* 2. Only allow the above when there are no tables on the page (NA)         */
  /* 3. Copy the entire token stream as well as the flex data (NA)             */
  /* 4. Reformat in the actual browser and have it reformat again afterwards.  */
  /*                                                                           */
  /* Since 1 to 3 aren't acceptable - 3 mostly because not only is it a lot of */
  /* memory to have to find, but it's in malloc space -> WimpSlot problems -   */
  /* only 4 is left. So this is what we now do here. Consequently, lots of     */
  /* bits of the browser_data structure have to be copied away and restored    */
  /* later, which can get quite messy.                                         */
  /*                                                                           */
  /* The fact that option 4 was chosen doesn't mean it isn't hideous...        */

  if (!from) markers_remember_position(b);

  e = reformat_format_from(b, -1, 1, -1);

  if (e != NULL)
  {
    _swix(Hourglass_Off, 0);
    return e;
  }

  while (reformat_formatting(b))
  {
    reformat_reformatter(b);

    if (!from) browser_check_for_request(b);

    /* It is virtually impossible to assess progress without */
    /* doing something time consuming like scan the token    */
    /* list and work out how far down it we are, compared to */
    /* the whole length. Instead, alternate the LEDs - this  */
    /* fits in well with what the table reformatter code     */
    /* will be doing with the hourglass.                     */

    leds ^= 3;

    _swix(Hourglass_LEDs,
          _INR(0,1),

          3,
          leds);
  }

  _swix(Hourglass_LEDs,
        _INR(0, 1),

        0,
        0);

  return _swix(Hourglass_Off, 0);
}

/**************************************************************/
/* print_reformat_to_restore()                                */
/*                                                            */
/* Restore a page formatted by print_reformat_for_printing.   */
/* YOU MUST HAVE CALLED print_restore_browser FIRST!          */
/*                                                            */
/* Parameters: Pointer to the browser_data struct relevant to */
/*             the page being printed and formatted;          */
/*                                                            */
/*             1 to start at the top of the web page, else    */
/*             start from the top of the visible area in the  */
/*             window;                                        */
/**************************************************************/

static _kernel_oserror * print_reformat_to_restore(browser_data * b, int from)
{
  int leds = 1;

  _swix(Hourglass_Start, _IN(0), 1);

  /* Wait around whilst the reformatter reformats. */

  reformat_format_from(b, -1, 1, -1); /* Ignore errors */

  while (reformat_formatting(b))
  {
    reformat_reformatter(b);

    if (!from) browser_check_for_request(b);

    leds ^= 3;

    _swix(Hourglass_LEDs,
          _INR(0,1),

          3,
          leds);
  }

  if (!from) markers_forget_position(b);

  return _swix(Hourglass_Off, 0);;
}

/**************************************************************/
/* print_find_window_edges()                                  */
/*                                                            */
/* Set 'top' to the offset from the top of the document to    */
/* get to the top of the currently visible portion, and       */
/* 'bottom' to the offset to get to the bottom of the         */
/* currently visible portion. The positive direction is       */
/* downwards (so they should both be positive numbers).       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the window edges of interest;                  */
/*                                                            */
/*             1 to start at the top of the web page, else    */
/*             start from the top of the visible area in the  */
/*             window;                                        */
/*                                                            */
/*             Pointer to an int, updated on successful exit  */
/*             with the "top" value - may be NULL;            */
/*                                                            */
/*             Pointer to an int, updated on successful exit  */
/*             with the "bottom" value - may be NULL.         */
/**************************************************************/

static _kernel_oserror * print_find_window_edges
                         (
                           browser_data * b,
                           int            from,
                           int          * r_top,
                           int          * r_bottom
                         )
{
  WimpGetWindowStateBlock state;
  int                     htop, hbot, top, bottom;

  state.window_handle = b->window_handle;
  RetError(wimp_get_window_state(&state));

  /* Get the basic offsets */

  top    = -state.yscroll;
  bottom = state.visible_area.ymax - state.visible_area.ymin;

  /* Correct for toolbar presence */

  if (!controls.swap_bars)
  {
    htop = toolbars_button_height(b) + toolbars_url_height(b);
    hbot = toolbars_status_height(b);
  }
  else
  {
    htop = toolbars_status_height(b);
    hbot = toolbars_button_height(b) + toolbars_url_height(b);
  }

  if (htop) htop += wimpt_dy();
  if (hbot) hbot += wimpt_dy();

  top    += htop;
  bottom -= (htop + hbot - top);

  /* If 'from' is non-zero, want to print from the top of the whole   */
  /* page; else from the top of the visible area as worked out above. */

  if (from) top = htop;

  if (r_top    != NULL) *r_top    = top;
  if (r_bottom != NULL) *r_bottom = bottom;

  return NULL;
}

/**************************************************************/
/* print_declare_fonts()                                      */
/*                                                            */
/* For printer drivers where the PDriver_Info SWI returns a   */
/* features word with the Browser_Printer_DeclareFont flags   */
/* bit set, call this function to do the declarations.        */
/**************************************************************/

static _kernel_oserror * print_declare_fonts(void)
{
  fm_face h;

  /* If using system font, only the system faces will be */
  /* used; otherwise, need to declare the sans, serif    */
  /* and fixed faces.                                    */

  if (!choices.system_font)
  {
    h = fm_find_font(NULL, "sans",  192,192,0,0); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "sans",  192,192,1,0); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "sans",  192,192,0,1); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "sans",  192,192,1,1); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);

    h = fm_find_font(NULL, "serif", 192,192,0,0); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "serif", 192,192,1,0); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "serif", 192,192,0,1); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "serif", 192,192,1,1); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);

    h = fm_find_font(NULL, "fixed", 192,192,0,0); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "fixed", 192,192,1,0); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "fixed", 192,192,0,1); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "fixed", 192,192,1,1); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
  }

  /* Finish declaring fonts */

  return _swix(PDriver_DeclareFont,
               _INR(0,2),

               0,
               0,
               2);
}

/**************************************************************/
/* print_return_dialogue_info()                               */
/*                                                            */
/* Returns information on the Print dialogue, and its         */
/* ancestor.                                                  */
/*                                                            */
/* Parameters: Pointer to an ObjectId, in which the ID of the */
/*             PrintDBox object is placed;                    */
/*                                                            */
/*             Pointer to an ObjectId, in which the ID of the */
/*             underlying window object is placed;            */
/*                                                            */
/*             Pointer to an ObjectId, in which the ID of the */
/*             ancestor window is placed;                     */
/*                                                            */
/*             Pointer to a pointer to a browser_data struct, */
/*             in which the address of the browser_data       */
/*             struct associated with the ancestor object is  */
/*             placed.                                        */
/*                                                            */
/* Returns:    See parameters list, and note that the         */
/*             returned values will be 0, 0, 0 and NULL if    */
/*             the Print dialogue is closed.                  */
/*                                                            */
/* Assumes:    Any of the pointers may be NULL.               */
/**************************************************************/

void print_return_dialogue_info(ObjectId * self, ObjectId * window, ObjectId * ancestor, browser_data ** ancestor_b)
{
  if (self)       *self       = self_id;
  if (window)     *window     = window_id;
  if (ancestor)   *ancestor   = ancestor_id;
  if (ancestor_b) *ancestor_b = ancestor_browser;
}

/**************************************************************/
/* print_roman()                                              */
/*                                                            */
/* From HTMLLib (ol.c). Convert a value into a roman numeral  */
/* string in the given buffer. The buffer is assumed to be    */
/* large enough.                                              */
/*                                                            */
/* Parameters: Pointer to the buffer;                         */
/*                                                            */
/*             Value to convert;                              */
/*                                                            */
/*             Zero for lower case, else upper case.          */
/*                                                            */
/* Returns:    Pointer to the output buffer given in the      */
/*             parameters.                                    */
/**************************************************************/

static char * print_roman(char * temp, unsigned int value, int isupper)
{
  static const char ones[10][5] =
  {
    "", "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix"
  };
  static const char tens[10][5] =
  {
    "", "x", "xx", "xxx", "xl", "l", "lx", "lxx", "lxxx", "xc"
  };
  static const char hundreds[10][5] =
  {
    "", "c", "cc", "ccc", "cd", "d", "dc", "dcc", "dccc", "cm"
  };

  char       * p = temp;
  const char * s;
  int          o, t, h;

  value %= 5000;

  while (value >= 1000)
  {
    *p++ = 'm';
    value -= 1000;
  }

  t = value / 10;
  o = value % 10;
  h = t     / 10;
  t = t     % 10;

  for (s = hundreds[h]; *s; ) *p++ = *s++;
  for (s = tens[t];     *s; ) *p++ = *s++;
  for (s = ones[o];     *s; ) *p++ = *s++;

  *p = '\0';

  if (isupper != 0)
  {
    char * t = temp;

    while (*t) *t++ -= 32;
  }

  return temp;
}

/**************************************************************/
/* print_roman()                                              */
/*                                                            */
/* Convert a value into an alphabetic indicator - 1 is a, 2   */
/* is b, 3 is c etc. up to 26 being z, 27 is aa, 28 is ab,    */
/* etc. to zz, to aaa, aab, aac...zzy, zzz, aaaa and so-on.   */
/* The output is a NUL terminated string in a given buffer,   */
/* assumed to be large enough.                                */
/*                                                            */
/* Parameters: Pointer to the buffer;                         */
/*                                                            */
/*             Value to convert;                              */
/*                                                            */
/*             Zero for lower case, else upper case.          */
/*                                                            */
/* Returns:    Pointer to the output buffer given in the      */
/*             parameters.                                    */
/**************************************************************/

static char * print_alpha(char * temp, unsigned int value, int isupper)
{
  unsigned int vcopy;
  int          top;
  char         base;

  /* Work out how many characters we'll need and fill in backwards */

  top   = 0;
  vcopy = value;

  while (vcopy != 0)
  {
    top += 1;
    vcopy = (vcopy - 1) / 26;
  }

  /* Now build the string */

  if (isupper != 0) base = 'A';
  else              base = 'a';

  temp[top--] = '\0';

  while (top >= 0 && value != 0)
  {
    temp[top--] = base + ((value - 1) % 26);
    value = (value - 1) / 26;
  }

  return temp;
}

/**************************************************************/
/* print_date()                                               */
/*                                                            */
/* Output either the current date or a given date formatted   */
/* according to PrintDateFormat in the Choices file.          */
/*                                                            */
/* Parameters: Pointer to a date string in the form of a      */
/*             LastModified header value which will be        */
/*             converted to the required format (NOT          */
/*             IMPLEMENTED YET!) or NULL to use the current   */
/*             date and time;                                 */
/*                                                            */
/*             Pointer to a buffer to write the time into;    */
/*                                                            */
/*             Size of the buffer.                            */
/*                                                            */
/* Returns:    Pointer to the output buffer given in the      */
/*             parameters.                                    */
/**************************************************************/

static char * print_date(const char * source, char * buffer, unsigned int buflen)
{
  char * format = utils_strdup(choices.print_date_format);
  char   block[5];
  char * separator;

  if (!format || !buffer || buflen < 1) return buffer;;

  separator = format;

  /* The date format uses '!' instead of '%' so you don't have to worry */
  /* about (re-)escaping it for the Choices file when saving. Convert   */
  /* these to '%' now.                                                  */

  while (*separator != '\0')
  {
    if (*separator == '!')
    {
      char * marker = separator;
      char   tag[2];

      /* Special field */

      separator++;
      if (toupper(*separator) == 'Z') separator++;

      tag[0] = toupper(*separator);

      if (*separator != '\0')
      {
        tag[1] = toupper(*(separator + 1));
      }
      else
      {
        tag[1] = '\0';
      }

      if (
           !strncmp(tag, "12", 2) ||
           !strncmp(tag, "24", 2) ||
           !strncmp(tag, "AM", 2) ||
           !strncmp(tag, "CE", 2) ||
           !strncmp(tag, "CS", 2) ||
           !strncmp(tag, "DN", 2) ||
           !strncmp(tag, "DY", 2) ||
           !strncmp(tag, "M3", 2) ||
           !strncmp(tag, "MI", 2) ||
           !strncmp(tag, "MN", 2) ||
           !strncmp(tag, "MO", 2) ||
           !strncmp(tag, "PM", 2) ||
           !strncmp(tag, "SE", 2) ||
           !strncmp(tag, "ST", 2) ||
           !strncmp(tag, "TZ", 2) ||
           !strncmp(tag, "W3", 2) ||
           !strncmp(tag, "WE", 2) ||
           !strncmp(tag, "WK", 2) ||
           !strncmp(tag, "WN", 2) ||
           !strncmp(tag, "YR", 2)
         )
      {
        /* A legal looking field; change the field separator back to */
        /* a '%' sign.                                               */

        *marker = '%';
        separator += 2;
      }
      else if (*separator == '0')
      {
        /* Attempt to include ASCII zero. Remove this field. */

        memmove(marker, separator + 1, strlen(separator + 1) + 1);
      }
      else if (*separator == '!')
      {
        /* Attempt to include a literal "!" - remove one of these to */
        /* leave just the single literal character.                  */

        memmove(marker + 1, separator + 1, strlen(separator + 1) + 1);
      }
      else if (*separator == '%')
      {
        /* Attempt to include a literal '%' - just change the field */
        /* separator again.                                         */

        *marker = '%';
        separator++;
      }
    }
    else
    {
      separator++;
    }
  }

  /* If we've no date string, read the current date/time */

  if (!source)
  {
    block[0] = 3; /* OS_Word 14 sub-reason code, read soft-copy of CMOS clock as 5-byte integer */

    if (
         _swix(OS_Word,
               _INR(0,1),

               14, /* 14 - read CMOS clock */
               block)
       )
       memset(block, 0, sizeof(block));
  }
  else
  {
    // Not implemented yet

    memset(block, 0, sizeof(block));
  }

  /* Now convert it */

  if (
       _swix(OS_ConvertDateAndTime,
             _INR(0,3) | _OUT(1),

             block,
             buffer,
             buflen,
             format,

             &separator)
     )
  {
    *buffer = '\0';
  }
  else
  {
    if ((unsigned int) separator - (unsigned int) buffer >= buflen) buffer[buflen - 1] = '\0';
    else *separator = '\0';
  }

  /* Don't forget to free the strdup'd format string... */

  free(format);

  return buffer;
}

/**************************************************************/
/* print_build_formatted()                                    */
/*                                                            */
/* Builds a header or footer string based on the given format */
/* string into the given buffer.                              */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the header or footer;                          */
/*                                                            */
/*             Number of pages or 0 if unknown;               */
/*                                                            */
/*             Notional current page number;                  */
/*                                                            */
/*             Notional current section or NULL;              */
/*                                                            */
/*             Pointer to the buffer into which to build the  */
/*             string, or NULL to find the required size;     */
/*                                                            */
/*             Length of the buffer (ignored if pointer to    */
/*             buffer is NULL);                               */
/*                                                            */
/*             Pointer to the format string.                  */
/*                                                            */
/* Returns:    Pointer to the buffer you gave so it can be    */
/*             used in expressions directly for non-NULL      */
/*             buffer pointers, else the required size for    */
/*             the buffer in bytes including a NUL string     */
/*             terminator character, cast to 'char *'.        */
/**************************************************************/

static char * print_build_formatted
              (
                browser_data * b,
                unsigned int   pages,
                unsigned int   page,
                const char   * section,
                char         * buffer,
                size_t         buflen,
                const char   * format
              )
{
  char         * url   = browser_current_url(b);
  char         * title = browser_current_title(b);
  char         * start = buffer;
  unsigned int   total = 0;
  unsigned int   written;

  /* Simple checks, plus, if we've a non-NULL buffer, */
  /* make a recursive call to ensure that the buffer  */
  /* is big enough.                                   */

  if (
       !b      ||
       !format ||
       (
         buffer != NULL &&
         buflen < (size_t) print_build_formatted(b,
                                                 pages,
                                                 page,
                                                 section,
                                                 NULL,
                                                 0,
                                                 format)
       )
     )
  {
    if (buffer && buflen > 0) *buffer = '\0';
    return buffer == NULL ? (char *) sizeof('\0') : buffer;
  }

  if (!url)     url       = "";
  if (!section) section   = "";
  if (buffer)   buffer[0] = '\0';

  /* Step through the format string */

  while (*format)
  {
    /* Is this a formatting command? */

    if (*format == '!')
    {
      written = 0;

      /* Yes; advance the pointer to its first character */

      format++;

      switch (*format)
      {
        default:
        {
          /* Any unrecognised character implies an unrecognised or invalid */
          /* format string - just copy the character straight out to the   */
          /* output buffer.                                                */

          if (buffer) sprintf(buffer, "!%c", *format);
          written = 2;
        }
        break;

        /* Escaped characters */

        case '!':
        case '%':
        {
          if (buffer) sprintf(buffer, "%c", *format);
          written = 1;
        }
        break;

        /* The next few items all have a secondary character as a parameter */

        case 'p': /* Current page number */
        case 'P': /* Total page count    */
        {
          unsigned int value;
          char         number[128];

          if (*format == 'p') value = page;
          else                value = pages;

          format++;

          switch (*format)
          {
            default:
            {
              /* Unrecognised parameter - output the literal string */

              if (buffer) sprintf(buffer, "!p%c", *format);
              written = 3;
            }
            break;

            case '1': /* Ordinary numbers */
            {
              if (buffer) sprintf(buffer, "%d%n", page, &written);
              else written = utils_number_length(page);
            }
            break;

            case 'i': /* Lower case Roman numerals */
            {
              if (buffer) sprintf(buffer, "%s%n", print_roman(number, page, 0), &written);
              else written = strlen(print_roman(number, page, 0));

            }
            break;

            case 'I': /* Upper case Roman numerals */
            {
              if (buffer) sprintf(buffer, "%s%n", print_roman(number, page, 1), &written);
              else written = strlen(print_roman(number, page, 1));
            }
            break;

            case 'a': /* Lower case alphabetic count */
            {
              if (buffer) sprintf(buffer, "%s%n", print_alpha(number, page, 0), &written);
              else written = strlen(print_alpha(number, page, 0));
            }
            break;

            case 'A': /* Upper case alphabetic count */
            {
              if (buffer) sprintf(buffer, "%s%n", print_alpha(number, page, 1), &written);
              else written = strlen(print_alpha(number, page, 1));
            }
            break;
          }
        }
        break;

        case 't': /* Document title */
        {
          format++;

          switch (*format)
          {
            default:
            {
              /* Unrecognised parameter - output the literal string */

              if (buffer) sprintf(buffer, "!t%c", *format);
              written = 3;
            }
            break;

            case 'k': /* Title if known */
            case 'a': /* Title always   */
            {
              char * output = title ? title : (*format == 'a' ? url : "");

              if (buffer) sprintf(buffer, "%s%n", output, &written);
              else written = strlen(output);
            }
            break;
          }
        }
        break;

        case 'd': /* Dates */
        {
          char date[128];

          format++;

          switch (*format)
          {
            default:
            {
              /* Unrecognised parameter - output the literal string */

              if (buffer) sprintf(buffer, "!d%c", *format);
              written = 3;
            }
            break;

            case 'p': /* Date of printing */
            {
              if (buffer) sprintf(buffer, "%s%n", print_date(NULL, date, sizeof(date)), &written);
              else written = strlen(print_date(NULL, date, sizeof(date)));
            }
            break;

            case 'm': /* Date of document modification */
            {
              const char * modified = b->last_modified ? b->last_modified : "";

              if (buffer) sprintf(buffer, "%s%n", print_date(modified, date, sizeof(date)), &written);
              else written = strlen(print_date(modified, date, sizeof(date)));
            }
            break;
          }
        }
        break;

        /* The next few items have no secondary character */

        case 'u': /* Document URL */
        {
          if (buffer) sprintf(buffer, "%s%n", url, &written);
          else written += strlen(url);
        }
        break;

        case 's': /* Inferred section */
        {
          if (buffer) sprintf(buffer, "%s%n", section, &written);
          else written += strlen(section);
        }
        break;
      }

      /* Advance through the input and output buffers */

      if (buffer)  buffer += written;
      if (*format) format ++;

      total += written;
    }
    else
    {
      /* Not a special field, so just output the current character */

      if (buffer)
      {
        sprintf(buffer, "%c", *format);
        buffer++;
      }

      format ++;
      total  ++;
    }
  }

  if (buffer) return start;
  else        return (char *) (total + 1);
}

/**************************************************************/
/* print_header_and_footer_sizes()                            */
/*                                                            */
/* Via. the above header and footer code, return the height   */
/* of the header and height of the footer for the given       */
/* browser window.                                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page being printed;                        */
/*                                                            */
/*             Notional current page number;                  */
/*                                                            */
/*             Number of pages or 0 if unknown;               */
/*                                                            */
/*             Notional current section or NULL;              */
/*                                                            */
/*             Pointer to an int into which the header height */
/*             is written, in OS units;                       */
/*                                                            */
/*             Pointer to an int into which the footer height */
/*             is written, in OS units.                       */
/*                                                            */
/* Assumes:    Pointers are non-NULL and valid.               */
/**************************************************************/

static void print_header_and_footer_sizes(browser_data * b, unsigned int pages, unsigned int page,
                                          const char * section, int * header, int * footer)
{
  char buffer[Limits_Message]; /* Slightly arbitrary choice */
  int  ok;
  int  top, bot;

  if (!header || !footer) return;

  *header = *footer = 0;

  /* Set bit 0 of ok for a header, and bit 1 for a footer */

  ok = 0;

  if (choices.print_headers_from != 0)
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_left);

    if (*buffer) ok = 1;
    else
    {
      print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_mid);

      if (*buffer) ok = 1;
      else
      {
        print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_right);
        if (*buffer) ok = 1;
      }
    }
  }

  if (choices.print_footers_from != 0)
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_left);

    if (*buffer) ok |= 2;
    else
    {
      print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_mid);

      if (*buffer) ok |= 2;
      else
      {
        print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_right);

        if (*buffer) ok |= 2;
      }
    }
  }

  if (reformat_text_line_height(b, NULL, &top, &bot)) return;

  if ((ok & 1) != 0) *header = ((top + bot) * PrintHeaderAndFooterHeightMultiplier * choices.print_hf_scale) / 1000;
  if ((ok & 2) != 0) *footer = ((top + bot) * PrintHeaderAndFooterHeightMultiplier * choices.print_hf_scale) / 1000;

  return;
}

/**************************************************************/
/* print_header()                                             */
/*                                                            */
/* Given a page number and y coordinate, print a page header. */
/* The LeftMargin and RightMargin Choices file entries are    */
/* dealt with internally.                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page being printed;                        */
/*                                                            */
/*             Number of pages or 0 if unknown;               */
/*                                                            */
/*             Current page number;                           */
/*                                                            */
/*             Current section or NULL;                       */
/*                                                            */
/*             Y coordinate of top of header in OS units;     */
/*                                                            */
/*             Printable header width in OS units.            */
/**************************************************************/

static _kernel_oserror * print_header(browser_data * b, unsigned int pages, unsigned int page,
                                      const char * section, int header_y, int width)
{
  char buffer[Limits_Message];
  int  top, bot, h;
  int  lm,  rm;

  if (choices.print_headers_from == 0 || page < choices.print_headers_from) return NULL;
  if (reformat_text_line_height(b, NULL, &top, &bot))                       return NULL;

  convert_to_os(b->left_margin,  &lm);
  convert_to_os(b->right_margin, &rm);

  top = (top * choices.print_hf_scale) / 100;
  bot = (bot * choices.print_hf_scale) / 100;

  header_y -= top;
  h         = fm_find_font(b,
                           "serif",
                           (choices.font_size * choices.print_hf_scale) / 100,
                           (choices.font_size * choices.print_hf_scale) / 100,
                           choices.print_hf_italic,
                           choices.print_hf_bold);

  convert_to_points(width, &width);

  /* Left hand side's string */

  /* We print the left hand item on the left hand side if facing pages is "No" */
  /* or otherwise on any even numbered page.                                   */

  if (choices.print_facing_pages == Choices_PrintFacingPages_No || (page % 2) == 0)
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_left);
  }

  /* If we reach here we're on an odd page. In that case, we don't print anything */
  /* if facing pages is "Spread" and print the right hand item if it is "Page".   */

  else if (choices.print_facing_pages == Choices_PrintFacingPages_Page)
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_right);
  }
  else *buffer = '\0';

  if (*buffer != '\0')
  {
    RetError(redrawcore_text(b,
                             h,
                             scale_millipoints_to_user(b, b->left_margin),
                             scale_os_to_user         (b, header_y),
                             buffer,
                             0,
                             Redraw_Colour_Black, Redraw_Colour_White,
                             0));
  }

  /* Centre string */

  print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_mid);

  if (*buffer)
  {
    int w;

    RetError(fm_get_string_width(h,
                                 buffer,
                                 width,          /* Not splitting anyway right now, but might one day... */
                                 strlen(buffer),
                                 -1,
                                 NULL,
                                 &w));

    RetError(redrawcore_text(b,
                             h,
                             scale_millipoints_to_user(b, (width - w) / 2),
                             scale_os_to_user         (b, header_y),
                             buffer,
                             0,
                             Redraw_Colour_Black, Redraw_Colour_White,
                             0));
  }

  /* Right hand side's string */

  /* We print the right hand item on the right hand side if facing pages is "No" */
  /* or if it is "Page" and we're on an even page, or "Spread" and we're on an   */
  /* odd page.                                                                   */

  if (
       choices.print_facing_pages == Choices_PrintFacingPages_No
       ||
       (
         (page % 2) == 0 &&
         choices.print_facing_pages == Choices_PrintFacingPages_Page
       )
       ||
       (
         (page % 2) == 1 &&
         choices.print_facing_pages == Choices_PrintFacingPages_Spread
       )
     )
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_right);
  }

  /* We print the left hand item on the right hand side if facing pages is "Page" */
  /* and we're on an odd page.                                                    */

  else if (
            (page % 2) == 1 &&
            choices.print_facing_pages == Choices_PrintFacingPages_Page
          )
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_left);
  }
  else *buffer = '\0';

  if (*buffer)
  {
    int w;

    RetError(fm_get_string_width(h,
                                 buffer,
                                 width,          /* Not splitting anyway right now, but might one day... */
                                 strlen(buffer),
                                 -1,
                                 NULL,
                                 &w));

    RetError(redrawcore_text(b,
                             h,
                             scale_millipoints_to_user (b, width - w - b->right_margin),
                             scale_os_to_user          (b, header_y),
                             buffer,
                             0,
                             Redraw_Colour_Black, Redraw_Colour_White,
                             0));
  }

  return NULL;
}

/**************************************************************/
/* print_footer()                                             */
/*                                                            */
/* Given a page number and y coordinate, print a page footer. */
/* The LeftMargin and RightMargin Choices file entries are    */
/* dealt with internally.                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page being printed;                        */
/*                                                            */
/*             Number of pages or 0 if unknown;               */
/*                                                            */
/*             Current page number;                           */
/*                                                            */
/*             Current section or NULL;                       */
/*                                                            */
/*             Y coordinate of top of footer in OS units;     */
/*                                                            */
/*             Printable footer width in OS units.            */
/**************************************************************/

static _kernel_oserror * print_footer(browser_data * b, unsigned int pages, unsigned int page,
                                      const char * section, int footer_y, int width)
{
  char buffer[Limits_Message];
  int  top, bot, h;
  int  lm,  rm;

  if (choices.print_footers_from == 0 || page < choices.print_footers_from) return NULL;
  if (reformat_text_line_height(b, NULL, &top, &bot))                       return NULL;

  convert_to_os(b->left_margin,  &lm);
  convert_to_os(b->right_margin, &rm);

  top = (top * choices.print_hf_scale) / 100;
  bot = (bot * choices.print_hf_scale) / 100;

  h = fm_find_font(b,
                   "serif",
                   (choices.font_size * choices.print_hf_scale) / 100,
                   (choices.font_size * choices.print_hf_scale) / 100,
                   choices.print_hf_italic,
                   choices.print_hf_bold);

  convert_to_points(width, &width);

  /* Left hand side's string */

  /* We print the left hand item on the left hand side if facing pages is "No" */
  /* or otherwise on any even numbered page.                                   */

  if (choices.print_facing_pages == Choices_PrintFacingPages_No || (page % 2) == 0)
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_left);
  }

  /* If we reach here we're on an odd page. In that case, we don't print anything */
  /* if facing pages is "Spread" and print the right hand item if it is "Page".   */

  else if (choices.print_facing_pages == Choices_PrintFacingPages_Page)
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_right);
  }
  else *buffer = '\0';

  if (*buffer != '\0')
  {
    RetError(redrawcore_text(b,
                             h,
                             scale_millipoints_to_user(b, b->left_margin),
                             scale_os_to_user         (b, bot),
                             buffer,
                             0,
                             Redraw_Colour_Black, Redraw_Colour_White,
                             0));
  }

  /* Centre string */

  print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_mid);

  if (*buffer)
  {
    int w;

    RetError(fm_get_string_width(h,
                                 buffer,
                                 width,          /* Not splitting anyway right now, but might one day... */
                                 strlen(buffer),
                                 -1,
                                 NULL,
                                 &w));

    RetError(redrawcore_text(b,
                             h,
                             scale_millipoints_to_user(b, (width - w) / 2),
                             scale_os_to_user         (b, bot),
                             buffer,
                             0,
                             Redraw_Colour_Black, Redraw_Colour_White,
                             0));
  }

  /* Right hand side's string */

  /* We print the right hand item on the right hand side if facing pages is "No" */
  /* or if it is "Page" and we're on an even page, or "Spread" and we're on an   */
  /* odd page.                                                                   */

  if (
       choices.print_facing_pages == Choices_PrintFacingPages_No
       ||
       (
         (page % 2) == 0 &&
         choices.print_facing_pages == Choices_PrintFacingPages_Page
       )
       ||
       (
         (page % 2) == 1 &&
         choices.print_facing_pages == Choices_PrintFacingPages_Spread
       )
     )
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_right);
  }

  /* We print the left hand item on the right hand side if facing pages is "Page" */
  /* and we're on an odd page.                                                    */

  else if (
            (page % 2) == 1 &&
            choices.print_facing_pages == Choices_PrintFacingPages_Page
          )
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_left);
  }
  else *buffer = '\0';

  if (*buffer)
  {
    int w;

    RetError(fm_get_string_width(h,
                                 buffer,
                                 width,          /* Not splitting anyway right now, but might one day... */
                                 strlen(buffer),
                                 -1,
                                 NULL,
                                 &w));

    RetError(redrawcore_text(b,
                             h,
                             scale_millipoints_to_user (b, width - w - b->right_margin),
                             scale_os_to_user          (b, bot),
                             buffer,
                             0,
                             Redraw_Colour_Black, Redraw_Colour_White,
                             0));
  }

  return NULL;
}

/**************************************************************/
/* print_count_pages()                                        */
/*                                                            */
/* MAINTENANCE WARNING - ANY ALTERATIONS TO PRINT_PAGE WILL   */
/* NEED ECHOING HERE IF IN AN ANALOGOUS CODE SECTION.         */
/*                                                            */
/* Count the number of pages that are about to be printed.    */
/* This is an internal service routine for print_page and     */
/* derives its core code from that function; as a result, a   */
/* lot of in-progress data in print_page has to be thrown in  */
/* through the following rather long parameter list.          */
/*                                                            */
/* The basic premise is to simulate a print and redraw loop   */
/* and return the final page count. It works pretty well.     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page to be printed;                        */
/*                                                            */
/*             Where to end - End_Whole, End_Visible or       */
/*             End_Many (as defined at the top of the file);  */
/*                                                            */
/*             For End_Many, how many sheets to fill;         */
/*                                                            */
/*             In-use left margin position in millipoints;    */
/*                                                            */
/*             In-use right margin position in millipoints;   */
/*                                                            */
/*             In-use top margin position in millipoints;     */
/*                                                            */
/*             In-use bottom margin position in millipoints;  */
/*                                                            */
/*             Offset from top of document to get to top of   */
/*             currently visible region in OS units, positive */
/*             downwards;                                     */
/*                                                            */
/*             Offset from top of document to get to bottom   */
/*             of currently visible region in OS units,       */
/*             positive downwards.                            */
/*                                                            */
/* Returns:    The number of pages that will be printed.      */
/**************************************************************/

static unsigned int print_count_pages(browser_data * b, int end, int to, int lmarg, int rmarg,
                                      int tmarg, int bmarg, int top, int bottom)
{
  WimpRedrawWindowBlock redraw;
  unsigned int          page = 0;
  int                   temp;
  int                   round;
  int                   next_line;
  BBox                  last_rect;

  /* We'll use an empty table to draw nothing in the redraw loop */

  redrawcore_function_table_t empty_table;
  memset(&empty_table, 0, sizeof(empty_table));

  /* For more comments, see the inner print loop in print_page. */

  next_line      = 0;
  redraw.xscroll = 0;
  redraw.yscroll = -top;

  convert_to_points(1, &round);
  round /= 2;

  /* Set the empty redraw table up */

  redrawcore_replace_table(&empty_table);

  /* Redraw loop */

  while (
          (
            end == End_Many &&
            page < to
          )
          ||
          (
            end != End_Many
          )
        )
  {
    page ++;

    /* Set up the Redraw block ready for the calls to redraw_draw */

    redraw.visible_area.xmax = rmarg - lmarg;
    redraw.visible_area.xmin = 0;

    convert_to_os(redraw.visible_area.xmax, &redraw.visible_area.xmax);
    convert_to_os(tmarg - bmarg,            &temp); /* 'temp' now holds the printable page height in OS units */

    if (end != End_Visible)
    {
      redraw.visible_area.ymax = temp,
      redraw.visible_area.ymin = 0;
    }
    else
    {
      if (next_line != 0 && bottom != 0) bottom -= (redraw.yscroll - next_line);

      if (bottom - top > temp) /* And *not* '>= temp'! See 'else' code below */
      {
        redraw.visible_area.ymax = temp;
      }
      else
      {
        redraw.visible_area.ymax = bottom - top;
        bottom = 0;
      }

      redraw.visible_area.ymin = 0;
    }

    if (next_line != 0)
    {
      redraw.yscroll = next_line;
      next_line      = 0;
    }

    /* Imaginary call to PDriver_DrawPage */

    redraw.redraw_area.xmin = 0;
    redraw.redraw_area.ymin = 0;

    convert_pair_to_os(rmarg - lmarg + round,
                       tmarg - bmarg + round,
                       &redraw.redraw_area.xmax,
                       &redraw.redraw_area.ymax);

    /* The redraw loop itself */

    last_rect.xmin = last_rect.xmax = last_rect.ymin = last_rect.ymax = 0;

    /* Do the imaginary redraw */

    (void) redraw_draw(b,
                       &redraw,
                       &next_line,
                       0,
                       NULL);

    /* If we should print down to the bottom of the visible */
    /* area of the page, this is flagged with 'end' set to  */
    /* End_Visible; if 'bottom' is zero as well, there's    */
    /* nothing more to print.                               */

    if (end == End_Visible && !bottom) break;

    /* If next_line is 0, redraw_draw must not have found any */
    /* lines that fell off the bottom of the page - so there  */
    /* cannot be any more pages.                              */

    if (next_line == 0) break;

    /* Otherwise, close the outer while loop - which */
    /* may mean we loop for another page.            */
  }

  /* Restore the redraw table and return the page count */

  redrawcore_default_table();
  return page;
}

/**************************************************************/
/* print_find_splitting_point()                               */
/*                                                            */
/* Service routine for print_fake_redraw and redraw_draw_r.   */
/* Given a reformat cell, line number within it and page      */
/* dimensions, works out if a new page should be started.     */
/*                                                            */
/* Parameters: Pointer to the reformat_cell being printed     */
/*             (really this should always be top level);      */
/*                                                            */
/*             Notional y coord origin of cell in OS units;   */
/*                                                            */
/*             Current line number within the cell;           */
/*                                                            */
/*             Page bottom y coordinate in OS units;          */
/*                                                            */
/*             Page height in OS units;                       */
/*                                                            */
/*             Pointer to an int updated with the y coord     */
/*             split point (OS units, negative down from 0).  */
/*                                                            */
/*             Pointer to an int updated with 1 if the        */
/*             inferred section should be stored through the  */
/*             returned token, else 0.                        */
/*                                                            */
/* Returns:    Pointer to the token that will be used on the  */
/*             first line of the new page if a split point is */
/*             found, with the given int updated with the y   */
/*             coordinate; else NULL.                         */
/*                                                            */
/* Assumes:    All pointers are non-NULL and valid.           */
/**************************************************************/

HStream * print_find_splitting_point(const reformat_cell * d, int osyorg, int l, int page_bottom, int page_height,
                                     int * split_y, int * store)
{
  int page_top = page_bottom + page_height;

  *store = 0;

  /* Printing page split rules: First, simple "line drops off page" rule. */
  /* For large lines - e.g. very big images, tables, or lines taller than */
  /* the whole page - we either should, or in the latter case must, split */
  /* that line. So, if the line is taller than 1/PrintSplitFraction of    */
  /* the page height, it will be split over the page boundary. This 'if'  */
  /* checks to see if it should *NOT* be split, and if not, returns an    */
  /* a y-coordinate to start the next page on which is the top of the     */
  /* line we reckon shouldn't be split in two.                            */

  if (osyorg + d->ldata[l].y < page_bottom)
  {
    int remaining; /* Not unsigned, as line "l-1" might be taller than the page too! */

    if (l > 0) remaining = osyorg + d->ldata[l - 1].y - page_bottom;
    else       remaining = page_height;

    // Old logic - if line itself is <= 100/PrintSplitFraction, don't split it. Bad
    // as there's nothing wrong with dropping tall lines to the next page if they
    // only leave a tiny gap.
    //
    // if (d->ldata[l].h <= ((page_height * 100) / PrintSplitFraction)) /* (See Print.h) */

    if (remaining <= ((page_height * 100) / PrintSplitFraction)) /* (See Print.h) */
    {
      HStream * t1 = d->cdata[d->ldata[l].chunks].t;

      /* Set a split point equivalent to just above the top of this line, so */
      /* that we drop it to the next page. Lines can have gaps between them, */
      /* so the top of one line doesn't necessarily mean the bottom of the   */
      /* line preceeding it - so don't change this code to look at "l-1"'s   */
      /* y-coordinate, for example.                                          */

      *split_y = osyorg + d->ldata[l].y + d->ldata[l].h;

      if (
           choices.print_page_break_hx > 0 &&
           reformat_istext(t1)             &&
           redraw_header(t1->style) > 0    &&
           redraw_header(t1->style) <= choices.print_page_break_hx
         )
         *store = 1;

      return t1;
    }
  }

  /* ...with "line fits on *exactly*" adjustment. */

  else if (
            osyorg + d->ldata[l].y == page_bottom &&
            l + 1 < d->nlines
          )
  {
    HStream * t1 = d->cdata[d->ldata[l + 1].chunks].t;

    *split_y = osyorg + d->ldata[l + 1].y + d->ldata[l + 1].h;

    if (
         choices.print_page_break_hx > 0 &&
         reformat_istext(t1)             &&
         redraw_header(t1->style) > 0    &&
         redraw_header(t1->style) <= choices.print_page_break_hx
       )
       *store = 1;

    return t1;
  }

  /* Trying to get clever now. Here we look one line ahead, and see if */
  /* this line would fall off the page. If so, then should we allow it */
  /* to get seperated from the current line, or should we put *both*   */
  /* onto the next side? (Above caveat on fraction of page gap left    */
  /* applies).                                                         */

  /* Note that the "gap <= fraction of page height" stuff must be a signed */
  /* comparison this time, as line "l" may have its base off the bottom of */
  /* the page if (so far, at least) we're thinking of splitting it rather  */
  /* than carrying it to the next page.                                    */

  if (
       (l + 1 < d->nlines)                                               &&
       osyorg + d->ldata[l + 1].y < page_bottom                          &&
       (osyorg + d->ldata[l].y - page_bottom <= ((page_height * 100) / PrintSplitFraction))
     )
// Was (d->ldata[l + 1].h <= ((page_height * 100) / PrintSplitFraction))
  {
    HStream * t1 = d->cdata[d->ldata[l].chunks].t;
    HStream * t2 = d->cdata[d->ldata[l + 1].chunks].t;

    /* If current line is a heading and next line isn't, or current line */
    /* is a definition list term (heading) and the next line is data,    */
    /* then don't split up the two lines.                                */

    if (
         reformat_istext(t1) &&
         (
           (
             ((t1->style & H_MASK) != 0) &&
             (
               (t2->style & H_MASK) == 0 ||
               !reformat_istext(t2)
             )
           )
           ||
           (
             ((t1->style & DT) != 0) &&
             ((t2->style & DD) != 0)
           )
         )
       )
    {
      *split_y = osyorg + d->ldata[l].y + d->ldata[l].h;

      if (
           choices.print_page_break_hx > 0 &&
           reformat_istext(t1)             &&
           redraw_header(t1->style) > 0    &&
           redraw_header(t1->style) <= choices.print_page_break_hx
         )
         *store = 1;

      return t1;
    }
  }

  /* There's also a case for look-behind. If this line is heading 1 or 2 */
  /* and the previous wasn't, start a new page here.                     */

  if (l > 0 && choices.print_page_break_hx != 0)
  {
    int       scan = l - 1;

    HStream * t1   = d->cdata[d->ldata[scan].chunks].t;
    HStream * t2   = d->cdata[d->ldata[l].chunks].t;

    int       h1;
    int       h2;

    if (reformat_istext(t2))
    {
      /* The previous line might not be useful (e.g. two H2s in a row */
      /* would have a dummy tag in between occuping a zero height     */
      /* line of its own). So we need to scan backwards to get a      */
      /* useful token.                                                */

      while (
              t1 != NULL &&
              (
                reformat_istext(t1) &&
                t1->text == NULL
              )
              && --scan >= 0
            )
            t1 = d->cdata[d->ldata[scan].chunks].t;

      h1 = reformat_istext(t1) ? redraw_header(t1->style) : 0;
      h2 = redraw_header(t2->style);

      if (
           osyorg + d->ldata[scan].y < page_top &&
//           osyorg + d->ldata[scan].y + d->ldata[scan].h <= page_top
//           &&
           (
             h1 > choices.print_page_break_hx ||
             h1 == 0
           )
           && h2 <= choices.print_page_break_hx
           && h2 > 0
         )
      {
        *split_y = osyorg + d->ldata[l].y + d->ldata[l].h;
        *store   = 1;

        return t2;
      }
    }
  }

  /* No split point found */

  return NULL;
}

/**************************************************************/
/* print_set_hourglass_by_area()                              */
/*                                                            */
/* Give a percentage completed indicator. This is first based */
/* on the current page being printed, so there's some scaling */
/* of the 100% range to cope with the fact that if you're on  */
/* page 3 of 4, the variation must be between 50% and 75%,    */
/* for example. Since rectangle order cannot be relied upon,  */
/* need to use the area printed so far for the calculation.   */
/* This may fail under unusual circumstances, and certainly   */
/* is not fully accurate as the rectangles always overlap by  */
/* a small amount (the printer driver gives room for rounding */
/* errors by overlapping the rectangles) but in any case      */
/* there will at least be some kind of percentage indication! */
/* With bit image printing, which can be painfully slow, this */
/* is extremely important.                                    */
/*                                                            */
/* There is an attempt to correct for overlapping rectangles  */
/* which works if this one and the last were overlapping.     */
/*                                                            */
/* Parameters: Pointer to a BBox holding the redraw rectangle */
/*             in OS units;                                   */
/*                                                            */
/*             Pointer to a BBox holding the previous redraw  */
/*             rectangle in OS units, for intersections (set  */
/*             all fields to 0 if there is no previous box);  */
/*                                                            */
/*             Total number of pages;                         */
/*                                                            */
/*             Current page number;                           */
/*                                                            */
/*             Area of the complete visible page in square    */
/*             OS units;                                      */
/*                                                            */
/*             Current cumulative area printed on this page   */
/*             in square OS units (set to 0 at start of each  */
/*             new page).                                     */
/*                                                            */
/* Returns:    Updated cumulative printed area.               */
/**************************************************************/

static unsigned int print_set_hourglass_by_area
                    (
                      BBox         * redraw_rect,
                      BBox         * last_rect,
                      unsigned int   pages,
                      unsigned int   page,
                      unsigned int   page_area,
                      unsigned int   completed_area
                    )
{
  BBox i;
  int  this_area;
  int  percent;

  /* Calculate the area of the redraw rectangle */

  this_area = (redraw_rect->xmax - redraw_rect->xmin) *
              (redraw_rect->ymax - redraw_rect->ymin);


  /* If this intersects with the last redraw rectangle, */
  /* subtract the area of the intersection.             */

  if (utils_intersection(redraw_rect, last_rect, &i))
  {
    this_area -= (i.xmax - i.xmin) *
                 (i.ymax - i.ymin);
  }

  completed_area += this_area;
  if (completed_area > page_area) completed_area = page_area;

  percent = (100 * (page - 1)) / pages +
            ((100 / pages) * completed_area) / page_area;

  if (percent < 0)  percent = 0;
  if (percent > 99) percent = 99;

  (void) _swix(Hourglass_Percentage,
              _IN(0),

              percent);

  return completed_area;
}
