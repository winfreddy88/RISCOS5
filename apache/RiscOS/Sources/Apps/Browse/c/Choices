/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Choices.c                                         */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Functions related to the Chices dialogue box and  */
/*          associated sub-windows.                           */
/*                                                            */
/* Author:  D.T.A.Brown.                                      */
/*                                                            */
/* History: 23-Sep-1997 (DTAB): Created.                      */
/*          18-Apr-1998 (ADH): choices_find_component will    */
/*                             complain if the same thing is  */
/*                             found more than once in TRACE  */
/*                             builds.                        */
/*          25-May-2000 (ADH): 64-wide comments adopted.      */
/*          17-Feb-2006 (ADH): New internal function order.   */
/**************************************************************/

#include <stdlib.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/window.h>
#include <tboxlibs/menu.h>
#include <tboxlibs/colourdbox.h>
#include <tboxlibs/fontmenu.h>

#include "ToolAction.h" /* Local copy that doesn't use OSLib */

#include <ImageLib/imagetrans.h>

#include "Global.h"
#include "FromROSLib.h"
#include "Utils.h"

#include "ChoiceDefs.h"
#include "Encoding.h"
#include "FetchPage.h"
#include "FontManage.h"
#include "History.h"
#include "Menus.h"
#include "NestWimp.h"
#include "Redraw.h"
#include "Reformat.h"
#include "Save.h"
#include "URLutils.h"
#include "Windows.h"

#include "Choices.h"

/* Local compile-time options */

#define CREATE_ONLY_ONCE

/* Local variables */

static char          consonant     []        = "bcdfghjklmnpqrstvwxyz";
static char          vowel         []        = "aeiou";
static int           rubbish_seed;

/* Used to prevent rounding errors when converting to/from font 16ths of a point to decimal */

static unsigned char todecimal     []        = {0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9};
static unsigned char fromdecimal   []        = {0, 2, 4, 5, 7, 8, 10, 12, 13, 15};

static ObjectId *    subwindows              = NULL;
static int           current_subwindow       = 0;
static ObjectId      colourdbox_id           = 0;

static ComponentId   save_ticked             = NULL_ComponentId;
static ComponentId   disp_ticked             = NULL_ComponentId;
static ComponentId   pbrk_ticked             = NULL_ComponentId;
static ComponentId   urih_ticked             = NULL_ComponentId;
static ComponentId   cook_ticked             = NULL_ComponentId;
static ComponentId   refe_ticked             = NULL_ComponentId;
static ComponentId   jpeg_ticked             = NULL_ComponentId;
static ComponentId   bord_ticked             = NULL_ComponentId;
static ComponentId   plug_ticked             = NULL_ComponentId;
static ComponentId   time_ticked             = NULL_ComponentId;

#ifdef JAVASCRIPT
  static ComponentId wino_ticked             = NULL_ComponentId;
  static ComponentId winc_ticked             = NULL_ComponentId;
#endif

static int           history_radio           = 0; /* 0 - page history, 1 - image history */

static int           expiry_age_greyed       = 0;
static int           max_size_greyed         = 0;
static int           image_expiry_age_greyed = 0;
static int           image_max_size_greyed   = 0;

static int           choices_modechanged     = 0;

static fm_typeface * new_typefaces           = NULL;

#ifdef CREATE_ONLY_ONCE
  static int         objects_created         = 0;
#endif

/* Enumeration describing known units of time */

typedef enum choices_time
{
  choices_time_NONE    = -1,
  choices_time_MINUTES = 0,
  choices_time_HOURS   = 1,
  choices_time_DAYS    = 2,
  choices_time_WEEKS   = 3,
  choices_time_MONTHS  = 4,
}
choices_time_e;

/* Records of units chosen for various menus */

static choices_time_e image_expiry_units   = choices_time_NONE;
static choices_time_e history_expiry_units = choices_time_NONE;

/* Type used to hold a mapping between a menu entry component ID */
/* and the value of a Choices item.                              */

typedef struct choices_map
{
  ComponentId id;
  int         value;
}
choices_map_t;

/* Map for the hotlist display type menu */

static choices_map_t map_hldisplay[] =
       {
         { CD_DispDesc,            Choices_HotlistType_Descriptions  },
         { CD_DispURL,             Choices_HotlistType_URLs          },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the history display type menu */

static choices_map_t map_hidisplay[] =
       {
         { CD_DispDesc,            0                                 },
         { CD_DispURL,             1                                 },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the hotlist save frequency menu */

static choices_map_t map_hlsave[] =
       {
         { CD_SaveNever,           Choices_SaveHotlist_Never         },
         { CD_SaveOnExit,          Choices_SaveHotlist_Once          },
         { CD_SaveAlways,          Choices_SaveHotlist_Always        },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the history save frequency menu */

static choices_map_t map_hisave[] =
       {
         { CD_SaveNever,           Choices_SaveHistory_Never         },
         { CD_SaveOnExit,          Choices_SaveHistory_Once          },
         { CD_SaveAlways,          Choices_SaveHistory_Always        },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the image history save frequency menu */

static choices_map_t map_hiimsave[] =
       {
         { CD_SaveNever,           Choices_SaveImageHistory_Never    },
         { CD_SaveOnExit,          Choices_SaveImageHistory_Once     },
         { CD_SaveAlways,          Choices_SaveImageHistory_Always   },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the page break menu */

static choices_map_t map_pagebreak[] =
       {
         { CD_PBreakNever,         0                                 },
         { CD_PBreakH1,            1                                 },
         { CD_PBreakH2,            2                                 },
         { CD_PBreakH3,            3                                 },
         { CD_PBreakH4,            4                                 },
         { CD_PBreakH5,            5                                 },
         { CD_PBreakH6,            6                                 },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the URI handler menu */

static choices_map_t map_uri[] =
       {
         { CD_URINever,            Choices_URI_Never                 },
         { CD_URIProcOnly,         Choices_URI_RequestsOnly          },
         { CD_URIBroadUk,          Choices_URI_BroadcastUnknowns     },
         { CD_URIProcAndBroad,     Choices_URI_UnknownsAndRequests   },
         { CD_URIProcAndEvery,     Choices_URI_EverythingAndRequests },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the cookie menu */

static choices_map_t map_cookie[] =
       {
         { CD_CookieReject,        Choices_Cookies_Reject            },
         { CD_CookiePrompt,        Choices_Cookies_Prompt            },
         { CD_CookieAccept,        Choices_Cookies_Accept            },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the referer menu */

static choices_map_t map_referer[] =
       {
         { CD_RefererNever,        Choices_SendReferer_Never         },
         { CD_RefererAlways,       Choices_SendReferer_Always        },
         { CD_RefererWhenHTTP,     Choices_SendReferer_WhenHTTP      },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the JPEG menu */

static choices_map_t map_jpeg[] =
       {
         { CD_JPEGOS,              Choices_SupportPJPEG_OS           },
         { CD_JPEGBoth,            Choices_SupportPJPEG_Both         },
         { CD_JPEGInternal,        Choices_SupportPJPEG_Internal     },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the outer table border menu */

static choices_map_t map_table_inner[] =
       {
         { CD_TableBorderNone,     Choices_TableOuter_Never          },
         { CD_TableBorder2D,       Choices_TableOuter_Always2D       },
         { CD_TableBorder3D,       Choices_TableOuter_Always3D       },
         { CD_TableBorderAuto,     Choices_TableOuter_Auto           },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the inner table border menu */

static choices_map_t map_table_outer[] =
       {
         { CD_TableBorderNone,     Choices_TableInner_Never          },
         { CD_TableBorder2D,       Choices_TableInner_Always2D       },
         { CD_TableBorder3D,       Choices_TableInner_Always3D       },
         { CD_TableBorderAuto,     Choices_TableInner_Auto           },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the plug-in launch menu */

static choices_map_t map_plugin[] =
       {
         { CD_PlugDont,            Choices_PlugIns_Never             },
         { CD_PlugRedraw,          Choices_PlugIns_Viewed            },
         { CD_PlugASAP,            Choices_PlugIns_ASAP              },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the time type (units) menu */

static choices_map_t map_timetype[] =
       {
         { CD_TimeMinutes,         (int) choices_time_MINUTES        },
         { CD_TimeHours,           (int) choices_time_HOURS          },
         { CD_TimeDays,            (int) choices_time_DAYS           },
         { CD_TimeWeeks,           (int) choices_time_WEEKS          },
         { CD_TimeMonths,          (int) choices_time_MONTHS         },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the header/footer special text menu (actually forming */
/* indices into the text insertion array below, with additional  */
/* offsets from the special text sub-menu).                      */

static choices_map_t map_hfspecial[] =
       {
         { CD_HFTextPageNumber,    0                                 },
         { CD_HFTextTotalPages,    5                                 },
         { CD_HFTextURL,           10                                },
         { CD_HFTextTitleBlank,    11                                },
         { CD_HFTextTitleURL,      12                                },
         { CD_HFTextDate,          13                                },
         { CD_HFTextHeadings,      14                                },
         { CD_HFTextExclaimation,  15                                },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the header/footer special text sub-menu (actually */
/* additions to indices in the map_hfspecial array above).   */

static choices_map_t map_hfspecsub[] =
       {
         { CD_HFSub123,            0                                 },
         { CD_HFSubiii,            1                                 },
         { CD_HFSubIII,            2                                 },
         { CD_HFSubaaa,            3                                 },
         { CD_HFSUbAAA,            4                                 },
         { NULL_ComponentId,       0                                 }
       };

/* A similar map to the special text menus above, this time for */
/* date format strings.                                         */

static choices_map_t map_hfdate[] =
       {
         { CD_HFDate24Hour,        0                                 },
         { CD_HFDate12Hour,        1                                 },
         { CD_HFDateAMPM,          2                                 },
         { CD_HFDateMinutes,       3                                 },
         { CD_HFDateSeconds,       4                                 },
         { CD_HFDateCentiseconds,  5                                 },
         { CD_HFDateFullWeekday,   6                                 },
         { CD_HFDateShortWeekday,  7                                 },
         { CD_HFDateNumWeekday,    8                                 },
         { CD_HFDateDayOfMonth,    9                                 },
         { CD_HFDateOrdinalPS,     10                                },
         { CD_HFDateFullMonth,     11                                },
         { CD_HFDateShortMonth,    12                                },
         { CD_HFDateNumMonth,      13                                },
         { CD_HFDateCentury,       14                                },
         { CD_HFDateYear,          15                                },
         { CD_HFDateWeekOfYear,    16                                },
         { CD_HFDateDayOfYear,     17                                },
         { CD_HFDateTimezone,      18                                },
         { CD_HFDateExclaimation,  19                                },
         { CD_HFDatePercent,       20                                },
         { NULL_ComponentId,       0                                 }
       };

#ifdef JAVASCRIPT

  /* Map for the JS 'window.open' menu */

  static choices_map_t map_win_open[] =
         {
           { CD_WinOpenAllow,      Choices_JSWindowOpen_Allow        },
           { CD_WinOpenReplace,    Choices_JSWindowOpen_Replace      },
           { CD_WinOpenQuery,      Choices_JSWindowOpen_Query        },
           { CD_WinOpenSuppress,   Choices_JSWindowOpen_Suppress     },
           { NULL_ComponentId,     0                                 }
         };

  /* Map for the JS 'window.close' menu */

  static choices_map_t map_win_close[] =
         {
           { CD_WinCloseAlways,    Choices_JSWindowClose_Always      },
           { CD_WinCloseSometimes, Choices_JSWindowClose_Sometimes   },
           { CD_WinCloseQuery,     Choices_JSWindowClose_Query       },
           { CD_WinCloseSuppress,  Choices_JSWindowClose_Suppress    },
           { NULL_ComponentId,     0                                 }
         };

#endif

/* Array of items inserted by the special text menu plus offsets */
/* from the special text sub-menu.                               */

const char * restrict special_text[] = {
                                         "!p1",
                                         "!pi",
                                         "!pI",
                                         "!pa",
                                         "!pA",

                                         "!P1",
                                         "!Pi",
                                         "!PI",
                                         "!Pa",
                                         "!PA",

                                         "!u",
                                         "!tk",
                                         "!ta",
                                         "!dp",
                                         "!dm",
                                         "!s",
                                         "!!"
                                       };

const char * restrict special_date[] = {
                                         "!24",
                                         "!12",
                                         "!am",
                                         "!mi",
                                         "!se",
                                         "!cs",
                                         "!we",
                                         "!w3",
                                         "!wn",
                                         "!dy",
                                         "!st",
                                         "!mo",
                                         "!m3",
                                         "!mn",
                                         "!ce",
                                         "!yr",
                                         "!wk",
                                         "!dn",
                                         "!tz",
                                         "!!",
                                         "!%"
                                       };

/* Lifecycle support */

static void              choices_internal_shutdown              (void);
static _kernel_oserror * choices_show_subwindow                 (ObjectId choices_window, int subwindow);
static void              choices_delete_subwindows              (void);

static int               choices_open_choice_window             (int eventcode, WimpPollBlock * event, IdBlock * id_block, void * handle);

static _kernel_oserror * choices_set_contents                   (void);
static _kernel_oserror * choices_get_contents                   (void);

/* Main dialogue box button handlers */

static int               choices_set_button_handler             (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_cancel_button_handler          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_save_button_handler            (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/* Colour choices 'fake page' routines */

static int               choices_redraw_fakepage_handler        (int eventcode, WimpPollBlock * event, IdBlock * id_block, void * handle);
static _kernel_oserror * choices_write_rubbish                  (fm_face h,                int xpos, int ypos, int maxxish,   int forecolour, int backcolour, int * newxpos, int seed);
static _kernel_oserror * choices_draw_string                    (fm_face h, char * string, int xpos, int ypos, int underline, int forecolour, int backcolour, int * newxpos);

/* Radio group handlers */

static int               choices_radio_click_handler            (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_history_radio_handler          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_printing_layout_radio_change   (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_printing_h_or_f_radio_change   (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);

/* Option button handlers */

static int               choices_option_state_handler           (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/* Menu handling support */

static ComponentId       choices_map_choice_to_entry
                         (
                           int                            choices_value,
                           const choices_map_t * restrict map
                         );

static int               choices_map_entry_to_choice
                         (
                           ComponentId                    menu_entry,
                           const choices_map_t * restrict map
                         );

static _kernel_oserror * choices_menu_open_by_popup
                         (
                           ObjectId               pane,
                           ComponentId            button,
                           const char  * restrict menu_name,
                           ObjectId    *          menu_object
                         );

static _kernel_oserror * choices_menu_popup_handler
                         (
                           ObjectId                       pane,
                           ComponentId                    button,
                           const char          * restrict menu_name,
                           int                            choices_value,
                           ComponentId         * restrict ticked_entry,
                           const choices_map_t * restrict map
                         );

static _kernel_oserror * choices_menu_selection_handler
                         (
                           ObjectId                       menu_object,
                           ComponentId                    selected_entry,
                           const char          * restrict menu_name,
                           int                 * restrict choices_value,
                           ComponentId         * restrict ticked_entry,
                           ComponentId                    associated_display_field,
                           const choices_map_t * restrict map
                         );

static _kernel_oserror * choices_update_popup_menu_display_field
                         (
                           ComponentId            display_field,
                           ComponentId            menu_entry,
                           const char  * restrict menu_name
                         );

/* Menu pop-up button handlers */

static int               choices_display_popup_handler          (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_save_popup_handler             (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_pagebreak_popup_handler        (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_uri_popup_handler              (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_cookie_popup_handler           (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_referer_popup_handler          (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_jpeg_popup_handler             (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_table_border_popup_handler     (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_plugin_popup_handler           (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_timetype_popup_handler         (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);

#ifdef JAVASCRIPT
  static int             choices_win_open_popup_handler         (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
  static int             choices_win_close_popup_handler        (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
#endif

static int               choices_font_button_handler            (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_encoding_button_handler        (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_colour_button_handler          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/* Simple menu selection handlers */

static int               choices_display_selection_handler      (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_save_selection_handler         (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_pagebreak_selection_handler    (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_uri_selection_handler          (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_cookie_selection_handler       (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_referer_selection_handler      (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_jpeg_selection_handler         (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_table_border_selection_handler (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_plugin_selection_handler       (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_timetype_selection_handler     (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_hfspecial_selection_handler    (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_hfspecsub_selection_handler    (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_hfdate_selection_handler       (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);

#ifdef JAVASCRIPT
  static int             choices_win_open_selection_handler     (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
  static int             choices_win_close_selection_handler    (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
#endif

static int               choices_font_selected_handler          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_colour_selected_handler        (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/* Menu closed handlers */

static int               choices_font_closed_handler            (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_colour_closed_handler          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/* Menu-related display field and number range updating */

static _kernel_oserror * choices_set_display_field              (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_save_field                 (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_pagebreak_field            (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_uri_field                  (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_cookie_field               (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_referer_field              (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_jpeg_field                 (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_table_border_field         (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_plugin_field               (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_timetype_field             (ComponentId display_field, int choices_value);

#ifdef JAVASCRIPT
  static _kernel_oserror * choices_set_win_open_field           (ComponentId display_field, int choices_value);
  static _kernel_oserror * choices_set_win_close_field          (ComponentId display_field, int choices_value);
#endif

/* Time menu utilities */

static choices_time_e    choices_return_appropriate_timetype    (int seconds);
static int               choices_seconds_to_typed_time          (int secs, choices_time_e timetype);
static int               choices_typed_time_to_seconds          (int time, choices_time_e timetype);
static int               choices_get_range_of_typed_time        (choices_time_e timetype);

/* Greying/ungreying items, with related actions */

static _kernel_oserror * choices_batch_gadget_state             (const ComponentId * restrict array, int state);

static void              choices_set_tables_greyed              (int state);
static _kernel_oserror * choices_set_printing_greyed            (void);
static void              choices_set_frame_related_greyed       (ObjectId window, int state);
static void              choices_set_fonts_greyed               (int state);

static void              choices_set_expiry_age                 (ObjectId window);
static void              choices_set_expiry_age_greyed          (int state);
static void              choices_set_im_expiry_age              (ObjectId window);
static void              choices_set_im_expiry_age_greyed       (int state);
static void              choices_set_max_size                   (ObjectId window);
static void              choices_set_max_size_greyed            (ObjectId window, int state);
static void              choices_set_im_max_size                (ObjectId window);
static void              choices_set_im_max_size_greyed         (ObjectId window, int state);

#ifdef JAVASCRIPT
  static void            choices_set_js_watchdog_greyed         (int state);
  static void            choices_set_js_all_greyed              (int state);
#endif

/* Finding gadgets */

static ObjectId          choices_find_component                 (ComponentId component);

/* Setting gadget parameters */

static _kernel_oserror * choices_displayfield_set_value         (const unsigned int flags, const ObjectId window, const ComponentId writable, const char * restrict text);
static _kernel_oserror * choices_writablefield_set_value        (const unsigned int flags, const ObjectId window, const ComponentId writable, const char * restrict text);
static _kernel_oserror * choices_writablefield_add_text         (const unsigned int flags, const ObjectId window, const ComponentId writable, const char * restrict text);
static _kernel_oserror * choices_button_set_validation          (const unsigned int flags, const ObjectId window, const ComponentId writable, const char * restrict text);
static _kernel_oserror * choices_numberrange_set_value          (const unsigned int flags, const ObjectId window, const ComponentId writable, const int value);
static _kernel_oserror * choices_colour_set_component           (ObjectId window, ComponentId component, int colour);

/* Reading gadget parameters */

static _kernel_oserror * choices_get_menu_entry_text            (const char * restrict menuname, ComponentId compid, char ** tempstring);
static _kernel_oserror * choices_retrieve_text_item             (ComponentId writable_field, char ** choice_to_update);

/* Miscellaneous utility functions */

static void              choices_modified_font                  (char * orig, char * mod, char * buffer);
int                      choices_clip_to_min_max                (int value, int min, int max);

/**************************************************************/
/* choices_to_be_shown()                                      */
/*                                                            */
/* Called when the ECDToBeShown event is generated.           */
/*                                                            */
/* Creates all the subwindow dialogues and fills them in with */
/* appropriate values. Registers all additional event         */
/* handlers used while the choices dialogue is visible.       */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int choices_to_be_shown(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror       *e;
  ObjectId              window;
  int                   subwindow_tobeshown;

  dprintf(("Choi", "choices_to_be_shown: Called\n"));

  /* In multiuser builds, need to be logged in - otherwise, close */
  /* the dialogue!                                                */

  #ifndef SINGLE_USER

    if (!logged_in)
    {
      toolbox_hide_object(0, idb->self_id);
      return 1;
    }

  #endif

  if (choices_windowid != NULL_ObjectId) return 1;

  _swix(OS_ReadMonotonicTime, _OUT(0), &rubbish_seed);

  choices_windowid = idb->self_id;

  /* Allocate block for holding subwindows ObjectIds */

  if (!subwindows)
  {
    subwindows = malloc(sizeof(ObjectId)*CDNoSubwindows);

    /* If hide object doesn't work, things are really screwed */

    if (!subwindows)
    {
      ChkError(toolbox_hide_object(0, idb->self_id));
      return 1;
    }
  }

  if (!new_choices)
  {
    new_choices = malloc(sizeof(global_choices));

    if (!new_choices)
    {
      ChkError(toolbox_hide_object(0, idb->self_id));
      return 1;
    }
    else
    {
      memcpy(new_choices, &choices, sizeof(global_choices));
    }
  }

  if (!new_typefaces)
  {
    new_typefaces = calloc(sizeof(fm_typeface), 3);

    if (!new_typefaces)
    {
      free(new_choices);
      new_choices = NULL;
      free(subwindows);
      subwindows  = NULL;
    }
    else
    {
      fm_typeface * tfptr;

      tfptr = fm_find_typeface("serif");
      memcpy(&new_typefaces[0], tfptr, sizeof(fm_typeface));
      tfptr = fm_find_typeface("sans");
      memcpy(&new_typefaces[1], tfptr, sizeof(fm_typeface));
      tfptr = fm_find_typeface("fixed");
      memcpy(&new_typefaces[2], tfptr, sizeof(fm_typeface));
    }
  }

  /* Create all choices subwindows.  Set their ObjectIds to NULL if they cannot be created */

  /* Might be worth changing this to a loop in the future */

  #ifdef CREATE_ONLY_ONCE
  if (!objects_created)
  {
  #endif
    e = toolbox_create_object(0, "ChSub0", &subwindows[0]);  if (e) subwindows[0]  = NULL;
    e = toolbox_create_object(0, "ChSub1", &subwindows[1]);  if (e) subwindows[1]  = NULL;
    e = toolbox_create_object(0, "ChSub2", &subwindows[2]);  if (e) subwindows[2]  = NULL;
    e = toolbox_create_object(0, "ChSub3", &subwindows[3]);  if (e) subwindows[3]  = NULL;
    e = toolbox_create_object(0, "ChSub4", &subwindows[4]);  if (e) subwindows[4]  = NULL;
    e = toolbox_create_object(0, "ChSub5", &subwindows[5]);  if (e) subwindows[5]  = NULL;
    e = toolbox_create_object(0, "ChSub6", &subwindows[6]);  if (e) subwindows[6]  = NULL;
    e = toolbox_create_object(0, "ChSub7", &subwindows[7]);  if (e) subwindows[7]  = NULL;
    e = toolbox_create_object(0, "ChSub8", &subwindows[8]);  if (e) subwindows[8]  = NULL;
    e = toolbox_create_object(0, "ChSub9", &subwindows[9]);  if (e) subwindows[9]  = NULL;
    e = toolbox_create_object(0, "ChSubA", &subwindows[10]); if (e) subwindows[10] = NULL;
  #ifdef CREATE_ONLY_ONCE
  }
  #endif

  subwindow_tobeshown = current_subwindow;
  current_subwindow   = CDSubNone;

  ChkError(choices_show_subwindow(idb->self_id, subwindow_tobeshown));

  ChkError(radiobutton_set_state(0, idb->self_id, CDFirstSubRadio + subwindow_tobeshown, 1));

  ChkError(choices_set_contents());

  /* Register choices event handlers. Make sure any additions here */
  /* are matched by deregistration in choices_internal_shutdown,   */
  /* just underneath this function.                                */

  #ifdef CREATE_ONLY_ONCE
  e = NULL;

  if (!objects_created)
  {
  #endif
    e         = event_register_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,            NULL);
    if (!e) e = event_register_toolbox_handler(-1, CDSet,                     choices_set_button_handler,             NULL);
    if (!e) e = event_register_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,            NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,        NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_LayoutRadios,          (ToolboxEventHandler *)
                                                                              choices_printing_layout_radio_change,   NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HFRadios,              (ToolboxEventHandler *)
                                                                              choices_printing_h_or_f_radio_change,   NULL);

    if (!e) e = event_register_toolbox_handler(-1, ECD_HlDispBt,              (ToolboxEventHandler *)
                                                                              choices_display_popup_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiDispBt,              (ToolboxEventHandler *)
                                                                              choices_display_popup_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HlSaveBt,              (ToolboxEventHandler *)
                                                                              choices_save_popup_handler,             NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiSaveBt,              (ToolboxEventHandler *)
                                                                              choices_save_popup_handler,             NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiImSaveBt,            (ToolboxEventHandler *)
                                                                              choices_save_popup_handler,             NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_PageBreakBt,           (ToolboxEventHandler *)
                                                                              choices_pagebreak_popup_handler,        NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_URIHandlerBt,          (ToolboxEventHandler *)
                                                                              choices_uri_popup_handler,              NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_CookieBt,              (ToolboxEventHandler *)
                                                                              choices_cookie_popup_handler,           NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_RefererBt,             (ToolboxEventHandler *)
                                                                              choices_referer_popup_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_JPEGBt,                (ToolboxEventHandler *)
                                                                              choices_jpeg_popup_handler,             NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_TabInnerBordBt,        (ToolboxEventHandler *)
                                                                              choices_table_border_popup_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_TabOuterBordBt,        (ToolboxEventHandler *)
                                                                              choices_table_border_popup_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_ObjPlugBt,             (ToolboxEventHandler *)
                                                                              choices_plugin_popup_handler,           NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiAgeTypeBt,           (ToolboxEventHandler *)
                                                                              choices_timetype_popup_handler,         NULL);

    #ifdef JAVASCRIPT
      if (!e) e = event_register_toolbox_handler(-1, ECD_WinOpenBt,           (ToolboxEventHandler *)
                                                                              choices_win_open_popup_handler,         NULL);
      if (!e) e = event_register_toolbox_handler(-1, ECD_WinCloseBt,          (ToolboxEventHandler *)
                                                                              choices_win_close_popup_handler,        NULL);
    #endif


    if (!e) e = event_register_toolbox_handler(-1, ECDDispMenuClick,          (ToolboxEventHandler *)
                                                                              choices_display_selection_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDSaveMenuClick,          (ToolboxEventHandler *)
                                                                              choices_save_selection_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDPageBreakMenuClick,     (ToolboxEventHandler *)
                                                                              choices_pagebreak_selection_handler,    NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDURIMenuClick,           (ToolboxEventHandler *)
                                                                              choices_uri_selection_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDCookieMenuClick,        (ToolboxEventHandler *)
                                                                              choices_cookie_selection_handler,       NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDRefererMenuClick,       (ToolboxEventHandler *)
                                                                              choices_referer_selection_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDJPEGMenuClick,          (ToolboxEventHandler *)
                                                                              choices_jpeg_selection_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDBordMenuClick,          (ToolboxEventHandler *)
                                                                              choices_table_border_selection_handler, NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDPlugMenuClick,          (ToolboxEventHandler *)
                                                                              choices_plugin_selection_handler,       NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDTimeMenuClick,          (ToolboxEventHandler *)
                                                                              choices_timetype_selection_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDHFSpecialMenuClick,     (ToolboxEventHandler *)
                                                                              choices_hfspecial_selection_handler,    NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDHFSpecSubMenuClick,     (ToolboxEventHandler *)
                                                                              choices_hfspecsub_selection_handler,    NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDHFDateMenuClick,        (ToolboxEventHandler *)
                                                                              choices_hfdate_selection_handler,       NULL);

    #ifdef JAVASCRIPT
      if (!e) e = event_register_toolbox_handler(-1, ECDWinOpenMenuClick,     (ToolboxEventHandler *)
                                                                              choices_win_open_selection_handler,     NULL);
      if (!e) e = event_register_toolbox_handler(-1, ECDWinCloseMenuClick,    (ToolboxEventHandler *)
                                                                              choices_win_close_selection_handler,    NULL);
    #endif


    if (!e) e = event_register_toolbox_handler(-1, ECDHiRadioClick,           choices_history_radio_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,           NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,            NULL);

    if ((window = choices_find_component(CD_FakePage)) != 0)
    {
      if (!e) e = event_register_wimp_handler(window, Wimp_ERedrawWindow, choices_redraw_fakepage_handler, NULL);
    }
    if (!e) e = event_register_wimp_handler(idb->self_id, Wimp_EOpenWindow, choices_open_choice_window, NULL);
  #ifdef CREATE_ONLY_ONCE
  }
  #endif

  /* Deal with errors */

  if (e)
  {
    choices_internal_shutdown();
    ChkError(e);
  }

  #ifdef CREATE_ONLY_ONCE
  objects_created = 1;
  #endif

  return 1;
}

/**************************************************************/
/* choices_internal_shutdown()                                */
/*                                                            */
/* Shut down the Choices system. Should be called if an error */
/* occurs when setting up or if CREATE_ONLY_ONCE is undefined */
/* and the window is closing. If CREATE_ONLY_ONCE is defined, */
/* the objects_created flag is cleared to endeavour to ensure */
/* internal consistency.                                      */
/**************************************************************/

static void choices_internal_shutdown(void)
{
  ObjectId window;

  /* Clear the "created" flag if relevant */

  #ifdef CREATE_ONLY_ONCE
    objects_created = 0;
  #endif

  /* Delete all subwindow objects */

  choices_delete_subwindows();

  free(new_choices);
  new_choices = NULL;
  free(new_typefaces);
  new_typefaces = NULL;

  /* Deregister choices event handlers */
  event_deregister_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,            NULL);
  event_deregister_toolbox_handler(-1, CDSet,                     choices_set_button_handler,             NULL);
  event_deregister_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,          NULL);
  event_deregister_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,            NULL);
  event_deregister_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,        NULL);
  event_deregister_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,          NULL);
  event_deregister_toolbox_handler(-1, ECD_LayoutRadios,          (ToolboxEventHandler *)
                                                                  choices_printing_layout_radio_change,   NULL);
  event_deregister_toolbox_handler(-1, ECD_HFRadios,              (ToolboxEventHandler *)
                                                                  choices_printing_h_or_f_radio_change,   NULL);

  event_deregister_toolbox_handler(-1, ECD_HlDispBt,              (ToolboxEventHandler *)
                                                                  choices_display_popup_handler,          NULL);
  event_deregister_toolbox_handler(-1, ECD_HiDispBt,              (ToolboxEventHandler *)
                                                                  choices_display_popup_handler,          NULL);
  event_deregister_toolbox_handler(-1, ECD_HlSaveBt,              (ToolboxEventHandler *)
                                                                  choices_save_popup_handler,             NULL);
  event_deregister_toolbox_handler(-1, ECD_HiSaveBt,              (ToolboxEventHandler *)
                                                                  choices_save_popup_handler,             NULL);
  event_deregister_toolbox_handler(-1, ECD_HiImSaveBt,            (ToolboxEventHandler *)
                                                                  choices_save_popup_handler,             NULL);
  event_deregister_toolbox_handler(-1, ECD_PageBreakBt,           (ToolboxEventHandler *)
                                                                  choices_pagebreak_popup_handler,        NULL);
  event_deregister_toolbox_handler(-1, ECD_URIHandlerBt,          (ToolboxEventHandler *)
                                                                  choices_uri_popup_handler,              NULL);
  event_deregister_toolbox_handler(-1, ECD_CookieBt,              (ToolboxEventHandler *)
                                                                  choices_cookie_popup_handler,           NULL);
  event_deregister_toolbox_handler(-1, ECD_RefererBt,             (ToolboxEventHandler *)
                                                                  choices_referer_popup_handler,          NULL);
  event_deregister_toolbox_handler(-1, ECD_JPEGBt,                (ToolboxEventHandler *)
                                                                  choices_jpeg_popup_handler,             NULL);
  event_deregister_toolbox_handler(-1, ECD_TabInnerBordBt,        (ToolboxEventHandler *)
                                                                  choices_table_border_popup_handler,     NULL);
  event_deregister_toolbox_handler(-1, ECD_TabOuterBordBt,        (ToolboxEventHandler *)
                                                                  choices_table_border_popup_handler,     NULL);
  event_deregister_toolbox_handler(-1, ECD_ObjPlugBt,             (ToolboxEventHandler *)
                                                                  choices_plugin_popup_handler,           NULL);
  event_deregister_toolbox_handler(-1, ECD_HiAgeTypeBt,           (ToolboxEventHandler *)
                                                                  choices_timetype_popup_handler,         NULL);

  #ifdef JAVASCRIPT
    event_deregister_toolbox_handler(-1, ECD_WinOpenBt,           (ToolboxEventHandler *)
                                                                  choices_win_open_popup_handler,         NULL);
    event_deregister_toolbox_handler(-1, ECD_WinCloseBt,          (ToolboxEventHandler *)
                                                                  choices_win_close_popup_handler,        NULL);
  #endif


  event_deregister_toolbox_handler(-1, ECDDispMenuClick,          (ToolboxEventHandler *)
                                                                  choices_display_selection_handler,      NULL);
  event_deregister_toolbox_handler(-1, ECDSaveMenuClick,          (ToolboxEventHandler *)
                                                                  choices_save_selection_handler,         NULL);
  event_deregister_toolbox_handler(-1, ECDPageBreakMenuClick,     (ToolboxEventHandler *)
                                                                  choices_pagebreak_selection_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECDURIMenuClick,           (ToolboxEventHandler *)
                                                                  choices_uri_selection_handler,          NULL);
  event_deregister_toolbox_handler(-1, ECDCookieMenuClick,        (ToolboxEventHandler *)
                                                                  choices_cookie_selection_handler,       NULL);
  event_deregister_toolbox_handler(-1, ECDRefererMenuClick,       (ToolboxEventHandler *)
                                                                  choices_referer_selection_handler,      NULL);
  event_deregister_toolbox_handler(-1, ECDJPEGMenuClick,          (ToolboxEventHandler *)
                                                                  choices_jpeg_selection_handler,         NULL);
  event_deregister_toolbox_handler(-1, ECDBordMenuClick,          (ToolboxEventHandler *)
                                                                  choices_table_border_selection_handler, NULL);
  event_deregister_toolbox_handler(-1, ECDPlugMenuClick,          (ToolboxEventHandler *)
                                                                  choices_plugin_selection_handler,       NULL);
  event_deregister_toolbox_handler(-1, ECDTimeMenuClick,          (ToolboxEventHandler *)
                                                                  choices_timetype_selection_handler,     NULL);
  event_deregister_toolbox_handler(-1, ECDHFSpecialMenuClick,     (ToolboxEventHandler *)
                                                                  choices_hfspecial_selection_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECDHFSpecSubMenuClick,     (ToolboxEventHandler *)
                                                                  choices_hfspecsub_selection_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECDHFDateMenuClick,        (ToolboxEventHandler *)
                                                                  choices_hfdate_selection_handler,       NULL);

  #ifdef JAVASCRIPT
    event_deregister_toolbox_handler(-1, ECDWinOpenMenuClick,     (ToolboxEventHandler *)
                                                                  choices_win_open_selection_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDWinCloseMenuClick,    (ToolboxEventHandler *)
                                                                  choices_win_close_selection_handler,    NULL);
  #endif


  event_deregister_toolbox_handler(-1, ECDHiRadioClick,           choices_history_radio_handler,          NULL);
  event_deregister_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,           NULL);
  event_deregister_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,            NULL);

  if ((window = choices_find_component(CD_FakePage)) != 0)
  {
    event_deregister_wimp_handler(window, Wimp_ERedrawWindow, choices_redraw_fakepage_handler, NULL);
  }

  if (choices_windowid != NULL_ObjectId)
  {
    event_deregister_wimp_handler(choices_windowid,
                                  Wimp_EOpenWindow,
                                  choices_open_choice_window,
                                  NULL);
  }
}

/**************************************************************/
/* choices_show_subwindow()                                   */
/*                                                            */
/* Shows a choice subwindow in the main choices window.      */
/*                                                            */
/* Parameters: the ObjectId of the main choices window        */
/*                                                            */
/*             the number of the subwindow to show. Defined   */
/*             in choices.h Use CDSubNone to remove the       */
/*             current subwindow.                             */
/*                                                            */
/* Returns:    pointer to _kernel_oserror                     */
/**************************************************************/

static _kernel_oserror * choices_show_subwindow(ObjectId choices_window, int subwindow)
{
  _kernel_oserror           * e;
  WindowShowObjectBlock       show_block;
  WimpGetWindowStateBlock     state;
  WimpGetWindowOutlineBlock   outline;
  int                         window_handle;
  int                         vwidth, hheight;

  if (current_subwindow != CDSubNone && current_subwindow != subwindow)
  {
    /* remove the current subwindow */

    RetError(toolbox_hide_object(0, subwindows[current_subwindow]));
    current_subwindow = CDSubNone;
  }

  if (subwindow == CDSubNone || !(subwindows[subwindow]))
  {
    /* Have not been asked to open a new subwindow */

    return NULL;
  }

  RetError(window_get_wimp_handle(0, choices_window, &window_handle));
  state.window_handle = window_handle;
  RetError(wimp_get_window_state(&state));
  RetError(gadget_get_bbox(0, choices_window, CDPlaceHolder, &show_block.visible_area));
  windows_return_tool_sizes(NULL, &hheight, &vwidth);

  show_block.visible_area.xmin = coords_x_toscreen(show_block.visible_area.xmin, (WimpRedrawWindowBlock *) &state);
  show_block.visible_area.xmax = coords_x_toscreen(show_block.visible_area.xmax, (WimpRedrawWindowBlock *) &state);
  show_block.visible_area.ymin = coords_y_toscreen(show_block.visible_area.ymin, (WimpRedrawWindowBlock *) &state);
  show_block.visible_area.ymax = coords_y_toscreen(show_block.visible_area.ymax, (WimpRedrawWindowBlock *) &state);

  /* Adjustments for different types of window */

  dprintf(("Choi", "choices_show_subwindow: Wimp flags = %x\n", state.flags));

  RetError(window_get_wimp_handle(0, subwindows[subwindow], &state.window_handle));
  RetError(wimp_get_window_state(&state));

  if (state.flags & WimpWindow_VScroll) show_block.visible_area.xmax -= vwidth;
  else vwidth  = 0;

  if (state.flags & WimpWindow_HScroll) show_block.visible_area.ymin += hheight;
  else hheight = 0;

  show_block.xscroll = 0;
  show_block.yscroll = 0;
  show_block.behind  = -1;

  show_block.window_flags    = 0;
  show_block.alignment_flags = 0;

  /* Requires wimp handle just to be awkward */

  show_block.parent_window_handle = window_handle;

  RetError(toolbox_show_object(Toolbox_ShowObject_AsSubWindow,
                               subwindows[subwindow],
                               Toolbox_ShowObject_FullSpec,
                               &show_block,
                               choices_window,
                               -1));

  outline.window_handle = state.window_handle;
  wimp_get_window_outline(&outline);

  if (outline.outline.xmin < show_block.visible_area.xmin)
  {
    show_block.visible_area.xmin += (show_block.visible_area.xmin - outline.outline.xmin);
  }
  if (outline.outline.ymin < (show_block.visible_area.ymin - hheight))
  {
    show_block.visible_area.ymin += (show_block.visible_area.ymin - outline.outline.ymin);
  }
  if (outline.outline.xmax > (show_block.visible_area.xmax + vwidth))
  {
    show_block.visible_area.xmax -= (outline.outline.xmax - show_block.visible_area.xmax);
  }
  if (outline.outline.ymax > show_block.visible_area.ymax)
  {
    show_block.visible_area.ymax -= (outline.outline.ymax - show_block.visible_area.ymax);
  }

  e = toolbox_show_object(Toolbox_ShowObject_AsSubWindow,
                          subwindows[subwindow],
                          Toolbox_ShowObject_FullSpec,
                          &show_block,
                          choices_window,
                          -1);

  if (!e) current_subwindow = subwindow;

  return e;
}

/**************************************************************/
/* choices_delete_subwindows()                                */
/*                                                            */
/* Deletes all subwindows, reports any and all errors         */
/* occuring while deleting them. Frees the structure holding  */
/* the subwindows. Only call if CREATE_ONLY_ONCE is undefined */
/* or you're going to tidy up events etc. and make sure the   */
/* objects_created flag setting is appropriate.               */
/**************************************************************/

static void choices_delete_subwindows(void)
{
  _kernel_oserror *e;
  int count;

  for(count = 0; count < CDNoSubwindows; count++)
  {
    if (subwindows[count])
    {
      e = toolbox_delete_object(0, subwindows[count]);
      if (e) show_error_ret(e);
      subwindows[count] = 0;
    }
  }
  free(subwindows);
  subwindows = NULL;
}

/**************************************************************/
/* choices_hidden()                                           */
/*                                                            */
/* Called when the ECDHidden event is generated. Deletes all  */
/* the subwindow dialogues. Deregisters all additional event  */
/* handlers used while the choices dialogue is visible.       */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int choices_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror * e;
  int               temp;

  temp = current_subwindow;

  /* Close subwindow */

  e = choices_show_subwindow(idb->self_id, CDSubNone);
  if (e) show_error_ret(e);

  #ifndef CREATE_ONLY_ONCE
    choices_internal_shutdown();
  #endif

  choices_windowid  = NULL_ObjectId;
  current_subwindow = temp;

  return 1;
}

/**************************************************************/
/* choices_close()                                            */
/*                                                            */
/* Close the Choices dialogue as if the 'Cancel' button had   */
/* been activated with Select.                                */
/**************************************************************/

_kernel_oserror * choices_close(void)
{
  if (new_choices) memcpy(new_choices, &choices, sizeof(global_choices));

  if (choices_windowid) return toolbox_hide_object(0, choices_windowid);
  else                  return NULL;
}

/**************************************************************/
/* choices_mode_change()                                      */
/*                                                            */
/* Called on every mode change event. Records that a mode     */
/* change has taken place for use with the                    */
/* choices_open_choice_window function.                       */
/**************************************************************/

_kernel_oserror * choices_mode_change(void)
{
  choices_modechanged = 1;

  return NULL;
}

/**************************************************************/
/* choices_open_choice_window()                               */
/*                                                            */
/* Called whenever the choices window needs to be moved and   */
/* specifically on mode changes so the current sub window can */
/* be positioned correctly dealing with rounding errors       */
/* between modes of different aspect ratio.                   */
/**************************************************************/

static int choices_open_choice_window(int eventcode, WimpPollBlock * event, IdBlock * idb, void * handle)
{
  toolbox_show_object(0, idb->self_id, Toolbox_ShowObject_FullSpec, &(event->open_window_request.visible_area), idb->parent_id, idb->parent_component);

  if (choices_modechanged)
  {
    /* Reshow the subwindow at possibly new location */

    choices_show_subwindow(idb->self_id, current_subwindow);
    choices_modechanged = 0;
  }

  return 1;
}

/**************************************************************/
/* choices_set_contents()                                     */
/*                                                            */
/* Sets the contents of all choices subwindows to reflect the */
/* current state of the global choices.                       */
/*                                                            */
/* Returns:    pointer to _kernel_oserror.                    */
/**************************************************************/

static _kernel_oserror * choices_set_contents(void)
{
  ObjectId          window;
  unsigned int      temp, frac;

  /* No error handling here, as we want to allow items to be missing */

  /* Networking - URI handling, cookies, referer header */

  if ((window = choices_find_component(CD_Homepage))          != 0) choices_writablefield_set_value (0, window, CD_Homepage,          new_choices->home_page);
  if ((window = choices_find_component(CD_NetLaunchProxy))    != 0) optionbutton_set_state          (0, window, CD_NetLaunchProxy,    new_choices->start_proxy);
  if ((window = choices_find_component(CD_ClientPull))        != 0) optionbutton_set_state          (0, window, CD_ClientPull,        new_choices->client_pull);
  if ((window = choices_find_component(CD_NetscapeEmu))       != 0) optionbutton_set_state          (0, window, CD_NetscapeEmu,       new_choices->clone);
  if ((window = choices_find_component(CD_StripExtensions))   != 0) optionbutton_set_state          (0, window, CD_StripExtensions,   new_choices->strip_extensions);
  if ((window = choices_find_component(CD_NetUseProxy))       != 0) optionbutton_set_state          (0, window, CD_NetUseProxy,       new_choices->use_proxy);
  if ((window = choices_find_component(CD_NetProxyAddr))      != 0)
  {
    set_gadget_state(window, CD_NetProxyAddr, !new_choices->use_proxy);
    set_gadget_state(window, CD_NetProxyLabl, !new_choices->use_proxy);
    choices_writablefield_set_value(0, window, CD_NetProxyAddr, new_choices->proxy_address);
  }

  (void) choices_set_uri_field     (CD_URIHandlerDisp, new_choices->uri_usage);
  (void) choices_set_cookie_field  (CD_CookieDisp,     new_choices->cookies);
  (void) choices_set_referer_field (CD_RefererDisp,    new_choices->send_referer);

  /* Colours */

  if ((window = choices_find_component(CD_UseDocColours))     != 0) optionbutton_set_state          (0, window, CD_UseDocColours,     new_choices->use_source_cols);

  if ((window = choices_find_component(CD_BackColour))        != 0) choices_colour_set_component       (window, CD_BackColour,        new_choices->background_colour);
  if ((window = choices_find_component(CD_TextColour))        != 0) choices_colour_set_component       (window, CD_TextColour,        new_choices->text_colour);
  if ((window = choices_find_component(CD_LinkColour))        != 0) choices_colour_set_component       (window, CD_LinkColour,        new_choices->link_colour);
  if ((window = choices_find_component(CD_UsedColour))        != 0) choices_colour_set_component       (window, CD_UsedColour,        new_choices->used_colour);
  if ((window = choices_find_component(CD_FolwColour))        != 0) choices_colour_set_component       (window, CD_FolwColour,        new_choices->followed_colour);
  if ((window = choices_find_component(CD_SlctColour))        != 0) choices_colour_set_component       (window, CD_SlctColour,        new_choices->selected_colour);

  /* Fonts */

  if ((window = choices_find_component(CD_FontsSystem))       != 0)
  {
    optionbutton_set_state(0, window, CD_FontsSystem, new_choices->system_font);
    choices_set_fonts_greyed(new_choices->system_font);

    /*set_gadget_state(window, CD_FontsGroup1,  new_choices->system_font);*/
  }

  if ((window = choices_find_component(CD_FontsTF1Disp))      != 0) choices_displayfield_set_value  (0, window, CD_FontsTF1Disp,      new_typefaces[0].fontnames[0]);
  if ((window = choices_find_component(CD_FontsTF2Disp))      != 0) choices_displayfield_set_value  (0, window, CD_FontsTF2Disp,      new_typefaces[1].fontnames[0]);
  if ((window = choices_find_component(CD_FontsTF3Disp))      != 0) choices_displayfield_set_value  (0, window, CD_FontsTF3Disp,      new_typefaces[2].fontnames[0]);

  temp = new_choices->font_size;
  frac = (temp & 0xf);
  temp = ((temp >> 4) * 10) + todecimal[frac];

  if ((window = choices_find_component(CD_FontsSize))         != 0) choices_numberrange_set_value   (0, window, CD_FontsSize,         temp);
  if ((window = choices_find_component(CD_FontsAspect))       != 0) choices_numberrange_set_value   (0, window, CD_FontsAspect,       new_choices->tt_aspect);
  if ((window = choices_find_component(CD_FontsMinSize))      != 0) choices_numberrange_set_value   (0, window, CD_FontsMinSize,      new_choices->minimum_font_size);
  if ((window = choices_find_component(CD_UnderlineLinks))    != 0) optionbutton_set_state          (0, window, CD_UnderlineLinks,    new_choices->underline_links);

  /* Encoding */

  choices_set_encoding_field();

  /* Images */

  if ((window = choices_find_component(CD_ShowForeground))    != 0) optionbutton_set_state          (0, window, CD_ShowForeground,    new_choices->show_foreground);
  if ((window = choices_find_component(CD_ShowBackground))    != 0) optionbutton_set_state          (0, window, CD_ShowBackground,    new_choices->show_background);
  if ((window = choices_find_component(CD_NetMaxImageFetch))  != 0) choices_numberrange_set_value   (0, window, CD_NetMaxImageFetch,  new_choices->max_images);

  (void) choices_set_jpeg_field(CD_JPEGDisp, new_choices->support_pjpeg);

  /* Image RAM cache */

  if ((window = choices_find_component(CD_GCAfterNewFetch))   != 0) optionbutton_set_state          (0, window, CD_GCAfterNewFetch,   new_choices->collect_after);
  if ((window = choices_find_component(CD_GCUnusedLimitDisp)) != 0) choices_numberrange_set_value   (0, window, CD_GCUnusedLimitDisp, new_choices->unused_image_limit);
  if ((window = choices_find_component(CD_GCFreeLimitDisp))   != 0) choices_numberrange_set_value   (0, window, CD_GCFreeLimitDisp,   new_choices->free_ram_limit);

  /* Image history */

  if ((window = choices_find_component(CD_HiImExpiryAge))     != 0) choices_set_im_expiry_age (window);
  if ((window = choices_find_component(CD_HiImMaxSize))       != 0) choices_set_im_max_size   (window);

  (void) choices_set_save_field    (CD_HiImSaveDisp, new_choices->save_image_history);

  if (history_radio)
  {
    if ((window = choices_find_component(CD_HiRadImage)) != 0)
    radiobutton_set_state(0, window, CD_HiRadImage, 1);
  }
  else
  {
    if ((window = choices_find_component(CD_HiRadPage)) != 0)
    radiobutton_set_state(0, window, CD_HiRadPage, 1);
  }

  /* View */

  if ((window = choices_find_component(CD_URLBar))            != 0) optionbutton_set_state          (0, window, CD_URLBar,            new_choices->url_bar);
  if ((window = choices_find_component(CD_StatusBar))         != 0) optionbutton_set_state          (0, window, CD_StatusBar,         new_choices->status_bar);
  if ((window = choices_find_component(CD_ButtonBar))         != 0) optionbutton_set_state          (0, window, CD_ButtonBar ,        new_choices->button_bar);
  if ((window = choices_find_component(CD_FullScreen))        != 0) optionbutton_set_state          (0, window, CD_FullScreen,        new_choices->full_screen);
  if ((window = choices_find_component(CD_PreserveWidth))     != 0) optionbutton_set_state          (0, window, CD_PreserveWidth,     new_choices->toggle_on_y_only);

  /* Reformatting */

  if ((window = choices_find_component(CD_RefoKeep))          != 0) optionbutton_set_state          (0, window, CD_RefoKeep,          new_choices->refo_keep);
  if ((window = choices_find_component(CD_RefoHold))          != 0) optionbutton_set_state          (0, window, CD_RefoHold,          new_choices->refo_hold);
  if ((window = choices_find_component(CD_RefoWait))          != 0)
  {
    optionbutton_set_state(0, window, CD_RefoWait, new_choices->refo_wait);

    set_gadget_state(window, CD_RefoTimeLabl,  !new_choices->refo_wait);
    set_gadget_state(window, CD_RefoTimeDisp,  !new_choices->refo_wait);
    set_gadget_state(window, CD_RefoTimeLabl2, !new_choices->refo_wait);
  }
  if ((window = choices_find_component(CD_RefoTimeDisp))      != 0) choices_numberrange_set_value   (0, window, CD_RefoTimeDisp,      new_choices->refo_time);

  /* Printing */

  (void) choices_set_pagebreak_field (CD_PageBreakDisp,  new_choices->print_page_break_hx);

  if (new_choices->print_headers_from == 0)
  {
    if ((window = choices_find_component(CD_HeadersOff))      != 0) radiobutton_set_state           (0, window, CD_HeadersOff,        1);
    if ((window = choices_find_component(CD_HeadersFrom))     != 0) radiobutton_set_state           (0, window, CD_HeadersFrom,       0);
    if ((window = choices_find_component(CD_HeadersDisp))     != 0) choices_numberrange_set_value   (0, window, CD_HeadersDisp,       1);
  }
  else
  {
    if ((window = choices_find_component(CD_HeadersOff))      != 0) radiobutton_set_state           (0, window, CD_HeadersOff,        0);
    if ((window = choices_find_component(CD_HeadersFrom))     != 0) radiobutton_set_state           (0, window, CD_HeadersFrom,       1);
    if ((window = choices_find_component(CD_HeadersDisp))     != 0) choices_numberrange_set_value   (0, window, CD_HeadersDisp,       new_choices->print_headers_from);
  }

  if (new_choices->print_footers_from == 0)
  {
    if ((window = choices_find_component(CD_FootersOff))      != 0) radiobutton_set_state           (0, window, CD_FootersOff,        1);
    if ((window = choices_find_component(CD_FootersFrom))     != 0) radiobutton_set_state           (0, window, CD_FootersFrom,       0);
    if ((window = choices_find_component(CD_FootersDisp))     != 0) choices_numberrange_set_value   (0, window, CD_FootersDisp,       1);
  }
  else
  {
    if ((window = choices_find_component(CD_FootersOff))      != 0) radiobutton_set_state           (0, window, CD_FootersOff,        0);
    if ((window = choices_find_component(CD_FootersFrom))     != 0) radiobutton_set_state           (0, window, CD_FootersFrom,       1);
    if ((window = choices_find_component(CD_FootersDisp))     != 0) choices_numberrange_set_value   (0, window, CD_FootersDisp,       new_choices->print_footers_from);
  }

  if ((window = choices_find_component(CD_HeaderLeft))        != 0) choices_writablefield_set_value (0, window, CD_HeaderLeft,        new_choices->print_header_left);
  if ((window = choices_find_component(CD_HeaderMiddle))      != 0) choices_writablefield_set_value (0, window, CD_HeaderMiddle,      new_choices->print_header_mid);
  if ((window = choices_find_component(CD_HeaderRight))       != 0) choices_writablefield_set_value (0, window, CD_HeaderRight,       new_choices->print_header_right);
  if ((window = choices_find_component(CD_FooterLeft))        != 0) choices_writablefield_set_value (0, window, CD_FooterLeft,        new_choices->print_footer_left);
  if ((window = choices_find_component(CD_FooterMiddle))      != 0) choices_writablefield_set_value (0, window, CD_FooterMiddle,      new_choices->print_footer_mid);
  if ((window = choices_find_component(CD_FooterRight))       != 0) choices_writablefield_set_value (0, window, CD_FooterRight,       new_choices->print_footer_right);
  if ((window = choices_find_component(CD_DateFormat))        != 0) choices_writablefield_set_value (0, window, CD_DateFormat,        new_choices->print_date_format);

  if (new_choices->print_facing_pages == Choices_PrintFacingPages_No)
  {
    if ((window = choices_find_component(CD_NormalHFRadio))   != 0) radiobutton_set_state           (0, window, CD_NormalHFRadio,     1);
    if ((window = choices_find_component(CD_BookHFRadio))     != 0) radiobutton_set_state           (0, window, CD_BookHFRadio,       0);
    if ((window = choices_find_component(CD_SpreadHFRadio))   != 0) radiobutton_set_state           (0, window, CD_SpreadHFRadio,     0);
  }
  else if (new_choices->print_facing_pages == Choices_PrintFacingPages_Page)
  {
    if ((window = choices_find_component(CD_NormalHFRadio))   != 0) radiobutton_set_state           (0, window, CD_NormalHFRadio,     0);
    if ((window = choices_find_component(CD_BookHFRadio))     != 0) radiobutton_set_state           (0, window, CD_BookHFRadio,       1);
    if ((window = choices_find_component(CD_SpreadHFRadio))   != 0) radiobutton_set_state           (0, window, CD_SpreadHFRadio,     0);
  }
  else
  {
    if ((window = choices_find_component(CD_NormalHFRadio))   != 0) radiobutton_set_state           (0, window, CD_NormalHFRadio,     0);
    if ((window = choices_find_component(CD_BookHFRadio))     != 0) radiobutton_set_state           (0, window, CD_BookHFRadio,       0);
    if ((window = choices_find_component(CD_SpreadHFRadio))   != 0) radiobutton_set_state           (0, window, CD_SpreadHFRadio,     1);
  }

  if ((window = choices_find_component(CD_BoldHF))            != 0) optionbutton_set_state          (0, window, CD_BoldHF,            new_choices->print_hf_bold);
  if ((window = choices_find_component(CD_ItalicHF))          != 0) optionbutton_set_state          (0, window, CD_ItalicHF,          new_choices->print_hf_italic);
  if ((window = choices_find_component(CD_SizeHFDisp))        != 0) choices_numberrange_set_value   (0, window, CD_SizeHFDisp,        new_choices->print_hf_scale);

  (void) choices_set_printing_greyed();

  /* JavaScript */

  #ifdef JAVASCRIPT
    if ((window = choices_find_component(CD_SupportJS))       != 0) optionbutton_set_state          (0, window, CD_SupportJS,         new_choices->support_js);
    if ((window = choices_find_component(CD_JSWatchdog))      != 0) optionbutton_set_state          (0, window, CD_JSWatchdog,        new_choices->js_watchdog);
    if ((window = choices_find_component(CD_JSTimeoutDisp))   != 0) choices_numberrange_set_value   (0, window, CD_JSTimeoutDisp,     new_choices->js_timeout);
    if ((window = choices_find_component(CD_JSNavAsNav))      != 0) optionbutton_set_state          (0, window, CD_JSNavAsNav,        new_choices->js_nav_as_nav);
    if ((window = choices_find_component(CD_JSErrorBoxes))    != 0) optionbutton_set_state          (0, window, CD_JSErrorBoxes,      new_choices->js_error_boxes);

    (void) choices_set_win_open_field  (CD_JSWinOpenDisp,  new_choices->js_window_open);
    (void) choices_set_win_close_field (CD_JSWinCloseDisp, new_choices->js_window_close);

    choices_set_js_all_greyed(!new_choices->support_js);
  #endif

  /* Visit history */

  if ((window = choices_find_component(CD_HiExpiryAge))       != 0) choices_set_expiry_age (window);
  if ((window = choices_find_component(CD_HiMaxSize))         != 0) choices_set_max_size   (window);

  (void) choices_set_display_field (CD_HiDispDisp, new_choices->show_urls);
  (void) choices_set_save_field    (CD_HiSaveDisp, new_choices->save_history);

  /* Hotlist */

  if ((window = choices_find_component(CD_HlAutoOpen))        != 0) choices_numberrange_set_value   (0,  window, CD_HlAutoOpen,       new_choices->auto_open_delay);
  if ((window = choices_find_component(CD_HlAutoScroll))      != 0) choices_numberrange_set_value   (0,  window, CD_HlAutoScroll,     new_choices->auto_scroll_delay);

  (void) choices_set_display_field (CD_HlDispDisp, new_choices->hotlist_show);
  (void) choices_set_save_field    (CD_HlSaveDisp, new_choices->save_hotlist);

  /* Tables */

  if ((window = choices_find_component(CD_MSIE4StyleTables))  != 0) optionbutton_set_state          (0, window, CD_MSIE4StyleTables,  new_choices->msie4_style_tables);
  if ((window = choices_find_component(CD_TabSupport))        != 0)
  {
    optionbutton_set_state(0, window, CD_TabSupport, new_choices->support_tables);
    choices_set_tables_greyed(!new_choices->support_tables);
  }

  (void) choices_set_table_border_field(CD_TabInnerBordDisp, new_choices->table_inner);
  (void) choices_set_table_border_field(CD_TabOuterBordDisp, new_choices->table_outer);

  /* Frames */

  if ((window = choices_find_component(CD_DragToScroll))      != 0) optionbutton_set_state          (0, window, CD_DragToScroll,      new_choices->drag_to_scroll);
  if ((window = choices_find_component(CD_NoScrollBars))      != 0) optionbutton_set_state          (0, window, CD_NoScrollBars,      new_choices->no_scroll_bars);
  if ((window = choices_find_component(CD_ShowMayScroll))     != 0) optionbutton_set_state          (0, window, CD_ShowMayScroll,     new_choices->show_may_scroll);
  if ((window = choices_find_component(CD_FramesSupport))     != 0) optionbutton_set_state          (0, window, CD_FramesSupport,     new_choices->support_frames);

  choices_set_frame_related_greyed(window, !new_choices->support_frames);
  if (new_choices->support_frames) set_gadget_state(window, CD_ShowMayScroll, !new_choices->no_scroll_bars);

  /* Plug-ins */

  if ((window = choices_find_component(CD_ObjHandle))         != 0) optionbutton_set_state          (0,  window, CD_ObjHandle,        new_choices->support_object);
  if ((window = choices_find_component(CD_ObjPlugDisp))       != 0)
  {
    set_gadget_state(window, CD_ObjPlugLabl, !new_choices->support_object);
    set_gadget_state(window, CD_ObjPlugBt,   !new_choices->support_object);
    set_gadget_state(window, CD_ObjPlugDisp, !new_choices->support_object);

    (void) choices_set_plugin_field(CD_ObjPlugDisp, new_choices->plugin_control);
  }

  return NULL;
}

/**************************************************************/
/* choices_get_contents()                                     */
/*                                                            */
/* Sets the state of the global choices to reflect the        */
/* contents of all the choices subwindows. Many items are     */
/* maintained as they get changed, but some must be read back */
/* explicitly.                                                */
/**************************************************************/

static _kernel_oserror * choices_get_contents(void)
{
  WimpGetWindowStateBlock   s;
  browser_data            * b;
  fm_typeface             * tfptr;
  ObjectId                  window;

  int                       serif_changed      = 0;
  int                       sans_changed       = 0;
  int                       fixed_changed      = 0;
  int                       tablestyle_changed = 0;
  int                       needs_redraw       = 0;
  int                       colours_changed    = 0;

  int                       old_font_size,          old_system_font;
  int                       old_msie4_style_tables, old_minimum_font_size;
  int                       frac,                   temp;

  /* Get the Home page address */

  RetError(choices_retrieve_text_item(CD_Homepage, &new_choices->home_page));

  /* The lack of error checking is to allow */
  /* items to be missing from the dialogue. */

  if ((window = choices_find_component(CD_HlAutoOpen))        != 0) numberrange_get_value (0, window, CD_HlAutoOpen,        &new_choices->auto_open_delay);
  if ((window = choices_find_component(CD_HlAutoScroll))      != 0) numberrange_get_value (0, window, CD_HlAutoScroll,      &new_choices->auto_scroll_delay);
  if ((window = choices_find_component(CD_RefoTimeDisp))      != 0) numberrange_get_value (0, window, CD_RefoTimeDisp,      &new_choices->refo_time);
  if ((window = choices_find_component(CD_GCUnusedLimitDisp)) != 0) numberrange_get_value (0, window, CD_GCUnusedLimitDisp, &new_choices->unused_image_limit);
  if ((window = choices_find_component(CD_GCFreeLimitDisp))   != 0) numberrange_get_value (0, window, CD_GCFreeLimitDisp,   &new_choices->free_ram_limit);

  #ifdef JAVASCRIPT
    if ((window = choices_find_component(CD_JSTimeoutDisp))   != 0) numberrange_get_value (0, window, CD_JSTimeoutDisp,     (int *) &new_choices->js_timeout);
  #endif

  if (expiry_age_greyed)
  {
    if (history_radio) new_choices->image_expiry_age = 0;
    else               new_choices->expiry_age       = 0;
  }
  else
  {
    if ((window = choices_find_component(CD_HiExpiryAge)) != 0)
    {
      numberrange_get_value(0, window, CD_HiExpiryAge, &temp);

      if (history_radio) new_choices->image_expiry_age = choices_typed_time_to_seconds(temp, history_expiry_units);
      else               new_choices->expiry_age       = choices_typed_time_to_seconds(temp, history_expiry_units);
    }
  }

  if (max_size_greyed)
  {
    if (history_radio) new_choices->image_max_size = 0;
    else               new_choices->max_size       = 0;
  }
  else
  {
    if ((window = choices_find_component(CD_HiMaxSize)) != 0)
    {
      RetError(numberrange_get_value(0, window, CD_HiMaxSize, &temp));

      if (history_radio) new_choices->image_max_size = temp * 1024;
      else               new_choices->max_size       = temp * 1024;
    }
  }

  if (image_expiry_age_greyed)
  {
    new_choices->image_expiry_age = 0;
  }
  else
  {
    if ((window = choices_find_component(CD_HiImExpiryAge)) != 0)
    {
      RetError(numberrange_get_value(0, window, CD_HiImExpiryAge, &temp));
      new_choices->image_expiry_age = choices_typed_time_to_seconds(temp, image_expiry_units);
    }
  }

  if (image_max_size_greyed)
  {
    new_choices->image_max_size = 0;
  }
  else
  {
    if ((window = choices_find_component(CD_HiImMaxSize)) != 0)
    {
      RetError(numberrange_get_value(0, window, CD_HiImMaxSize, &temp));
      new_choices->image_max_size = temp * 1024;
    }
  }

  /* Read the proxy address */

  RetError(choices_retrieve_text_item(CD_NetProxyAddr, &new_choices->proxy_address));

  if ((window = choices_find_component(CD_NetMaxImageFetch)) != 0)
  {
    RetError(numberrange_get_value(0, window, CD_NetMaxImageFetch,  &temp));
    new_choices->max_images = temp;
  }

  /* Grab various printing options */

  RetError(choices_retrieve_text_item(CD_HeaderLeft,   &new_choices->print_header_left));
  RetError(choices_retrieve_text_item(CD_HeaderMiddle, &new_choices->print_header_mid));
  RetError(choices_retrieve_text_item(CD_HeaderRight,  &new_choices->print_header_right));
  RetError(choices_retrieve_text_item(CD_FooterLeft,   &new_choices->print_footer_left));
  RetError(choices_retrieve_text_item(CD_FooterMiddle, &new_choices->print_footer_mid));
  RetError(choices_retrieve_text_item(CD_FooterRight,  &new_choices->print_footer_right));
  RetError(choices_retrieve_text_item(CD_DateFormat,   &new_choices->print_date_format));

  if ((window = choices_find_component(CD_SizeHFDisp)) != 0) numberrange_get_value(0, window, CD_SizeHFDisp, &new_choices->print_hf_scale);

  if (new_choices->print_headers_from != 0)
  {
    if ((window = choices_find_component(CD_HeadersDisp)) != 0)
    {
      ChkError(numberrange_get_value(0,
                                     window,
                                     CD_HeadersDisp,
                                     &new_choices->print_headers_from));
    }
    else new_choices->print_headers_from = 1;
  }

  if (new_choices->print_footers_from != 0)
  {
    if ((window = choices_find_component(CD_FootersDisp)) != 0)
    {
      ChkError(numberrange_get_value(0,
                                     window,
                                     CD_FootersDisp,
                                     &new_choices->print_footers_from));
    }
    else new_choices->print_footers_from = 1;
  }

  /* Remember some of the old values */

  old_font_size          = choices.font_size;
  old_minimum_font_size  = choices.minimum_font_size;
  old_system_font        = choices.system_font;
  old_msie4_style_tables = choices.msie4_style_tables;

  if ((window = choices_find_component(CD_FontsSize)) != 0)
  {
    numberrange_get_value(0, window, CD_FontsSize, &new_choices->font_size);
    frac = new_choices->font_size % 10;
    new_choices->font_size = ((new_choices->font_size / 10)<<4) + fromdecimal[frac];
  }

  if ((window = choices_find_component(CD_FontsAspect)) != 0)
  {
    numberrange_get_value(0, window, CD_FontsAspect, &new_choices->tt_aspect);
    if (choices.tt_aspect != new_choices->tt_aspect) fixed_changed = 1;
  }

  if ((window = choices_find_component(CD_FontsMinSize)) != 0)
  {
    numberrange_get_value(0, window, CD_FontsMinSize, &temp);
    if (temp < 1) temp = 1;
    if (temp > 7) temp = 7;
    new_choices->minimum_font_size = temp;
    if (choices.minimum_font_size != new_choices->minimum_font_size) serif_changed = sans_changed = fixed_changed = 1;
  }

  /* Have the default document colours changed? */

  if (
      choices.background_colour != new_choices->background_colour ||
      choices.text_colour       != new_choices->text_colour       ||
      choices.link_colour       != new_choices->link_colour       ||
      choices.used_colour       != new_choices->used_colour       ||
      choices.followed_colour   != new_choices->followed_colour   ||
      choices.selected_colour   != new_choices->selected_colour
     )
  {
    colours_changed = 1;
  }

  /* Do we need to redraw because certain special items have changed? */
  /* (As opposed to reformat, and/or ditch and reclaim fonts).        */

  if (
       choices.table_inner  != new_choices->table_inner ||
       choices.table_outer  != new_choices->table_outer
     )
     needs_redraw = 1;

  /* Now start using the dialogue's new settings */

  memcpy(&choices, new_choices, sizeof(global_choices));

  /* Before we change fonts, we need to forget the basic */
  /* typeface definitions. First find out which have     */
  /* changed, if any.                                    */

  tfptr = fm_find_typeface("serif");

  if (tfptr)
  {
    if (memcmp(tfptr, &new_typefaces[0], sizeof(fm_typeface))) serif_changed = 1;
  }

  tfptr = fm_find_typeface("sans");

  if (tfptr)
  {
    if (memcmp(tfptr, &new_typefaces[1], sizeof(fm_typeface))) sans_changed = 1;
  }

  tfptr = fm_find_typeface("fixed");

  if (tfptr)
  {
    if (memcmp(tfptr, &new_typefaces[2], sizeof(fm_typeface))) fixed_changed = 1;
  }

  if (choices.system_font) choices.font_size = FM_Standard_Size;

  /* Other ways that font styles can change */

  if (
       choices.font_size         != old_font_size         ||
       choices.minimum_font_size != old_minimum_font_size ||
       choices.system_font       != old_system_font
     )
  {
    serif_changed = 1;
    sans_changed  = 1;
    fixed_changed = 1;
    fm_set_system_font(choices.system_font);
    fm_init_sizes(choices.font_size);
  }

  /* Has the table reformat style changed? */

  if (choices.msie4_style_tables != old_msie4_style_tables) tablestyle_changed = 1;

  /* If fonts have changed, get ready to update them */

  if (serif_changed || sans_changed || fixed_changed)
  {
    /* Dump *all* current fonts */

    fm_shutdown();

    /* Write the new typeface details into the existing structures */

    tfptr = fm_find_typeface("serif");
    if (tfptr) memcpy(tfptr, &new_typefaces[0], sizeof(fm_typeface));

    tfptr = fm_find_typeface("sans");
    if (tfptr) memcpy(tfptr, &new_typefaces[1], sizeof(fm_typeface));

    tfptr = fm_find_typeface("fixed");
    if (tfptr) memcpy(tfptr, &new_typefaces[2], sizeof(fm_typeface));
  }

  /* Tell ImageLib how to handle JPEGs based on the dialogue box settings */

  ImageLib_SetInternalJPEG(choices.support_pjpeg);

  /* Update browsers - *must* call fm_lose_fonts for all */
  /* browsers if the above code called fm_shutdown.      */

  b = last_browser;

  while (b)
  {
    if (
         tablestyle_changed ||
         serif_changed      ||
         sans_changed       ||
         fixed_changed
       )
    {
      /* Get rid of the currently used fonts for this browser */

      fm_lose_fonts(b);

      /* Only reformat page if it has no children */

      if (!b->children) reformat_format_from(b, -1, 1, -1);
    }
    else
    {
      if (b->background_colour == -1)
      {
        b->antialias_colour = redraw_backcol(b);
      }

      /* The Choices are only used directly for browsers which are */
      /* set to override document colours. Otherwise defaults will */
      /* have been read locally and possibly overridden by HTML,   */
      /* and a reload will be needed to reflect the changes.       */
      /*                                                           */
      /* Alternatively, it may be the case that all browsers need  */
      /* redrawing (e.g. if the table border types change).        */

      if (
           needs_redraw ||
           (
             colours_changed &&
             (
               !b->use_source_cols
               ||
               (
                 b->background_colour == -1 &&
                 b->background_image  == -1
               )
             )
           )
         )
      {
        s.window_handle = b->window_handle;
        RetError(wimp_get_window_state(&s));

        coords_box_toworkarea(&s.visible_area, (WimpRedrawWindowBlock *) &s);

        RetError(wimp_force_redraw(b->window_handle,
                                   s.visible_area.xmin,
                                   s.visible_area.ymin,
                                   s.visible_area.xmax,
                                   s.visible_area.ymax));
      }
    }

    b = b->previous;
  }

  if (serif_changed || sans_changed || fixed_changed)
  {
    /* Reclaim basic typefaces - remember to claim at the *new* */
    /* font Choices size.                                       */

    fm_claim_basic_typefaces(choices.font_size);
  }

  return NULL;
}

/**************************************************************/
/* choices_set_button_handler()                               */
/*                                                            */
/* Called when the set button in the main choices dialogue is */
/* clicked. Uses choices_get_contents to set the global       */
/* choices to reflect the choices set in the choices          */
/* subwindows                                                 */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int choices_set_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e = NULL;
  int             buttons;

  ChkError(window_get_pointer_info(0, NULL, NULL, &buttons, NULL, NULL));

  e = choices_get_contents();
  if (e) show_error_ret(e);

  if (buttons != 1)
  {
    ChkError(toolbox_hide_object(0, choices_windowid));
  }

  return 1;
}

/**************************************************************/
/* choices_cancel_button_handler()                            */
/*                                                            */
/* Called when the cancel button in the main choices dialogue */
/* is clicked. Uses choices_set_contents to restore the       */
/* subwindows to their previous state.                        */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int choices_cancel_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  ObjectId        window;
  int             update_fake;
  fm_typeface   * tfptr;
  int             buttons;

  ChkError(window_get_pointer_info(0, NULL, NULL, &buttons, NULL, NULL));

  if (buttons == 1)
  {
    if ((choices.background_colour != new_choices->background_colour) ||
        (choices.text_colour       != new_choices->text_colour)       ||
        (choices.link_colour       != new_choices->link_colour)       ||
        (choices.used_colour       != new_choices->used_colour)       ||
        (choices.followed_colour   != new_choices->followed_colour)   ||
        (choices.selected_colour   != new_choices->selected_colour)   ||
        (choices.underline_links   != new_choices->underline_links))
    {
      update_fake = 1;
    }
    else
    {
      update_fake = 0;
    }

    memcpy(new_choices, &choices, sizeof(global_choices));

    tfptr = fm_find_typeface("serif");
    memcpy(&new_typefaces[0], tfptr, sizeof(fm_typeface));
    tfptr = fm_find_typeface("sans");
    memcpy(&new_typefaces[1], tfptr, sizeof(fm_typeface));
    tfptr = fm_find_typeface("fixed");
    memcpy(&new_typefaces[2], tfptr, sizeof(fm_typeface));

    choices_set_contents();

    /* Attempt to redraw fake page display */

    if (update_fake && (window = choices_find_component(CD_FakePage)) != 0) button_set_flags(0, window, CD_FakePage, 0, 0);
  }
  else
  {
    memcpy(new_choices, &choices, sizeof(global_choices));
    ChkError(toolbox_hide_object(0, choices_windowid));
  }

  return 1;
}

/**************************************************************/
/* choices_save_button_handler()                              */
/*                                                            */
/* Called when the set button in the main choices dialogue is */
/* clicked. Uses choices_get_contents to set the global       */
/* choices to reflect the choices set in the choices          */
/* subwindows and then saves the choices file.                */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int choices_save_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e = NULL;
  ObjectId        window;
  int             buttons;

  ChkError(window_get_pointer_info(0, NULL, NULL, &buttons, NULL, NULL));

  e = choices_get_contents();
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  /* Attempt to redraw fake page display */

  if ((window = choices_find_component(CD_FakePage)) != 0) button_set_flags(0, window, CD_FakePage, 0, 0);

  e = save_save_choices(NULL);
  if (e) show_error_ret(e);

  if (buttons != 1)
  {
    ChkError(toolbox_hide_object(0, choices_windowid));
  }

  return 1;
}

/**************************************************************/
/* choices_redraw_fakepage_handler()                          */
/*                                                            */
/* Redraws the fake page in the colour selection dbox.        */
/**************************************************************/

static int choices_redraw_fakepage_handler(int eventcode, WimpPollBlock * event, IdBlock * idb, void * handle)
{
  _kernel_oserror       * e = NULL;
  WimpRedrawWindowBlock   block;
  WimpGetWindowStateBlock state;
  int                     more, ypos, xtarget, ptsize, gadsize, xstart, nolines;
  int                     fontheight = 0;
  int                     gotfont    = 0;
  BBox                    icon_coords, fbox;
  fm_face                 h = 0;
  char                    display_this[4];

  block.window_handle = event->redraw_window_request.window_handle;
  state.window_handle = event->redraw_window_request.window_handle;

  e = wimp_get_window_state(&state);
  show_error_ret(e);
  if (!e) e = gadget_get_bbox(0, idb->self_id, CD_FakePage, &icon_coords);

  gadsize = icon_coords.ymax - icon_coords.ymin;

  xstart = gadsize / 8;

  if (e)
  {
    /* Gadget doesn't exist or something strange happened trying */
    /* to get window state so just do a simple redraw loop to    */
    /* keep the wimp happy.                                      */

    ChkError(wimp_redraw_window(&block, &more));
    while (more && !e) e = wimp_get_rectangle(&block, &more);
    return 1;
  }

  coords_box_toscreen(&icon_coords, (WimpRedrawWindowBlock *) &state);

  /* Find out which lines to draw */

  for(nolines = 0; nolines < sizeof(display_this); nolines++) display_this[nolines] = 0;

  nolines = 1; /* Start with one line (half at top, half at bottom) */

  if (choices_find_component(CD_LinkColourBt))
  {
    nolines ++;
    display_this[0] = 1;
  }
  if (choices_find_component(CD_UsedColourBt))
  {
    nolines ++;
    display_this[1] = 1;
  }
  if (choices_find_component(CD_FolwColourBt))
  {
    nolines ++;
    display_this[2] = 1;
  }
  if (choices_find_component(CD_SlctColourBt))
  {
    nolines ++;
    display_this[3] = 1;
  }

  /* Start the redraw loop */

  ChkError(wimp_redraw_window(&block, &more));

  while (more && !e)
  {
    /* Clip the redraw area to only take in the gadget */

    if (utils_set_graphics_window(&icon_coords, &block.redraw_area, NULL))
    {
      /* Only claim the font if it is required */

      if (!gotfont)
      {
        /* Find default browser font, the font manager will return system */
        /* font if it is configured.                                      */

        /* Find a 1000 subpoint (big) version of default browser font to scale against */

        h = fm_find_font(NULL, "serif", 1000, 1000, 0, 0);
        e = fm_font_box(h, &fbox);
        fm_lose_font(NULL, h);
        if (e) show_error_cont(e);
        fontheight = fbox.ymax - fbox.ymin;

        /* Find a version of the default browser font with a */
        /* point size which will allow an appropriate number */
        /* of lines in the fake page display.                */

        ptsize = ((gadsize * 1000 / nolines) / fontheight);

        h = fm_find_font(NULL, "serif", ptsize, ptsize, 0, 0);
        ChkError(fm_font_box(h, &fbox));
        fontheight = fbox.ymax - fbox.ymin;
        gotfont = 1;
      }

      /* Fake browser drawing code is here */

      /* Fill background with background colour */

      redraw_set_colour(new_choices->background_colour);
      ChkError(bbc_rectanglefill(icon_coords.xmin, icon_coords.ymin, icon_coords.xmax - icon_coords.xmin, icon_coords.ymax - icon_coords.ymin));

      xtarget = icon_coords.xmin - 32;
      ypos = icon_coords.ymax - fontheight / 3;

      /* Display the top line of the fake page display */

      ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 1));

      ypos -= fontheight;
      xtarget = icon_coords.xmin - 32;

      /* Display the new link line of the fake page display */

      if (display_this[0])
      {
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 2));
        ChkError(choices_draw_string(h, "new", xtarget, ypos, new_choices->underline_links, new_choices->link_colour, new_choices->background_colour, &xtarget));
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 3));

        ypos -= fontheight;
        xtarget = icon_coords.xmin - 32;
      }

      /* Display the new followed line of the fake page display */

      if (display_this[1])
      {
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 4));
        ChkError(choices_draw_string(h, "followed", xtarget, ypos, new_choices->underline_links, new_choices->used_colour, new_choices->background_colour, &xtarget));
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 5));

        ypos -= fontheight;
        xtarget = icon_coords.xmin - 32;
      }

      /* Display the highlighted link line of the fake page display */

      if (display_this[2])
      {
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 6));
        ChkError(choices_draw_string(h, "highlighted", xtarget, ypos, new_choices->underline_links, new_choices->followed_colour, new_choices->background_colour, &xtarget));
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 7));

        ypos -= fontheight;
        xtarget = icon_coords.xmin - 32;
      }

      /* Display the selected link line of the fake page display */

      if (display_this[3])
      {
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 8));
        ChkError(choices_draw_string(h, "selected", xtarget, ypos, new_choices->underline_links, new_choices->selected_colour, new_choices->background_colour, &xtarget));
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 9));

        ypos -= fontheight;
        xtarget = icon_coords.xmin - 32;
      }

      /* Display the bottom line of the fake page display */

      ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 10));
    }

    utils_restore_graphics_window(&block.redraw_area);

    /* Get the next redraw rectangle */

    if (!e) e = wimp_get_rectangle(&block, &more);
  }

  if (gotfont) fm_lose_font(NULL, h);

  return 1;
}

/**************************************************************/
/* choices_write_rubbish()                                    */
/*                                                            */
/* Writes a string of readable rubbish on the screen using    */
/* the passed font handle. It also returns the position to    */
/* paint the next string following this one.                  */
/*                                                            */
/* Parameters: Font handle;                                   */
/*                                                            */
/*             X position on screen (OS coords);              */
/*                                                            */
/*             Y position on screen (OS coords);              */
/*                                                            */
/*             Approximate x position to stop printing at (OS */
/*             coords);                                       */
/*                                                            */
/*             Foreground colour;                             */
/*                                                            */
/*             Background colour;                             */
/*                                                            */
/*             Pointer to int to return x position in;        */
/*                                                            */
/*             Random seed for string to print (if you pass   */
/*             the same seed the string should be the same).  */
/**************************************************************/

static _kernel_oserror * choices_write_rubbish
                         (
                           fm_face   h,
                           int       xpos,
                           int       ypos,
                           int       maxxish,
                           int       forecolour,
                           int       backcolour,
                           int     * newxpos,
                           int       seed
                         )
{
  char ministring[5];
  int chars = 0;
  int spcwidth, width, nochars;

  fm_set_font_colour(h, forecolour, backcolour);

  srand(seed);

  fm_get_string_width(h, " ", 0x1000000, 1, -1, &nochars, &width);
  convert_to_os(width, &spcwidth);
  xpos += spcwidth;

  while(xpos < maxxish)
  {
    ministring[0] = consonant[rand()%(sizeof(consonant)-1)];
    ministring[1] = vowel[rand()%(sizeof(vowel)-1)];

    if (rand()%2)
    {
      ministring[2] = consonant[rand()%(sizeof(consonant)-1)];
      ministring[3] = vowel[rand()%(sizeof(vowel)-1)];
      ministring[4] = 0;
    }
    else
    {
      ministring[2] = 0;
    }

    fm_puts(h, xpos, ypos, ministring, 1, 0);
    fm_get_string_width(h, ministring, 0x1000000, strlen(ministring), -1, &nochars, &width);
    convert_to_os(width, &width);
    xpos += width;

    chars++;
    if (chars > rand()%2 || xpos >= maxxish)
    {
      chars = 0;
      xpos += spcwidth;
    }
  }

  *newxpos = xpos;
  return NULL;
}

/**************************************************************/
/* choices_draw_string()                                      */
/*                                                            */
/* Writes a string on the screen using the passed font        */
/* handle, it underlines the text if required. It also        */
/* returns the position to paint the next string following    */
/* this one.                                                  */
/*                                                            */
/* Parameters: Font handle;                                   */
/*                                                            */
/*             String to print;                               */
/*                                                            */
/*             X position on screen (OS coords);              */
/*                                                            */
/*             Y position on screen (OS coords);              */
/*                                                            */
/*             0 - don't underline, non-0 - underline;        */
/*                                                            */
/*             Foreground colour;                             */
/*                                                            */
/*             Background colour;                             */
/*                                                            */
/*             Pointer to int to return x position in.        */
/**************************************************************/

static _kernel_oserror * choices_draw_string
                         (
                           fm_face   h,
                           char    * string,
                           int       xpos,
                           int       ypos,
                           int       underline,
                           int       forecolour,
                           int       backcolour,
                           int     * newxpos
                         )
{
  int width, nochars;

  fm_set_font_colour(h, forecolour, backcolour);
  fm_get_string_width(h, string, 0x1000000, strlen(string), -1, &nochars, &width);
  convert_to_os(width, &width);

  /* The next string must be plotted straight after this string */

  *newxpos = xpos + width;

  fm_puts(h, xpos, ypos, string, 1, 0);

  if (underline)
  {
    redraw_set_colour(forecolour);
    bbc_move(xpos, ypos - 7);
    bbc_draw(*newxpos, ypos - 7);
  }
  return NULL;
}

/**************************************************************/
/* choices_radio_click_handler()                              */
/*                                                            */
/* Shows the appropriate subwindow when a radio button in the */
/* choices dialogue is clicked on                             */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int choices_radio_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int window, state;

  radiobutton_get_state(0, idb->self_id, idb->self_component, &state, NULL);

  /* Is this a radiobutton selected event? */

  if (state)
  {
    window = idb->self_component - CDFirstSubRadio;
    if (window > CDNoSubwindows) window = CDSubNone;
    choices_show_subwindow(idb->self_id, window);
  }

  return 1;
}

/**************************************************************/
/* choices_history_radio_handler()                            */
/*                                                            */
/* Handles radio button state changes. Swaps between page and */
/* image history settings.                                    */
/**************************************************************/

static int choices_history_radio_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int state, temp;
  ObjectId window;

  radiobutton_get_state(0, idb->self_id, idb->self_component, &state, NULL);

  /* Is this a radiobutton selected event? */

  if (state)
  {
    if (expiry_age_greyed)
    {
      if (history_radio) new_choices->image_expiry_age = 0;
      else               new_choices->expiry_age = 0;
    }
    else
    {
      if ((window = choices_find_component(CD_HiExpiryAge))    != 0)
      {
        numberrange_get_value(0, window, CD_HiExpiryAge,  &temp);
        if (history_radio) new_choices->image_expiry_age = choices_typed_time_to_seconds(temp, history_expiry_units);
        else               new_choices->expiry_age = choices_typed_time_to_seconds(temp, history_expiry_units);
      }
    }

    if (max_size_greyed)
    {
      if (history_radio) new_choices->image_max_size = 0;
      else               new_choices->max_size = 0;
    }
    else
    {
      if ((window = choices_find_component(CD_HiMaxSize))      != 0)
      {
        numberrange_get_value(0, window, CD_HiMaxSize,    &temp);
        if (history_radio) new_choices->image_max_size = temp * 1024;
        else               new_choices->max_size = temp * 1024;
      }
    }

    switch(idb->self_component)
    {
      case CD_HiRadPage:
      history_radio = 0;
      if ((window = choices_find_component(CD_HiExpiryAge))    != 0) choices_set_expiry_age(window);
      if ((window = choices_find_component(CD_HiMaxSize))      != 0) choices_set_max_size(window);
      break;

      case CD_HiRadImage:
      history_radio = 1;
      if ((window = choices_find_component(CD_HiExpiryAge))    != 0) choices_set_expiry_age(window);
      if ((window = choices_find_component(CD_HiMaxSize))      != 0) choices_set_max_size(window);
      break;
    }
  }

  return 1;
}

/**************************************************************/
/* choices_printing_layout_radio_change()                     */
/*                                                            */
/* Handles printing layout radio button selections, updating  */
/* new_choices as required.                                   */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_printing_layout_radio_change
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  switch (idb->self_component)
  {
    case CD_NormalHFBt:      radiobutton_set_state(0, idb->self_id, CD_NormalHFRadio, 1); /* ...and drop through */
    case CD_NormalHFRadio:   new_choices->print_facing_pages = Choices_PrintFacingPages_No;     break;
    case CD_BookHFBt:        radiobutton_set_state(0, idb->self_id, CD_BookHFRadio  , 1); /* ...and drop through */
    case CD_BookHFRadio:     new_choices->print_facing_pages = Choices_PrintFacingPages_Page;   break;
    case CD_SpreadHFBt:      radiobutton_set_state(0, idb->self_id, CD_SpreadHFRadio, 1); /* ...and drop through */
    case CD_SpreadHFRadio:   new_choices->print_facing_pages = Choices_PrintFacingPages_Spread; break;
  }

  return 1;
}

/**************************************************************/
/* choices_printing_h_or_f_radio_change()                     */
/*                                                            */
/* Handles header or footer on/off radio button selections,   */
/* updating new_choices and gadget greyed/ungreyed states as  */
/* required.                                                  */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_printing_h_or_f_radio_change
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  ObjectId window;

  switch (idb->self_component)
  {
    /* If headers are off, set this in Choices. If headers are on,  */
    /* try to read the starting page; if the relevant gadget cannot */
    /* be found, assume we start on page 1.                         */

    case CD_HeadersOff:  new_choices->print_headers_from = 0; break;
    case CD_HeadersFrom:
    {
      if ((window = choices_find_component(CD_HeadersDisp)) != 0)
      {
        ChkError(numberrange_get_value(0,
                                       window,
                                       CD_HeadersDisp,
                                       &new_choices->print_headers_from));
      }
      else new_choices->print_headers_from = 1;
    }
    break;

    /* If footers are off, set this in Choices. If footers are on,  */
    /* try to read the starting page; if the relevant gadget cannot */
    /* be found, assume we start on page 1.                         */

    case CD_FootersOff:  new_choices->print_footers_from = 0; break;
    case CD_FootersFrom:
    {
      if ((window = choices_find_component(CD_FootersDisp)) != 0)
      {
        ChkError(numberrange_get_value(0,
                                       window,
                                       CD_FootersDisp,
                                       &new_choices->print_footers_from));
      }
      else new_choices->print_footers_from = 1;
    }
    break;
  }

  /* Set greyed/ungreyed states according to these new settings */

  ChkError(choices_set_printing_greyed());

  return 1;
}

/**************************************************************/
/* choices_option_state_handler()                             */
/*                                                            */
/* Called when an option button has its state changed by      */
/* being clicked on. Sets or unsets the relevant flag in      */
/* new_choices and causes redraws where necessary.            */
/**************************************************************/

static int choices_option_state_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int               state;
  ObjectId          window;

  ChkError(optionbutton_get_state(0, idb->self_id, idb->self_component, &state));

  switch(idb->self_component)
  {
    case CD_UnderlineLinks:
    {
      new_choices->underline_links = !!state;

      /* Attempt to redraw fake page display */

      if ((window = choices_find_component(CD_FakePage)) != 0) button_set_flags(0, window, CD_FakePage, 0, 0);
      break;
    }

    case CD_UseDocColours:  new_choices->use_source_cols = !!state; break;
    case CD_ShowForeground: new_choices->show_foreground = !!state; break;
    case CD_ShowBackground: new_choices->show_background = !!state; break;

    case CD_URLBar:         new_choices->url_bar         = !!state; break;
    case CD_StatusBar:      new_choices->status_bar      = !!state; break;
    case CD_ButtonBar:      new_choices->button_bar      = !!state; break;
    case CD_FullScreen:     new_choices->full_screen     = !!state; break;

    case CD_ClientPull:     new_choices->client_pull     = !!state; break;
    case CD_NetscapeEmu:    new_choices->clone           = !!state; break;

    case CD_FramesSupport:
    {
      new_choices->support_frames = !!state;
      choices_set_frame_related_greyed(idb->self_id, !state);
      if (new_choices->support_frames) set_gadget_state(idb->self_id, CD_ShowMayScroll, !new_choices->no_scroll_bars);
    }
    break;

    case CD_RefoKeep:       new_choices->refo_keep       = !!state; break;
    case CD_RefoHold:       new_choices->refo_hold       = !!state; break;
    case CD_RefoWait:
    {
      new_choices->refo_wait = !!state;

      if ((window = choices_find_component(CD_RefoTimeLabl)) != 0)
      {
        set_gadget_state(window, CD_RefoTimeLabl,  !state);
        set_gadget_state(window, CD_RefoTimeDisp,  !state);
        set_gadget_state(window, CD_RefoTimeLabl2, !state);
      }
    }
    break;

    case CD_NoScrollBars:
    {
      new_choices->no_scroll_bars = !!state;
      set_gadget_state(idb->self_id, CD_ShowMayScroll, !new_choices->no_scroll_bars);
    }
    break;

    case CD_DragToScroll:   new_choices->drag_to_scroll  = !!state; break;
    case CD_ShowMayScroll:  new_choices->show_may_scroll = !!state; break;

    case CD_FontsSystem:
    {
      new_choices->system_font = !!state;
      if ((window = choices_find_component(CD_FontsTF1Labl)) != 0)
      {
        choices_set_fonts_greyed(new_choices->system_font);
        /*set_gadget_state(window, CD_FontsGroup1,  new_choices->system_font);*/
        if ((window = choices_find_component(CD_FontsSize)) != 0)
        {
          if (new_choices->system_font)
          {
            int frac, temp;
            numberrange_get_value(0, window, CD_FontsSize, &new_choices->font_size);
            frac = new_choices->font_size % 10;
            new_choices->font_size = ((new_choices->font_size / 10)<<4) + fromdecimal[frac];
            temp = FM_Standard_Size;
            frac = (temp & 0xf);
            temp = ((temp >> 4) * 10) + todecimal[frac];
            choices_numberrange_set_value(0, window, CD_FontsSize, temp);
            choices_numberrange_set_value(0, window, CD_FontsAspect, 100);
          }
          else
          {
            int temp, frac;
            temp = new_choices->font_size;
            frac = (temp & 0xf);
            temp = ((temp >> 4) * 10) + todecimal[frac];
            choices_numberrange_set_value(0, window, CD_FontsSize, temp);
            choices_numberrange_set_value(0, window, CD_FontsAspect, new_choices->tt_aspect);
          }
        }
      }
    }
    break;

    case CD_ObjHandle:
    {
      new_choices->support_object = !!state;

      if ((window = choices_find_component(CD_ObjPlugDisp)) != 0)
      {
        set_gadget_state(window, CD_ObjPlugLabl, !new_choices->support_object);
        set_gadget_state(window, CD_ObjPlugBt,   !new_choices->support_object);
        set_gadget_state(window, CD_ObjPlugDisp, !new_choices->support_object);
      }
    }
    break;

    case CD_NetUseProxy:
    {
      new_choices->use_proxy = !!state;
      if ((window = choices_find_component(CD_NetProxyAddr))    != 0)
      {
        set_gadget_state(window, CD_NetProxyAddr, !new_choices->use_proxy);
        set_gadget_state(window, CD_NetProxyLabl, !new_choices->use_proxy);
      }
    }
    break;

    case CD_NetLaunchProxy: new_choices->start_proxy = !!state; break;

    case CD_HiDontAge:
    {
      choices_set_expiry_age_greyed(!state);
      expiry_age_greyed = !state;
    }
    break;

    case CD_HiDontSize:
    {
      choices_set_max_size_greyed(idb->self_id, !state);
      max_size_greyed = !state;
    }
    break;

    case CD_HiImDontAge:
    {
      choices_set_im_expiry_age_greyed(!state);
      image_expiry_age_greyed = !state;
    }
    break;

    case CD_HiImDontSize:
    {
      choices_set_im_max_size_greyed(idb->self_id, !state);
      image_max_size_greyed = !state;
    }
    break;

    case CD_MSIE4StyleTables: new_choices->msie4_style_tables = !!state; break;

    case CD_TabSupport:
    {
      new_choices->support_tables = !!state;
      choices_set_tables_greyed(!state);
    }
    break;

    #ifdef JAVASCRIPT

      case CD_SupportJS:
      {
        new_choices->support_js = !!state;
        choices_set_js_all_greyed(!state);
      }
      break;

      case CD_JSWatchdog:
      {
        new_choices->js_watchdog = !!state;
        choices_set_js_watchdog_greyed(!state);
      }
      break;

      case CD_JSNavAsNav:   new_choices->js_nav_as_nav  = !!state; break;
      case CD_JSErrorBoxes: new_choices->js_error_boxes = !!state; break;

    #endif

    case CD_GCAfterNewFetch: new_choices->collect_after    = !!state; break;
    case CD_PreserveWidth:   new_choices->toggle_on_y_only = !!state; break;
    case CD_StripExtensions: new_choices->strip_extensions = !!state; break;

    case CD_BoldHF:   new_choices->print_hf_bold   = !!state; break;
    case CD_ItalicHF: new_choices->print_hf_italic = !!state; break;

    /* Haven't recognised this option button event so pass it on */

    default: return 0;
  }

  return 1;
}

/**************************************************************/
/* choices_map_choice_to_entry()                              */
/*                                                            */
/* Map a Choices setting to a menu entry component ID using   */
/* the given map array.                                       */
/*                                                            */
/* Parameters: Choices value;                                 */
/*                                                            */
/*             Pointer to a choices_map_t array terminated    */
/*             with an entry with an ID of NULL_ComponentId.  */
/*                                                            */
/* Returns:    Equivalent component ID or the first map entry */
/*             ID as a default if no mapping is found.        */
/**************************************************************/

static ComponentId choices_map_choice_to_entry
                   (
                     int                            choices_value,
                     const choices_map_t * restrict map
                   )
{
  int entry = 0;

  /* Simple linear search through a potentially unsorted array */
  /* - arrays are expected to be very short and the routine is */
  /* not called during speed critical sections.                */

  while (map[entry].id != NULL_ComponentId)
  {
    if (map[entry].value == choices_value) return map[entry].id;
    entry ++;
  }

  return map[0].id;
}

/**************************************************************/
/* choices_map_entry_to_choice()                              */
/*                                                            */
/* Map a menu entry component ID to a Choices setting using   */
/* the given map array.                                       */
/*                                                            */
/* Parameters: Menu entry component ID;                       */
/*                                                            */
/*             Pointer to a choices_map_t array terminated    */
/*             with an entry with an ID of NULL_ComponentId.  */
/*                                                            */
/* Returns:    Equivalent Choices setting value or the first  */
/*             map entry value as a default if no mapping is  */
/*             found.                                         */
/**************************************************************/

static int choices_map_entry_to_choice
           (
             ComponentId                    menu_entry,
             const choices_map_t * restrict map
           )
{
  int entry = 0;

  /* Simple linear search through a potentially unsorted array */
  /* - arrays are expected to be very short and the routine is */
  /* not called during speed critical sections.                */

  while (map[entry].id != NULL_ComponentId)
  {
    if (map[entry].id == menu_entry) return map[entry].value;
    entry ++;
  }

  return map[0].value;
}

/**************************************************************/
/* choices_menu_open_by_popup()                               */
/*                                                            */
/* Open a menu positioned next to a pop-up button. The menu   */
/* will not appear on screen until the next Wimp_Poll, so     */
/* subsequent alterations to its contents beforehand will not */
/* be seen by the user.                                       */
/*                                                            */
/* Parameters: Object ID of object holding pop-up button;     */
/*                                                            */
/*             Component ID of pop-up button;                 */
/*                                                            */
/*             Name of template in Res file for menu to open; */
/*                                                            */
/*             Pointer to an ObjectId, updated on successful  */
/*             exit with the object ID of the opened menu.    */
/**************************************************************/

static _kernel_oserror * choices_menu_open_by_popup
                         (
                           ObjectId               pane,
                           ComponentId            button,
                           const char  * restrict menu_name,
                           ObjectId    *          menu_object
                         )
{
  WimpGetWindowStateBlock state;
  BBox                    box;
  int                     position[2];

  /* Set open coordinates of menu to top left of display button */

  RetError(gadget_get_bbox(0, pane, button, &box));
  RetError(window_get_wimp_handle(0, pane, &state.window_handle));
  RetError(wimp_get_window_state(&state));

  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock *) &state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock *) &state);

  /* (Re-)Create the menu */

  RetError(toolbox_create_object(0, (void *) menu_name, menu_object));

  /* Show the menu */

  return toolbox_show_object(Toolbox_ShowObject_AsMenu,
                             *menu_object,
                             Toolbox_ShowObject_TopLeft,
                             position,
                             pane,
                             button);
}

/**************************************************************/
/* choices_menu_popup_handler()                               */
/*                                                            */
/* Generic handler for activations of pop-up buttons designed */
/* to open menus representing a Choices item, with entries    */
/* that map to values for that item, so that at any given     */
/* time exactly one entry will be ticked in accordance with   */
/* the current value of the associated Choices item.          */
/*                                                            */
/* Parameters: Object ID of object holding pop-up button;     */
/*                                                            */
/*             Component ID of pop-up button;                 */
/*                                                            */
/*             Name of template in Res file for menu to open; */
/*                                                            */
/*             Current value of the associated Choices item;  */
/*                                                            */
/*             Pointer to a component ID, updated on          */
/*             successful exit with the component ID of the   */
/*             menu entry that got ticked based on the given  */
/*             Choices value;                                 */
/*                                                            */
/*             Pointer to a choices_map_t array giving the    */
/*             mappings between menu entries and Choices      */
/*             values terminated by an entry with a component */
/*             ID of NULL_ComponentId.                        */
/**************************************************************/

static _kernel_oserror * choices_menu_popup_handler
                         (
                           ObjectId                       pane,
                           ComponentId                    button,
                           const char          * restrict menu_name,
                           int                            choices_value,
                           ComponentId         * restrict ticked_entry,
                           const choices_map_t * restrict map
                         )
{
  ObjectId                menu;

  RetError(choices_menu_open_by_popup(pane,
                                      button,
                                      menu_name,
                                      &menu));

  /* If an entry was previously ticked, untick it */

  if (*ticked_entry != NULL_ComponentId)
  {
    RetError(menu_set_tick(0, menu, *ticked_entry, 0));
  }

  /* Set the new ticked entry value using the supplied mapping function */

  *ticked_entry = choices_map_choice_to_entry(choices_value, map);
  return menu_set_tick(0, menu, *ticked_entry, 1);
}

/**************************************************************/
/* choices_menu_selection_handler()                           */
/*                                                            */
/* Generic handler for selections in pop-up menus supporting  */
/* single ticked item selections, each entry corresponding to */
/* a value of a particular Choices item.                      */
/*                                                            */
/* Parameters: Object ID of menu;                             */
/*                                                            */
/*             Component ID of selected entry;                */
/*                                                            */
/*             Name of related menu template in Res file;     */
/*                                                            */
/*             Pointer to an int, updated on successful exit  */
/*             with the new Choices item value corresponding  */
/*             to the selected menu entry;                    */
/*                                                            */
/*             Pointer to a component ID, containing on entry */
/*             the component ID of the currently ticked menu  */
/*             entry, updated on successful exit with the     */
/*             component ID of the new ticked menu entry      */
/*                                                            */
/*             Component ID of an associated display field to */
/*             be updated with the text of the selected menu  */
/*             entry, or NULL_ComponentId if there is no such */
/*             display field;                                 */
/*                                                            */
/*             Pointer to a choices_map_t array giving the    */
/*             mappings between menu entries and Choices      */
/*             values terminated by an entry with a component */
/*             ID of NULL_ComponentId.                        */
/**************************************************************/

static _kernel_oserror * choices_menu_selection_handler
                         (
                           ObjectId                       menu_object,
                           ComponentId                    selected_entry,
                           const char          * restrict menu_name,
                           int                 * restrict choices_value,
                           ComponentId         * restrict ticked_entry,
                           ComponentId                    associated_display_field,
                           const choices_map_t * restrict map
                         )
{
  /* Was there a change in ticked entry? */

  if (
       menu_object   != NULL_ObjectId &&
       *ticked_entry != selected_entry
     )
  {
    /* Untick the current ticked item if there is one */

    if (*ticked_entry != NULL_ComponentId)
    {
      RetError(menu_set_tick(0, menu_object, *ticked_entry, 0));
    }

    /* Set the new tick and record the ticked entry */

    RetError(menu_set_tick(0, menu_object, selected_entry, 1));
    *ticked_entry = selected_entry;
  }

  /* Map the selected entry to a choices value even if the    */
  /* ticked entry appears to be the same as the new selection */

  *choices_value = choices_map_entry_to_choice(selected_entry, map);

  /* Is there an associated display field to update? If so do */
  /* it, even if the tick hasn't moved - the redraw will make */
  /* the menu re-selection seem less "dead" to the user.      */

  if (associated_display_field != NULL_ComponentId)
  {
    return choices_update_popup_menu_display_field(associated_display_field,
                                                   selected_entry,
                                                   menu_name);
  }
  else
  {
    return NULL;
  }
}

/**************************************************************/
/* choices_update_popup_menu_display_field()                  */
/*                                                            */
/* Update a display field associated with a pop-up menu using */
/* the text from one of the menu's entries.                   */
/*                                                            */
/* Parameters: Component ID of the display field - if this is */
/*             not found in the Choices panes the function    */
/*             exits with no error;                           */
/*                                                            */
/*             Component ID of the menu entry - if this is a  */
/*             NULL ID the function exits with no error;      */
/*                                                            */
/*             Name of related menu template in Res file.     */
/**************************************************************/

static _kernel_oserror * choices_update_popup_menu_display_field
                         (
                           ComponentId            display_field,
                           ComponentId            menu_entry,
                           const char  * restrict menu_name
                         )
{
  _kernel_oserror * e;
  char            * text;
  ObjectId          container;

  /* If the menu entry is NULL bail out straight away. */

  if (menu_entry == NULL_ComponentId) return NULL;

  /* Find the object holding the given display field, bailing */
  /* out if not located.                                      */

  container = choices_find_component(display_field);
  if (container == NULL_ObjectId) return NULL;

  /* Get the menu text for the given menu name associated with */
  /* the selected menu entry.                                  */

  RetError(choices_get_menu_entry_text(menu_name,
                                       menu_entry,
                                       &text));

  /* Set this in the display field, recording the error but */
  /* not returning it until the text buffer is freed.       */

  e = choices_displayfield_set_value(0,
                                     container,
                                     display_field,
                                     text);

  free(text);

  return e;
}

/**************************************************************/
/* choices_display_popup_handler()                            */
/*                                                            */
/* Opens the display menu with a value appropriate to either  */
/* the hotlist or history.                                    */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_display_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int             value = 0;
  choices_map_t * map   = NULL;

  /* This menu is used for both hotlist and history display */

  switch(idb->self_component)
  {
    default:
    case CD_HlDispBt: value = new_choices->hotlist_show; map = map_hldisplay; break;
    case CD_HiDispBt: value = new_choices->show_urls;    map = map_hidisplay; break;
  }

  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChDisplay",
                                            value,
                                            &disp_ticked,
                                            map));
  return 1;
}

/**************************************************************/
/* choices_save_popup_handler()                               */
/*                                                            */
/* Opens the save menu with a value appropriate to either the */
/* hotlist or visit/image history.                            */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_save_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int             value = 0;
  choices_map_t * map   = NULL;

  /* This menu is used for both hotlist and history display */

  switch(idb->self_component)
  {
    default:
    case CD_HlSaveBt:   value = new_choices->save_hotlist;       map = map_hlsave;   break;
    case CD_HiSaveBt:   value = new_choices->save_history;       map = map_hisave;   break;
    case CD_HiImSaveBt: value = new_choices->save_image_history; map = map_hiimsave; break;
  }

  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChSave",
                                            value,
                                            &save_ticked,
                                            map));
  return 1;
}

/**************************************************************/
/* choices_pagebreak_popup_handler()                          */
/*                                                            */
/* Handles page break menu pop-up button activations.         */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_pagebreak_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChPBreakAt",
                                            new_choices->print_page_break_hx,
                                            &pbrk_ticked,
                                            map_pagebreak));
  return 1;
}

/**************************************************************/
/* choices_uri_popup_handler()                                */
/*                                                            */
/* Handles URI handler menu pop-up button activations.        */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_uri_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChURI",
                                            new_choices->uri_usage,
                                            &urih_ticked,
                                            map_uri));
  return 1;
}

/**************************************************************/
/* choices_cookie_popup_handler()                             */
/*                                                            */
/* Handles cookie menu pop-up button activations.             */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_cookie_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChCookies",
                                            new_choices->cookies,
                                            &cook_ticked,
                                            map_cookie));
  return 1;
}

/**************************************************************/
/* choices_referer_popup_handler()                            */
/*                                                            */
/* Handles referer menu pop-up button activations.            */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_referer_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChReferer",
                                            new_choices->send_referer,
                                            &refe_ticked,
                                            map_referer));
  return 1;
}

/**************************************************************/
/* choices_jpeg_popup_handler()                               */
/*                                                            */
/* Handles JPEG menu pop-up button activations.               */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_jpeg_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChJPEG",
                                            new_choices->support_pjpeg,
                                            &jpeg_ticked,
                                            map_jpeg));
  return 1;
}

/**************************************************************/
/* choices_table_border_popup_handler()                       */
/*                                                            */
/* Opens the table border menu with a value appropriate to    */
/* either the inner or outer borders.                         */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_table_border_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int             value = 0;
  choices_map_t * map   = NULL;

  /* This menu is used for both hotlist and history display */

  switch(idb->self_component)
  {
    default:
    case CD_TabInnerBordBt: value = new_choices->table_inner; map = map_table_inner; break;
    case CD_TabOuterBordBt: value = new_choices->table_outer; map = map_table_outer; break;
  }

  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChTabBord",
                                            value,
                                            &bord_ticked,
                                            map));
  return 1;
}

/**************************************************************/
/* choices_plugin_popup_handler()                             */
/*                                                            */
/* Handles plug-in launch menu pop-up button activations.     */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_plugin_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChPlugin",
                                            new_choices->plugin_control,
                                            &plug_ticked,
                                            map_plugin));
  return 1;
}

/**************************************************************/
/* choices_timetype_popup_handler()                           */
/*                                                            */
/* Displays the time units menu when the appropriate          */
/* toolaction button is pressed.                              */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_timetype_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  choices_time_e value;

  /* This menu is used for both image and visit histories */

  switch(idb->self_component)
  {
    default:
    case CD_HiAgeTypeBt:   value = history_expiry_units; break;
    case CD_HiImAgeTypeBt: value = image_expiry_units;   break;
  }

  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChTime",
                                            (int) value,
                                            &time_ticked,
                                            map_timetype));
  return 1;
}

#ifdef JAVASCRIPT

  /**************************************************************/
  /* choices_win_open_popup_handler()                           */
  /*                                                            */
  /* Handles JS 'window.open' menu pop-up button activations.   */
  /*                                                            */
  /* Parameters: As standard for a Toolbox event handler.       */
  /**************************************************************/

  static int choices_win_open_popup_handler
             (
               const int                     eventcode,
               const ToolboxEvent * restrict event,
               const IdBlock      * restrict idb,
               const void         * restrict handle
             )
  {
    show_error_ret(choices_menu_popup_handler(idb->self_id,
                                              idb->self_component,
                                              "ChWinOpen",
                                              new_choices->js_window_open,
                                              &wino_ticked,
                                              map_win_open));
    return 1;
  }

  /**************************************************************/
  /* choices_win_close_popup_handler()                          */
  /*                                                            */
  /* Handles JS 'window.close' menu pop-up button activations.  */
  /*                                                            */
  /* Parameters: As standard for a Toolbox event handler.       */
  /**************************************************************/

  static int choices_win_close_popup_handler
             (
               const int                     eventcode,
               const ToolboxEvent * restrict event,
               const IdBlock      * restrict idb,
               const void         * restrict handle
             )
  {
    show_error_ret(choices_menu_popup_handler(idb->self_id,
                                              idb->self_component,
                                              "ChWinClose",
                                              new_choices->js_window_close,
                                              &winc_ticked,
                                              map_win_close));
    return 1;
  }

#endif

/**************************************************************/
/* choices_font_button_handler()                              */
/*                                                            */
/* Opens a font menu box with appropriate settings for the    */
/* current font.                                              */
/**************************************************************/

static int choices_font_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  WimpGetWindowStateBlock   state;
  BBox                      box;
  int                       position[2];
  ObjectId                  fontmenu_id;
  char                    * fontname = NULL;

  /* Ensure we know why we're being opened */

  switch(idb->self_component)
  {
    case CD_FontsTF1Bt: break;
    case CD_FontsTF2Bt: break;
    case CD_FontsTF3Bt: break;

    default: return 1;
  }

  /* Set open coordinates of menu to top left of display idb->self_component */

  ChkError(gadget_get_bbox(0, idb->self_id, idb->self_component, &box));
  ChkError(window_get_wimp_handle(0, idb->self_id, &state.window_handle));
  ChkError(wimp_get_window_state(&state));

  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock *) &state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock *) &state);

  /* Create the menu */

  ChkError(toolbox_create_object(0, "FontMenu", &fontmenu_id));

  /* Set the selected (ticked) font. Irritatingly this has to be done */
  /* before the menu is opened or fontmenu_set_font appears to do     */
  /* nothing - presumably a Toolbox bug - so we can't use the generic */
  /* "open menu at popup" routine.                                    */

  switch(idb->self_component)
  {
    case CD_FontsTF1Bt: fontname = new_typefaces[0].fontnames[0]; break;
    case CD_FontsTF2Bt: fontname = new_typefaces[1].fontnames[0]; break;
    case CD_FontsTF3Bt: fontname = new_typefaces[2].fontnames[0]; break;
  }

  ChkError(fontmenu_set_font(0, fontmenu_id, fontname));

  /* Show the menu */

  ChkError(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                               fontmenu_id,
                               Toolbox_ShowObject_TopLeft,
                               position,
                               idb->self_id,
                               idb->self_component));

  /* Register event handlers and return */

  ChkError(event_register_toolbox_handler(fontmenu_id, FontMenu_HasBeenHidden, choices_font_closed_handler,   NULL));
  ChkError(event_register_toolbox_handler(fontmenu_id, FontMenu_Selection,     choices_font_selected_handler, NULL));

  return 1;
}

/**************************************************************/
/* choices_encoding_button_handler()                          */
/*                                                            */
/* Opens the encoding window with appropriate values for the  */
/* choices dialogue.                                          */
/**************************************************************/

static int choices_encoding_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e;
  int  position[2];
  BBox box;
  WimpGetWindowStateBlock state;

  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = wimp_get_window_state(&state);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  /* Set open coordinates of encoding menu to top left of encoding button */

  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);

  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     encoding_get_menuid(),
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     choices_windowid,
                                     NULL));

  return 1;
}

/**************************************************************/
/* choices_colour_button_handler()                            */
/*                                                            */
/* Opens a colour dialogue box with appropriate settings for  */
/* the current colour.                                        */
/**************************************************************/

static int choices_colour_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e;
  int  position[2];
  BBox box;
  WimpGetWindowStateBlock state;
  int colour[2];

  /* Is the ColourDbox module in RMA? */

  e = _swix(OS_Module, _INR(0,1), 18, "ColourDbox");

  /* No, well try and load it from system */

  if (e)
  {
    e = _swix(OS_Module, _INR(0,1), 1, "System:Modules.Toolbox.ColourDbox");
  }

  /* That didn't work so try reinitialising it */

  if (e)
  {
    e = _swix(OS_Module, _INR(0,1), 3, "ColourDbox");
  }

  /* That didn't work either!  So it's tough you can't change the colours */

  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  switch(idb->self_component)
  {
    case CD_BackColourBt: colour[0] = new_choices->background_colour; break;
    case CD_TextColourBt: colour[0] = new_choices->text_colour;       break;
    case CD_LinkColourBt: colour[0] = new_choices->link_colour;       break;
    case CD_UsedColourBt: colour[0] = new_choices->used_colour;       break;
    case CD_FolwColourBt: colour[0] = new_choices->followed_colour;   break;
    case CD_SlctColourBt: colour[0] = new_choices->selected_colour;   break;
    default:
    return 1;
    break;
  }

  colour[1] = 0;

  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = wimp_get_window_state(&state);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  /* Set open coordinates of encoding menu to top left of encoding button */

  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);

  e = toolbox_create_object(0, "ColourDbox", &colourdbox_id);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = colourdbox_set_colour(0, colourdbox_id, colour);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     colourdbox_id,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));

  e = event_register_toolbox_handler(colourdbox_id, ColourDbox_DialogueCompleted, choices_colour_closed_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  e = event_register_toolbox_handler(colourdbox_id, ColourDbox_ColourSelected, choices_colour_selected_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  return 1;
}

/**************************************************************/
/* choices_display_selection_handler()                        */
/*                                                            */
/* Called when there is a selection in the display menu. Sets */
/* the selected menu item to be ticked, unticks the           */
/* previously ticked entry sets appropriate new_choices field */
/* and updates the associated display field.                  */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_display_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int             new_value     = 0;
  ComponentId     display_field = NULL_ComponentId;
  choices_map_t * map           = NULL;

  /* This menu is used for both hotlist and history display */

  switch (idb->parent_component)
  {
    case CD_HlDispBt: display_field = CD_HlDispDisp; map = map_hldisplay; break;
    case CD_HiDispBt: display_field = CD_HiDispDisp; map = map_hidisplay; break;
  }

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChDisplay",
                                                &new_value,
                                                &disp_ticked,
                                                display_field,
                                                map));

  switch(idb->parent_component)
  {
    case CD_HlDispBt: new_choices->hotlist_show = new_value; break;
    case CD_HiDispBt: new_choices->show_urls    = new_value; break;
  }

  return 1;
}

/**************************************************************/
/* choices_save_selection_handler()                           */
/*                                                            */
/* Called when there is a selection in the save menu. Sets    */
/* the selected menu item to be ticked, unticks the           */
/* previously ticked entry sets appropriate new_choices field */
/* and updates the associated display field.                  */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_save_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int             new_value     = 0;
  ComponentId     display_field = NULL_ComponentId;
  choices_map_t * map           = NULL;

  /* This menu is used for both hotlist and history display */

  switch (idb->parent_component)
  {
    case CD_HlSaveBt:   display_field = CD_HlSaveDisp;   map = map_hlsave;   break;
    case CD_HiSaveBt:   display_field = CD_HiSaveDisp;   map = map_hisave;   break;
    case CD_HiImSaveBt: display_field = CD_HiImSaveDisp; map = map_hiimsave; break;
  }

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChSave",
                                                &new_value,
                                                &save_ticked,
                                                display_field,
                                                map));

  switch(idb->parent_component)
  {
    case CD_HlSaveBt:   new_choices->save_hotlist       = new_value; break;
    case CD_HiSaveBt:   new_choices->save_history       = new_value; break;
    case CD_HiImSaveBt: new_choices->save_image_history = new_value; break;
  }

  return 1;
}

/**************************************************************/
/* choices_pagebreak_selection_handler()                      */
/*                                                            */
/* Handle page break menu selections.                         */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_pagebreak_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int new_value;

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChPBreakAt",
                                                &new_value,
                                                &pbrk_ticked,
                                                CD_PageBreakDisp,
                                                map_pagebreak));

  new_choices->print_page_break_hx = new_value;
  return 1;
}

/**************************************************************/
/* choices_uri_selection_handler()                            */
/*                                                            */
/* Handle URI handler menu selections.                        */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_uri_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int new_value;

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChURI",
                                                &new_value,
                                                &urih_ticked,
                                                CD_URIHandlerDisp,
                                                map_uri));
  new_choices->uri_usage = new_value;
  return 1;
}

/**************************************************************/
/* choices_cookie_selection_handler()                         */
/*                                                            */
/* Handle cookie menu selections.                             */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_cookie_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int new_value;

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChCookies",
                                                &new_value,
                                                &cook_ticked,
                                                CD_CookieDisp,
                                                map_cookie));
  new_choices->cookies = new_value;
  return 1;
}

/**************************************************************/
/* choices_referer_selection_handler()                        */
/*                                                            */
/* Handle referer menu selections.                            */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_referer_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int new_value;

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChReferer",
                                                &new_value,
                                                &refe_ticked,
                                                CD_RefererDisp,
                                                map_referer));
  new_choices->send_referer = new_value;
  return 1;
}

/**************************************************************/
/* choices_jpeg_selection_handler()                           */
/*                                                            */
/* Handle JPEG menu selections.                               */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_jpeg_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int new_value;

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChJPEG",
                                                &new_value,
                                                &jpeg_ticked,
                                                CD_JPEGDisp,
                                                map_jpeg));
  new_choices->support_pjpeg = new_value;
  return 1;
}

/**************************************************************/
/* choices_table_border_selection_handler()                   */
/*                                                            */
/* Called when there is a selection in the table border menu. */
/* Sets the selected menu item to be ticked, unticks the      */
/* previously ticked entry sets appropriate new_choices field */
/* and updates the associated display field.                  */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_table_border_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int             new_value     = 0;
  ComponentId     display_field = NULL_ComponentId;
  choices_map_t * map           = NULL;

  /* This menu is used for both inner and outer border styles */

  switch (idb->parent_component)
  {
    case CD_TabInnerBordBt: display_field = CD_TabInnerBordDisp; map = map_table_inner; break;
    case CD_TabOuterBordBt: display_field = CD_TabOuterBordDisp; map = map_table_outer; break;
  }

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChTabBord",
                                                &new_value,
                                                &bord_ticked,
                                                display_field,
                                                map));

  switch(idb->parent_component)
  {
    case CD_TabInnerBordBt: new_choices->table_inner = new_value; break;
    case CD_TabOuterBordBt: new_choices->table_outer = new_value; break;
  }

  return 1;
}

/**************************************************************/
/* choices_plugin_selection_handler()                         */
/*                                                            */
/* Handle plug-in launch menu selections.                     */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_plugin_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int new_value;

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChPlugin",
                                                &new_value,
                                                &plug_ticked,
                                                CD_ObjPlugDisp,
                                                map_plugin));
  new_choices->plugin_control = new_value;
  return 1;
}

/**************************************************************/
/* choices_timetype_selection_handler()                       */
/*                                                            */
/* Called when there is a selection in the time units menu.   */
/* Sets the selected menu item to be ticked, unticks the      */
/* previously ticked entry sets appropriate new_choices field */
/* and updates the associated display and numerical fields.   */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_timetype_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  choices_time_e old_units, new_units;
  ComponentId    numbers, display;
  ObjectId       window;

  /* This menu is used for both image and visit histories */

  switch (idb->parent_component)
  {
    default:

    case CD_HiAgeTypeBt:   numbers = CD_HiExpiryAge;   display = CD_HiAgeTypeDisp;   break;
    case CD_HiImAgeTypeBt: numbers = CD_HiImExpiryAge; display = CD_HiImAgeTypeDisp; break;
  }

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChTime",
                                                (int *) &new_units,
                                                &time_ticked,
                                                display,
                                                map_timetype));

  /* This menu is used for both image and visit histories */

  switch (idb->parent_component)
  {
    default:

    case CD_HiAgeTypeBt:   old_units = history_expiry_units; history_expiry_units = new_units; break;
    case CD_HiImAgeTypeBt: old_units = image_expiry_units;   image_expiry_units   = new_units; break;
  }

  /* Sort out the number range gadget */

  window = choices_find_component(numbers);

  if (window != NULL_ObjectId)
  {
    int temptime;

    /* What was the existing time converted to seconds using the old units? */

    show_error_ret(numberrange_get_value(0, window, numbers, &temptime));

    temptime = choices_typed_time_to_seconds(temptime, old_units);

    /* Set this time in the new units, then bound the number range to make */
    /* sure the figure is pulled into range.                               */

    show_error_ret(numberrange_set_value(0,
                                         window,
                                         numbers,
                                         choices_seconds_to_typed_time(temptime,
                                                                       new_units)));

    show_error_ret(numberrange_set_bounds(NumberRange_LowerBound |
                                          NumberRange_UpperBound |
                                          NumberRange_StepSize   |
                                          NumberRange_Precision,

                                          window,
                                          numbers,
                      /* Lower bound */   1,
                      /* Upper bound */   choices_get_range_of_typed_time(new_units),
                      /* Step size   */   1,
                      /* Precision   */   0));
  }

  return 1;
}

/**************************************************************/
/* choices_hfspecial_selection_handler()                      */
/*                                                            */
/* Handle header/footer special text menu selections.         */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_hfspecial_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int         index = choices_map_entry_to_choice(idb->self_component, map_hfspecial);
  ObjectId    window;
  ComponentId writable;

  /* Find the writable field related to the parent pop-up button */

  switch (idb->parent_component)
  {
    default:

    case CD_HeaderLeftBt:   writable = CD_HeaderLeft;   break;
    case CD_HeaderMiddleBt: writable = CD_HeaderMiddle; break;
    case CD_HeaderRightBt:  writable = CD_HeaderRight;  break;
    case CD_FooterLeftBt:   writable = CD_FooterLeft;   break;
    case CD_FooterMiddleBt: writable = CD_FooterMiddle; break;
    case CD_FooterRightBt:  writable = CD_FooterRight;  break;
  }

  /* Insert text based on the selection */

  window = choices_find_component(writable);

  if (
       window != NULL_ObjectId &&
       index  >= 0             &&
       index  <  sizeof(special_text) / sizeof(*special_text)
     )
  {
    show_error_ret(choices_writablefield_add_text(0,
                                                  window,
                                                  writable,
                                                  special_text[index]));
  }

  return 1;
}

/**************************************************************/
/* choices_hfspecsub_selection_handler()                      */
/*                                                            */
/* Handle header/footer special text sub-menu selections.     */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_hfspecsub_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  ObjectId    window,   original_object;
  ComponentId writable, original_component;

  int         index    = choices_map_entry_to_choice(idb->parent_component, map_hfspecial);
  int         subindex = choices_map_entry_to_choice(idb->self_component,   map_hfspecsub);

  /* Find the writable field related to the original pop-up button - */
  /* this is our parent's parent (*not* the ancestor).               */

  ChkError(toolbox_get_parent(0,
                              idb->parent_id,
                              &original_object,
                              &original_component));

  switch (original_component)
  {
    default:

    case CD_HeaderLeftBt:   writable = CD_HeaderLeft;   break;
    case CD_HeaderMiddleBt: writable = CD_HeaderMiddle; break;
    case CD_HeaderRightBt:  writable = CD_HeaderRight;  break;
    case CD_FooterLeftBt:   writable = CD_FooterLeft;   break;
    case CD_FooterMiddleBt: writable = CD_FooterMiddle; break;
    case CD_FooterRightBt:  writable = CD_FooterRight;  break;
  }

  /* Insert text based on the selection */

  window  = choices_find_component(writable);
  index  += subindex;

  if (
       window != NULL_ObjectId &&
       index  >= 0             &&
       index  <  sizeof(special_text) / sizeof(*special_text)
     )
  {
    show_error_ret(choices_writablefield_add_text(0,
                                                  window,
                                                  writable,
                                                  special_text[index]));
  }

  return 1;
}

/**************************************************************/
/* choices_hfdate_selection_handler()                         */
/*                                                            */
/* Handle header/footer special text menu selections.         */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_hfdate_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int      index = choices_map_entry_to_choice(idb->self_component, map_hfdate);
  ObjectId window;

  /* Insert text based on the selection */

  window = choices_find_component(CD_DateFormat);

  if (
       window != NULL_ObjectId &&
       index  >= 0             &&
       index  <  sizeof(special_date) / sizeof(*special_date)
     )
  {
    show_error_ret(choices_writablefield_add_text(0,
                                                  window,
                                                  CD_DateFormat,
                                                  special_date[index]));
  }

  return 1;
}

#ifdef JAVASCRIPT

  /**************************************************************/
  /* choices_win_open_selection_handler()                       */
  /*                                                            */
  /* Handle JS 'window.open' menu selections.                   */
  /*                                                            */
  /* Parameters: As standard for a Toolbox event handler.       */
  /**************************************************************/

  static int choices_win_open_selection_handler
             (
               const int                     eventcode,
               const ToolboxEvent * restrict event,
               const IdBlock      * restrict idb,
               const void         * restrict handle
             )
  {
    int new_value;

    show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                  idb->self_component,
                                                  "ChWinOpen",
                                                  &new_value,
                                                  &wino_ticked,
                                                  CD_JSWinOpenDisp,
                                                  map_win_open));
    new_choices->js_window_open = new_value;
    return 1;
  }

  /**************************************************************/
  /* choices_win_close_selection_handler()                      */
  /*                                                            */
  /* Handle JS 'window.close' menu selections.                  */
  /*                                                            */
  /* Parameters: As standard for a Toolbox event handler.       */
  /**************************************************************/

  static int choices_win_close_selection_handler
             (
               const int                     eventcode,
               const ToolboxEvent * restrict event,
               const IdBlock      * restrict idb,
               const void         * restrict handle
             )
  {
    int new_value;

    show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                  idb->self_component,
                                                  "ChWinClose",
                                                  &new_value,
                                                  &winc_ticked,
                                                  CD_JSWinCloseDisp,
                                                  map_win_close));
    new_choices->js_window_close = new_value;
    return 1;
  }

#endif

/**************************************************************/
/* choices_font_selected_handler()                            */
/*                                                            */
/* Called when the a font is selected in the font menu.       */
/**************************************************************/

static int choices_font_selected_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  char font[4] [Limits_FontName], *p, *p2;
  int found;
  fm_typeface * target;

  dprintf(("Choi", "choices_font_selected_handler: called\n"
                   "choices_font_selected_handler: Selected font = %s\n",

                   ((FontMenuSelectionEvent *) event)->font_id));

  p2 = font[0];

  /* Assume that the F field will be found because the font menu */
  /* returns the font in the correct format.                     */

  ChkError(_swix(Font_FindField, _INR(1,2)|_OUTR(1,2), ((FontMenuSelectionEvent*)event)->font_id, 'F', &p, &found));

  /* Extract the font name */

  while (*p > 32 && *p != '\\') *p2++ = *p++;
  *p2 = '\0';

  choices_modified_font(font[0], getenv("Font$Italic"), font[1]); /* Get italic variant of base font */
  choices_modified_font(font[0], getenv("Font$Bold"),   font[2]); /* Get bold version of base font   */
  choices_modified_font(font[2], getenv("Font$Italic"), font[3]); /* Get italic version of bold font */

  dprintf(("Choi", "Base font           = %s\n"
                   "Italic version      = %s\n"
                   "Bold version        = %s\n"
                   "Bold-Italic version = %s\n",

                   font[0],
                   font[1],
                   font[2],
                   font[3]));

  /* Set display field to name of new font */
  /* Ignore error as the display isn't     */
  /* required.                             */

  choices_displayfield_set_value(0, idb->parent_id, idb->parent_component - 1, font[0]);

  switch(idb->parent_component)
  {
    case CD_FontsTF1Bt: target = &new_typefaces[0]; break;
    case CD_FontsTF2Bt: target = &new_typefaces[1]; break;
    case CD_FontsTF3Bt: target = &new_typefaces[2]; break;

    default:
    return 1;
    break;
  }

  strcpy(target->fontnames[0], font[0]);
  strcpy(target->fontnames[1], font[1]);
  strcpy(target->fontnames[2], font[2]);
  strcpy(target->fontnames[3], font[3]);

  return 1;
}

/**************************************************************/
/* choices_colour_selected_handler()                          */
/*                                                            */
/* Called when the a colour is selected in the colour         */
/* dialogue box. Sets appropriate fields in the new_choices   */
/* structure and updates the window to reflect the new colour */
/* chosen.                                                    */
/**************************************************************/

static int choices_colour_selected_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  ColourDboxColourSelectedEvent *cevent = (ColourDboxColourSelectedEvent*)event;

  switch(idb->parent_component)
  {
    case CD_BackColourBt: new_choices->background_colour = cevent->colour_block[0]; break;
    case CD_TextColourBt: new_choices->text_colour       = cevent->colour_block[0]; break;
    case CD_LinkColourBt: new_choices->link_colour       = cevent->colour_block[0]; break;
    case CD_UsedColourBt: new_choices->used_colour       = cevent->colour_block[0]; break;
    case CD_FolwColourBt: new_choices->followed_colour   = cevent->colour_block[0]; break;
    case CD_SlctColourBt: new_choices->selected_colour   = cevent->colour_block[0]; break;
    default:
    return 1;
    break;
  }

  /* Don't bother with errors as colour display field might not exist */

  choices_colour_set_component(idb->parent_id, idb->parent_component-1, cevent->colour_block[0]);

  /* Don't bother with errors as fake page display might not exist */

  button_set_flags(0, idb->parent_id, CD_FakePage, 0, 0);

  return 1;
}

/**************************************************************/
/* choices_font_closed_handler()                              */
/*                                                            */
/* Called when the font menu is closed deregisters all events */
/* attached to it and deletes the menu object.                */
/**************************************************************/

static int choices_font_closed_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e;

  e = event_register_toolbox_handler(idb->self_id, FontMenu_HasBeenHidden, choices_font_closed_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  e = event_register_toolbox_handler(idb->self_id, FontMenu_Selection, choices_font_selected_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  e = toolbox_delete_object(0, idb->self_id);
  if (e) {show_error_ret(e); return 1;}

  dprintf(("Choi", "choices_font_closed_handler: FontMenu deleted\n"));

  return 1;
}

/**************************************************************/
/* choices_colour_closed_handler()                            */
/*                                                            */
/* Called when the colour dialogue box is closed deregisters  */
/* all events attached to it and deletes the dbox object.     */
/**************************************************************/

static int choices_colour_closed_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e;

  e = event_deregister_toolbox_handler(idb->self_id, ColourDbox_DialogueCompleted, choices_colour_closed_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  e = event_deregister_toolbox_handler(colourdbox_id, ColourDbox_ColourSelected, choices_colour_selected_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  e = toolbox_delete_object(0, idb->self_id);
  if (e) {show_error_ret(e); return 1;}

  dprintf(("Choi", "choices_colour_closed_handler: Colour DBox deleted\n"));

  return 1;
}

/**************************************************************/
/* choices_set_encoding_field()                               */
/*                                                            */
/* Sets the encoding display field appropriately to reflect   */
/* the current state of new_choices->encoding                 */
/**************************************************************/

_kernel_oserror * choices_set_encoding_field(void)
{
  _kernel_oserror * e;
  ObjectId          objid, destwind;
  ComponentId       compid;
  char            * textptr;
  int               sizereqd;

  /* Find which window the encoding display is in */

  destwind = choices_find_component(CD_EncodingDisply);
  if (!destwind) return NULL;

  /* Find menu item which contains encoding name */

  if (encoding_get_encoding_item(new_choices->encoding, &objid, &compid))
  {
    RetError(menu_get_entry_text(0, objid, compid, NULL, 0, &sizereqd));

    /* Add 1 to the buffer size just incase the sizereqd field is returned as string */
    /* length rather than the buffer size required.  Typical paranoid precautions    */
    /* when using the toolbox.                                                       */

    textptr = malloc(sizereqd+1);

    if (textptr)
    {
      e = menu_get_entry_text(0, objid, compid, textptr, sizereqd+1, NULL);
      if (e)
      {
        free(textptr);
        return e;
      }

      e = choices_displayfield_set_value(0, destwind, CD_EncodingDisply, textptr);

      free(textptr);
      return e;
    }
    else
    {
      RetError(make_no_memory_error(18));
    }
  }
  else
  {
    /* The encoding name could not be found in the menu structure */

    RetError(choices_displayfield_set_value(0,
                                            destwind,
                                            CD_EncodingDisply,
                                            lookup_token("NoEncoding:Unknown encoding", 0, 0)));
  }

  return NULL;
}

/**************************************************************/
/* choices_set_display_field()                                */
/*                                                            */
/* Sets the passed display menu display field appropriately   */
/* to reflect the passed state.                               */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_display_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  ComponentId menu_entry = NULL_ComponentId;

  dprintf(("Choi", "choices_set_display_field: Called\n"));

  /* This menu is used for both hotlist and history display */

  switch (display_field)
  {
    case CD_HlDispDisp: menu_entry = choices_map_choice_to_entry(choices_value, map_hldisplay); break;
    case CD_HiDispDisp: menu_entry = choices_map_choice_to_entry(choices_value, map_hidisplay); break;
  }

  /* Safe even if menu_entry still holds a NULL ID */

  return choices_update_popup_menu_display_field(display_field,
                                                 menu_entry,
                                                 "ChDisplay");
}

/**************************************************************/
/* choices_set_save_field()                                   */
/*                                                            */
/* Sets the passed save display field appropriately to        */
/* reflect the passed state.                                  */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_save_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  ComponentId menu_entry = NULL_ComponentId;

  dprintf(("Choi", "choices_set_save_field: Called\n"));

  /* This menu is used in several different places */

  switch (display_field)
  {
    case CD_HlSaveDisp:   menu_entry = choices_map_choice_to_entry(choices_value, map_hlsave);   break;
    case CD_HiSaveDisp:   menu_entry = choices_map_choice_to_entry(choices_value, map_hisave);   break;
    case CD_HiImSaveDisp: menu_entry = choices_map_choice_to_entry(choices_value, map_hiimsave); break;
  }

  /* Safe even if menu_entry still holds a NULL ID */

  return choices_update_popup_menu_display_field(display_field,
                                                 menu_entry,
                                                 "ChSave");
}

/**************************************************************/
/* choices_set_pagebreak_field()                              */
/*                                                            */
/* Sets the passed page break display field appropriately to  */
/* reflect the passed state.                                  */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_pagebreak_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_pagebreak_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_pagebreak),
                                                 "ChPBreakAt");
}

/**************************************************************/
/* choices_set_uri_field()                                    */
/*                                                            */
/* Sets the passed URI handler display field appropriately to */
/* reflect the passed state.                                  */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_uri_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_uri_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_uri),
                                                 "ChURI");
}

/**************************************************************/
/* choices_set_cookie_field()                                 */
/*                                                            */
/* Sets the passed cookie display field appropriately to      */
/* reflect the passed state.                                  */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_cookie_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_cookie_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_cookie),
                                                 "ChCookies");
}

/**************************************************************/
/* choices_set_referer_field()                                */
/*                                                            */
/* Sets the passed referer display field appropriately to     */
/* reflect the passed state.                                  */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_referer_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_referer_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_referer),
                                                 "ChReferer");
}

/**************************************************************/
/* choices_set_jpeg_field()                                   */
/*                                                            */
/* Sets the passed JPEG display field appropriately to        */
/* reflect the passed state.                                  */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_jpeg_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_jpeg_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_jpeg),
                                                 "ChJPEG");
}

/**************************************************************/
/* choices_set_table_border_field()                           */
/*                                                            */
/* Sets the passed table border display field appropriately   */
/* to reflect the passed state.                               */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_table_border_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  ComponentId menu_entry = NULL_ComponentId;

  dprintf(("Choi", "choices_set_table_border_field: Called\n"));

  /* This menu is used for both hotlist and history display */

  switch (display_field)
  {
    case CD_TabInnerBordDisp: menu_entry = choices_map_choice_to_entry(choices_value, map_table_inner); break;
    case CD_TabOuterBordDisp: menu_entry = choices_map_choice_to_entry(choices_value, map_table_outer); break;
  }

  /* Safe even if menu_entry still holds a NULL ID */

  return choices_update_popup_menu_display_field(display_field,
                                                 menu_entry,
                                                 "ChTabBord");
}

/**************************************************************/
/* choices_set_plugin_field()                                 */
/*                                                            */
/* Sets the passed plug-in launch display field appropriately */
/* to reflect the passed state.                               */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_plugin_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_plugin_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_plugin),
                                                 "ChPlugin");
}

/**************************************************************/
/* choices_set_timetype_field()                               */
/*                                                            */
/* Sets the time field appropriately to reflect the passed    */
/* state.                                                     */
/*                                                            */
/* Parameters: timetype - see defined values in choices.h     */
/**************************************************************/

static _kernel_oserror * choices_set_timetype_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_timetype_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_timetype),
                                                 "ChTime");
}

#ifdef JAVASCRIPT

  /**************************************************************/
  /* choices_set_win_open_field()                               */
  /*                                                            */
  /* Sets the passed window.open display field appropriately to */
  /* reflect the passed state.                                  */
  /*                                                            */
  /* Parameters: Component ID of the display field;             */
  /*                                                            */
  /*             State (a Choices item value).                  */
  /**************************************************************/

  static _kernel_oserror * choices_set_win_open_field
                           (
                             ComponentId display_field,
                             int         choices_value
                           )
  {
    dprintf(("Choi", "choices_set_win_open_field: Called\n"));

    return choices_update_popup_menu_display_field(display_field,
                                                   choices_map_choice_to_entry(choices_value,
                                                                               map_win_open),
                                                   "ChWinOpen");
  }

  /**************************************************************/
  /* choices_set_win_close_field()                              */
  /*                                                            */
  /* Sets the passed window.close display field appropriately   */
  /* to reflect the passed state.                               */
  /*                                                            */
  /* Parameters: Component ID of the display field;             */
  /*                                                            */
  /*             State (a Choices item value).                  */
  /**************************************************************/

  static _kernel_oserror * choices_set_win_close_field
                           (
                             ComponentId display_field,
                             int         choices_value
                           )
  {
    dprintf(("Choi", "choices_set_win_close_field: Called\n"));

    return choices_update_popup_menu_display_field(display_field,
                                                   choices_map_choice_to_entry(choices_value,
                                                                               map_win_close),
                                                   "ChWinClose");
  }

#endif

/**************************************************************/
/* choices_return_appropriate_timetype()                      */
/*                                                            */
/* Given a time in seconds returns the most appropriate set   */
/* of units to display that time in.                          */
/*                                                            */
/* Parameters: Time in seconds.                               */
/*                                                            */
/* Returns:    The type of the appropriate units.             */
/**************************************************************/

static choices_time_e choices_return_appropriate_timetype(int seconds)
{
  if (seconds <= 60*60)        return choices_time_MINUTES;
  if (seconds <= 60*60*24)     return choices_time_HOURS;
  if (seconds <= 60*60*24*7)   return choices_time_DAYS;
  if (seconds <= 60*60*24*7*4) return choices_time_WEEKS;

  return choices_time_MONTHS;
}

/**************************************************************/
/* choices_seconds_to_typed_time()                            */
/*                                                            */
/* Converts a time in seconds to a time in the passed units.  */
/*                                                            */
/* Parameters: Time in seconds;                               */
/*                                                            */
/*             The units in which to return the time.         */
/*                                                            */
/* Returns:    The time in the passed units.                  */
/**************************************************************/

static int choices_seconds_to_typed_time(int secs, choices_time_e timetype)
{
  switch (timetype)
  {
    case choices_time_MINUTES: return choices_clip_to_min_max(secs/(60),           1, 60);
    case choices_time_HOURS:   return choices_clip_to_min_max(secs/(60*60),        1, 24);
    case choices_time_DAYS:    return choices_clip_to_min_max(secs/(60*60*24),     1, 7);
    case choices_time_WEEKS:   return choices_clip_to_min_max(secs/(60*60*24*7),   1, 4);
    case choices_time_MONTHS:  return choices_clip_to_min_max(secs/(60*60*24*7*4), 1, 12);
    default:                   return 1;
  }
}

/**************************************************************/
/* choices_typed_time_to_seconds()                            */
/*                                                            */
/* Converts a time in the passed units to seconds.            */
/*                                                            */
/* Parameters: Time in passed units;                          */
/*                                                            */
/*             Units which the time was passed.               */
/*                                                            */
/* Returns:    Time in seconds.                               */
/**************************************************************/

static int choices_typed_time_to_seconds(int time, choices_time_e timetype)
{
  switch (timetype)
  {
    case choices_time_MINUTES: return time * 60;
    case choices_time_HOURS:   return time * 60*60;
    case choices_time_DAYS:    return time * 60*60*24;
    case choices_time_WEEKS:   return time * 60*60*24*7;
    case choices_time_MONTHS:  return time * 60*60*24*7*4;
    default:                   return 0;
  }
}

/**************************************************************/
/* choices_get_range_of_typed_time()                          */
/*                                                            */
/* Returns the max acceptable value of the passed time units  */
/* type.                                                      */
/*                                                            */
/* Parameters: The type of time units.                        */
/*                                                            */
/* Returns:    The maximum acceptable value.                  */
/**************************************************************/

static int choices_get_range_of_typed_time(choices_time_e timetype)
{
  switch (timetype)
  {
    case choices_time_MINUTES: return 60;
    case choices_time_HOURS:   return 24;
    case choices_time_DAYS:    return 7;
    case choices_time_WEEKS:   return 4;
    case choices_time_MONTHS:  return 12;
    default:                   return 0;
  }
}

/**************************************************************/
/* choices_batch_gadget_state()                               */
/*                                                            */
/* Set a batch of gadgets grey or ungrey in a way that will   */
/* minimise flicker.                                          */
/*                                                            */
/* Parameters: Pointer to an array of component IDs for all   */
/*             gadgets to be modified, terminated by an entry */
/*             of NULL_ComponentId;                           */
/*                                                            */
/*             1 to grey the gadgets, 0 to ungrey them.       */
/**************************************************************/

static _kernel_oserror * choices_batch_gadget_state
                         (
                           const ComponentId * restrict array,
                           int                          state
                         )
{
  int         entry = 0;
  ComponentId window;

  while (array[entry] != NULL_ComponentId)
  {
    window = choices_find_component(array[entry]);

    if (window != NULL_ObjectId)
    {
      RetError(set_gadget_state(window, array[entry], state));
    }

    entry++;
  }

  return NULL;
}

/**************************************************************/
/* choices_set_tables_greyed()                                */
/*                                                            */
/* Sets the table border gadgets to greyed or ungreyed.       */
/*                                                            */
/* Parameters: 0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_tables_greyed(int state)
{
  ComponentId array[] = {
                          CD_TabInnerBordLabl, CD_TabInnerBordDisp, CD_TabInnerBordBt,
                          CD_TabOuterBordLabl, CD_TabOuterBordDisp, CD_TabOuterBordBt,
                          CD_MSIE4StyleTables,
                          NULL_ComponentId
                        };

  (void) choices_batch_gadget_state(array, state);
}

/**************************************************************/
/* choices_set_printing_greyed()                              */
/*                                                            */
/* Update the greyed/ungreyed state of printing items in the  */
/* Choices dialogue box panes according to the new_choices    */
/* contents. Set the layout sprites to indicate header and    */
/* footer activation condition.                               */
/**************************************************************/

static _kernel_oserror * choices_set_printing_greyed(void)
{
  int           state;
  ComponentId   window;
  const char  * spr1 = NULL;
  const char  * spr2 = NULL;
  const char  * spr3 = NULL;

  /* Sort out the header/footer layout indicator sprites. It looks */
  /* better if this is done before the grey/ungrey operations as a */
  /* sprite ungreying, then changing, is more obvious than a one   */
  /* which changes whilst still greyed out.                        */

  if (new_choices->print_headers_from != 0 && new_choices->print_footers_from != 0)
  {
    /* Headers and footers both on */

    spr1 = "phf_normal";
    spr2 = "phf_book";
    spr3 = "phf_spread";
  }
  else if (new_choices->print_headers_from == 0 && new_choices->print_footers_from != 0)
  {
    /* Headers off */

    spr1 = "phf_normal_f";
    spr2 = "phf_book_f";
    spr3 = "phf_spread_f";
  }
  else if (new_choices->print_footers_from == 0 && new_choices->print_headers_from != 0)
  {
    /* Footers off */

    spr1 = "phf_normal_h";
    spr2 = "phf_book_h";
    spr3 = "phf_spread_h";
  }

  /* Update the sprites? */

  if (spr1 != NULL)
  {
    if ((window = choices_find_component(CD_NormalHFBt)) != NULL_ObjectId)
    {
      RetError(_swix(Toolbox_ObjectMiscOp,
                     _INR(0,4),

                     toolaction_SET_IDENT_OFF,
                     window,
                     ToolAction_SetIdent,
                     CD_NormalHFBt,
                     spr1));
    }

    if ((window = choices_find_component(CD_BookHFBt)) != NULL_ObjectId)
    {
      RetError(_swix(Toolbox_ObjectMiscOp,
                     _INR(0,4),

                     toolaction_SET_IDENT_OFF,
                     window,
                     ToolAction_SetIdent,
                     CD_BookHFBt,
                     spr2));
    }

    if ((window = choices_find_component(CD_SpreadHFBt)) != NULL_ObjectId)
    {
      RetError(_swix(Toolbox_ObjectMiscOp,
                     _INR(0,4),

                     toolaction_SET_IDENT_OFF,
                     window,
                     ToolAction_SetIdent,
                     CD_SpreadHFBt,
                     spr3));
    }
  }

  /* Grey/ungrey items immediately related to headers on/off */

  if (new_choices->print_headers_from == 0) state = 1;
  else                                      state = 0;

  /* C99 mid-block declaration */

  ComponentId array1[] = {
                           CD_HeadersDisp,
                           CD_HeaderLabl,
                           CD_HeaderLeft,   CD_HeaderLeftBt,
                           CD_HeaderMiddle, CD_HeaderMiddleBt,
                           CD_HeaderRight,  CD_HeaderRightBt,
                           NULL_ComponentId
                         };

  RetError(choices_batch_gadget_state(array1, state));

  /* Grey/ungrey items immediately related to footers on/off */

  if (new_choices->print_footers_from == 0) state = 1;
  else                                      state = 0;

  /* C99 mid-block declaration */

  ComponentId array2[] = {
                           CD_FootersDisp,
                           CD_FooterLabl,
                           CD_FooterLeft,   CD_FooterLeftBt,
                           CD_FooterMiddle, CD_FooterMiddleBt,
                           CD_FooterRight,  CD_FooterRightBt,
                           NULL_ComponentId
                         };

  RetError(choices_batch_gadget_state(array2, state));

  /* Grey/ungrey items only affected if both headers and footers are on/off */

  if (new_choices->print_headers_from == 0 && new_choices->print_footers_from == 0) state = 1;
  else                                                                              state = 0;

  /* C99 mid-block declaration */

  ComponentId array3[] = {
                           CD_HFLeftLabl,     CD_HFMiddleLabl,  CD_HFRightLabl,
                           CD_DateFormatLabl, CD_DateFormat,    CD_DateFormatBt,
                           CD_NormalHFLabl,   CD_NormalHFRadio, CD_NormalHFBt,
                           CD_BookHFLabl,     CD_BookHFRadio,   CD_BookHFBt,
                           CD_SpreadHFLabl,   CD_SpreadHFRadio, CD_SpreadHFBt,
                           CD_BoldHF,         CD_ItalicHF,
                           CD_SizeHFLabl,     CD_SizeHFDisp,    CD_PercentageHFLabl,
                           NULL_ComponentId
                         };

  RetError(choices_batch_gadget_state(array3, state));

  /* Finished */

  return NULL;
}

/**************************************************************/
/* choices_set_frame_related_greyed()                         */
/*                                                            */
/* Sets frame related gadgets, except "Support Frames", to    */
/* greyed or ungreyed.                                        */
/*                                                            */
/* CD_ShowMayScroll is greyed with everything else, but only  */
/* ungreyed if new_choices->no_scroll_bars is set, so make    */
/* sure this is set appropriately before calling to ungrey    */
/* stuff.                                                     */
/*                                                            */
/* Parameters: Object ID of the window which contains the     */
/*             icons;                                         */
/*                                                            */
/*             0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_frame_related_greyed(ObjectId window, int state)
{
  set_gadget_state(window, CD_NoScrollBars,  !!state);
  set_gadget_state(window, CD_ShowMayScroll, state ? 1 : !new_choices->no_scroll_bars);
}

/**************************************************************/
/* choices_set_fonts_greyed()                                 */
/*                                                            */
/* Sets the font name and font size gadgets to                */
/* greyed/ungreyed.                                           */
/*                                                            */
/* Parameters: 0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_fonts_greyed(int state)
{
  ComponentId array[] = {
                          CD_FontsTF1Labl, CD_FontsTF1Disp,     CD_FontsTF1Bt,
                          CD_FontsTF2Labl, CD_FontsTF2Disp,     CD_FontsTF2Bt,
                          CD_FontsTF3Labl, CD_FontsTF3Disp,     CD_FontsTF3Bt,
                          CD_FontsSize,    CD_FontsSzLabl1,     CD_FontsSzLabl2,
                          CD_FontsAspect,  CD_FontsAspectLabl1, CD_FontsAspectLabl2,
                          NULL_ComponentId
                        };

  (void) choices_batch_gadget_state(array, state);
}

/**************************************************************/
/* choices_set_expiry_age()                                   */
/*                                                            */
/* Sets up the expiry age fields and greys/ungreys them as    */
/* appropriate.                                               */
/*                                                            */
/* Parameters: ObjectId of the window containing the gadgets. */
/**************************************************************/

static void choices_set_expiry_age(ObjectId window)
{
  int            temp;
  int            rangetop;
  choices_time_e time_scale;
  int            age;

  age = history_radio ? new_choices->image_expiry_age : new_choices->expiry_age;

  if (age == 0)
  {
    time_scale = choices_time_DAYS;
    temp       = 1;
    rangetop   = 7;
  }
  else
  {
    time_scale = choices_return_appropriate_timetype(age);
    temp       = choices_seconds_to_typed_time(age, time_scale);
    rangetop   = choices_get_range_of_typed_time(time_scale);
  }

  expiry_age_greyed = !age;
  choices_set_expiry_age_greyed(!age);
  optionbutton_set_state(0, window, CD_HiDontAge, !!age);

  choices_numberrange_set_value(0, window, CD_HiExpiryAge, temp);
  choices_set_timetype_field(CD_HiAgeTypeDisp, time_scale);

  history_expiry_units = time_scale;

  numberrange_set_bounds(15, window, CD_HiExpiryAge, 1, rangetop, 1, 0);
}

/**************************************************************/
/* choices_set_expiry_age_greyed()                            */
/*                                                            */
/* Sets the expiry age gadgets to greyed/ ungreyed.           */
/*                                                            */
/* Parameters: 0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_expiry_age_greyed(int state)
{
  ComponentId array[] = {
                          CD_HiExpiryAgeLabl,
                          CD_HiExpiryAge,
                          CD_HiAgeTypeDisp,
                          CD_HiAgeTypeBt,
                          NULL_ComponentId
                        };

  (void) choices_batch_gadget_state(array, state);
}

/**************************************************************/
/* choices_set_im_expiry_age()                                */
/*                                                            */
/* Sets up the image expiry age fields and greys/ungreys      */
/* them as appropriate.                                       */
/*                                                            */
/* Parameters: ObjectId of the window containing the gadgets. */
/**************************************************************/

static void choices_set_im_expiry_age(ObjectId window)
{
  int            temp;
  int            rangetop;
  choices_time_e time_scale;

  if (new_choices->image_expiry_age == 0)
  {
    time_scale = choices_time_DAYS;
    temp       = 1;
    rangetop   = 7;
  }
  else
  {
    time_scale = choices_return_appropriate_timetype(new_choices->image_expiry_age);
    temp       = choices_seconds_to_typed_time(new_choices->image_expiry_age, time_scale);
    rangetop   = choices_get_range_of_typed_time(time_scale);
  }

  image_expiry_age_greyed = !new_choices->image_expiry_age;
  choices_set_im_expiry_age_greyed(!new_choices->image_expiry_age);
  optionbutton_set_state(0, window, CD_HiImDontAge, !!new_choices->image_expiry_age);

  choices_numberrange_set_value(0, window, CD_HiImExpiryAge, temp);
  choices_set_timetype_field(CD_HiImAgeTypeDisp, time_scale);

  image_expiry_units = time_scale;

  numberrange_set_bounds(15, window, CD_HiImExpiryAge, 1, rangetop, 1, 0);
}

/**************************************************************/
/* choices_set_im_expiry_age_greyed()                         */
/*                                                            */
/* Sets the image expiry age gadgets to greyed/ ungreyed.     */
/*                                                            */
/* Parameters: 0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_im_expiry_age_greyed(int state)
{
  ComponentId array[] = {
                          CD_HiImExpiryAgeLabl,
                          CD_HiImExpiryAge,
                          CD_HiImAgeTypeDisp,
                          CD_HiImAgeTypeBt,
                          NULL_ComponentId
                        };

  (void) choices_batch_gadget_state(array, state);
}

/**************************************************************/
/* choices_set_max_size()                                     */
/*                                                            */
/* Sets up the max size field and greys or ungreys it as      */
/* appropriate.                                               */
/*                                                            */
/* Parameters: The ObjectId of the window which contains the  */
/*             gadgets.                                       */
/**************************************************************/

static void choices_set_max_size(ObjectId window)
{
  int size;

  size = history_radio ? new_choices->image_max_size : new_choices->max_size;

  optionbutton_set_state(0, window, CD_HiDontSize, !!size);
  max_size_greyed = !size;
  choices_set_max_size_greyed(window, max_size_greyed);

  choices_numberrange_set_value(0,
                                window,
                                CD_HiMaxSize,
                                !size ? 32 : size/1024);
}

/**************************************************************/
/* choices_set_max_size_greyed()                              */
/*                                                            */
/* Sets the max size gadgets to greyed/ungreyed.              */
/*                                                            */
/* Parameters: ObjectId of the window which contains the      */
/*             icons.                                         */
/*                                                            */
/*             0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_max_size_greyed(ObjectId window, int state)
{
  set_gadget_state(window, CD_HiMaxSizeLabl1, !!state);
  set_gadget_state(window, CD_HiMaxSizeLabl2, !!state);
  set_gadget_state(window, CD_HiMaxSize,      !!state);
}

/**************************************************************/
/* choices_set_im_max_size()                                  */
/*                                                            */
/* Sets up the image max size field and greys or ungreys it   */
/* as appropriate.                                            */
/*                                                            */
/* Parameters: The ObjectId of the window which contains the  */
/*             gadgets.                                       */
/**************************************************************/

static void choices_set_im_max_size(ObjectId window)
{
  optionbutton_set_state(0, window, CD_HiImDontSize, !!new_choices->image_max_size);
  image_max_size_greyed = !new_choices->image_max_size;
  choices_set_im_max_size_greyed(window, image_max_size_greyed);

  choices_numberrange_set_value(0,
                                window,
                                CD_HiImMaxSize,
                                !new_choices->image_max_size ? 32 : new_choices->image_max_size/1024);
}

/**************************************************************/
/* choices_set_im_max_size_greyed()                           */
/*                                                            */
/* Sets the image max size gadgets to greyed/ ungreyed.       */
/*                                                            */
/* Parameters: ObjectId of the window which contains the      */
/*             icons.                                         */
/*                                                            */
/*             0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_im_max_size_greyed(ObjectId window, int state)
{
  set_gadget_state(window, CD_HiImMaxSizeLabl1, !!state);
  set_gadget_state(window, CD_HiImMaxSizeLabl2, !!state);
  set_gadget_state(window, CD_HiImMaxSize,      !!state);
}

#ifdef JAVASCRIPT

  /**************************************************************/
  /* choices_set_js_watchdog_greyed()                           */
  /*                                                            */
  /* Sets the JS watchdog timeout gadgets to greyed or          */
  /* ungreyed.                                                  */
  /*                                                            */
  /* Parameters: 0 to ungrey, any other value to to grey.       */
  /**************************************************************/

  static void choices_set_js_watchdog_greyed(int state)
  {
    ComponentId array[] = {
                            CD_JSTimeoutLabl,
                            CD_JSTimeoutDisp,
                            CD_JSTimeoutLabl2,

                            NULL_ComponentId
                          };

    (void) choices_batch_gadget_state(array, state);
  }

  /**************************************************************/
  /* choices_set_js_all_greyed()                                */
  /*                                                            */
  /* Sets all JS related gadgets, except "Support JavaScript",  */
  /* to greyed or ungreyed. Watchdog related stuff is set       */
  /* according to the value of new_choices->js_watchdog, so     */
  /* make sure this is valid before calling the function. This  */
  /* is handled as follows; if you ask for items to be greyed,  */
  /* the watchdog stuff will always be greyed too; if you ask   */
  /* for items to be ungreyed, the watchdog stuff will be only  */
  /* if new_choices->js_watchdog is set.                        */
  /*                                                            */
  /* Parameters: 0 to ungrey, any other value to to grey        */
  /*             (except for watchdog items, see details        */
  /*             above).                                        */
  /**************************************************************/

  static void choices_set_js_all_greyed(int state)
  {
    ComponentId array[] = {
                            CD_JSWatchdog,
                            CD_JSNavAsNav,
                            CD_JSErrorBoxes,

                            CD_JSOpenCloseLabl,

                            CD_JSWinOpenLabl,
                            CD_JSWinOpenDisp,
                            CD_JSWinOpenBt,

                            CD_JSWinCloseLabl,
                            CD_JSWinCloseDisp,
                            CD_JSWinCloseBt,

                            NULL_ComponentId
                          };

    (void) choices_batch_gadget_state(array, state);
    choices_set_js_watchdog_greyed(state ? 1 : !new_choices->js_watchdog);
  }

#endif

/**************************************************************/
/* choices_find_component()                                   */
/*                                                            */
/* Scans all the choices subwindows for the requested         */
/* component and returns the id of the first window in which  */
/* it was seen.                                               */
/*                                                            */
/* Parameters: The component to find.                         */
/*                                                            */
/* Returns:    Where to return the object id to. 0 if the     */
/*             component was not found                        */
/**************************************************************/

static ObjectId choices_find_component(ComponentId component)
{
  int          findwindow;
  unsigned int flags;

  #ifndef TRACE

    /* Uses lazy evaluation to not call gadget_get_flags unless */
    /* subwindows[findwindow] contains an objectid.             */

    for (findwindow = 0; findwindow < CDNoSubwindows; findwindow++)
    {
      if (
           subwindows[findwindow] &&
           !gadget_get_flags(0,
                             subwindows[findwindow],
                             component,
                             &flags)
         )
         return subwindows[findwindow];
    }

  #else

    /* TRACE builds will check for multiple same component IDs,   */
    /* and complain. Would have saved at least one time consuming */
    /* error in Phoenix if I'd thought to do this a week earlier! */

    {
      ObjectId found = NULL_ObjectId;
      int      pane  = 0;

      for (findwindow = 0; findwindow < CDNoSubwindows; findwindow++)
      {
        if (
             subwindows[findwindow] &&
             !gadget_get_flags(0,
                               subwindows[findwindow],
                               component,
                               &flags)
           )
        {
          if (found == NULL_ObjectId)
          {
            found = subwindows[findwindow];
            pane  = findwindow;
          }
          else
          {
            erb.errnum = Utils_Error_Custom_Normal;

            sprintf(erb.errmess,
                    "Duplicate component ID 0x%x in Choices dialogue box panes %d and %d.",
                    component,
                    pane,
                    findwindow);

            show_error_ret(&erb);

            found = subwindows[findwindow];
          }

        /* Closure of 'if' with code above running if the gadget is found */
        }

      /* Closure of 'for' loop */
      }

      if (found != NULL_ObjectId) return found;
    }

  #endif

  return 0;
}

/**************************************************************/
/* choices_displayfield_set_value()                           */
/*                                                            */
/* Does as displayfield_set_value but will only update it if  */
/* the text is different to that currently in the display     */
/* field.                                                     */
/*                                                            */
/* Parameters: Same as displayfield_set_value.                */
/**************************************************************/

static _kernel_oserror * choices_displayfield_set_value
                         (
                           const unsigned int   flags,
                           const ObjectId       window,
                           const ComponentId    writable,
                           const char         * restrict text
                         )
{
  int               reqdsize;
  char            * oldtext;
  _kernel_oserror * e = NULL;

  RetError(displayfield_get_value(0, window, writable, NULL, 0, &reqdsize));

  oldtext = malloc(reqdsize+1);
  if (!oldtext) return make_no_memory_error(20);

  displayfield_get_value(0, window, writable, oldtext, reqdsize, NULL);

  if (strcmp(text, oldtext))
  {
    e = displayfield_set_value(flags, window, writable, (char *) text);
  }

  free(oldtext);

  return e;
}

/**************************************************************/
/* choices_writablefield_set_value()                          */
/*                                                            */
/* Does as writablefield_set_value but will only update it if */
/* the text is different to that currently in the display     */
/* field.                                                     */
/*                                                            */
/* Parameters: Same as writablefield_set_value.               */
/**************************************************************/

static _kernel_oserror * choices_writablefield_set_value
                         (
                           const unsigned int   flags,
                           const ObjectId       window,
                           const ComponentId    writable,
                           const char         * restrict text
                         )
{
  int               reqdsize;
  char            * oldtext;
  _kernel_oserror * e = NULL;

  RetError(writablefield_get_value(0, window, writable, NULL, 0, &reqdsize));

  oldtext = malloc(reqdsize+1);
  if (!oldtext) return make_no_memory_error(20);

  writablefield_get_value(0, window, writable, oldtext, reqdsize, NULL);

  if (strcmp(text, oldtext))
  {
    e = writablefield_set_value(flags, window, writable, (char *) text);
  }

  free(oldtext);

  return e;
}

/**************************************************************/
/* choices_writablefield_add_text()                           */
/*                                                            */
/* Adds the specified text either at the caret position if    */
/* the caret is in the given writable field, or at the end of */
/* the field if the caret position is elsewhere or cannot be  */
/* determined.                                                */
/*                                                            */
/* Parameters: Flags to pass to writablefield_set_value;      */
/*                                                            */
/*             Object ID to pass to writablefield_set_value;  */
/*                                                            */
/*             Component ID to pass to                        */
/*             writablefield_set_value;                       */
/*                                                            */
/*             Pointer to NUL-terminated piece of text to     */
/*             insert into or append to existing gadget text. */
/**************************************************************/

static _kernel_oserror * choices_writablefield_add_text
                         (
                           const unsigned int   flags,
                           const ObjectId       window,
                           const ComponentId    writable,
                           const char         * restrict text
                         )
{
  WimpGetCaretPositionBlock            caret;
  int                                  window_handle;
  int                                  icon_handle;
  int                                  reqdsize;
  char                      * restrict oldtext;
  size_t                               newlen, oldlen;
  _kernel_oserror           *          e = NULL;

  newlen = strlen(text);

  /* A writable field should consist of just the one icon */

  RetError(gadget_get_icon_list(0,
                                window,
                                writable,
                                &icon_handle,
                                sizeof(icon_handle),
                                NULL));

  /* Read the current caret position and window's Wimp handle */

  RetError(wimp_get_caret_position(&caret));
  RetError(window_get_wimp_handle(0, window, &window_handle));

  /* Allocate room for the existing text plus new text plus NUL */

  RetError(writablefield_get_value(0, window, writable, NULL, 0, &reqdsize));

  oldtext = malloc(reqdsize + newlen + 1);
  if (oldtext == NULL) return make_no_memory_error(20);

  /* Read the current value */

  e = writablefield_get_value(0, window, writable, oldtext, reqdsize, NULL);

  if (e != NULL)
  {
    free(oldtext);
    return e;
  }

  oldlen = strlen(oldtext);

  /* Do we insert or append the text? */

  if (
       caret.window_handle == window_handle &&
       caret.icon_handle   == icon_handle   &&
       caret.index         >= 0             &&
       caret.index         <  oldlen
     )
  {
    /* Insert the new text */

    memmove(oldtext + caret.index + newlen,
            oldtext + caret.index,
            oldlen  - caret.index + 1); /* + 1 moves NUL too */

    memcpy (oldtext + caret.index,
            text,
            newlen);

    e = writablefield_set_value(0, window, writable, oldtext);

    if (e == NULL)
    {
      /* Move the caret to just after the new text */

      (void) wimp_set_caret_position(caret.window_handle,
                                     caret.icon_handle,
                                     caret.xoffset,
                                     caret.yoffset,
                                     caret.height,
                                     caret.index + newlen);
    }
  }
  else
  {
    /* Append the new text */

    strcat(oldtext, text);

    e = writablefield_set_value(0, window, writable, oldtext);

    /* If that worked, put the caret at the end of this writable   */
    /* field's new text. Otherwise, appended data can get scrolled */
    /* out of view depending upon the field's alignment settings.  */

    if (e == NULL)
    {
      (void) wimp_set_caret_position(window_handle,
                                     icon_handle,
                                     0,
                                     0,
                                     -1,
                                     oldlen + newlen);
    }
  }

  free(oldtext);
  return e;
}

/**************************************************************/
/* choices_button_set_validation()                            */
/*                                                            */
/* Does as button_set_validation but will only update it if   */
/* the text is different to that currently in the button.     */
/*                                                            */
/* Parameters: Same as button_set_validation.                 */
/**************************************************************/

static _kernel_oserror * choices_button_set_validation
                         (
                           const unsigned int   flags,
                           const ObjectId       window,
                           const ComponentId    writable,
                           const char         * restrict text
                         )
{
  int               reqdsize;
  char            * oldtext;
  _kernel_oserror * e = NULL;

  RetError(button_get_validation(0, window, writable, NULL, 0, &reqdsize));

  oldtext = malloc(reqdsize+1);
  if (!oldtext) return make_no_memory_error(20);

  button_get_validation(0, window, writable, oldtext, reqdsize, NULL);

  if (strcmp(text, oldtext))
  {
    e = button_set_validation(flags, window, writable, (char *) text);
  }

  free(oldtext);

  return e;
}

/**************************************************************/
/* choices_numberrange_set_value()                            */
/*                                                            */
/* Does as numberrange_set_value but will only update it if   */
/* the number is different to that currently in the display.  */
/*                                                            */
/* Parameters: Same as numberrange_set_value.                 */
/**************************************************************/

static _kernel_oserror * choices_numberrange_set_value
                         (
                           const unsigned int flags,
                           const ObjectId     window,
                           const ComponentId  writable,
                           const int          value
                         )
{
  int               oldvalue;
  _kernel_oserror * e = NULL;

  RetError(numberrange_get_value(0, window, writable, &oldvalue));

  if (oldvalue != value)
  {
    e = numberrange_set_value(flags, window, writable, value);
  }

  return e;
}

/**************************************************************/
/* choices_colour_set_component()                             */
/*                                                            */
/* Sets the validation string of a button to be slabbed in    */
/* and have the background colour specified.                  */
/*                                                            */
/* Parameters: Window ObjectId;                               */
/*                                                            */
/*             Button ComponentId;                            */
/*                                                            */
/*             Colour.                                        */
/**************************************************************/

static _kernel_oserror * choices_colour_set_component(ObjectId window, ComponentId component, int colour)
{
  char            newvalidation[32];
  unsigned char * newcol;

  newcol = (unsigned char*)&colour;

  sprintf(newvalidation, "R2;C/%02.2x%02.2x%02.2x", *(newcol + 3), *(newcol + 2), *(newcol + 1));

  return choices_button_set_validation(0, window, component, newvalidation);
}

/**************************************************************/
/* choices_get_menu_entry_text()                              */
/*                                                            */
/* Gets a pointer to a piece of text acquired from a menu.    */
/* The pointer is to a malloc block and so must be freed      */
/* after use.                                                 */
/*                                                            */
/* Parameters: pointer to the menu name                       */
/*                                                            */
/*             menu componentid                               */
/*                                                            */
/*             pointer to char* to use for the malloc block   */
/*                                                            */
/* Assumes:    the menu is a shared object.                   */
/**************************************************************/

static _kernel_oserror * choices_get_menu_entry_text
                         (
                           const char   * restrict menuname,
                           ComponentId             compid,
                           char        **          tempstring
                         )
{
  ObjectId menu_id;
  int      reqdsize;

  RetError(toolbox_create_object(0, (void *) menuname, &menu_id));

  RetError(menu_get_entry_text(0, menu_id, compid, NULL, 0, &reqdsize));

  *tempstring = malloc(reqdsize+1);
  if (!*tempstring) return make_no_memory_error(20);

  RetError(menu_get_entry_text(0, menu_id, compid, *tempstring, reqdsize+1, NULL));

  return NULL;
}

/**************************************************************/
/* choices_retrieve_text_item()                               */
/*                                                            */
/* Read a writable field's contents into a Choices item.      */
/*                                                            */
/* Parameters: Component ID of the writable field to read;    */
/*                                                            */
/*             Pointer to a char *, assumed to contain NULL   */
/*             or a malloc'd string that is free-able, which  */
/*             will be updated on exit with a pointer to the  */
/*             new string read from the writable field,       */
/*             itself malloc'd, the old string free'd.        */
/**************************************************************/

static _kernel_oserror * choices_retrieve_text_item
                         (
                           ComponentId    writable_field,
                           char        ** choice_to_update
                         )
{
  ObjectId   container;
  char     * tempstring;
  int        reqsize;

  /* Find the component */

  container = choices_find_component(writable_field);
  if (container == NULL_ObjectId) return NULL;

  /* Find out how much space is needed for the value */

  RetError(writablefield_get_value(0,
                                   container,
                                   writable_field,
                                   NULL,
                                   0,
                                   &reqsize));

  /* Allocate space for the value */

  tempstring = malloc(reqsize + 1);
  if (tempstring == NULL) return make_no_memory_error(17);

  RetError(writablefield_get_value(0,
                                   container,
                                   writable_field,
                                   tempstring,
                                   reqsize,
                                   NULL));

  /* Delete the old choices item and replace it */

  free(*choice_to_update);
  *choice_to_update = tempstring;

  /* Finished */

  return NULL;
}

/**************************************************************/
/* choices_modified_font()                                    */
/*                                                            */
/* Finds a version of a font with a specified modification    */
/* eg. bold or italic.                                        */
/*                                                            */
/* Parameters: pointer to the original font name              */
/*                                                            */
/*             pointer to a space separated and null          */
/*             terminated list of modifications in order of   */
/*             preference                                     */
/*                                                            */
/*             pointer to a buffer to contain the name of the */
/*             new font.                                      */
/**************************************************************/

static void choices_modified_font(char * orig, char * mod, char * buffer)
{
  _kernel_oserror * e = NULL;
  char              origname[Limits_FontName];
  int               f=-1;
  char            * p, * p2;
  char            * lastdot;
  BOOL              found;

  /* Find the fontname field */

  _swix(Font_FindField, _INR(1,2)|_OUTR(1,2), orig, 'F', &p, &found);

  /* If the field could not be found assume that the entire */
  /* string is the font name.                               */

  if (!found) p = orig;

  p2 = origname;

  /* Extract the font name.                                       */
  /* Copys the string pointed to by p to p2 until either a \ or a */
  /* character with an ascii value less than 32 is encountered.   */

  while (*p > 32 && *p != '\\') *p2++ = *p++;

  /* NULL terminate the new string */

  *p2 = '\0';

  lastdot = strrchr(origname, '.');

  /* Get first of possibly several possible modifications */

  p = strtok(mod, " ");

  while (p)
  {
    sprintf(buffer, "%s.%s", origname, p);
    e=_swix(Font_FindFont, _INR(1,5)|_OUT(0), buffer, 12*16, 12*16, 90, 90, &f);

    /* If there was no error then the font must have been found */

    if (!e) break;

    if (lastdot)
    {
      *lastdot = '\0';
      sprintf(buffer, "%s.%s", origname, p);
      *lastdot = '.';
      e=_swix(Font_FindFont, _INR(1,5)|_OUT(0), buffer, 12*16, 12*16, 90, 90, &f);
      if (e==NULL) break;
    }

    /* Get the next modification */

    p=strtok(NULL, " ");
  }

  /* If a font has been 'found' we need to lose it again */

  if (f >= 0) _swix(Font_LoseFont, _IN(0), f);

  /* If an error was encountered the best we can do is */
  /* to return the original font.                      */

  if (e) strcpy(buffer, orig);
}

/**************************************************************/
/* choices_clip_to_min_max()                                  */
/*                                                            */
/* Clips a number to a minimum and maximum value              */
/*                                                            */
/* Parameters: initial value;                                 */
/*                                                            */
/*             minimum;                                       */
/*                                                            */
/*             maximum.                                       */
/*                                                            */
/* Returns:    clipped value.                                 */
/**************************************************************/

int choices_clip_to_min_max(int value, int min, int max)
{
  return value > max ? max : (value < min ? min : value);
}
