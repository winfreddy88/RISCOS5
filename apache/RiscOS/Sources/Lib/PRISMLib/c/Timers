/* Copyright 2005 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Timers.c                                          */
/*          (C) 2005 Tematic Ltd.                             */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Funky CallAfter handler stuff. If used more       */
/*          widely, stop it sitting on TickerV first!         */
/*                                                            */
/* Author:  From the Internet module.                         */
/*                                                            */
/* History: 10-Mar-2005 (ADH): Imported from PRISM.           */
/*          14-Apr-2005 (ADH): Renamed to Timers.h to match   */
/*                             new corresponding header file. */
/**************************************************************/

#include <stdlib.h>

#include <Global/RISCOS.h>
#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "Timers.h"

/* External declarations assumed to have been generated by CMHG. The
 * code for the _entry variants should also have been generated by
 * CMHG, as a veneer to call the _handler variants, included herein
 * towards the end of this file.
 */

extern void              prismlib_callout_entry   (void);
extern void              prismlib_tick_entry      (void);
extern _kernel_oserror * prismlib_callout_handler (_kernel_swi_regs * r, void * pw);
extern _kernel_oserror * prismlib_tick_handler    (_kernel_swi_regs * r, void * pw);

/* Callout function descriptor */

struct prismlib_callout
{
  struct       prismlib_callout * c_next; /* next callout in queue */
  const void * c_arg;                     /* function argument     */
  void         (*c_func)(void *);         /* function to call      */
  int          c_time;                    /* ticks to the event    */
};

/* Number of concurrent items supported */

#define NCALLOUT 32

static struct prismlib_callout   callout [NCALLOUT];
static struct prismlib_callout * callfree;
static struct prismlib_callout   calltodo;

static int                       ncallout = NCALLOUT;
static volatile int              callo_pending;

/**************************************************************/
/* prismlib_callout_start()                                   */
/*                                                            */
/* Start the Callout engine. No callouts can be set unless    */
/* this function has been called. IT IS ESSENTIAL that a      */
/* module calls prismlib_callout_stop when it no longer wants */
/* callout services (in particular, when it is killed).       */
/*                                                            */
/* Parameters: The module private word, passed as a parameter */
/*             to the main module initialisation function.    */
/*                                                            */
/* Returns:    Pointer to an error block upon failure or NULL */
/*             if successful.                                 */
/**************************************************************/

_kernel_oserror * prismlib_callout_start(const void * pw)
{
  int i;

  callo_pending   = 0;
  calltodo.c_next = 0;
  callfree        = &callout[0];

  for (i = 1; i < ncallout; i++)
  {
    callout[i-1].c_next = &callout[i];
  }

  return _swix(OS_Claim,
               _INR(0,2),

               TickerV,
               prismlib_tick_entry,
               pw);
}

/**************************************************************/
/* prismlib_callout_stop()                                    */
/*                                                            */
/* Stop the Callout engine. Timer resources related to the    */
/* callout system are released. IT IS ESSENTIAL that a module */
/* which previously called prismlib_callout_start, then calls */
/* here when it no longer wants callout services (in          */
/* particular, when it is killed).                            */
/*                                                            */
/* Any pending callouts must be cancelled with                */
/* prismlib_untimeout before calling here.                    */
/*                                                            */
/* Parameters: The module private word, passed as a parameter */
/*             to the main module initialisation function.    */
/*                                                            */
/* Returns:    Pointer to an error block upon failure or NULL */
/*             if successful.                                 */
/**************************************************************/

_kernel_oserror * prismlib_callout_stop(const void * pw)
{
  _swix(OS_RemoveCallBack,
        _INR(0,1),

        prismlib_callout_entry,
        pw);

  return _swix(OS_Release,
               _INR(0,2),

               TickerV,
               prismlib_tick_entry,
               pw);
}

/**************************************************************/
/* prismlib_timeout()                                         */
/*                                                            */
/* Ask for a given function to be called at no earlier than   */
/* after a given number of centiseconds. If you want to shut  */
/* down the callout system later, and the timeout is still    */
/* pending, you must use prismlib_untimeout to cancel it      */
/* first. There is no harm in attempting to cancel timeout    */
/* functions which are no longer pending.                     */
/*                                                            */
/* Callout functions are invoked by using a TickerV-based     */
/* counter which, when a function becomes due, calls it by    */
/* using SWI OS_AddCallBack.                                  */
/*                                                            */
/* Parameters: Pointer to the function to call;               */
/*                                                            */
/*             An argument that will be passed to the         */
/*             function, cast to void *;                      */
/*                                                            */
/*             The number of centiseconds to wait before      */
/*             calling the function.                          */
/*                                                            */
/* Returns:    Pointer to an error block upon failure or NULL */
/*             if successful.                                 */
/**************************************************************/

void prismlib_timeout
     (
       const prismlib_timeout_func_t   fun,
       const void                    * arg,
       int                             t
     )
{
  struct prismlib_callout * p1;
  struct prismlib_callout * p2;
  struct prismlib_callout * pnew;
  int    irqs_off;

  irqs_off = _kernel_irqs_disabled();
  _kernel_irqs_off();

  if (t <= 0) t = 1;

  pnew = callfree;

  if (pnew == NULL)
  {
    if (!irqs_off) _kernel_irqs_on();
    dprintf(("CallOut", "timeout: Timeout table overflow!\n"));
    return;
  }

  callfree     = pnew->c_next;
  pnew->c_arg  = arg;
  pnew->c_func = fun;

  for (p1 = &calltodo; (p2 = p1->c_next) != NULL && p2->c_time < t; p1 = p2)
  {
    if (p2->c_time > 0) t -= p2->c_time;
  }

  p1->c_next   = pnew;
  pnew->c_next = p2;
  pnew->c_time = t;

  if (p2) p2->c_time -= t;

  if (!irqs_off) _kernel_irqs_on();

  return;
}

/**************************************************************/
/* prismlib_untimeout()                                       */
/*                                                            */
/* Cancels a callout function previously requested using a    */
/* call to prismlib_timeout.                                  */
/*                                                            */
/* Parameters: Pointer to the function given in               */
/*             prismlib_timeout;                              */
/*                                                            */
/*             The argument to be passed to the function      */
/*             given in prismlib_timeout.                     */
/*                                                            */
/* Returns:    Nothing.                                       */
/**************************************************************/

void prismlib_untimeout
     (
       const prismlib_timeout_func_t   fun,
       const void                    * arg
     )
{
  struct prismlib_callout * p1;
  struct prismlib_callout * p2;
  int    irqs_off;

  irqs_off = _kernel_irqs_disabled();
  _kernel_irqs_off();

  for (p1 = &calltodo; (p2 = p1->c_next) != 0; p1 = p2)
  {
    if (p2->c_func == fun && p2->c_arg == arg)
    {
      if (p2->c_next && p2->c_time > 0)
      {
        p2->c_next->c_time += p2->c_time;
      }

      p1->c_next = p2->c_next;
      p2->c_next = callfree;
      callfree   = p2;

      break;
    }
  }

  if (!irqs_off) _kernel_irqs_on();

  return;
}

/**************************************************************/
/* prismlib_tick_handler()                                    */
/*                                                            */
/* Internal function called from TickerV that checks the      */
/* callout queue and calls any due functions by using SWI     */
/* OS_AddCallBack.                                            */
/*                                                            */
/* Parameters: Pointer to a register block (ignored);         */
/*                                                            */
/*             The module private word, passed as a parameter */
/*             to the main module initialisation function.    */
/*                                                            */
/* Returns:    Pointer to an error block upon failure or NULL */
/*             if successful.                                 */
/**************************************************************/

_kernel_oserror * prismlib_tick_handler
                  (
                    _kernel_swi_regs * r,
                    void             * pw
                  )
{
  struct prismlib_callout * p1;
  int                       needtocall = 0;

  (void) r;

  /*
   * Update real-time timeout queue.
   * At front of queue are some number of events which are ``due''.
   * The time to these is <= 0 and if negative represents the
   * number of ticks which have passed since it was supposed to happen.
   * The rest of the q elements (times > 0) are events yet to happen,
   * where the time for each is given as a delta from the previous.
   * Decrementing just the first of these serves to decrement the time
   * to all events.
   */

  p1 = calltodo.c_next;

  while (p1)
  {
    if (--p1->c_time > 0) break;

    needtocall = 1;

    if (p1->c_time == 0) break;

    p1 = p1->c_next;
  }

  if (needtocall && !callo_pending)
  {
    _kernel_oserror * e = _swix(OS_AddCallBack,
                                _INR(0,1),

                                prismlib_callout_entry,
                                pw);

    if (!e) callo_pending = 1;
    /* else we_are_screwed() */
  }

  return NULL;
}

/**************************************************************/
/* prismlib_callout_handler()                                 */
/*                                                            */
/* Internal callback function registered with OS_AddCallBack  */
/* by prismlib_tick_handler. Checks for any callout functions */
/* due to be called and for each, stores the details, removes */
/* the function information from the queue, then calls it.    */
/*                                                            */
/* Parameters: Pointer to a register block (ignored);         */
/*                                                            */
/*             The module private word, passed as a parameter */
/*             to the main module initialisation function.    */
/*                                                            */
/* Returns:    Pointer to an error block upon failure or NULL */
/*             if successful.                                 */
/**************************************************************/

_kernel_oserror * prismlib_callout_handler
                  (
                    _kernel_swi_regs * r,
                    void             * pw
                  )
{
  struct prismlib_callout * p1;
  const void              * arg;
  prismlib_timeout_func_t   func;
  int                       a;
  int                       irqs_off;

  (void) r;
  (void) pw;

  callo_pending = 0;

  for (;;)
  {
    if ((p1 = calltodo.c_next) == 0 || p1->c_time > 0) return NULL;

    arg  = p1->c_arg;
    func = p1->c_func;
    a    = p1->c_time;

    irqs_off = _kernel_irqs_disabled();
    _kernel_irqs_off();

    calltodo.c_next = p1->c_next;
    p1->c_next      = callfree;
    callfree        = p1;

    if (!irqs_off) _kernel_irqs_on();

    /* We cast the argument down from 'const void *' as whilst we
     * have no right to alter the argument here, the function that
     * is called has every right to do whatever the person who set
     * up the callout in the first place wants.
     */

    (*func)((void *) arg);
  }

  return NULL;
}
