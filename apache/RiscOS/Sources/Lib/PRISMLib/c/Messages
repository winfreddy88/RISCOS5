/* Copyright 2005 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Messages.c                                        */
/*          (C) 2005 Tematic Ltd.                             */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Messages file handling.                           */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 14-Apr-2005 (ADH): Created from Utils.c.          */
/**************************************************************/

#include <stdlib.h>
#include <stdarg.h>
#include <stdbool.h>
#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "Messages.h"

/* Local variables */

static int registered = false;
static int messages_fd[4];

/**************************************************************/
/* prismlib_open_messages()                                   */
/*                                                            */
/* Open the named messages file, using the global messages    */
/* block.                                                     */
/*                                                            */
/* Parameters: Pointer to the filename of the Messages file.  */
/**************************************************************/

_kernel_oserror * prismlib_open_messages
                  (
                    const char * restrict messages_filename
                  )
{
  if (registered == false)
  {
    _kernel_oserror * e = _swix(MessageTrans_OpenFile,
                                _INR(0,2),

                                messages_fd,
                                messages_filename,
                                0);

    if (e == NULL) registered = true;
    else return e;
  }

  return NULL;
}

/**************************************************************/
/* prismlib_reopen_messages()                                 */
/*                                                            */
/* Reopen the named messages file, using the global messages  */
/* block. Intended to be used on Services_MessagesFileClosed, */
/* so only attempts the reopen if the "registered" flag is    */
/* already *set* from a successful prismlib_open_messages()   */
/* call.                                                      */
/*                                                            */
/* Parameters: Pointer to the filename of the Messages file.  */
/**************************************************************/

_kernel_oserror * prismlib_reopen_messages
                  (
                    const char * restrict messages_filename
                  )
{
  if (registered == true)
  {
    _kernel_oserror * e = _swix(MessageTrans_OpenFile,
                                _INR(0,2),

                                messages_fd,
                                messages_filename,
                                0);

    if (e != NULL)
    {
      registered = false;
      return e;
    }
  }

  return NULL;
}

/**************************************************************/
/* prismlib_close_messages()                                  */
/*                                                            */
/* Close the Messages file using the global messages block.   */
/**************************************************************/

_kernel_oserror * prismlib_close_messages(void)
{
  _kernel_oserror * e;

  if (registered == true)
  {
    e = _swix(MessageTrans_CloseFile,
              _IN(0),

              messages_fd);
  }
  else
  {
    e = NULL;
  }

  /* Regardless of any returned error, we have to assume that
   * internally things have closed (maybe the error was to say
   * that things were already shut down even though we didn't
   * expect it).
   */

  registered = false;

  /* Return the error, in case the caller can do something
   * sensible with it.
   */

  return e;
}

/**************************************************************/
/* prismlib_read_message()                                    */
/*                                                            */
/* Look up a given message through MessageTrans into a given  */
/* buffer with no parameter substitution. You must have first */
/* opened a Messages file with prismlib_open_messages.        */
/*                                                            */
/* You can ask to have the string copied into a local buffer  */
/* or have a pointer directly into the static messages file   */
/* returned. In the latter case, you must ensure that you     */
/* handle Service_MessagesFileClosed, calling                 */
/* prismlib_open_messages again to re-open your file and      */
/* noting that any pointers to messages you had previously    */
/* received are now invalid.                                  */
/*                                                            */
/* When you get a direct pointer into a messages file note    */
/* that the terminating character will be whatever control    */
/* character terminates the relevant line in the actual       */
/* Messages file - normally 10. It will only be NUL if you    */
/* arrange to include a NUL character at the end of relevant  */
/* strings in the Messages file itself.                       */
/*                                                            */
/* If you instead supply a buffer for a copy of the message   */
/* but the message is too large to fit in it, a truncated     */
/* result is returned with the last character in the buffer   */
/* used for a NUL terminator.                                 */
/*                                                            */
/* Parameters: Pointer to the token to look up;               */
/*                                                            */
/*             Pointer to a char * pointing to the buffer, or */
/*             pointing to NULL to get a pointer into the     */
/*             static messages file (hence the use of 'const' */
/*             in this parameter), updated on exit to point   */
/*             to the actual location of the string;          */
/*                                                            */
/*             Pointer to a size_t holding the buffer size or */
/*             ignored if the above pointer points to NULL,   */
/*             updated on exit to hold the size of the looked */
/*             up string excluding terminator character.      */
/**************************************************************/

_kernel_oserror * prismlib_read_message
                  (
                    const char  * restrict token,

                    const char ** restrict buffer,
                    size_t      * restrict inoutlength
                  )
{
  return _swix(MessageTrans_Lookup,
               _INR(0,7) | _OUTR(2,3),

               messages_fd,
               token,
               *buffer,
               *inoutlength,
               0,
               0,
               0,
               0,

               buffer,
               inoutlength);
}

/**************************************************************/
/* prismlib_make_message()                                    */
/*                                                            */
/* Look up a given message through MessageTrans into a given  */
/* buffer with parameter substitution. You must have first    */
/* opened a Messages file with prismlib_open_messages.        */
/*                                                            */
/* If the buffer is not large enough to hold the string, a    */
/* truncated result is returned, with the last character in   */
/* the buffer being used for a NUL terminator.                */
/*                                                            */
/* Parameters: Pointer to the token to look up;               */
/*                                                            */
/*             Pointer to a char * pointing to the buffer     */
/*             into which the string should be written;       */
/*                                                            */
/*             Pointer to a size_t holding the buffer size,   */
/*             updated on exit to hold the size of the looked */
/*             up string excluding NUL terminator;            */
/*                                                            */
/*             Number of parameters to pass to MessageTrans   */
/*             for substitution into the string or zero for   */
/*             none - up to four parameters will be read;     */
/*                                                            */
/*             Between zero and four pointers to strings to   */
/*             use as substitution parameters.                */
/**************************************************************/

_kernel_oserror * prismlib_make_message
                  (
                    const char * restrict token,

                    char       * restrict buffer,
                    size_t     * restrict inoutlength,

                    size_t                parameters,
                    ...
                  )
{
  va_list   ap;
  char    * args[4] = { 0, 0, 0, 0 };
  int       i;

  va_start(ap, parameters);
  if (parameters > 4) parameters = 4;

  for (i = 0; parameters > 0; i++, parameters--)
  {
    args[i] = va_arg(ap, char *);
  }

  return _swix(MessageTrans_Lookup,
               _INR(0,7) | _OUT(3),

               messages_fd,
               token,
               buffer,
               *inoutlength,
               args[0],
               args[1],
               args[2],
               args[3],

               inoutlength);
}
