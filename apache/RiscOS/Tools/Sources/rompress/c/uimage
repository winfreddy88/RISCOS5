/* Copyright 2014 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include "zlib/zlib.h"

#include "uimage.h"

static const uint32_t uimage_magic = 0x56190527; /* uImage header magic value */


static uint32_t endianswap(uint32_t val)
{
  return (val>>24) | ((val>>8) & 0xff00) | ((val<<8) & 0xff0000) | (val<<24);
}

bool uimage_hasheader(const char *rom, uint32_t len)
{
  if (len < sizeof(uimage_header))
    return false;
  uimage_header header = *((const uimage_header *) rom); /* Take copy so we can poke header checksum */
  rom += sizeof(uimage_header);
  len -= sizeof(uimage_header);
  if ((header.magic != uimage_magic) || (endianswap(header.length) != len))
     return false;
  /* Check header checksum */
  uint32_t expected = endianswap(header.header_crc);
  header.header_crc = 0;
  uint32_t actual = crc32(0, (const Bytef *) &header, sizeof(header));
  if (actual != expected)
  {
    fprintf(stderr, "Warning: Ignoring potential uImage header due to header CRC mismatch (header says %08x, I say %08x)\n", expected, actual);
  }
  return (actual == expected);
}

bool uimage_checksum_valid(const uimage_header *header)
{
  const char *rom = (const char *) (header+1);
  uint32_t len = endianswap(header->length);
  uint32_t expected = endianswap(header->data_crc);
  uint32_t actual = crc32(0, (const Bytef *) rom, len);
  if (actual != expected)
  {
    fprintf(stderr, "uImage data CRC mismatch (header says %08x, I say %08x)\n", expected, actual);
  }
  return (actual == expected);
}

void uimage_fixup(uimage_header *header, uint32_t len)
{
  const char *rom = (const char *) (header+1);
  /* Update data parameters */
  header->length = endianswap(len-sizeof(uimage_header));
  header->data_crc = endianswap(crc32(0, (const Bytef *) rom, len-sizeof(uimage_header)));
  /* Zero the header checksum while we recalculate it */
  header->header_crc = 0;
  header->header_crc = endianswap(crc32(0, (const Bytef *) header, sizeof(uimage_header)));
}

void uimage_info(const uimage_header *header)
{
  printf("  Header CRC: %08x\n", endianswap(header->header_crc));
  time_t t = (time_t) endianswap(header->timestamp);
  printf("  Timestamp: %s", ctime(&t)); /* Use local time to match 'mkimage -l' */
  printf("  Data length: %08x\n", endianswap(header->length));
  printf("  Load addr: %08x\n", endianswap(header->load_addr));
  printf("  Exec addr: %08x\n", endianswap(header->exec_addr));
  printf("  Data CRC: %08x\n", endianswap(header->data_crc));
  printf("  OS code: %02x\n", header->os);
  printf("  Arch code: %02x\n", header->arch);
  printf("  Image type: %02x\n", header->type);
  printf("  Compression code: %02x\n", header->compression);
  printf("  Title: %.32s\n", header->name);
}
