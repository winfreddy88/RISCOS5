/** @file
  */
/* Created 10.12.2007 T. Milius
   Changed 10.02.2008 T. Milius Debugging optional to avoid syslog library problems.
   Changed 06.04.2016 T. Milius Support of RPi 12" display added.
   Changed 17.04.2016 T. Milius Calculation adapted to cope with arbitrary min/max values.
   Changed 30.05.2016 T. Milius command TchScrn_Status added
   Changed 27.04.2016 T. Milius command TchScrn_TellPoint added
   Changed 04.06.2016 T. Milius Restructed with common as most functions are now modul only
   Changed 04.06.2016 T. Milius different mode change times added
   Changed 10.07.2016 T. Milius RPi display 7" not 12" :-( */
/* Copyright (c) 2007-2016 by Thomas Milius Stade, Germany
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the &lt;organization&gt; nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Thomas Milius Stade, Germany ``AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Thomas Milius Stade, Germany BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
/** @mainpage
    @author Thomas Milius Stade, Germany
    @version 1.01
    @date 04.04.2016

    TchScrn implements a RISC OS touchscreen driver for the D-WAV eGalax monitor and
    RaspberryPi 7" display.

    See the <a href="../../../Manual/specification.html">specification</a> for concept details.

    */
/* RISCOS */

/* !!!!!!!!!! libraries !!!!!!!!!! */
/* ---------- ANSI-C ---------- */
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* ------------ RISC OS ------------ */
#include <kernel.h>
#include <swis.h>

/* ------------ extern ------------ */
#ifdef USE_SYSLOG
#include <syslog.h>
#endif

/* ------------ own ------------ */
#include "common.h"
#include "usb.h"
#include "rpi_disp7.h"

/* !!!!!!!!!!! definitions !!!!!!!!!! */
/* !!!!!!!!!! CMUNGE/CHMG-code declarations !!!!!!!!!! */
extern int pointer_handler_adap(_kernel_swi_regs *regs, void *pw);
extern int ticker_handler_adap(_kernel_swi_regs *regs, void *pw);
extern int key_handler_adap(_kernel_swi_regs *regs, void *pw);

#define IRQ_NOT_CLAIMED 1
#define IRQ_CLAIMED     0

/** @name Results of solving the equation.

    This codes will occur as results of solve_equation() */
/*@{*/
#define TOUCHSCREEN_EQUATION_RESULT_PARAM    -2
#define TOUCHSCREEN_EQUATION_RESULT_NO       -1
#define TOUCHSCREEN_EQUATION_RESULT_OK        0
#define TOUCHSCREEN_EQUATION_RESULT_SINGLE_Y  1
#define TOUCHSCREEN_EQUATION_RESULT_SINGLE_X  2
#define TOUCHSCREEN_EQUATION_RESULT_MANY      3
/*@}*/

/** @name States of the button emulation state machine

    This states will be used and changed by handle_screen_activities()
    to emulate the mouse buttons. */
/*@{*/
#define TOUCHSCREEN_DRIVER_STATE_IDLE              0
#define TOUCHSCREEN_DRIVER_STATE_BUTTTON_SELECTION 1
#define TOUCHSCREEN_DRIVER_STATE_RELEASED          2
#define TOUCHSCREEN_DRIVER_STATE_PRESSED           3
/*@}*/

/** @name RISC OS Mouse button key codes.

    The codes are used to inform RISC OS about mouse button clicks. */
/*@{*/
#define TOUCHSCREEN_DRIVER_BUTTON_NONE   0
#define TOUCHSCREEN_DRIVER_BUTTON_SELECT 0x00000070
#define TOUCHSCREEN_DRIVER_BUTTON_MENU   0x00000071
#define TOUCHSCREEN_DRIVER_BUTTON_ADJUST 0x00000072
/*@}*/

#ifdef USE_SYSLOG
#define TOUCHSCREEN_DEBUG_DETAIL 40
#endif

/** No double used because of trouble with FPE in SVC-mode.
    Therefore used long long with 1 Bit sign, 47 Bit Integer part and 16 Bit fractional part.

    All Additions/Subtractions are neutral.
    Every mutilplication must be divided by this factor to keep the relations.
    Every division must be multiplied by this factor to keep the relations.

    Value shall be a power of 2 to allow the compiler optimizations by shifting. */
#define TOUCHSCREEN_DOUBLE_INTEGER         0x0000000000010000
/** Determines approximation precision inside transform_touchscreen_point()

    1/16384 */
#define TOUCHSCREEN_DOUBLE_APPROX_PRECISON 0x0000000000000004

/** Allocated from ROOL */
#define TOUCHSCREEN_MOUSE_DRIVER_NUMBER 0x0E

/* !!!!!!!!!! data structures !!!!!!!!!! */
/** Points with fractional parts for distortion calculation. */
typedef struct {
long long x;
long long y;
} dpoint;

/** Point scheme:

    <center><img src="../../../Manual/Point_Scheme.png" width="0" height="0" border="0"></center>

    Note that this is the location on the screen and has nothing to do with the values of the points,
    eg. left side may have larger values than the right side and vice versa. The same is valid for the
    top and the bottom line.

    Original asumption (egalax) was:
    left side x is smaller than right side x.
    bottom y is smaller than top y
    2 is the point with the smallest values from screen.

    Orientation of OS is same one. */
/*  0-----1
    |     |
    |     |
    2-----3 */
typedef struct {
/** Values returned from screen for the edges. */
point screen_point[4];
/** According RISC OS screen coordinates. */
point os_point[4];
} screen_map_rectangle;

typedef struct {
screen_map_rectangle screen_map[TOUCHSCREEN_MAX_CELLS_X][TOUCHSCREEN_MAX_CELLS_Y];
/* One larger than array address bounds. */
unsigned int max_x_cell;
unsigned int max_y_cell;
} screen_map;

/** Array scheme:

    <center><img src="../../../Manual/Equation_Scheme.png" width="0" height="0" border="0"></center> */
/*    0      1      2
   0  Ax*X + Bx*Y = Cx
   1  Ay*X + By*Y = Cy */
typedef struct {
long long element[2][3];
} equation;

/** General driver data */
struct {
/* RISCOS error handling */
_kernel_oserror error_os;
/* Configuration */
unsigned int button_change_time[TOUCHSCREEN_BUTTON_EMULATION_STATES];
screen_map map;
/* Copy of mouse settings */
int double_click_interval;
int movement_distance;
int mouse_speed;
/* USB */
/* Must be stored in common as enabling of driver may occur
   separately and this information is required in this context. */
int screen_usb_device_number;
/* Internal */
touch_screen_control_struct touch_screen_control;
/* Must be stored in common as enabling of driver may occur
   separately and this information is required in this context. */
int panel_type;
bool in_use;
point start_point;
int start_time;
int last_button;
point last_reported_point;
int status;
int button_emu[TOUCHSCREEN_BUTTON_EMULATION_STATES];
int last_reported_button;
int last_button_emu_shown;
int regular_cursor;
bool enabled_flag;
int last_active_driver;
bool screen_info_changes;
#ifdef USE_SYSLOG
/* Debug */
char logname[20];
bool debug;
#endif
} common;

/* !!!!!!!!!! support functions !!!!!!!!!! */

/** Solves an equation with 2 unknown elements.

    It returns the unknown elements if possible and an information
    whether the equation could besolved or not. */
int solve_equation(equation *actual_equation,
                   long long *result_x,
                   long long *result_y)
{
long long tmp;

if ((!actual_equation) ||
    (!result_x) ||
    (!result_y)) {
  return TOUCHSCREEN_EQUATION_RESULT_PARAM;
  }
tmp=(actual_equation->element[0][0]*actual_equation->element[1][1] - actual_equation->element[1][0]*actual_equation->element[0][1])/TOUCHSCREEN_DOUBLE_INTEGER;
if (tmp == 0) {
  if ((actual_equation->element[0][0] == 0) &&
      (actual_equation->element[1][0] == 0)) {
    /* Component A and X without any relevance */
    if (actual_equation->element[0][1] != 0) {
      *result_x=0;
      *result_y=(actual_equation->element[0][2]*TOUCHSCREEN_DOUBLE_INTEGER)/actual_equation->element[0][1];
      if (((*result_y*actual_equation->element[1][1])/TOUCHSCREEN_DOUBLE_INTEGER) == actual_equation->element[1][2]) {
        return TOUCHSCREEN_EQUATION_RESULT_SINGLE_Y;
        }
      else {
        return TOUCHSCREEN_EQUATION_RESULT_NO;
        }
      }
    else if (actual_equation->element[1][1] != 0) {
      *result_x=0;
      *result_y=(actual_equation->element[1][2]*TOUCHSCREEN_DOUBLE_INTEGER)/actual_equation->element[1][1];
      if (((*result_y*actual_equation->element[0][1])/TOUCHSCREEN_DOUBLE_INTEGER) == actual_equation->element[0][2]) {
        return TOUCHSCREEN_EQUATION_RESULT_SINGLE_Y;
        }
      else {
        return TOUCHSCREEN_EQUATION_RESULT_NO;
        }
      }
    else {
      if ((actual_equation->element[0][2] == 0) &&
          (actual_equation->element[1][2] == 0)) {
        /* Arbitrary */
        *result_y=0;
        *result_x=0;
        return TOUCHSCREEN_EQUATION_RESULT_MANY;
        }
      else {
        return TOUCHSCREEN_EQUATION_RESULT_NO;
        }
      }
    }
  else if ((actual_equation->element[0][1] == 0) &&
           (actual_equation->element[1][1] == 0)) {
    /* Component B and Y without any relevance */
    if (actual_equation->element[0][0] != 0) {
      *result_y=0;
      *result_x=(actual_equation->element[0][2]*TOUCHSCREEN_DOUBLE_INTEGER)/actual_equation->element[0][0];
      if (((*result_x*actual_equation->element[1][0])/TOUCHSCREEN_DOUBLE_INTEGER) == actual_equation->element[1][2]) {
        return TOUCHSCREEN_EQUATION_RESULT_SINGLE_X;
        }
      else {
        return TOUCHSCREEN_EQUATION_RESULT_NO;
        }
      }
    else if (actual_equation->element[1][0] != 0) {
      *result_y=0;
      *result_x=(actual_equation->element[1][2]*TOUCHSCREEN_DOUBLE_INTEGER)/actual_equation->element[1][0];
      if (((*result_x*actual_equation->element[0][0])/TOUCHSCREEN_DOUBLE_INTEGER) == actual_equation->element[0][2]) {
        return TOUCHSCREEN_EQUATION_RESULT_SINGLE_X;
        }
      else {
        return TOUCHSCREEN_EQUATION_RESULT_NO;
        }
      }
    else {
      if ((actual_equation->element[0][2] == 0) &&
          (actual_equation->element[1][2] == 0)) {
        /* Arbitrary */
        *result_y=0;
        *result_x=0;
        return TOUCHSCREEN_EQUATION_RESULT_MANY;
        }
      else {
        return TOUCHSCREEN_EQUATION_RESULT_NO;
        }
      }
    }
  if (actual_equation->element[0][2] == actual_equation->element[1][2]) {
    /* Arbitrary */
    *result_y=0;
    *result_x=0;
    return TOUCHSCREEN_EQUATION_RESULT_MANY;
    }
  else {
    return TOUCHSCREEN_EQUATION_RESULT_NO;
    }
  }
else {
  /* Division compensates multiplication */
  *result_y=(actual_equation->element[0][0]*actual_equation->element[1][2] - actual_equation->element[1][0]*actual_equation->element[0][2])/tmp;
  /* Ax and Ay can't be both zero at here. */
  if (actual_equation->element[0][0] == 0) {
    *result_x=((actual_equation->element[1][2] - actual_equation->element[1][1])*TOUCHSCREEN_DOUBLE_INTEGER)/actual_equation->element[1][0];
    }
  else {
    *result_x=((actual_equation->element[0][2] - actual_equation->element[0][1])*TOUCHSCREEN_DOUBLE_INTEGER)/actual_equation->element[0][0];
    }
  return TOUCHSCREEN_EQUATION_RESULT_OK;
  }
}

/** The function starts import of the touch screen configuration file and
    sets up the screen map rectangles in accordance to the calibration content
    of the file and the screen resolution.

    Returns TRUE if successful or FALSE else. */
bool set_up_configuration(void)
{
int i,j;
int vdu_variables[5];
int vdu_variables_value[4];
unsigned long screen_width;
unsigned long screen_height;
_kernel_swi_regs regs;
point *screen_point;

/* Get RISC OS screen information */
vdu_variables[0]=4;
vdu_variables[1]=11;
vdu_variables[2]=5;
vdu_variables[3]=12;
vdu_variables[4]=-1;
regs.r[0]=(int) vdu_variables;
regs.r[1]=(int) vdu_variables_value;
if (_kernel_swi(OS_ReadVduVariables, &regs, &regs) != NULL) return false;
/* Load configuration */
/* Needed to be alloacted dynamically because of Module stack size limitations. */
if ((screen_point=malloc(sizeof(point)*(TOUCHSCREEN_MAX_CELLS_X + 1)*(TOUCHSCREEN_MAX_CELLS_Y + 1))) == NULL) return false;
if (!load_settings(common.button_change_time,
                   &common.map.max_x_cell,
                   &common.map.max_y_cell,
                   (point *) screen_point)) {
  free(screen_point);
  return false;
  }
screen_width=vdu_variables_value[1]<<vdu_variables_value[0];
screen_height=vdu_variables_value[3]<<vdu_variables_value[2];
/* Fill point data into the map. */
for (i=0; i < common.map.max_x_cell; i++) {
  for (j=0; j < common.map.max_y_cell; j++) {
    /* Touch screen data */
#ifdef USE_SYSLOG
    if (common.debug) {
      syslogf(common.logname,
              TOUCHSCREEN_DEBUG_DETAIL,
              "Set up rectangle %d %d",
              i,
              j);
      }
#endif
    common.map.screen_map[i][j].screen_point[0].x=screen_point[(TOUCHSCREEN_MAX_CELLS_Y + 1)*i + j].x;
    common.map.screen_map[i][j].screen_point[0].y=screen_point[(TOUCHSCREEN_MAX_CELLS_Y + 1)*i + j].y;
    common.map.screen_map[i][j].screen_point[1].x=screen_point[(TOUCHSCREEN_MAX_CELLS_Y + 1)*(i +1) + j].x;
    common.map.screen_map[i][j].screen_point[1].y=screen_point[(TOUCHSCREEN_MAX_CELLS_Y + 1)*(i +1) + j].y;
    common.map.screen_map[i][j].screen_point[2].x=screen_point[(TOUCHSCREEN_MAX_CELLS_Y + 1)*i + (j + 1)].x;
    common.map.screen_map[i][j].screen_point[2].y=screen_point[(TOUCHSCREEN_MAX_CELLS_Y + 1)*i + (j + 1)].y;
    common.map.screen_map[i][j].screen_point[3].x=screen_point[(TOUCHSCREEN_MAX_CELLS_Y + 1)*(i + 1) + (j + 1)].x;
    common.map.screen_map[i][j].screen_point[3].y=screen_point[(TOUCHSCREEN_MAX_CELLS_Y + 1)*(i + 1) + (j + 1)].y;
#ifdef USE_SYSLOG
    if (common.debug) {
      int k;

      for (k=0; k < 4; k++) {
        syslogf(common.logname,
                TOUCHSCREEN_DEBUG_DETAIL,
                "Screen point%d %ld %ld",
                k,
                common.map.screen_map[i][j].screen_point[k].x,
                common.map.screen_map[i][j].screen_point[k].y);
        }
      }
#endif
    /* RISC OS data */
    common.map.screen_map[i][j].os_point[2].x=(i*screen_width)/common.map.max_x_cell;
    common.map.screen_map[i][j].os_point[2].y=((common.map.max_y_cell - (j + 1))*screen_height)/common.map.max_y_cell;
    common.map.screen_map[i][j].os_point[0].x=common.map.screen_map[i][j].os_point[2].x;
    common.map.screen_map[i][j].os_point[0].y=((common.map.max_y_cell - j)*screen_height)/common.map.max_y_cell;
    common.map.screen_map[i][j].os_point[1].x=((i + 1)*screen_width)/common.map.max_x_cell;
    common.map.screen_map[i][j].os_point[1].y=common.map.screen_map[i][j].os_point[0].y;
    common.map.screen_map[i][j].os_point[3].x=common.map.screen_map[i][j].os_point[1].x;
    common.map.screen_map[i][j].os_point[3].y=common.map.screen_map[i][j].os_point[2].y;
#ifdef USE_SYSLOG
    if (common.debug) {
      int k;

      for (k=0; k < 4; k++) {
        syslogf(common.logname,
                TOUCHSCREEN_DEBUG_DETAIL,
                "OS point%d %ld %ld",
                k,
                common.map.screen_map[i][j].os_point[k].x,
                common.map.screen_map[i][j].os_point[k].y);
        }
      }
#endif
    }
  }
free(screen_point);
return true;
}

/** The function determines the map rectangle from a given
    screen mapping which contains a given touchscreen point.

    If no such rectangle can be found NULL is returned.

    The map is organized as an array of rectangles which are sharing
    their edge points. This is valid for the screen and for the
    RISC OS coordinates.

    The required rectangle is found by interval halving of
    the Y-array position first and afterwards by halving
    the X-array postiion.

    A given Y-array position determines an continous line sequence
    by the X-array elements. The line sequence is made up by the
    points 0 and 1 (upper left and right point of the rectangles).
    To get a quick comparision line the Y-Array positions are
    also interval halved by looking whether the X-coordinate
    of point 0 of a rectangle is larger than the X-coordinate
    of the given touschscreen point.

    After the comparation rectangle has been determined
    a check is made whether the touchscreen point is located above
    the upper rectangle line or not.

    This repeats until the Y-array position has been determined.

    Now the final X-array position is determined by interval
    halving. It is checked whether the touchscreen point
    is located left to the left line of the actual rectangle
    which is determined by the points 0 and 2.

    Complexity ist log2(n)^2. Where n is max(max x/y array element of the map).

    If having 10*10=100 rectangles n=10 and 16 checks are required. However
    only 8 time consuming location calculations are required (2*log2(n))
    all other parts are simple integer comparations.

    A matrix of 100 rectangles is a very precise adjustment, normally
    you will have 4 or 6 rectangles.

    Note that at this step care must be taken which edge of the
    rectangle has the bigger values. The sequence of the rectangles
    remains unchanged (from left to right and top to bottom).

    Orientation of OS doesn't play a role here as the rectangles are splitting
    the screen locically in the same way for the OS and the touchscreen. */
screen_map_rectangle *find_screen_map_rectangle(screen_map *actual_map,
                                                point *touchscreen_point)
{
int min_array_x;
int max_array_x;
int min_array_y;
int max_array_y;
int actual_array_x;
int actual_array_y;
int best_array_x;
int best_array_y;
screen_map_rectangle *actual_rectangle;
long long result_x;
long long result_y;
equation actual_vectors;

if ((!actual_map) ||
    (!touchscreen_point) ||
    (actual_map->max_x_cell == 0) ||
    (actual_map->max_y_cell == 0)) {
  return NULL;
  }
min_array_y=0;
max_array_y=actual_map->max_y_cell - 1;
best_array_y=0;
/* Interval halving y array */
while (min_array_y <= max_array_y) {
  actual_array_y=(min_array_y + max_array_y)/2;
#ifdef USE_SYSLOG
    if (common.debug) {
      syslogf(common.logname,
              TOUCHSCREEN_DEBUG_DETAIL,
              "find rectangle y %d %d %d %d",
              min_array_y,
              max_array_y,
              actual_array_y,
              best_array_y);
      }
#endif
  /* Subloop for x element determination */
  min_array_x=0;
  max_array_x=actual_map->max_x_cell - 1;
  best_array_x=0;
  while (min_array_x <= max_array_x) {
    actual_array_x=(min_array_x + max_array_x)/2;
#ifdef USE_SYSLOG
    if (common.debug) {
      syslogf(common.logname,
              TOUCHSCREEN_DEBUG_DETAIL,
              "find rectangle x %d %d %d %d",
              min_array_x,
              max_array_x,
              actual_array_x,
              best_array_x);
      }
#endif
    actual_rectangle=&actual_map->screen_map[actual_array_x][actual_array_y];
#ifdef USE_SYSLOG
    if (common.debug) {
      syslogf(common.logname,
              TOUCHSCREEN_DEBUG_DETAIL,
              "find rectangle compare x %d %d %d %d",
              actual_rectangle->screen_point[0].x,
              actual_rectangle->screen_point[1].x,
              actual_rectangle->screen_point[0].x,
              touchscreen_point->x);
      }
#endif
    /* Take care about the bigger side of the touchscreen data. */
    if (((actual_rectangle->screen_point[0].x <= actual_rectangle->screen_point[1].x) &&
         (actual_rectangle->screen_point[0].x < touchscreen_point->x)) ||
        ((actual_rectangle->screen_point[0].x > actual_rectangle->screen_point[1].x) &&
         (actual_rectangle->screen_point[0].x > touchscreen_point->x))) {
      best_array_x=actual_array_x;
      min_array_x=actual_array_x + 1;
      }
    else if (actual_rectangle->screen_point[0].x == touchscreen_point->x) {
      best_array_x=actual_array_x;
      break;
      }
    else {
      max_array_x=actual_array_x - 1;
      }
    }
  /* Determine on which side of the line touchscreen point is located.
     Line is running from point 0 to 1.
     The location of the touchscreen point is determined by a
     normal vector.

     P0 + X*(P1 - P0) + Y*Lot((P1 - P0))=TP
     X*(P1 - P0) + Y*Lot((P1 - P0))=TP - P0 */
  actual_rectangle=&actual_map->screen_map[best_array_x][actual_array_y];
  actual_vectors.element[0][0]=((long long) actual_rectangle->screen_point[1].x - actual_rectangle->screen_point[0].x)*TOUCHSCREEN_DOUBLE_INTEGER;
  actual_vectors.element[1][0]=((long long) actual_rectangle->screen_point[1].y - actual_rectangle->screen_point[0].y)*TOUCHSCREEN_DOUBLE_INTEGER;
  actual_vectors.element[0][1]=((long long) actual_rectangle->screen_point[1].y - actual_rectangle->screen_point[0].y)*TOUCHSCREEN_DOUBLE_INTEGER;
  actual_vectors.element[1][1]=((long long) actual_rectangle->screen_point[0].x - actual_rectangle->screen_point[1].x)*TOUCHSCREEN_DOUBLE_INTEGER;
  actual_vectors.element[0][2]=((long long) touchscreen_point->x - actual_rectangle->screen_point[0].x)*TOUCHSCREEN_DOUBLE_INTEGER;
  actual_vectors.element[1][2]=((long long) touchscreen_point->y - actual_rectangle->screen_point[0].y)*TOUCHSCREEN_DOUBLE_INTEGER;
  if (solve_equation(&actual_vectors,
                     &result_x,
                     &result_y) < TOUCHSCREEN_EQUATION_RESULT_OK) {
    return NULL;
    }
#ifdef USE_SYSLOG
    if (common.debug) {
      syslogf(common.logname,
              TOUCHSCREEN_DEBUG_DETAIL,
              "find rectangle y1 equation result %ld %ld",
              result_x,
              result_y);
      }
#endif
  /* Take care about the bigger side of the touchscreen data. */
//  if (((actual_rectangle->screen_point[0].x <= actual_rectangle->screen_point[1].x) &&
//       (result_y < 0)) ||
//      ((actual_rectangle->screen_point[0].x > actual_rectangle->screen_point[1].x) &&
//       (result_y > 0))) {
  if (result_y < 0) {
    best_array_y=actual_array_y;
    min_array_y=actual_array_y + 1;
    }
  else if (result_y == 0) {
    best_array_y=actual_array_y;
    break;
    }
  else {
    max_array_y=actual_array_y - 1;
    }
  }
/* Interval halving x array */
min_array_x=0;
max_array_x=actual_map->max_x_cell - 1;
best_array_x=0;
while (min_array_x <= max_array_x) {
  actual_array_x=(min_array_x + max_array_x)/2;
  /* Determine on which side of the line touchscreen point is located
     Line is running from point 2 to 0. */
  actual_rectangle=&actual_map->screen_map[actual_array_x][best_array_y];
  actual_vectors.element[0][0]=((long long) actual_rectangle->screen_point[0].x - actual_rectangle->screen_point[2].x)*TOUCHSCREEN_DOUBLE_INTEGER;
  actual_vectors.element[1][0]=((long long) actual_rectangle->screen_point[0].y - actual_rectangle->screen_point[2].y)*TOUCHSCREEN_DOUBLE_INTEGER;
  actual_vectors.element[0][1]=((long long) actual_rectangle->screen_point[0].y - actual_rectangle->screen_point[2].y)*TOUCHSCREEN_DOUBLE_INTEGER;
  actual_vectors.element[1][1]=((long long) actual_rectangle->screen_point[2].x - actual_rectangle->screen_point[0].x)*TOUCHSCREEN_DOUBLE_INTEGER;
  actual_vectors.element[0][2]=((long long) touchscreen_point->x - actual_rectangle->screen_point[2].x)*TOUCHSCREEN_DOUBLE_INTEGER;
  actual_vectors.element[1][2]=((long long) touchscreen_point->y - actual_rectangle->screen_point[2].y)*TOUCHSCREEN_DOUBLE_INTEGER;
  if (solve_equation(&actual_vectors,
                     &result_x,
                     &result_y) < TOUCHSCREEN_EQUATION_RESULT_OK) {
    return NULL;
    }
//  if (((actual_rectangle->screen_point[2].y <= actual_rectangle->screen_point[0].y) &&
//       (result_y < 0)) ||
//      ((actual_rectangle->screen_point[2].y > actual_rectangle->screen_point[0].y) &&
//       (result_y > 0))) {
  if (result_y < 0) {
    best_array_x=actual_array_x;
    min_array_x=actual_array_x + 1;
    }
  else if (result_y == 0) {
    best_array_x=actual_array_x;
    break;
    }
  else {
    max_array_x=actual_array_x - 1;
    }
  }
#ifdef USE_SYSLOG
    if (common.debug) {
      int k;

      for (k=0; k < 4; k++) {
        syslogf(common.logname,
                TOUCHSCREEN_DEBUG_DETAIL,
                "Found screen array element %d %d",
                best_array_x,
                best_array_y);
        }
      }
#endif
return &actual_map->screen_map[best_array_x][best_array_y];
}

/** Transforms a given touchscreen point into a RISC OS point
    using a given screen mapping. If the point could be
    calculated TRUE is returned or FALSE if the point couldn't be calculated.

    At first the screen map rectangle for the given touchscreen point
    is calculated using find_screen_map_rectangle.

    Afterwards the touchscreen point is calculated as a vector
    from the lines determined by the points 0/2 and 1/3 of the
    touchscreen rectangle edge coordinates. This results in
    two fractional values determining the length of the two
    vector lines.

    With this fractional parts the RISC OS point is calculated
    by building the same vector but this time using the RISC OS
    rectangle edge coordinates.

    Note that at this step care must be taken which edge of the
    rectangle has the bigger values. The sequence of the rectangles
    remains unchanged (from left to right and top to bottom). */
bool transform_touchscreen_point(screen_map *actual_map,
                                 point *touchscreen_point,
                                 point *os_point)
{
screen_map_rectangle *actual_screen_map_rectangle;
dpoint pa, pb;
long long tmp;
long long min_pos;
long long max_pos;
long long actual_pos;
long long result_x;
long long result_y;
long long best_pos_a;
long long best_pos_b;
equation actual_vectors;

if ((actual_screen_map_rectangle=find_screen_map_rectangle(actual_map,
                                                           touchscreen_point)) == NULL) {
  return false;
  }
/*  TP is located on a line generated by
                          Gradient from left to right
                          ------------------------------------
    Left line             Right line          Left Line
    ----------------      ----------------    ----------------
    P0 + X*(P2 - P0) + Y*(P1 + X*(P3 - P1) - (P0 + X*(P2 - P0)))=TP

    This can be either solved by iteration (interval halving of X from 0 to 1)
    with distance calculation or by solving the equation mathematically.

    Lets implement the interval halving by making usage of the normal vector.

    In calculation we have to take orientation of OS and Touchscreen coordinates
    into account. */
/* Interval halving touchscreen */
min_pos=0;
max_pos=1*TOUCHSCREEN_DOUBLE_INTEGER;
while (min_pos <= max_pos) {
  actual_pos=(min_pos + max_pos)/2;
  /* actual_pos shifts the integer value to the right long long position. */
  pa.x=((long long) actual_screen_map_rectangle->screen_point[2].x - actual_screen_map_rectangle->screen_point[0].x)*actual_pos + ((long long)actual_screen_map_rectangle->screen_point[0].x * TOUCHSCREEN_DOUBLE_INTEGER);
  pa.y=((long long) actual_screen_map_rectangle->screen_point[2].y - actual_screen_map_rectangle->screen_point[0].y)*actual_pos + ((long long)actual_screen_map_rectangle->screen_point[0].y * TOUCHSCREEN_DOUBLE_INTEGER);
  pb.x=((long long) actual_screen_map_rectangle->screen_point[3].x - actual_screen_map_rectangle->screen_point[1].x)*actual_pos + ((long long)actual_screen_map_rectangle->screen_point[1].x * TOUCHSCREEN_DOUBLE_INTEGER);
  pb.y=((long long) actual_screen_map_rectangle->screen_point[3].y - actual_screen_map_rectangle->screen_point[1].y)*actual_pos + ((long long)actual_screen_map_rectangle->screen_point[1].y * TOUCHSCREEN_DOUBLE_INTEGER);
  actual_vectors.element[0][0]=pb.x - pa.x;
  actual_vectors.element[1][0]=pb.y - pa.y;
  actual_vectors.element[0][1]=pb.y - pa.y;
  actual_vectors.element[1][1]=pa.x - pb.x;
  actual_vectors.element[0][2]=((long long) touchscreen_point->x*TOUCHSCREEN_DOUBLE_INTEGER) - pa.x;
  actual_vectors.element[1][2]=((long long) touchscreen_point->y*TOUCHSCREEN_DOUBLE_INTEGER) - pa.y;
  if (solve_equation(&actual_vectors,
                     &result_x,
                     &result_y) < TOUCHSCREEN_EQUATION_RESULT_OK) {
    return false;
    }
  /* Absolute value to detect precision. Not effected by edge values of touchscreen. */
  if (result_y < 0) {
    tmp=-result_y;
    }
  else {
    tmp=result_y;
    }
  /* Take care about the bigger side of the touchscreen data. */
//  if (((actual_screen_map_rectangle->screen_point[2].y <= actual_screen_map_rectangle->screen_point[0].y) &&
//       (result_y < 0)) ||
//      ((actual_screen_map_rectangle->screen_point[2].y > actual_screen_map_rectangle->screen_point[0].y) &&
//       (result_y > 0))) {
  if (result_y < 0) {
    best_pos_a=actual_pos;
    best_pos_b=result_x;
    min_pos=actual_pos + TOUCHSCREEN_DOUBLE_APPROX_PRECISON;
    }
  else if (tmp <= TOUCHSCREEN_DOUBLE_APPROX_PRECISON) {
    best_pos_a=actual_pos;
    best_pos_b=result_x;
    break;
    }
  else {
    max_pos=actual_pos - TOUCHSCREEN_DOUBLE_APPROX_PRECISON;
    }
  }
/* RISC OS values but calculated from sight of Touchscreen */
if (best_pos_a < 0) {
  best_pos_a=0;
  best_pos_b=result_x;
  }
if (best_pos_b < 0) {
  best_pos_b=0;
  }
if (best_pos_b > 1*TOUCHSCREEN_DOUBLE_INTEGER) {
  best_pos_b=1*TOUCHSCREEN_DOUBLE_INTEGER;
  }
/* We have to adjust the orientations now. */
//if (actual_screen_map_rectangle->screen_point[0].x > actual_screen_map_rectangle->screen_point[1].x) {
//  best_pos_a=1 - best_pos_a;
//  }
//if (actual_screen_map_rectangle->screen_point[2].y > actual_screen_map_rectangle->screen_point[0].y) {
//  best_pos_b=1 - best_pos_b;
//  }
/* best_pos_a shifts the integer value to the right long long position. */
pa.x=((long long) actual_screen_map_rectangle->os_point[2].x - actual_screen_map_rectangle->os_point[0].x)*best_pos_a + ((long long) actual_screen_map_rectangle->os_point[0].x*TOUCHSCREEN_DOUBLE_INTEGER);
pa.y=((long long) actual_screen_map_rectangle->os_point[2].y - actual_screen_map_rectangle->os_point[0].y)*best_pos_a + ((long long) actual_screen_map_rectangle->os_point[0].y*TOUCHSCREEN_DOUBLE_INTEGER);
/* best_pos_a shifts the integer value to the right long long position. */
os_point->x=(pa.x + (((((long long) actual_screen_map_rectangle->os_point[3].x - actual_screen_map_rectangle->os_point[1].x)*best_pos_a + ((long long) actual_screen_map_rectangle->os_point[1].x*TOUCHSCREEN_DOUBLE_INTEGER) - pa.x)
                    *best_pos_b)/TOUCHSCREEN_DOUBLE_INTEGER))/TOUCHSCREEN_DOUBLE_INTEGER;
os_point->y=(pa.y + (((((long long) actual_screen_map_rectangle->os_point[3].y - actual_screen_map_rectangle->os_point[1].y)*best_pos_a + ((long long) actual_screen_map_rectangle->os_point[1].y*TOUCHSCREEN_DOUBLE_INTEGER) - pa.y)
                    *best_pos_b)/TOUCHSCREEN_DOUBLE_INTEGER))/TOUCHSCREEN_DOUBLE_INTEGER;
return true;
}

/** Initializes a given touch_screen_control_struct structure. */
bool touch_screen_initialize(touch_screen_control_struct *touch_screen_control)
{

if (!touch_screen_control) return false;
touch_screen_control->panel_type=TOUCHSCREEN_TYPE_NOT_DEFINED;
touch_screen_control->state=TOUCHSCREEN_STATE_RELEASED;
touch_screen_control->input_file_handle=0;
touch_screen_control->buffer_size=0;
strcpy(touch_screen_control->device_name, "");
return true;
}

extern void touch_screen_prepare_change_detect_rpi_disp7(touch_screen_control_struct *touch_screen_control);

/** Claims USB connection to touch screen.
    The USB device number of the touch screen and a pointer to a touch_screen_control_struct structure
    must be given.

    The function will fill the connection structure and return NULL or
    a pointer to an error block if the connection cannot be claimed. */
_kernel_oserror *touch_screen_claim_control(unsigned int screen_usb_device_number,
                                            touch_screen_control_struct *touch_screen_control,
                                            int panel_type)

{
_kernel_swi_regs regs;
_kernel_oserror *error_os;

if (!touch_screen_control) return NULL;
touch_screen_initialize(touch_screen_control);
touch_screen_control->panel_type=panel_type;
touch_screen_control->screen_usb_device_number=screen_usb_device_number;
switch(touch_screen_control->panel_type) {
  case TOUCHSCREEN_TYPE_DWAV_EGALAX:
  case TOUCHSCREEN_TYPE_DWAV_EGALAX_HID:
  case TOUCHSCREEN_TYPE_DWAV_EGALAX_HID2: {
    char device_name[60];
    int ioctl_block[2];

    sprintf(touch_screen_control->device_name, "USB%d", touch_screen_control->screen_usb_device_number);
    /* Size makes usage of the buffer manager.
       This can contain size-1 bytes.
       The touch screen transfers 2*8 Bytes however.
       If this can't be transferred the device will reset.
       More bytes are unused. Therefore 17 Bytes as buffer size is the right
       choice. */
    sprintf(device_name, "Devices#endpoint1;interrupt;size257:USB%d", touch_screen_control->screen_usb_device_number);
    regs.r[0]=0x47;
    regs.r[1]=(int) device_name;
    regs.r[2]=NULL;
    if ((error_os=_kernel_swi(OS_Find, &regs, &regs)) != NULL) {
      touch_screen_initialize(touch_screen_control);
      return error_os;
      }
    touch_screen_control->input_file_handle=regs.r[0];
    /* Non Blocking */
    ioctl_block[0]=0x80FF0001;
    ioctl_block[1]=0x00000001;
    regs.r[0]=9;
    regs.r[1]=touch_screen_control->input_file_handle;
    regs.r[2]=(int) ioctl_block;
    if ((error_os=_kernel_swi(OS_Args, &regs, &regs)) != NULL) {
      touch_screen_initialize(touch_screen_control);
      return error_os;
      }
    /* Drop actual buffer content. */
    regs.r[0]=4;
    regs.r[1]=touch_screen_control->input_file_handle;
    regs.r[2]=(int) touch_screen_control->buffer;
    regs.r[3]=256;
    if ((error_os=_kernel_swi(OS_GBPB, &regs, &regs)) != NULL) {
      touch_screen_initialize(touch_screen_control);
      return error_os;
      }
    }
  break;
  case TOUCHSCREEN_TYPE_RPI_DISPLAY7: {
    int *hal_device;

    regs.r[0]=0x602;
    regs.r[1]=0;
    regs.r[8]=4;
    if ((error_os=_kernel_swi(OS_Hardware, &regs, &regs)) != NULL) {
      touch_screen_initialize(touch_screen_control);
      return error_os;
      }
    if (regs.r[1] == -1) {
      touch_screen_initialize(touch_screen_control);
      touch_screen_control->error_os.errnum=0;
      strcpy(touch_screen_control->error_os.errmess, "Can't access RPi 7"" display!");
      return &touch_screen_control->error_os;
      }
    hal_device=(int *) regs.r[2];
    touch_screen_control->touch_register_base=(unsigned char *) hal_device[4];
    touch_screen_prepare_change_detect_rpi_disp7(touch_screen_control);
    }
  break;
  default: {
    touch_screen_control->error_os.errnum=0;
    sprintf(touch_screen_control->error_os.errmess,
            "Invalid device type %d.",
            touch_screen_control->panel_type);
    touch_screen_initialize(touch_screen_control);
    return &touch_screen_control->error_os;
    }
  }
return NULL;
}

extern int touch_screen_get_position_usb(touch_screen_control_struct *touch_screen_control, int panel_type, bool clean_buffer);
extern int touch_screen_get_position_rpi_disp7(touch_screen_control_struct *touch_screen_control);

/** The function will release the control over the touch screen
    if it is still valid. You must pass a pointer to a valid
    touch_screen_control_struct structure. */
bool touch_screen_release_control(touch_screen_control_struct *touch_screen_control)
{
_kernel_swi_regs regs;

if (!touch_screen_control) return false;
if (touch_screen_control->input_file_handle != 0) {
  regs.r[0]=0;
  regs.r[1]=touch_screen_control->input_file_handle;
  _kernel_swi(OS_Find, &regs, &regs);
  }
touch_screen_initialize(touch_screen_control);
return true;
}

/** The function will update the x and y position of the pen on the screen and the button state
    inside a given touch_screen_control_struct structure.

    It will return the information whether an error occurred or the
    position of the pen has been changed. */
int touch_screen_get_position(touch_screen_control_struct *touch_screen_control)
{

if (!touch_screen_control) return TOUCHSCREEN_CONNECTION_RESULT_ERROR;
switch(touch_screen_control->panel_type) {
  case TOUCHSCREEN_TYPE_DWAV_EGALAX:
  case TOUCHSCREEN_TYPE_DWAV_EGALAX_HID:
  case TOUCHSCREEN_TYPE_DWAV_EGALAX_HID2: {
    return touch_screen_get_position_usb(touch_screen_control,
                                         touch_screen_control->panel_type,
                                         false);
    }
  break;
  case TOUCHSCREEN_TYPE_RPI_DISPLAY7: {
    return touch_screen_get_position_rpi_disp7(touch_screen_control);
    }
  break;
  default: {
    return TOUCHSCREEN_CONNECTION_RESULT_ERROR;
    }
  }
}

/** Changes the the shape of the mouse pointer in accordance to
    a given number.

    The number 0 will set the pointer back to "ptr_default".
    There are three other shapes possible which are called
    "ptr_btemu1", "ptr_btemu2" and "ptr_btemu3" and must have
    been loaded into WimpSrite pool.

    The "ptr_btemu" pointers are indicating the emulated button
    SELECT, MENU and ADJSUT during the button emulation selection
    phase. */
void change_pointer(int new_pointer_number)
{
char sprite_name[40];
_kernel_swi_regs regs;

if ((new_pointer_number > 0) &&
    (new_pointer_number <= 3)) {
  sprintf(sprite_name, "ptr_btemu%d", new_pointer_number);
  regs.r[2]=(int) sprite_name;
  regs.r[3]=0x00000061;
  }
else {
  regs.r[2]=(int) "ptr_default";
  regs.r[3]=0x00000061;
  }
regs.r[0]=36;
regs.r[4]=0;
regs.r[5]=0;
regs.r[6]=0;
regs.r[7]=0;
_kernel_swi(Wimp_SpriteOp, &regs, &regs);
}

/** Adds the difference between the actual touch point in os coordinates and
    the last reported point to the registers and reports changes of mouse clicks
    to the OS. */
bool report_action(int actual_button,
                   int *last_reported_button,
                   point *actual_os_point,
                   point *last_reported_point,
                   _kernel_swi_regs *ex_regs)
{
_kernel_swi_regs regs;

/* Report movement */
ex_regs->r[2]=(long) ex_regs->r[2] + actual_os_point->x - last_reported_point->x;
ex_regs->r[3]=(long) ex_regs->r[3] + actual_os_point->y - last_reported_point->y;
*last_reported_point=*actual_os_point;
/* Report button state */
if (actual_button != *last_reported_button) {
  if (*last_reported_button != TOUCHSCREEN_DRIVER_BUTTON_NONE) {
    regs.r[0]=1;
    regs.r[1]=*last_reported_button;
    regs.r[9]=0x00000013;
    if (_kernel_swi(OS_CallAVector, &regs, &regs) != NULL) return false;
    }
  if (actual_button != TOUCHSCREEN_DRIVER_BUTTON_NONE) {
    regs.r[0]=2;
    regs.r[1]=actual_button;
    regs.r[9]=0x00000013;
    if (_kernel_swi(OS_CallAVector, &regs, &regs) != NULL) return false;
    }
  *last_reported_button=actual_button;
  }
return true;
}

/*+ Returns the actual mouse position of the OS in a given point or an error.

    This function is necassry at start of the driver to fetch the actual position
    for the mouse driver concept onyl supports relative movements. RISC OS
    adjust the osue position form to time aysnchronously so the driver
    has to be resyncronized. */
_kernel_oserror *sync_mouse_position(point *actual_os_point)
{
unsigned char position_info[5];
_kernel_swi_regs regs;
_kernel_oserror *error_os;

position_info[0]=6;
regs.r[0]=21;
regs.r[1]=(int) position_info;
if ((error_os=_kernel_swi(OS_Word, &regs, &regs)) != NULL) return error_os;
actual_os_point->x=(position_info[2] << 8) | position_info[1];
actual_os_point->y=(position_info[4] << 8) | position_info[3];
return NULL;
}

/** The function fetches three mouse settings of RISC OS.

    These are MouseStep, WimpDoubleClickDelay and WimpDragMove.

    WimpDoubleClickDelay is used by the driver also to determine the
    time after which a new button emulation selection cycle may be
    introduced.

    WimpDragMove is required to get the OS Units when RISC OS
    recognizes a Drag movement of the cursor. The concept of the driver
    requires recognition of such a situation too for it delays the click
    on the first position until the pen is released or a drag is detect.

    Fetching of MouseStep is necassary to restore the value when the driver
    is disabled. The driver needs to set the MouseStep to 1 to report
    relative movements in such a way that an absolut position on the screen
    is reached. */
_kernel_oserror *get_os_settings(void)
{
char *command;
char *temporary_file_name;
_kernel_swi_regs regs;
_kernel_oserror *error_os;
FILE *settings_file;

/* Get common OS Mouse settings. */
/* All with malloc due to heap limitations in module. */
if ((command=malloc(L_tmpnam + 50)) == NULL) {
  common.error_os.errnum=0;
  strcpy(common.error_os.errmess, "Can't allocate memory for command.");
  return &common.error_os;
  }
if ((temporary_file_name=malloc(L_tmpnam)) == NULL) {
  common.error_os.errnum=0;
  strcpy(common.error_os.errmess, "Can't allocate memory for temporary file name.");
  free(command);
  return &common.error_os;
  }
if (!tmpnam(temporary_file_name)) {
  common.error_os.errnum=0;
  strcpy(common.error_os.errmess, "Can't get temporary file name.");
  free(temporary_file_name);
  free(command);
  return &common.error_os;
  }
sprintf(command, "status MouseStep { > %s }", temporary_file_name);
regs.r[0]=(int) command;
if ((error_os=_kernel_swi(OS_CLI, &regs, &regs)) != NULL) {
  remove(temporary_file_name);
  free(temporary_file_name);
  free(command);
  return error_os;
  }
sprintf(command, "status WimpDoubleClickDelay { >> %s }", temporary_file_name);
regs.r[0]=(int) command;
if ((error_os=_kernel_swi(OS_CLI, &regs, &regs)) != NULL) {
  remove(temporary_file_name);
  free(temporary_file_name);
  free(command);
  return error_os;
  }
sprintf(command, "status WimpDragMove { >> %s }", temporary_file_name);
regs.r[0]=(int) command;
if ((error_os=_kernel_swi(OS_CLI, &regs, &regs)) != NULL) {
  remove(temporary_file_name);
  free(temporary_file_name);
  free(command);
  return error_os;
  }
if ((settings_file=fopen(temporary_file_name, "r")) == NULL) {
  common.error_os.errnum=0;
  sprintf(common.error_os.errmess, "Can't read temporary file %s.", temporary_file_name);
  remove(temporary_file_name);
  free(temporary_file_name);
  free(command);
  return &common.error_os;
  }
if (fscanf(settings_file, "%*s%*[ ]%d\n", &common.mouse_speed) != 1) {
  common.error_os.errnum=0;
  strcpy(common.error_os.errmess, "Can't read actual MouseStep.");
  fclose(settings_file);
  remove(temporary_file_name);
  free(temporary_file_name);
  free(command);
  return &common.error_os;
  }
if (fscanf(settings_file, "%*s%*[ ]%d%*[^\n]\n", &common.double_click_interval) != 1) {
  common.error_os.errnum=0;
  strcpy(common.error_os.errmess, "Can't read actual WimpDoubleClickDelay");
  fclose(settings_file);
  remove(temporary_file_name);
  free(temporary_file_name);
  free(command);
  return &common.error_os;
  }
common.double_click_interval*=10;
if (fscanf(settings_file, "%*s%*[ ]%d%*[^\n]\n", &common.movement_distance) != 1) {
  common.error_os.errnum=0;
  strcpy(common.error_os.errmess, "Can't read actual WimpDragMove");
  fclose(settings_file);
  remove(temporary_file_name);
  free(temporary_file_name);
  free(command);
  return &common.error_os;
  }
fclose(settings_file);
remove(temporary_file_name);
free(temporary_file_name);
free(command);
return NULL;
}

/** This function enables the touchscreen driver.

    It therefore initializes some internal variables,
    notes the actual mouse positon and some RISC OS mouse related
    settings by calling get_os_settings(). It also loads the touchscreen
    configuration by calling !set_up_configuration(). Then it
    takes over the controll of the USB connection to the touchscreen
    and set mouse speed to 1. */
_kernel_oserror *tchscrn_driver_enable(int panel_type,
                                       int screen_usb_device_number)
{
unsigned char mouse_mutilpliers[3];
_kernel_swi_regs regs;
_kernel_oserror *error_os;

/* Initialize pointer handler state */
common.status=TOUCHSCREEN_DRIVER_STATE_IDLE;
common.last_button_emu_shown=0;
/* Get actual mouse position as base for first relative movement. */
if ((error_os=sync_mouse_position(&common.last_reported_point)) != NULL) return error_os;
/* Initialize button hanndling */
common.last_button=TOUCHSCREEN_DRIVER_BUTTON_NONE;
common.last_reported_button=common.last_button;
/* Set up configuration */
if (!set_up_configuration()) {
   common.error_os.errnum=0;
   strcpy(common.error_os.errmess, "Failed to setup configuration.");
   return &common.error_os;
  }
/* Get OS settings */
if ((error_os=get_os_settings()) != NULL) {
  return error_os;
  }
/* Claim control over the touch screen. */
if ((error_os=touch_screen_claim_control(screen_usb_device_number,
                                         &common.touch_screen_control,
                                         panel_type)) != NULL) {
  return error_os;
  }
/* Set "Mouse Speed" to 1 for touch screens. */
mouse_mutilpliers[0]=2;
mouse_mutilpliers[1]=1;
mouse_mutilpliers[2]=1;
regs.r[0]=21;
regs.r[1]=(int) mouse_mutilpliers;
if ((error_os=_kernel_swi(OS_Word, &regs, &regs)) != NULL) {
  touch_screen_release_control(&common.touch_screen_control);
  return error_os;
  }
common.enabled_flag=true;
common.screen_info_changes=false;
return NULL;
}

/** Disables the touchscreen driver if it is enabled. A given flag
    determines whether RISC OS shall be informed to restore the
    mouse driver which was active before the touchscreen driver was enabled.

    The USB connection is relased. Pointer is set to its regular shape
    and the mouse speed is restored. */
void tchscrn_driver_disable(bool reactivate_previous_driver)
{
unsigned char mouse_mutilpliers[3];
_kernel_swi_regs regs;

if (common.enabled_flag) {
  common.enabled_flag=false;
  /* Reset the pointer if it should be not at default. */
  change_pointer(0);
  /* Release control over the touch screen. */
  touch_screen_release_control(&common.touch_screen_control);
  /* Set "Mouse Speed" back to old value. */
  mouse_mutilpliers[0]=2;
  mouse_mutilpliers[1]=common.mouse_speed;
  mouse_mutilpliers[2]=common.mouse_speed;
  regs.r[0]=21;
  regs.r[1]=(int) mouse_mutilpliers;
  _kernel_swi(OS_Word, &regs, &regs);
  if ((common.last_active_driver != TOUCHSCREEN_MOUSE_DRIVER_NUMBER) &&
      (reactivate_previous_driver)) {
    /* Reenable the driver used before. */
    regs.r[0]=1;
    regs.r[1]=common.last_active_driver;
    /* No error handling because this would driver prevent
       from finishing. */
    _kernel_swi(OS_Pointer, &regs, &regs);
    }
  }
}

/** Controls mouse movements by updating the given registers
    if necassary and handles the mouse button emulation by
    a state machine.

    <center><img src="../../../Manual/State_Scheme.png" width="0" height="0" border="0"></center>

    - 0 Do nothing.
    - 1 Sync actual mouse position.
        Place cursor to touch point.
        Note touch point for movement detection.
        Reset button emulation time.
    - 2 Change cursor in accordance to button emulation time.
    - 3 Change cursor to regular shape.
        Report button at actual position.
        Report released button at the same position.
    - 4 Change cursor to regular shape.
        Report button at first touch point.
        Report button at actual position.
    - 5 Do nothing.
    - 6 Report button at actual position.
    - 7 Report actual position.
    - 8 Report released button at actual position.
    - 9 Report button at actual position.
        Report released button at the same position.
    - 10 Do nothing. */
int handle_screen_activities(_kernel_swi_regs *ex_regs)
{
int i;
int button_emu;
unsigned int total_button_change_time;
unsigned int actual_button_change_time;
_kernel_swi_regs regs;
point actual_screen_point;
point actual_os_point;

/* Movements must be acumulated.
   Therefore they must be initialized to no movement. */
ex_regs->r[2]=0;
ex_regs->r[3]=0;
switch(common.status) {
  case TOUCHSCREEN_DRIVER_STATE_IDLE: {
    if (common.screen_info_changes) {
      if (common.touch_screen_control.state == TOUCHSCREEN_STATE_PRESSED) {
        /* Syncronize mouse position for it can be set by RISC OS. */
        sync_mouse_position(&common.last_reported_point);
        ex_regs->r[2]=0;
        ex_regs->r[3]=0;
        /* Note actual screen point to detect movements */
        actual_screen_point.x=common.touch_screen_control.last_x_position;
        actual_screen_point.y=common.touch_screen_control.last_y_position;
        if (transform_touchscreen_point(&common.map,
                                        &actual_screen_point,
                                        &common.start_point)) {
          /* Show cursor at click position without click. */
          report_action(TOUCHSCREEN_DRIVER_BUTTON_NONE,
                        &common.last_reported_button,
                        &common.start_point,
                        &common.last_reported_point,
                        ex_regs);
          common.last_button=common.button_emu[0];
          /* Note the actual time for button emulation */
          _kernel_swi(OS_ReadMonotonicTime, &regs, &regs);
          common.start_time=regs.r[0];
          common.status=TOUCHSCREEN_DRIVER_STATE_BUTTTON_SELECTION;
          }
#ifdef USE_SYSLOG
        else {
          if (common.debug) {
            syslogf(common.logname,
                    TOUCHSCREEN_DEBUG_DETAIL,
                    "Transformation failed for %ld %ld",
                    actual_screen_point.x,
                    actual_screen_point.y);
            }
          }
#endif
        }
      }
    }
  break;
  case TOUCHSCREEN_DRIVER_STATE_BUTTTON_SELECTION: {
    /* Update button emulation according to time */
    /* Total time for button states (could be precalculated but it doesn't take much power) */
    total_button_change_time=0;
    for (i=0; i < TOUCHSCREEN_BUTTON_EMULATION_STATES; i++) {
      total_button_change_time+=common.button_change_time[i];
      }
    _kernel_swi(OS_ReadMonotonicTime, &regs, &regs);
    /* Adjust repeating interval so as if it would have just started to simplify comparism. */
    actual_button_change_time=(regs.r[0] - common.start_time)%total_button_change_time;
    /* Reuse variable but now with total time until end of assumed button emulation state. */
    total_button_change_time=0;
    button_emu=0;
    while (button_emu < TOUCHSCREEN_BUTTON_EMULATION_STATES) {
      total_button_change_time+=common.button_change_time[button_emu];
      if (actual_button_change_time <= total_button_change_time) {
        /* Found the actual required button emulation. */
        break;
        }
      button_emu++;
      }
    common.last_button=common.button_emu[button_emu];
    if (button_emu != common.last_button_emu_shown) {
      change_pointer(button_emu);
      }
    common.last_button_emu_shown=button_emu;
    if (common.screen_info_changes) {
      /* Check for moving */
      actual_screen_point.x=common.touch_screen_control.last_x_position;
      actual_screen_point.y=common.touch_screen_control.last_y_position;
      if (transform_touchscreen_point(&common.map,
                                      &actual_screen_point,
                                      &actual_os_point)) {
        if ((abs(actual_os_point.x - common.start_point.x) >= common.movement_distance) ||
            (abs(actual_os_point.y - common.start_point.y) >= common.movement_distance)) {
          change_pointer(0);
          report_action(common.last_button,
                        &common.last_reported_button,
                        &common.start_point,
                        &common.last_reported_point,
                        ex_regs);
          report_action(common.last_reported_button,
                        &common.last_reported_button,
                        &actual_os_point,
                        &common.last_reported_point,
                        ex_regs);
          common.last_button_emu_shown=0;
          /* Note time to handle idle */
          _kernel_swi(OS_ReadMonotonicTime, &regs, &regs);
          /* Just out of time to allow reselection of button. */
          common.start_time=regs.r[0] - common.double_click_interval;
          common.status=TOUCHSCREEN_DRIVER_STATE_PRESSED;
          }
        else {
          if (common.touch_screen_control.state == TOUCHSCREEN_STATE_RELEASED) {
            change_pointer(0);
            report_action(common.last_button,
                          &common.last_reported_button,
                          &actual_os_point,
                          &common.last_reported_point,
                          ex_regs);
            report_action(TOUCHSCREEN_DRIVER_BUTTON_NONE,
                          &common.last_reported_button,
                          &common.last_reported_point,
                          &common.last_reported_point,
                          ex_regs);
            common.last_button_emu_shown=0;
            if ((common.last_button == TOUCHSCREEN_DRIVER_BUTTON_NONE) ||
                (common.last_button == TOUCHSCREEN_DRIVER_BUTTON_MENU))  {
              common.last_button=TOUCHSCREEN_DRIVER_BUTTON_NONE;
              common.status=TOUCHSCREEN_DRIVER_STATE_IDLE;
              }
            else {
              /* Note time to handle idle */
              _kernel_swi(OS_ReadMonotonicTime, &regs, &regs);
              common.start_time=regs.r[0];
              common.status=TOUCHSCREEN_DRIVER_STATE_RELEASED;
              }
            }
          }
        }
#ifdef USE_SYSLOG
      else {
        if (common.debug) {
          syslogf(common.logname,
                  TOUCHSCREEN_DEBUG_DETAIL,
                  "Transformation failed for %ld %ld",
                  actual_screen_point.x,
                  actual_screen_point.y);
          }
        }
#endif
      }
    }
  break;
  case TOUCHSCREEN_DRIVER_STATE_RELEASED: {
    if (common.screen_info_changes) {
      /* Wait a certain time to handle multiple clicks */
      if (common.touch_screen_control.state == TOUCHSCREEN_STATE_PRESSED) {
        /* Syncronize mouse position for it can be set by RISC OS. */
        sync_mouse_position(&common.last_reported_point);
        ex_regs->r[2]=0;
        ex_regs->r[3]=0;
        /* Report actual position */
        actual_screen_point.x=common.touch_screen_control.last_x_position;
        actual_screen_point.y=common.touch_screen_control.last_y_position;
        if (transform_touchscreen_point(&common.map,
                                        &actual_screen_point,
                                        &actual_os_point)) {
          report_action(common.last_button,
                        &common.last_reported_button,
                        &actual_os_point,
                        &common.last_reported_point,
                        ex_regs);
          common.status=TOUCHSCREEN_DRIVER_STATE_PRESSED;
          }
#ifdef USE_SYSLOG
        else {
          if (common.debug) {
            syslogf(common.logname,
                    TOUCHSCREEN_DEBUG_DETAIL,
                    "Transformation failed for %ld %ld",
                    actual_screen_point.x,
                    actual_screen_point.y);
            }
          }
#endif
        }
      }
    /* Check for multiple click timeout. */
    _kernel_swi(OS_ReadMonotonicTime, &regs, &regs);
    if ((regs.r[0] - common.start_time) >= common.double_click_interval) {
      common.last_button=TOUCHSCREEN_DRIVER_BUTTON_NONE;
      common.status=TOUCHSCREEN_DRIVER_STATE_IDLE;
      }
    }
  break;
  case TOUCHSCREEN_DRIVER_STATE_PRESSED: {
    if (common.screen_info_changes) {
      /* Report actual position */
      actual_screen_point.x=common.touch_screen_control.last_x_position;
      actual_screen_point.y=common.touch_screen_control.last_y_position;
      if (transform_touchscreen_point(&common.map,
                                      &actual_screen_point,
                                      &actual_os_point)) {
        if (common.touch_screen_control.state == TOUCHSCREEN_STATE_RELEASED) {
          report_action(TOUCHSCREEN_DRIVER_BUTTON_NONE,
                        &common.last_reported_button,
                        &actual_os_point,
                        &common.last_reported_point,
                        ex_regs);
          common.status=TOUCHSCREEN_DRIVER_STATE_RELEASED;
          }
        else {
          report_action(common.last_button,
                        &common.last_reported_button,
                        &actual_os_point,
                        &common.last_reported_point,
                        ex_regs);
          }
        }
#ifdef USE_SYSLOG
      else {
        if (common.debug) {
          syslogf(common.logname,
                  TOUCHSCREEN_DEBUG_DETAIL,
                  "Transformation failed for %ld %ld",
                  actual_screen_point.x,
                  actual_screen_point.y);
          }
        }
#endif
      }
    }
  break;
  default: {
    /* Should never occur. */
    tchscrn_driver_disable(true);
    }
  }
common.screen_info_changes=false;
return IRQ_CLAIMED;
}

/* !!!!!!!!!! functions !!!!!!!!!! */
/** Handle screen mode changes in such a way that the screen map rectangles
    are rebuild in accordance to the new resolution.

    It uses set_up_configuration() to do so if the driver is enabled. */
void mode_change(int service_number,
                 _kernel_swi_regs *ex_regs,
                 void *pw)
{

switch(service_number) {
  case 0x00000046: {
    if (common.enabled_flag) {
      set_up_configuration();
      }
    break;
    }
  }
}

/** Performs USB actitivities to touch screen with interrupts enabled
    at TickerV.

    Concept is similar to that of other mouse drivers. */
int ticker_handler(_kernel_swi_regs *ex_regs,
                   void *pw)
{
int irq_flag;
bool activity_flag;

if (common.enabled_flag) {
  if (!common.in_use) {
    /* Protect against asynchronues activity. */
    common.in_use=true;
    /* Enable IRQs to avoid delaying of something. */
    irq_flag=_kernel_irqs_disabled();
    if (irq_flag != 0) {
      _kernel_irqs_on();
      }
    /* Evaluate all pending USB information. */
    activity_flag=true;
    do {
      switch(touch_screen_get_position(&common.touch_screen_control)) {
        case TOUCHSCREEN_CONNECTION_RESULT_ERROR: {
          /* Abort */
          tchscrn_driver_disable(true);
          activity_flag=false;
          }
        break;
        case TOUCHSCREEN_CONNECTION_RESULT_NO_DATA: {
          /* Evaluation finished. */
          activity_flag=false;
          }
        break;
        case TOUCHSCREEN_CONNECTION_RESULT_NO_CHANGE: {
          /* Continue with evaluation of activities */
          }
        break;
        case TOUCHSCREEN_CONNECTION_RESULT_CHANGE: {
#ifdef USE_SYSLOG
          if (common.debug) {
            syslogf(common.logname,
                    TOUCHSCREEN_DEBUG_DETAIL,
                    "Touchscreen point activities at %d %d",
                    common.touch_screen_control.last_x_position,
                    common.touch_screen_control.last_y_position);
            }
#endif
          /* Note that changes happened but not more.
             In case of too fast clicks they are ignored. */
          common.screen_info_changes=true;
          }
        break;
        default: {
          /* Abort */
          tchscrn_driver_disable(true);
          activity_flag=false;
          }
        }
      }
    while(activity_flag);
    /* Restore previous IRQ state. */
    if (irq_flag != 0) {
      _kernel_irqs_off();
      }
    common.in_use=false;
    }
  }
return IRQ_NOT_CLAIMED;
}

/** Handles the mouse activites for PointerV.

    Read the according RISC OS Programmers Manual section for
    further details. */
int pointer_handler(_kernel_swi_regs *ex_regs,
                    void *pw)
{
int result;

switch(ex_regs->r[0]) {
  case 0: {
    if ((ex_regs->r[1] == TOUCHSCREEN_MOUSE_DRIVER_NUMBER) &&
        (common.enabled_flag)) {
      if (!common.in_use) {
        common.in_use=true;
        /* Perform movement and clicks. */
        result=handle_screen_activities(ex_regs);
        common.in_use=false;
        return result;
        }
      else {
        /* In case that driver is already active
           leave all as it is. */
        ex_regs->r[2]=0;
        ex_regs->r[3]=0;
        return IRQ_CLAIMED;
        }
      }
    }
  break;
  case 1: {
    /* RISC OS mouse driver information structure */
    struct info_structur {
    void *next_info_block;
    unsigned long flags;
    unsigned long device_type;
    char device_name[30];
    } *info;

    /* Information */
    if ((info=malloc(sizeof(struct info_structur))) != NULL) {
      info->next_info_block=(void *) ex_regs->r[1];
      info->flags=0;
      info->device_type=TOUCHSCREEN_MOUSE_DRIVER_NUMBER;
      strcpy(info->device_name, "Touchscreen driver");
      ex_regs->r[1]=(int) info;
      }
    }
  break;
  case 2: {
    /* Enable/Disable. */
    if (ex_regs->r[1] == TOUCHSCREEN_MOUSE_DRIVER_NUMBER) {
      if (!common.enabled_flag) {
        tchscrn_driver_enable(common.panel_type,
                              common.screen_usb_device_number);
        }
      }
    else {
      common.last_active_driver=ex_regs->r[1];
      /* Criticial if in usage, but it would have to be postphoned
         and this makes not much sense. */
      tchscrn_driver_disable(false);
      }
    }
  break;
  }
return IRQ_NOT_CLAIMED;
}

/** Synchronizes the button state in accordance to
   to the kayboard handler (keyV). */
int key_handler(_kernel_swi_regs *ex_regs,
                void *pw)
{

switch(ex_regs->r[0]) {
  case 4: {
    common.last_reported_button=TOUCHSCREEN_DRIVER_BUTTON_NONE;
    }
  break;
  }
return IRQ_NOT_CLAIMED;
}

/** Handles the commands provided by the module.

    The commands are providing the possibilty
    - to <a href="../../../Manual/specification.html#TchScrn_Register">activate the driver</a>
    - to <a href="../../../Manual/specification.html#TchScrn_Disable">disable the driver especally in case of calibration</a>
    - to <a href="../../../Manual/specification.html#TchScrn_TellPoint">Prints the pressed point. used for debugging and calibration</a>
    - to <a href="../../../Manual/specification.html#TchScrn_Debug_On">enable writing of debug messages to syslog.</a> */
_kernel_oserror *tchscrn_driver_commands(char *arg_string,
                                         int argc,
                                         int cmd_no,
                                         void *pw)
{
char output[100];
char **arguments;
char temp_string[100];
_kernel_swi_regs regs;
_kernel_oserror *error_os;

switch(cmd_no) {
  case 0: {
    /* Start driver for a certain USB device number. */
    tchscrn_driver_disable(true);
    /* Get parameters here. Endpoint must be deregistered at any
       problem. Therefore they must be known from the beginning
       on. */
    /* Split up String into parts */
    regs.r[0]=(int) "type/K,devno";
    regs.r[1]=(int) arg_string;
    regs.r[2]=(int) output;
    regs.r[3]=99;
    _kernel_swi(OS_ReadArgs, &regs, &regs);
    /* Terminate last entry (a string) with zero.
       If last parameter is not given the termintion will automatically move one parameter
       forward and so on. */
    output[99 - regs.r[3]]='\0';
    arguments=(char **) output;
    /* Detemine device to emnulate */
    if (arguments[0]) {
      if (arguments[1]) {
        strncpy(temp_string, arguments[0], arguments[1] - arguments[0]);
        temp_string[arguments[1] - arguments[0]]='\0';
        }
      else {
        /* Terminated above */
        strcpy(temp_string, arguments[0]);
        }
      if (strcmp(temp_string, "egalax") == 0) {
        common.panel_type=TOUCHSCREEN_TYPE_DWAV_EGALAX;
        }
      else if (strcmp(temp_string, "egalax_hid") == 0) {
        common.panel_type=TOUCHSCREEN_TYPE_DWAV_EGALAX_HID;
        }
      else if (strcmp(temp_string, "egalax_hid2") == 0) {
        common.panel_type=TOUCHSCREEN_TYPE_DWAV_EGALAX_HID2;
        }
      else if (strcmp(temp_string, "rpi_display7") == 0) {
        common.panel_type=TOUCHSCREEN_TYPE_RPI_DISPLAY7;
        common.screen_usb_device_number=0;
        }
      else {
        common.error_os.errnum=0;
        strcpy(common.error_os.errmess, "Device type not supported.");
        return &common.error_os;
        }
      }
    else {
      common.panel_type=TOUCHSCREEN_TYPE_DWAV_EGALAX;
      }
    if ((common.panel_type == TOUCHSCREEN_TYPE_DWAV_EGALAX) ||
        (common.panel_type == TOUCHSCREEN_TYPE_DWAV_EGALAX_HID) ||
        (common.panel_type == TOUCHSCREEN_TYPE_DWAV_EGALAX_HID2)) {
      if (arguments[1]) {
        /* String has been terminated properly. */
        common.screen_usb_device_number=atoi(arguments[1]);
        }
      else {
        common.error_os.errnum=0;
        strcpy(common.error_os.errmess, "You must enter an USB device number.");
        return &common.error_os;
        }
      }
    if ((error_os=tchscrn_driver_enable(common.panel_type,
                                        common.screen_usb_device_number)) != NULL) return error_os;
    /* Tell RISC OS to enable the driver */
    regs.r[0]=1;
    regs.r[1]=TOUCHSCREEN_MOUSE_DRIVER_NUMBER;
    _kernel_swi(OS_Pointer, &regs, &regs);
    }
  break;
  case 1: {
    /* Disable the driver by command eg. during calibration. */
    if (common.enabled_flag) {
      tchscrn_driver_disable(true);
      }
    }
  break;
  case 2: {
    bool use_actual_connection;
    bool wait_for_result;
    int wait_time;

    /* Tell actual point for a given device in device values. */
    if (common.enabled_flag) {
      if (argc > 0) {
        common.error_os.errnum=0;
        strcpy(common.error_os.errmess, "Touchscreen driver must be disabled!");
        return &common.error_os;
        }
      use_actual_connection=true;
      wait_for_result=false;
      }
    else {
      use_actual_connection=false;
      /* Split up String into parts */
      regs.r[0]=(int) "type/K,devno,wait/K";
      regs.r[1]=(int) arg_string;
      regs.r[2]=(int) output;
      regs.r[3]=99;
      if ((error_os=_kernel_swi(OS_ReadArgs, &regs, &regs)) != NULL) {
        return error_os;
        }
      /* Terminate last entry (a string) with zero.
         If last parameter is not given the termintion will automatically move one parameter
         forward and so on. */
      output[99 - regs.r[3]]='\0';
      arguments=(char **) output;
      /* Detemine device to emnulate */
      if (arguments[0]) {
        if (arguments[1]) {
          strncpy(temp_string, arguments[0], arguments[1] - arguments[0]);
          temp_string[arguments[1] - arguments[0]]='\0';
          }
        else if (arguments[2]) {
          strncpy(temp_string, arguments[0], arguments[2] - arguments[0]);
          temp_string[arguments[2] - arguments[0]]='\0';
          }
        else {
          /* Terminated above */
          strcpy(temp_string, arguments[0]);
          }
        if (strcmp(temp_string, "egalax") == 0) {
          common.panel_type=TOUCHSCREEN_TYPE_DWAV_EGALAX;
          }
        else if (strcmp(temp_string, "egalax_hid") == 0) {
          common.panel_type=TOUCHSCREEN_TYPE_DWAV_EGALAX_HID;
          }
        else if (strcmp(temp_string, "egalax_hid2") == 0) {
          common.panel_type=TOUCHSCREEN_TYPE_DWAV_EGALAX_HID2;
          }
        else if (strcmp(temp_string, "rpi_display7") == 0) {
          common.panel_type=TOUCHSCREEN_TYPE_RPI_DISPLAY7;
          common.screen_usb_device_number=0;
          }
        else {
          common.error_os.errnum=0;
          strcpy(common.error_os.errmess, "Device type not supported.");
          return &common.error_os;
          }
        }
      else {
        common.panel_type=TOUCHSCREEN_TYPE_DWAV_EGALAX;
        }
      if (arguments[2]) {
        /* Terminated above */
        wait_time=atoi(arguments[2]);
        }
      else {
        /* Wait for eternity if no touch happens. */
        wait_time=-1;
        }
      if ((common.panel_type == TOUCHSCREEN_TYPE_DWAV_EGALAX) ||
          (common.panel_type == TOUCHSCREEN_TYPE_DWAV_EGALAX_HID) ||
          (common.panel_type == TOUCHSCREEN_TYPE_DWAV_EGALAX_HID2)) {
        if (arguments[1]) {
          /* String has been terminated properly. */
          common.screen_usb_device_number=atoi(arguments[1]);
          }
        else {
          common.error_os.errnum=0;
          strcpy(common.error_os.errmess, "You must enter an USB device number.");
          return &common.error_os;
          }
        }
      /* Clear connection to device in any case. */
      touch_screen_release_control(&common.touch_screen_control);
      /* Setup the connection to device */
      if ((error_os=touch_screen_claim_control(common.screen_usb_device_number,
                                               &common.touch_screen_control,
                                               common.panel_type)) != NULL) return error_os;
      wait_for_result=true;
      }
    /* note time to allow waiting */
    _kernel_swi(OS_ReadMonotonicTime, &regs, &regs);
    common.touch_screen_control.last_pressure_time=regs.r[0];
    do {
      switch(touch_screen_get_position(&common.touch_screen_control)) {
        case TOUCHSCREEN_CONNECTION_RESULT_ERROR: {
          printf("Error: Can't access device.\n");
          wait_for_result=false;
          }
        break;
        case TOUCHSCREEN_CONNECTION_RESULT_NO_DATA:
        case TOUCHSCREEN_CONNECTION_RESULT_NO_CHANGE: {
          if (wait_time >= 0) {
            _kernel_swi(OS_ReadMonotonicTime, &regs, &regs);
            if ((regs.r[0] - common.touch_screen_control.last_pressure_time) > wait_time) {
              printf("Error: Screen not touched in time.\n");
              wait_for_result=false;
              }
            }
          }
        break;
        case TOUCHSCREEN_CONNECTION_RESULT_CHANGE: {
          printf("x: %d y: %d\n",
                 common.touch_screen_control.last_x_position,
                 common.touch_screen_control.last_y_position);
          wait_for_result=false;
          }
        break;
        default: {
          printf("Error: Invalid internal result.\n");
          wait_for_result=false;
          }
        }
      }
    while (wait_for_result);
    if (!use_actual_connection) {
      /* Sometimes a collection of points is reported and will disturb the next call.
         Clean this up. */
      do {
        touch_screen_get_position(&common.touch_screen_control);
        _kernel_swi(OS_ReadMonotonicTime, &regs, &regs);
        }
      while ((regs.r[0] - common.touch_screen_control.last_pressure_time) < 10);
      /* Clear connection to device. */
      touch_screen_release_control(&common.touch_screen_control);
      }
    }
  break;
  case 3: {
    regs.r[0]=(int) "V/K/S";
    regs.r[1]=(int) arg_string;
    regs.r[2]=(int) output;
    regs.r[3]=99;
    if ((error_os=_kernel_swi(OS_ReadArgs, &regs, &regs)) != NULL) {
      return error_os;
      }
    if (common.enabled_flag) {
      printf("Active\n");
      }
    else {
      printf("Inactive\n");
      }
    arguments=(char **) output;
    if (arguments[0] != 0) {
      switch(common.touch_screen_control.panel_type) {
        case TOUCHSCREEN_TYPE_DWAV_EGALAX: {
          printf("egalax USB%d\n", common.touch_screen_control.screen_usb_device_number);
          }
        break;
        case TOUCHSCREEN_TYPE_DWAV_EGALAX_HID: {
          printf("egalax_hid USB%d\n", common.touch_screen_control.screen_usb_device_number);
          }
        break;
        case TOUCHSCREEN_TYPE_DWAV_EGALAX_HID2: {
          printf("egalax_hid2 USB%d\n", common.touch_screen_control.screen_usb_device_number);
          }
        break;
        case TOUCHSCREEN_TYPE_RPI_DISPLAY7: {
          printf("rpi_display7\n");
          }
        break;
        }
      }
    }
  break;
#ifdef USE_SYSLOG
  case 4: {
    if (!common.debug) {
      common.debug=true;

      syslog_logmessage(common.logname,"Debug enabled.", TOUCHSCREEN_DEBUG_DETAIL);
      }
    }
  break;
#endif
  }
return NULL;
}

/** Handles installation of the driver module.

    Various values are initialized and some required vectors (PointerV, KeyV, TickerV) are claimed. */
_kernel_oserror *tchscrn_driver_install(char *cmd_tail,
                                        int podule_base,
                                        void *pw)
{
_kernel_swi_regs regs;
_kernel_oserror *error_os;

/* Sequence of button emulation */
common.button_emu[0]=TOUCHSCREEN_DRIVER_BUTTON_NONE;
common.button_emu[1]=TOUCHSCREEN_DRIVER_BUTTON_SELECT;
common.button_emu[2]=TOUCHSCREEN_DRIVER_BUTTON_MENU;
common.button_emu[3]=TOUCHSCREEN_DRIVER_BUTTON_ADJUST;
#ifdef USE_SYSLOG
strcpy(common.logname, "TchScrn");
common.debug=false;
#endif
common.in_use=false;
touch_screen_initialize(&common.touch_screen_control);
/* Note actual mouse driver.
   Further changes are kept by the vector handler. */
regs.r[0]=0;
if ((error_os=_kernel_swi(OS_Pointer, &regs, &regs)) != NULL) return error_os;
common.last_active_driver=regs.r[0];
/* Not enabled at first. */
common.enabled_flag=false;
/* Install RISCOS Driver */
regs.r[0]=0x00000013;
regs.r[1]=(int) key_handler_adap;
regs.r[2]=(int) pw;
if ((error_os=_kernel_swi(OS_Claim, &regs, &regs)) != NULL) {
  return error_os;
  }
regs.r[0]=0x00000026;
regs.r[1]=(int) pointer_handler_adap;
regs.r[2]=(int) pw;
if ((error_os=_kernel_swi(OS_Claim, &regs, &regs)) != NULL) {
  regs.r[0]=0x00000013;
  regs.r[1]=(int) key_handler_adap;
  regs.r[2]=(int) pw;
  _kernel_swi(OS_Release, &regs, &regs);
  return error_os;
  }
regs.r[0]=0x0000001C;
regs.r[1]=(int) ticker_handler_adap;
regs.r[2]=(int) pw;
if ((error_os=_kernel_swi(OS_Claim, &regs, &regs)) != NULL) {
  regs.r[0]=0x00000026;
  regs.r[1]=(int) pointer_handler_adap;
  regs.r[2]=(int) pw;
  _kernel_swi(OS_Release, &regs, &regs);
  regs.r[0]=0x00000013;
  regs.r[1]=(int) key_handler_adap;
  regs.r[2]=(int) pw;
  _kernel_swi(OS_Release, &regs, &regs);
  return error_os;
  }
return NULL;
}

/** Handles deinstallation of the driver modules.

    It is ensured that the driver is disabled and some vectors are released. */
_kernel_oserror *tchscrn_driver_deinstall(int fatal,
                                          int podule,
                                          void *pw)
{
_kernel_swi_regs regs;

/* Control goes back to other mouse driver */
tchscrn_driver_disable(true);
#ifdef USE_SYSLOG
if (common.debug) {
  syslog_logcomplete(common.logname);
  }
#endif
/* Release related vectors */
regs.r[0]=0x0000001C;
regs.r[1]=(int) ticker_handler_adap;
regs.r[2]=(int) pw;
_kernel_swi(OS_Release, &regs, &regs);
regs.r[0]=0x00000026;
regs.r[1]=(int) pointer_handler_adap;
regs.r[2]=(int) pw;
_kernel_swi(OS_Release, &regs, &regs);
regs.r[0]=0x00000013;
regs.r[1]=(int) key_handler_adap;
regs.r[2]=(int) pw;
_kernel_swi(OS_Release, &regs, &regs);
return NULL;
}
