/** @file

  Implements ... under RISC OS.

  */
/* Created 08.10.2011 T. Milius
   Changed 31.03.2012 T. Milius */
/* Copyright (c) 2011-2012 by Thomas Milius Stade, Germany
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Thomas Milius Stade, Germany nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Thomas Milius Stade, Germany ``AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Thomas Milius Stade, Germany BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
/** @mainpage
    @author Thomas Milius Stade, Germany
    @version 0.31
    @date 31.03.2012

 Implements ... under RISC OS.

    */
/* RISC OS */

/* !!!!!!!!!! libraries !!!!!!!!!! */
/* ---------- ANSI-C ---------- */
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

/* ------------ RISC OS ------------ */
#include "kernel.h"
#include "swis.h"
#include "Global/HALEntries.h"
#include "Global/HALDevice.h"
#include "Global/RISCOS.h"
#include "Global/Keyboard.h"
#include "Global/Pointer.h"
#include "Global/NewErrors.h"

/* ------------ Own ------------ */
#include "pandorakeyhead.h"
#include "pandorakey.h"
#include "nubs.h"
#include "gpio.h"
#include "gpiokey.h"

/* !!!!!!!!!!! definitions !!!!!!!!!! */

/* !!!!!!!!!! data structures !!!!!!!!!! */
static const unsigned char keypad_regoffset_rowcontent[MAX_ROWS]={0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10};

static const unsigned long key_mapping[2][MAX_ROWS][MAX_COLUMNS]={
/* No FN */
{
/* Row 0 */
{KeyNo_Digit9,       KeyNo_Digit8,    KeyNo_LetterI,          KeyNo_LetterJ,       KeyNo_LetterN,       KeyNo_LetterM,      KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 1 */                                                                                             
{KeyNo_Digit0,       KeyNo_Digit7,    KeyNo_LetterU,          KeyNo_LetterH,       KeyNo_LetterB,       KeyNo_Space,        KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 2 */                                                                                             
/* ignore FN. handled elsewhere */                                                                      
{KeyNo_BackSpace,    KeyNo_Digit6,    KeyNo_LetterY,          KeyNo_LetterG,       KeyNo_LetterV,       KEYMAPPING_NOTHING, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 3 */                                                                                             
{KeyNo_LetterO,      KeyNo_Digit5,    KeyNo_LetterT,          KeyNo_LetterF,       KeyNo_LetterC,       KEYMAPPING_NOTHING, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 4 */                                                                                             
{KeyNo_LetterP,      KeyNo_Digit4,    KeyNo_LetterR,          KeyNo_LetterD,       KeyNo_LetterX,       KEYMAPPING_NOTHING, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 5 */                                                                                             
{KeyNo_LetterK,      KeyNo_Digit3,    KeyNo_LetterE,          KeyNo_LetterS,       KeyNo_LetterZ,       KEYMAPPING_NOTHING, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 6 */                                                                                             
{KeyNo_LetterL,      KeyNo_Digit2,    KeyNo_LetterW,          KeyNo_LetterA,       KeyNo_Dot,           KEYMAPPING_NOTHING, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 7 */                                                                                             
{KeyNo_Return,       KeyNo_Digit1,    KeyNo_LetterQ,          KeyNo_ShiftLeft,     KeyNo_Comma,         KEYMAPPING_NOTHING, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING}
},                                                                                                      
/* FN */                                                                                                
{                                                                                                       
/* Row 0 */                                                                                             
{KeyNo_Function9,    KeyNo_Function8, KeyNo_BrightnessUp,     KeyNo_AcuteAccent,   KeyNo_DollarSign,    KeyNo_EuroSign,     KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 1 */                                                                                             
{KeyNo_Function10,   KeyNo_Function7, KeyNo_BrightnessDown,   KeyNo_BackTick,      KeyNo_VerticalLine,  KeyNo_Tab,          KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 2 */
/* ignore FN. handled elsewhere */
{KeyNo_Insert,       KeyNo_Function6, KeyNo_LowLine,          KeyNo_Equals,        KeyNo_BackSlash,     KEYMAPPING_NOTHING, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 3 */
{KeyNo_Function11,   KeyNo_Function5, KeyNo_ExclamationMark,  KeyNo_PlusSign,      KeyNo_NotFittedLeft, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 4 */
{KeyNo_Function12,   KeyNo_Function4, KeyNo_RightParenthesis, KeyNo_Minus,         KeyNo_QuestionMark,  KEYMAPPING_NOTHING, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 5 */                                                                                            
{KeyNo_Pound,        KeyNo_Function3, KeyNo_LeftParenthesis,  KeyNo_QuotationMark, KeyNo_Slash,         KEYMAPPING_NOTHING, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 6 */                                                                                            
{KeyNo_YenSign,      KeyNo_Function2, KeyNo_CommercialAt,     KeyNo_Tick,          KeyNo_Colon,         KEYMAPPING_NOTHING, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING},
/* Row 7 */                                                                                            
{KEYMAPPING_NOTHING, KeyNo_Function1, KeyNo_Escape,           KeyNo_CapsLock,      KeyNo_SemiColon,     KEYMAPPING_NOTHING, KEYMAPPING_NOTHING, KEYMAPPING_NOTHING}
}
};

static struct {
  int last_active_driver;
  bool driver_enabled;
  bool ticker_handler_running;
  bool handler_stopped;
  char device_name[30 + 1]; 
  unsigned long special_key_status;
  unsigned long pandora_key_status[ROW_STATUS_ARRAY_SIZE]; /* Press state of each key */
  unsigned long pandora_fn_status[ROW_STATUS_ARRAY_SIZE]; /* FN status of each key at time it was pressed; this is the easiest way of avoiding losing track of which keys are FN-modified */
} common;
int mouse_x=0;
int mouse_y=0;

/* !!!!!!!!!! support functions !!!!!!!!!! */
static _kernel_oserror *i2c_write_value(unsigned char chip_register,
                                 unsigned char value)
{
  _kernel_oserror *error_os;
  unsigned char i2c_buffer[2];
  unsigned int transfer[3];
  
  /* First set address */
  i2c_buffer[0]=KEYPAD_BASE_ADDRESS + chip_register;
  /* Afterwards data to write follows. */
  i2c_buffer[1]=value;
  transfer[0]=KEYPAD_IIC_ADDRESS;
  transfer[1]=(int) i2c_buffer;
  transfer[2]=2;
  if ((error_os=_swix(OS_IICOp,_INR(0,1),transfer,1)) != NULL) {
    return error_os;
  }
  return NULL;
}

static _kernel_oserror *i2c_read_data(unsigned char chip_register,
                               unsigned char *buffer,
                               int number_of_bytes)
{
  _kernel_oserror *error_os;
  unsigned char i2c_buffer[1];
  unsigned int transfer[6];
  
  /* First set address */
  i2c_buffer[0]=KEYPAD_BASE_ADDRESS + chip_register;
  transfer[0]=KEYPAD_IIC_ADDRESS;
  transfer[1]=(int) i2c_buffer;
  transfer[2]=1;
  transfer[3]=KEYPAD_IIC_ADDRESS | 1;
  transfer[4]=(int) buffer;
  transfer[5]=number_of_bytes;
  if ((error_os=_swix(OS_IICOp,_INR(0,1),transfer,2)) != NULL) {
    return error_os;
  }
  return NULL;
}

static unsigned long get_key_mapping(unsigned long pressed_key,
                              unsigned long actual_key_bank)
{
  /* Determine RISC OS key belonging to Pandora key */
  return key_mapping[actual_key_bank][pressed_key>>3][pressed_key & 0x7];
}

static void release_keys(unsigned long i,unsigned long status_diff)
{
  unsigned long j, k, l;
  while(status_diff)
  {
    __asm
    {
    CLZ j,status_diff;
    }
    j=31-j;
    status_diff^=((unsigned long) 1<<j);
    l = j+(i<<5);
    k = get_key_mapping(l,(common.pandora_fn_status[i]>>j)&1);
    if(k != KEYMAPPING_NOTHING)
    {
      if(!_swix(OS_CallAVector,_INR(0,1)|_IN(9),KeyV_KeyUp,k,KEYV))
      {
        /* Mark as successfully released */
        common.pandora_key_status[i] &= ~(1<<j);
      }
    }
  }
}

static void press_keys(unsigned long i,unsigned long status_diff)
{
  unsigned long j, k, l;
  while(status_diff)
  {
    __asm
    {
    CLZ j,status_diff;
    }
    j=31-j;
    status_diff^=((unsigned long) 1<<j);
    l = j+(i<<5);
    unsigned long key_bank = (common.special_key_status & (SPECIAL_KEY_FN | SPECIAL_KEY_FN_STICKY | SPECIAL_KEY_FN_LOCK))?1:0;
    k = get_key_mapping(l,key_bank);
    if(k != KEYMAPPING_NOTHING)
    {
      if(!_swix(OS_CallAVector,_INR(0,1)|_IN(9),KeyV_KeyDown,k,KEYV))
      {
        /* Mark as successfully pressed */
        common.pandora_key_status[i] |= 1<<j;
        /* And remember FN state */
        common.pandora_fn_status[i] = (common.pandora_fn_status[i] & ~(1<<j)) | (key_bank<<j);
        /* And clear any sticky FN state */
        common.special_key_status = common.special_key_status & ~SPECIAL_KEY_FN_STICKY;
      }
    }
  }
}

/* !!!!!!!!!! functions !!!!!!!!!! */
int ticker_handler(_kernel_swi_regs *regs,
                   void *pw)
{
  unsigned long i, j;
  unsigned long actual_key_status[ROW_STATUS_ARRAY_SIZE], status_diff;
  _kernel_oserror *error_os;
  
  (void) regs;
  (void) pw;
  
  if ((!common.driver_enabled) || (common.ticker_handler_running))
  {
    return 1;
  }
  /* Protect against reentrancy */
  common.ticker_handler_running=true;
  common.handler_stopped=false;
  /* Allow parallel activity */
  _kernel_irqs_on();
  /* Update nubs */
  nubs_update();
  /* Update GPIO keys */
  gpiokey_update();
  if ((error_os=i2c_read_data(keypad_regoffset_rowcontent[0], (unsigned char *) actual_key_status, MAX_ROWS)) == NULL)
  {
    /* Process keys in the following order:
       1. Key releases
       2. FN key transition
       3. Key presses
       This should help keep things sensible if multiple transitions occur at once
    */
    /* 1. Key releases */
    for(i=0;i<ROW_STATUS_ARRAY_SIZE;i++)
    {
      status_diff = common.pandora_key_status[i] & ~actual_key_status[i];
      if(status_diff)
        release_keys(i,status_diff);
    }
    /* 2. FN key state */
    i = common.special_key_status & SPECIAL_KEY_FN;
    j = actual_key_status[PANDORA_KEY_FN>>5] & (1<<(PANDORA_KEY_FN & 31));
    if(i && !j)
    {
      /* FN released */
      common.special_key_status &= ~SPECIAL_KEY_FN;
    }
    else if(!i && j)
    {
      /* FN pressed */
      if(common.special_key_status & SPECIAL_KEY_FN_STICKY)
      {
        /* Two FN presses in a row -> enable FN lock */
        common.special_key_status = SPECIAL_KEY_FN | SPECIAL_KEY_FN_LOCK;
      }
      else if(common.special_key_status & SPECIAL_KEY_FN_LOCK)
      {
        /* FN pressed while FN lock in effect -> disable FN lock */
        common.special_key_status = SPECIAL_KEY_FN;
      }
      else
      {
        /* Regular FN press -> set FN + sticky state */
        common.special_key_status = SPECIAL_KEY_FN | SPECIAL_KEY_FN_STICKY;
      }
    }
    /* 3. Key presses */
    for(i=0;i<ROW_STATUS_ARRAY_SIZE;i++)
    {
      status_diff = actual_key_status[i] & ~common.pandora_key_status[i];
      if(status_diff)
        press_keys(i,status_diff);
    }     
  }
  /* Restore old IRQ State (disabled) */
  _kernel_irqs_off();
  common.ticker_handler_running=false;
  return 1;
}

int mouse_handler(_kernel_swi_regs *regs,
                  void *pw)
{
  (void) pw;
  
  switch(regs->r[0]) {
    case PointerReason_Request: {
      if (regs->r[1] == POINTER_TYPE) {
        /* Report movement */
        regs->r[2]=mouse_x>>1;
        regs->r[3]=mouse_y>>1;
        /* Keep fractional part */
        mouse_x&=0x1;
        mouse_y&=0x1;
        return 0;
        }
      }
    break;
    case PointerReason_Identify: {
      /* RISC OS mouse driver information structure */
      struct info_structur {
      void *next_info_block;
      unsigned long flags;
      unsigned char device_type;
      char device_name[30 + 1];
      } *info;
  
      /* Information */
      if ((info=malloc(sizeof(struct info_structur))) != NULL) {
        info->next_info_block=(void *) regs->r[1];
        info->flags=0;
        info->device_type=POINTER_TYPE;
        strcpy(info->device_name, common.device_name);
        regs->r[1]=(int) info;
        }
      }
    break;
    case PointerReason_Selected: {
      /* Enable/Disable. */
      if (regs->r[1] == POINTER_TYPE) {
        /* ??? */
        }
      else {
        common.last_active_driver=regs->r[1];
        }
      }
    break;
    }
  return 1;
}

int key_handler(_kernel_swi_regs *regs,
                 void *pw)
{
  (void) pw;
  
  switch(regs->r[0]) {
    case KeyV_EnableDrivers: {
      common.driver_enabled=true;
      /* TODO - clear key press states, or at the least re-press the ones we
         know are held? (so FN state doesn't get confused) */
      gpiokey_reset();
      }
    break;
    case KeyV_KeyboardRemoved: {
      /* Switch the OS back to using our keyboard */
      _swix(OS_CallAVector,_INR(0,1)|_IN(9),KeyV_KeyboardPresent,KEYBOARD_TYPE,KEYV);
      /* Claim vector? */
      return 0;
      }
    break;
    }
  return 1;
}

_kernel_oserror *module_init(const char *cmd_tail,
                             int podule_base,
                             void *pw)
{
  int i;
  _kernel_oserror *error_os;
  int msgstruct[4];

  (void) cmd_tail;
  (void) podule_base;
  
  /* Find the HAL device to verify that we're running on a Pandora */
  struct device *dev=NULL;
  int pos=0;
  do {
    error_os = _swix(OS_Hardware, _INR(0,1) | _IN(8) | _OUTR(1,2), HALDeviceType_HID + HALDeviceHID_Keyboard,pos,OSHW_DeviceEnumerate,&pos,&dev);
    if(error_os)
      return error_os;
    if(pos == -1)
    {
      static const internat_err hwdep = { ErrorNumber_HardwareDepends, "HWDep" };
      
      return _swix(MessageTrans_ErrorLookup, _INR(0,2), &hwdep, 0, 0);
    }
  } while(dev->id != HALDeviceID_Keyboard_Pandora);
  
  for (i=0; i < ROW_STATUS_ARRAY_SIZE; i++)  {
    common.pandora_key_status[i]=0;
    }
  common.driver_enabled=false;
  common.ticker_handler_running=false;
  if ((error_os=i2c_write_value(KEYPAD_REGOFFSET_CTRL, KEYPAD_CTRL_SOFT_NRST | KEYPAD_CTRL_SOFTMOD_EN | KEYPAD_CTRL_TOE_EN | KEYPAD_CTRL_KBD_ON)) != NULL) {
    return error_os;
    }
  if ((error_os=i2c_write_value(KEYPAD_REGOFFSET_EDR, KEYPAD_EDR_KP_F | KEYPAD_EDR_KP_R | KEYPAD_EDR_TO_R)) != NULL) {
    return error_os;
    }
  if ((error_os=i2c_write_value(KEYPAD_REGOFFSET_LKPTV, 0x80)) != NULL) {
    return error_os;
    }
  if ((error_os=i2c_write_value(KEYPAD_REGOFFSET_DEB, 20)) != NULL) {
    return error_os;
    }
  if ((error_os=i2c_write_value(KEYPAD_REGOFFSET_TIMEOUTL, 100)) != NULL) {
    return error_os;
    }
  if ((error_os=i2c_write_value(KEYPAD_REGOFFSET_TIMEOUTH, 0)) != NULL) {
    return error_os;
    }
  if ((error_os=i2c_write_value(KEYPAD_REGOFFSET_SIH_CTRL, 6)) != NULL) {
    return error_os;
    }
  if ((error_os=i2c_write_value(KEYPAD_REGOFFSET_IMR1, 15)) != NULL) {
    return error_os;
    }
  if ((error_os=i2c_write_value(KEYPAD_REGOFFSET_IMR2, 15)) != NULL) {
    return error_os;
    }
  if((error_os=gpio_init()) != NULL) {
    return error_os;
    }
  nubs_init();
  gpiokey_init();

  /* Translate the driver name for PointerV */
  if((error_os = _swix(MessageTrans_OpenFile, _INR(0,2), msgstruct,
                       "Resources:$.Resources.PandoraKey.Messages", 0)) != NULL) {
    return error_os;
    }
  error_os = _swix(MessageTrans_Lookup, _INR(0,3), msgstruct,
                   "KName", common.device_name, sizeof(common.device_name));
  _swix(MessageTrans_CloseFile, _IN(0), msgstruct);
  if(error_os != NULL) {
    return error_os;
    }
  /* Examine KeyV */
  if((error_os = _swix(OS_Claim, _INR(0,2), KEYV, key_handler_entry, pw)) != NULL) {
    return error_os;
    }
  /* Examine PointerV */
  if((error_os = _swix(OS_Claim, _INR(0,2), PointerV, mouse_handler_entry, pw)) != NULL) {
    goto error1;
    }
  /* Examine TickerV */
  if((error_os = _swix(OS_Claim, _INR(0,2), TickerV, ticker_handler_entry, pw)) != NULL) {
    goto error2;
    }
  /* Notify OS */
  if((error_os = _swix(OS_CallAVector, _INR(0,1) | _IN(9),
                       KeyV_KeyboardPresent, KEYBOARD_TYPE, KEYV)) != NULL) {
    goto error3;
    }
  /* Note currently active mouse driver.
     Further changes are kept by the vector handler. */
  if ((error_os = _swix(OS_Pointer, _IN(0) | _OUT(0),
                        0, &common.last_active_driver)) != NULL) {
    goto error3;
    }
  /* Tell RISC OS to enable the driver */
  if ((error_os = _swix(OS_Pointer, _INR(0,1), 1, POINTER_TYPE)) != NULL) {
    goto error3;
    }
  return NULL;
  
error3:
  /* No longer examine TickerV */
  _swix(OS_Release, _INR(0,2), TickerV, ticker_handler_entry, pw);
error2:
  /* No longer examine PointerV */
  _swix(OS_Release, _INR(0,2), PointerV, mouse_handler_entry, pw);
error1:
  /* No longer examine KeyV */
  _swix(OS_Release, _INR(0,2), KEYV, key_handler_entry, pw);
  return error_os;
}

_kernel_oserror *module_final(int fatal,
                              int podule,
                              void *pw)
{
  (void) fatal;
  (void) podule;

  common.driver_enabled=false;

  /* Release all keys */
  nubs_reset();
  gpiokey_shutdown();
  for(unsigned long i=0;i<ROW_STATUS_ARRAY_SIZE;i++)
    release_keys(i,common.pandora_key_status[i]);
  /* Reenable the driver used before. */
  _swix(OS_Pointer, _INR(0,1), 1, common.last_active_driver);
  /* No longer examine TickerV */
  _swix(OS_Release, _INR(0,2), TickerV, ticker_handler_entry, pw);
  /* No longer examine PointerV */
  _swix(OS_Release, _INR(0,2), PointerV, mouse_handler_entry, pw);
  /* No longer examine KeyV */
  _swix(OS_Release, _INR(0,2), KEYV, key_handler_entry, pw);
  /* Don't return an error as this would stop the driver from finishing */
  return NULL;
}
