/*
 * Copyright (c) 2010, RISC OS Open Ltd
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#include <stddef.h>

#include "swis.h"

#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Global/HALEntries.h"
#include "Global/GraphicsV.h"
#include "Global/Countries.h"

#include "DebugLib/DebugLib.h"

#include "regs.h"
#include "graphicsv.h"
#include "dispc.h"
#include "dss.h"
#include "venc.h"
#include "gvoverlay.h"
#include "globals.h"
#include "consts.h"
#include "vars.h"
#include "utils.h"
#include "palette.h"
#include "dsi.h"

static const omapformat_t omapformats[PIXELFORMAT_MAX] =
{
	{ OVERLAY_ATTRIBUTES_FORMAT_BMP1, FEATURE_PALETTE, FEATURE_PALETTE+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX), 0 }, //PIXELFORMAT_1_PAL,
	{ OVERLAY_ATTRIBUTES_FORMAT_BMP2, FEATURE_PALETTE, FEATURE_PALETTE+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX), 0 }, //PIXELFORMAT_2_PAL,
	{ OVERLAY_ATTRIBUTES_FORMAT_BMP4, FEATURE_PALETTE, FEATURE_PALETTE+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX), 0 }, //PIXELFORMAT_4_PAL,
	{ OVERLAY_ATTRIBUTES_FORMAT_BMP8, FEATURE_PALETTE, FEATURE_PALETTE+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX), 0 }, //PIXELFORMAT_8_PAL,
	{ OVERLAY_ATTRIBUTES_FORMAT_RGB12, FEATURE_CPR, FEATURE_CPR+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_4444_TBGR,
	{ OVERLAY_ATTRIBUTES_FORMAT_RGB12, 0, FEATURE_CPR+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_4444_TRGB,
	{ OVERLAY_ATTRIBUTES_FORMAT_ARGB16, FEATURE_CPR+FEATURE_ALPHA, FEATURE_CPR+FEATURE_ALPHA+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_4444_ABGR,
	{ OVERLAY_ATTRIBUTES_FORMAT_ARGB16, FEATURE_ALPHA, FEATURE_CPR+FEATURE_ALPHA+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_4444_ARGB,
	{ OVERLAY_ATTRIBUTES_FORMAT_RGB16_565, FEATURE_CPR+FEATURE_GAMMAHACK, FEATURE_CPR+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_1555_TBGR,
	{ OVERLAY_ATTRIBUTES_FORMAT_RGB16_565, FEATURE_GAMMAHACK, FEATURE_CPR+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_1555_TRGB,
	{ 0, 0, 0, 0, 0 }, //PIXELFORMAT_1555_ABGR,
	{ 0, 0, 0, 0, 0 }, //PIXELFORMAT_1555_ARGB,
	{ OVERLAY_ATTRIBUTES_FORMAT_RGB16_565, FEATURE_CPR, FEATURE_CPR+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_565_BGR,
	{ OVERLAY_ATTRIBUTES_FORMAT_RGB16_565, 0, FEATURE_CPR+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_565_RGB,
	{ OVERLAY_ATTRIBUTES_FORMAT_RGB24_24, FEATURE_CPR, FEATURE_CPR+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_888_BGR,
	{ OVERLAY_ATTRIBUTES_FORMAT_RGB24_24, 0, FEATURE_CPR+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_888_RGB,
	{ OVERLAY_ATTRIBUTES_FORMAT_xRGB24_8888, FEATURE_CPR, FEATURE_CPR+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_8888_TBGR,
	{ OVERLAY_ATTRIBUTES_FORMAT_xRGB24_8888, 0, FEATURE_CPR+FEATURE_GAMMAHACK, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_8888_TRGB,
	{ OVERLAY_ATTRIBUTES_FORMAT_ARGB32, FEATURE_CPR+FEATURE_ALPHA, FEATURE_CPR+FEATURE_GAMMAHACK+FEATURE_ALPHA, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_8888_ABGR,
	{ OVERLAY_ATTRIBUTES_FORMAT_ARGB32, FEATURE_ALPHA, FEATURE_CPR+FEATURE_GAMMAHACK+FEATURE_ALPHA, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_8888_ARGB,
	{ OVERLAY_ATTRIBUTES_FORMAT_UYVY, 0, 0, (1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), EXTRAFLAG_FULLRANGE }, //PIXELFORMAT_UYVY_601_full,
	{ OVERLAY_ATTRIBUTES_FORMAT_UYVY, 0, 0, (1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_UYVY_601_video,
	{ OVERLAY_ATTRIBUTES_FORMAT_UYVY, 0, 0, (1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), EXTRAFLAG_709+EXTRAFLAG_FULLRANGE }, //PIXELFORMAT_UYVY_709_full,
	{ OVERLAY_ATTRIBUTES_FORMAT_UYVY, 0, 0, (1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), EXTRAFLAG_709 }, //PIXELFORMAT_UYVY_709_video,
	{ OVERLAY_ATTRIBUTES_FORMAT_YUV2, 0, 0, (1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), EXTRAFLAG_FULLRANGE }, //PIXELFORMAT_YUY2_601_full,
	{ OVERLAY_ATTRIBUTES_FORMAT_YUV2, 0, 0, (1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_YUY2_601_video,
	{ OVERLAY_ATTRIBUTES_FORMAT_YUV2, 0, 0, (1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), EXTRAFLAG_709+EXTRAFLAG_FULLRANGE }, //PIXELFORMAT_YUY2_709_full,
	{ OVERLAY_ATTRIBUTES_FORMAT_YUV2, 0, 0, (1<<OVERLAY_VID1)|(1<<OVERLAY_VID2), EXTRAFLAG_709 }, //PIXELFORMAT_YUY2_709_video,
	{ 0, 0, 0, 0, 0 }, //PIXELFORMAT_NV12_601_full,
	{ 0, 0, 0, 0, 0 }, //PIXELFORMAT_NV12_601_video,
	{ 0, 0, 0, 0, 0 }, //PIXELFORMAT_NV12_709_full,
	{ 0, 0, 0, 0, 0 }, //PIXELFORMAT_NV12_709_video,
	{ OVERLAY_ATTRIBUTES_FORMAT_ARGB32, 0, 0, (1<<OVERLAY_GFX)|(1<<OVERLAY_VID2), 0 }, //PIXELFORMAT_POINTER,
};

static const uint16_t fifo_preload_for_lcd[LCD_MAX] = {0, 0x60, 0x72, 0xE0, 0xE0};

/* Transparency settings:

   NONE, TCK_VIDSRC use VID2->VID1->GFX->BGCOL overlay ordering (front->back)
   TCK_GFXSRC, TCK_GFXDEST, ALPHA use GFX->VID2->VID1->BGCOL ordering */

typedef enum
{
	TRANSPARENCY_NONE,
	TRANSPARENCY_TCK_VIDSRC, /* Video overlay pixels that match the colour key won't be drawn. Only if colour space conversion & scaling disabled. */
	TRANSPARENCY_TCK_GFXSRC, /* Graphics overlay pixels that match the colour key won't be drawn. Only if colour space conversion & scaling disabled. */
	TRANSPARENCY_TCK_GFXDEST, /* Graphics underlay pixels that match the colour key cause the overlay pixels (VID1, VID2) to be drawn */
	TRANSPARENCY_ALPHA, /* Use alpha value of each overlay pixel */

	TRANSPARENCY_MAX,
} transparencycfg;

static const uint32_t transparency_lut[TARGET_MAX][TRANSPARENCY_MAX] =
{
	{ /* TARGET_LCD */
		0,
		DISPC_CONFIG_TCKLCDENABLE | DISPC_CONFIG_TCKLCDSELECTION,
		DISPC_CONFIG_TCKLCDENABLE,
		DISPC_CONFIG_TCKLCDENABLE | DISPC_CONFIG_LCDALPHABLENDERENABLE,
		DISPC_CONFIG_LCDALPHABLENDERENABLE,
	},
	{ /* TARGET_TV */
		0,
		DISPC_CONFIG_TCKDIGENABLE | DISPC_CONFIG_TCKDIGSELECTION,
		DISPC_CONFIG_TCKDIGENABLE,
		DISPC_CONFIG_TCKDIGENABLE | DISPC_CONFIG_TVALPHABLENDERENABLE,
		DISPC_CONFIG_TVALPHABLENDERENABLE,
	},
};

/* Configuration information / hardware state softcopies */

static transparencycfg current_transparencycfgs[TARGET_MAX];

void omap_init(void)
{
	features_t *features = features_write_lock();
	for(int i=0;i<OVERLAY_MAX;i++)
	{
		features->requests[i].target = TARGET_NONE;
	}
	features_write_unlock();
}

void omap3_flush_transparency_cfg(bool go)
{
	int irqs;
	if(!begin_quick_hardware_update(&irqs))
		return;
	uint32_t orig_config = dispc->config;
	uint32_t config = orig_config & ~(DISPC_CONFIG_TCKLCDENABLE | DISPC_CONFIG_TCKLCDSELECTION | DISPC_CONFIG_TCKDIGENABLE | DISPC_CONFIG_TCKDIGSELECTION | DISPC_CONFIG_LCDALPHABLENDERENABLE | DISPC_CONFIG_TVALPHABLENDERENABLE);
	config |= transparency_lut[TARGET_TV][current_transparencycfgs[TARGET_TV]];

	/* TODO - Check for errors (e.g. VIDSRC when colour space conversion/scaling in use */
	config |= transparency_lut[TARGET_LCD][current_transparencycfgs[TARGET_LCD]];
	if(config != orig_config)
	{
		dispc->config = config;
		if(go)
		{
			uint32_t control = dispc->control;
			config = config ^ orig_config;
			if((control & DISPC_CONTROL_LCDENABLE) && (config & (DISPC_CONFIG_TCKLCDENABLE | DISPC_CONFIG_TCKLCDSELECTION | DISPC_CONFIG_LCDALPHABLENDERENABLE)))
				control |= DISPC_CONTROL_GOLCD;
			if((control & DISPC_CONTROL_DIGITALENABLE) && (config & (DISPC_CONFIG_TCKDIGENABLE | DISPC_CONFIG_TCKDIGSELECTION | DISPC_CONFIG_TVALPHABLENDERENABLE)))
				control |= DISPC_CONTROL_GODIGITAL;
			dispc->control = control;
		}
	}
	end_quick_hardware_update(irqs);
}

static bool get_default_tv_mode(tvmode *mode,tvouttype *type)
{
	/* Prefer S-Video over composite output */
	if(hwconfig->flags & BOARDCONFIG_SVIDEO)
		*type = TVOUT_SVIDEO;
	else if(hwconfig->flags & BOARDCONFIG_COMPOSITE)
		*type = TVOUT_COMPOSITE;
	else
		return false;
	/* Use configured territory to decide which signal mode to use
	   TODO - Add as SWI to territory manager */
	uint32_t territory;
	if(_swix(Territory_Number,_OUT(0),&territory))
		return false;
	/* We can only handle PAL and NTSC, and currently don't care too much about different variants
	   However anecdotal evidence suggests many SECAM TVs are dual-standard, so try using PAL in SECAM territories */
#define MODE_PAL *mode = TVMODE_PAL_601; break;
#define MODE_NTSC *mode = TVMODE_NTSC_601; break;
#define MODE_SECAM *mode = TVMODE_PAL_601; break;
#define MODE(x,y) MODE_ ## x
	/* Partial list of territories - some non-countries like 'Master', 'Compact', 'Esperanto', etc. ignored
	   Information from http://countrycode.org/tv-standards */
	switch(territory)
	{
	default:
		return false;
	case TerritoryNum_Albania:	MODE(PAL,BG);
	case TerritoryNum_Arabic:	MODE(PAL,BG); /* Most Arabic nations appear to use PAL B/G */
	case TerritoryNum_Australia:	MODE(PAL,BG);
	case TerritoryNum_Austria:	MODE(PAL,BG);
	case TerritoryNum_Belgium:	MODE(PAL,BH)
	case TerritoryNum_Bengal:	MODE(PAL,B) /* (Bangladesh) */
	case TerritoryNum_Brazil:	MODE(PAL,M)
	case TerritoryNum_Bulgaria:	MODE(PAL,_)
	case TerritoryNum_ByeloRuss:	MODE(SECAM,DK) /* (Belarus?) */
	case TerritoryNum_Canada1:	MODE(NTSC,M)
	case TerritoryNum_Canada2:	MODE(NTSC,M)
	case TerritoryNum_Canada:	MODE(NTSC,M)
	case TerritoryNum_China:	MODE(PAL,D)
	case TerritoryNum_Czech:	MODE(PAL,BGDK)
	case TerritoryNum_Denmark:	MODE(PAL,BG)
	case TerritoryNum_Devanag:	MODE(PAL,B) /* (Devanagari -> Sanskrit -> India) */
	case TerritoryNum_Estonia:	MODE(PAL,BG)
	case TerritoryNum_Faroe:	MODE(PAL,BG) /* (Faroes -> Denmark) */
	case TerritoryNum_Farsi:	MODE(PAL,B) /* Most Persian nations appear to use PAL B(/G) */
	case TerritoryNum_Finland:	MODE(PAL,BG)
	case TerritoryNum_France:	MODE(SECAM,L)
	case TerritoryNum_Gaelic:	MODE(PAL,I)
	case TerritoryNum_Germany:	MODE(PAL,BG)
	case TerritoryNum_Greece:	MODE(PAL,BG)
	case TerritoryNum_GreeceAnct:	MODE(PAL,BG)
	case TerritoryNum_Greenland:	MODE(PAL,B)
	case TerritoryNum_Gujarati:	MODE(PAL,B) /* (India) */
	case TerritoryNum_HongKong:	MODE(PAL,I)
	case TerritoryNum_Hungary:	MODE(PAL,K)
	case TerritoryNum_Iceland:	MODE(PAL,BG)
	case TerritoryNum_Ireland:	MODE(PAL,I)
	case TerritoryNum_Israel:	MODE(PAL,BG)
	case TerritoryNum_Italy:	MODE(PAL,BG)      
	case TerritoryNum_Japan:	MODE(NTSC,M)
	case TerritoryNum_Korea:	MODE(NTSC,M) /* (South) */
	case TerritoryNum_Lapp:		MODE(PAL,BG) /* (Sami) */
	case TerritoryNum_Latvia:	MODE(PAL,BG)
	case TerritoryNum_Lithuania:	MODE(PAL,BG)
	case TerritoryNum_Macedonia:	MODE(PAL,BH)
	case TerritoryNum_Malta:	MODE(PAL,B)
	case TerritoryNum_Maori:	MODE(PAL,BG) /* (New Zealand) */
	case TerritoryNum_Mexico:	MODE(NTSC,M)
	case TerritoryNum_MiddleEast:	MODE(PAL,BG) /* Most/all middle-eastern countries appear to use PAL B/G */
	case TerritoryNum_Netherland:	MODE(NTSC,M)
	case TerritoryNum_Norway:	MODE(PAL,BG)
	case TerritoryNum_Poland:	MODE(PAL,DK)
	case TerritoryNum_Portugal:	MODE(PAL,BG)
	case TerritoryNum_Punjab:	MODE(PAL,B) /* (India/Pakistan) */
	case TerritoryNum_Romania:	MODE(PAL,DG)
	case TerritoryNum_Russia2:	MODE(SECAM,DK)
	case TerritoryNum_Russia:	MODE(SECAM,DK)
	case TerritoryNum_SAfrica2:	MODE(PAL,I)
	case TerritoryNum_SAfrica:	MODE(PAL,I)
	case TerritoryNum_SerboCroat:	MODE(PAL,B) /* Serbia: PAL B/G, Croatia: PAL B/H */
	case TerritoryNum_Slovak:	MODE(PAL,BG)
	case TerritoryNum_Slovene:	MODE(PAL,BH)
	case TerritoryNum_Spain:	MODE(PAL,BG)
	case TerritoryNum_Sweden:	MODE(PAL,BG)
	case TerritoryNum_Swiss1:	MODE(SECAM,L) /* (French) */
	case TerritoryNum_Swiss2:	MODE(PAL,BG) /* (German) */
	case TerritoryNum_Swiss3:	MODE(PAL,BG) /* (Italian) */
	case TerritoryNum_Swiss4:	MODE(PAL,BG) /* (Romansch) */
	case TerritoryNum_Switzerland:	MODE(PAL,BG)
	case TerritoryNum_Taiwan:	MODE(NTSC,_)
	case TerritoryNum_Tamil:	MODE(PAL,_)
	case TerritoryNum_Turkey:	MODE(PAL,B)
	case TerritoryNum_UK:		MODE(PAL,I)
	case TerritoryNum_Ukraine:	MODE(SECAM,DK)
	case TerritoryNum_USA:		MODE(NTSC,M)
	case TerritoryNum_Wales2:	MODE(PAL,I)
	case TerritoryNum_Wales:	MODE(PAL,I)
	}
	return true;
}

void omap3_apply_features(const features_t *features)
{
	/* Enable/disable gamma table usage on LCD */
	bool palette_used = false;
	for(int i=0;i<TARGET_MAX;i++)
		if(features->head_vals[i] & FEATURE_PALETTE)
		{
			palette_used = true;
			break;
		}
	uint32_t config = dispc->config;
	uint32_t old_config = config;
	if(!palette_used)
		config |= DISPC_CONFIG_PALETTEGAMMATABLE;
	else
		config &= ~DISPC_CONFIG_PALETTEGAMMATABLE;

	/* Enable/disable CPR for LCD */
	if(features->head_vals[TARGET_LCD] & FEATURE_CPR)
	{
		config |= DISPC_CONFIG_CPR;
		/* Default CPR value for RISC OS */
		dispc->cpr_coef_r = 256;
		dispc->cpr_coef_g = 256 << 11;
		dispc->cpr_coef_b = 256 << 22;
	}
	else
	{
		config &= ~DISPC_CONFIG_CPR;
	}

	/* TODO need gobits here? */
	if(config != old_config)
		dispc->config = config;
}

void omap_update_features(overlayidx idx, overlaytarget target, pixelformat format)
{
	{
		features_t *features = features_write_lock();
		if ((features->requests[idx].target == target) && (features->requests[idx].format == format))
		{
			features_write_unlock();
			return;
		}
		features->requests[idx].target = target;
		features->requests[idx].format = format;

		/* Deduce required features for all heads */
		for(int i=0;i<TARGET_MAX;i++)
		{
			/* Don't unnecessarily hold onto the palette/gamma hardware */
			features->head_vals[i] &= ~(FEATURE_PALETTE | FEATURE_GAMMAHACK);
			/* Reset to base feature mask for the head */
			features->head_masks[i] = headattrs[i].features_mask;
		}

		for(int i=0;i<OVERLAY_MAX;i++)
		{
			const featurecfg_t cfg = features->requests[i];
			if(cfg.target != TARGET_NONE)
			{
				features->head_vals[cfg.target] = (features->head_vals[cfg.target] & ~omapformats[cfg.format].features_mask) | omapformats[cfg.format].features_val;
				features->head_masks[cfg.target] |= omapformats[cfg.format].features_mask;
			}
		}

		/* Override any requests to limit things to just the features supported by the head
		   TODO can be removed once overlay code prevents selection of unsupported formats? */
		for(int i=0;i<TARGET_MAX;i++)
		{
			features->head_vals[i] = (features->head_vals[i] & ~headattrs[i].features_mask) | headattrs[i].features_val;
		}
	}

	const features_t *features = features_write_to_read(); /* Downgrade to read lock */

	select_palette_func(NULL, features);

	omap3_apply_features(features);

	features_read_unlock();
}

overlaytarget omap_pick_display(void)
{
	/* If we're running on a board that supports TV-out, use that for output if a TV is detected */
	tvouttype tv_type;
	tvmode tv_mode;
	overlaytarget target = TARGET_LCD;
	if((hwconfig->mysize > offsetof(boardconfig_t,tvdet_func)) && (hwconfig->tvdet_func) && get_default_tv_mode(&tv_mode,&tv_type))
	{
		/* Wake up TV output */
		venc_configure(tv_mode,tv_type,false);
		venc_setmode();
		/* Enable TV detection */
		venc->gen_ctrl |= VENC_GEN_CTRL_EN;
		/* Wait a few frames to ensure result is valid */
		_swix(OS_Hardware,_IN(0)|_INR(8,9),100000,OSHW_CallHAL,EntryNo_HAL_CounterDelay);
		/* Poll relevant GPIO */
		bool result = (hwconfig->tvdet_func)(dev);
		/* Disable TV detection */
		venc->gen_ctrl &= ~ VENC_GEN_CTRL_EN;
		dprintf(("", "TV detection result: %d\n",result));
		/* Check result */
		if(result)
		{
			target = TARGET_TV;
		}
		else
		{
			venc_disable();
		}
	}
	return target;
}

static bool omap3_vetmode_lcd(overlaytarget target,const VIDCList3 *params,bool interlace,pixelformat format)
{
	(void) target;
	(void) format;

	/* Always accept if we're using fixed LCD timings */
	if(hwconfig->lcd_configs[current_lcd].max_pixelrate == 0)
		return true;

	/* Check interlace */
	if(interlace)
		return false;
	/* Check pixel rate */
	if(params->PixelRate > hwconfig->lcd_configs[current_lcd].max_pixelrate)
		return false;
	/* Use a lower limit of 15MHz on the pixel rate. The limiting factor appears to be the TFP410, which according to the datasheet only supports down to 25MHz, but appears to be stable down to 15MHz. Anything lower can result in picture instability.
	   https://www.riscosopen.org/forum/forums/3/topics/2583?page=1#posts-33233
	*/
	if(params->PixelRate < 15000)
		return false;
	/* Check screen size */
	if((params->HorizDisplaySize-1 > REG_MAX(DISPC_SIZE_LCD_PPL))
	|| ((params->VertiDisplaySize<<interlace)-1 > REG_MAX(DISPC_SIZE_LCD_LPP))
	|| (params->HorizDisplaySize & 0x7)) /* Width must be multiple of 8 pixels for STALLMODE=0 */
		return false;
	/* Check required REGM, REGN values */
	clock_divider_t div = calculate_dss_clock_divider(params->PixelRate*1000);
	if((div.regm > REG_MAX(DSI_PLL_CONFIGURATION1_DSI_PLL_REGM)) || (div.regn > REG_MAX(DSI_PLL_CONFIGURATION1_DSI_PLL_REGN)))
		return false;
	/* Now check mode timings */
	if((params->HorizSyncWidth > hwconfig->max_sync)
	|| (params->HorizBackPorch+params->HorizLeftBorder > hwconfig->max_porch)
	|| (params->HorizFrontPorch+params->HorizRightBorder > hwconfig->max_porch)
	|| (params->VertiSyncWidth > hwconfig->max_sync)
	|| (params->VertiBackPorch+params->VertiTopBorder > hwconfig->max_porch)
	|| (params->VertiFrontPorch+params->VertiBottomBorder > hwconfig->max_porch))
		return false;
	if((params->HorizSyncWidth < 1)
	|| (params->HorizBackPorch+params->HorizLeftBorder < 1)
	|| (params->HorizFrontPorch+params->HorizRightBorder < 1)
	|| (params->VertiSyncWidth < 1))
		return false;
	/* Check (HBP+HSW+HFP)*PCD > 8 */
	uint32_t val = params->HorizBackPorch + params->HorizLeftBorder
				 + params->HorizSyncWidth + params->HorizFrontPorch
				 + params->HorizRightBorder;
	if (val <= 4) /* We always used PCD of 2 */
		return false;

	return true;
}

static bool omap3_vetmode_tv(overlaytarget target,const VIDCList3 *params,bool interlace,pixelformat format)
{
	(void) target;
	(void) params;
	(void) interlace;
	(void) format;
	/* We accept anything, and just crop it to fit the screen */
	return true;
}

static void omap3_prepmode_lcd(overlaytarget target,modelocked_head_t *state,pixelformat format)
{
	(void) target;
	(void) state;
	(void) format;
	/* Defaults are all fine */
}

static void omap3_prepmode_tv(overlaytarget target,modelocked_head_t *state,pixelformat format)
{
	(void) target;
	venc_prepmode(state,format);
}

static void omap3_setmode_lcd(overlaytarget target,const modelocked_head_t *state)
{
	(void) target;
	/* The flow used here is similar to that shown in spruf98d fig 15-147 (p2343), except the PLL reprogramming steps use the DSI PLL */
	int irqs;
	if(!begin_slow_hardware_update(&irqs))
	{
		dprintf(("","omap3_setmode_lcd: Banned!\n"));
		return; /* TODO - Mark as pending */
	}
	dprintf(("","omap3_setmode_lcd: rate=%d syncpol=%d\n",state->mode.pixelrate,state->mode.syncpol));
	dprintf(("","hsw=%d hfp=%d hbp=%d width=%d\n",state->mode.hsw,state->mode.hfp,state->mode.hbp,state->mode.width));
	dprintf(("","vsw=%d vfp=%d vbp=%d height=%d\n",state->mode.vsw,state->mode.vfp,state->mode.vbp,state->mode.height));

	volatile uint32_t *dispc_config = &dispc->config;
	volatile uint32_t *dispc_control = &dispc->control;
	/* We can skip this if we aren't changing pixel rate */
	if(state->mode.pixelrate != dsi_pll_current_pixel_rate)
	{
		dispc_change_pixelrate(state->mode.pixelrate,dispc_config,dispc_control);
		/* Select DSI_ALWON_FCLK as DISPC functional clock */
		dss->control |= DSS_CONTROL_DISPC_CLK_SWITCH;
	}
	else
		*dispc_control &= ~DISPC_CONTROL_GOLCD; /* Prevent any updates from occuring in the middle of our update. TODO - this isn't foolproof */

	/* 24. Re-enable free-running clock, LCD
	       (not necessary - free-running clock is SDI-only thing, and we only want to enable the LCD once we've programmed the mode timings!) */

	/* Get register values */
	dispcmode_t dm;
	dm.control = *dispc_control;
	dispc_getmode(&state->mode,&dm);
	dispc->size_lcd = dm.size_lcd;
	dispc->timing_h = dm.timing_h;
	dispc->timing_v = dm.timing_v;
	dispc->pol_freq = dm.pol_freq;

	/* Program for RFBI bypass mode */
	dm.control |= DISPC_CONTROL_GPOUT0 | DISPC_CONTROL_GPOUT1;

	/* Apply features */
	{
		const features_t *features = features_read_lock();
		omap3_apply_features(features);
		features_read_unlock();
	}

	/* Update transparency settings */
	omap3_flush_transparency_cfg(false);

	/* Load palette + frame data. TODO - Tweak? */
	*dispc_config = (*dispc_config &~DISPC_CONFIG_LOADMODE_MASK) | DISPC_CONFIG_LOADMODE_BOTH;
	/* Re-enable all the other clocks */
	*dispc_config &= ~(DISPC_CONFIG_PIXELGATED | DISPC_CONFIG_HSYNCGATED | DISPC_CONFIG_VSYNCGATED | DISPC_CONFIG_ACBIASGATED);

	/* Mark the head as active */
	{
		irqlocked_t *irqlocked = irqlocked_lock();
		irqlocked->heads[TARGET_LCD].dpms = 0;
		irqlocked->heads[TARGET_LCD].blanked = false;
		irqlocked_unlock();
	}
	{
		/* Getting a read lock here should be safe, but this still feels a bit nasty */
		const modelocked_t *modelocked = modelocked_read_lock();

		uint32_t mask = DISPC_IRQ_VSYNC | DISPC_IRQ_SYNCLOST;
#if 0//def DEBUGLIB /* Enable these IRQs for debug builds so we can see when they occur. */
		mask |= DISPC_IRQ_GFXFIFOUNDERFLOW | DISPC_IRQ_OCPERROR | DISPC_IRQ_VID1FIFOUNDERFLOW | DISPC_IRQ_VID2FIFOUNDERFLOW;
#endif
		/* Now enable display */
		*dispc_control = dm.control | DISPC_CONTROL_GOLCD | DISPC_CONTROL_LCDENABLE;
		if(modelocked->heads[TARGET_TV].enabled)
			mask |= DISPC_IRQ_EVSYNC_EVEN | DISPC_IRQ_EVSYNC_ODD | DISPC_IRQ_SYNCLOSTDIGITAL;
		dispc->irqenable = mask;

		modelocked_read_unlock();
	}

	/* Enable power to any external chips */
	(hwconfig->lcd_configs[current_lcd].power)(dev,65536);

	dprintf(("","omap3_setmode_lcd: Done\n"));
	end_slow_hardware_update(irqs);
}

static void omap3_setmode_tv(overlaytarget target,const modelocked_head_t *state)
{
	(void) target;
	(void) state; /* TODO - Make use of this (store TV-out mode & type there) */
	volatile uint32_t *dispc_config = &dispc->config;

	/* Apply features */
	{
		const features_t *features = features_read_lock();
		omap3_apply_features(features);
		features_read_unlock();
	}

	/* Load palette + frame data. TODO - Tweak? */
	*dispc_config = (*dispc_config &~DISPC_CONFIG_LOADMODE_MASK) | DISPC_CONFIG_LOADMODE_BOTH;

	venc_setmode();
}

static void omap3_setblank_lcd(overlaytarget target,bool blanked,uint8_t dpms)
{
	(void) target;

	/* If we're on a device with a fixed LCD, ignore the supplied
	   DPMS state and just turn the LCD off entirely */
	if(hwconfig->lcd_configs[current_lcd].lcd_timings)
	{
		(hwconfig->lcd_configs[current_lcd].power)(dev,(blanked?0:65536));
		dpms = 3; /* Should be safe to gate all clocks if we've just turned off the LCD */
	}

	{
		irqlocked_t *irqlocked = irqlocked_lock();
		irqlocked->heads[TARGET_LCD].blanked = blanked;
		irqlocked->heads[TARGET_LCD].dpms = dpms;
		irqlocked_unlock();
	}

	int irqs;
	if(begin_quick_hardware_update(&irqs))
	{
		uint32_t config = dispc->config & ~(DISPC_CONFIG_HSYNCGATED | DISPC_CONFIG_VSYNCGATED | DISPC_CONFIG_PIXELGATED);
		if(blanked)
		{
			/* Gate pixel clock */
			config |= DISPC_CONFIG_PIXELGATED;
			if(dpms & 1) /* Gate HSync */
				config |= DISPC_CONFIG_HSYNCGATED;
			if(dpms & 2) /* Gate VSync */
				config |= DISPC_CONFIG_VSYNCGATED;
		}
		dispc->config = config;
		/* It looks like we might need to set the go bits for all of the updates to take effect, even though the TRM suggests otherwise */
		dispc->control |= DISPC_CONTROL_GOLCD;
		end_quick_hardware_update(irqs);
	}
}

static void omap3_setblank_tv(overlaytarget target,bool blanked,uint8_t dpms)
{
	(void) target;
	{
		irqlocked_t *irqlocked = irqlocked_lock();
		irqlocked->heads[TARGET_TV].blanked = blanked;
		irqlocked->heads[TARGET_TV].dpms = dpms;
		irqlocked_unlock();
	}
	/* TODO - Only turn fully off if DPMS says so */
	venc_setblank(blanked);
}

/* Rely on target 0 == LCD, 1 == TV */
static void omap3_setbackground(overlaytarget target,const irqlocked_t *irqlocked)
{
	const features_t *features = features_read_lock();
	uint32_t col = irqlocked->heads[target].background >> 8;
	if(!(features->head_vals[target] & FEATURE_CPR))
		col = (col<<16) | (col & 0xff00) | (col>>16);
	dispc->default_color[target] = col;
	dispc->control |= ((target == TARGET_LCD)?DISPC_CONTROL_GOLCD:DISPC_CONTROL_GODIGITAL);
	features_read_unlock();
}

/* Rely on target 0 == LCD, 1 == TV */
static void omap3_settransparent(overlaytarget target,const irqlocked_t *irqlocked)
{
	dispc->trans_color[target] = irqlocked->heads[target].transparent;
	dispc->control |= ((target == TARGET_LCD)?DISPC_CONTROL_GOLCD:DISPC_CONTROL_GODIGITAL);
}

static void omap3_iicop_lcd(overlaytarget target,_kernel_swi_regs *r)
{
	(void) target;
	/* Call through to the HAL */
	/* TODO - Implement here instead */
	int count = r->r[2];
	_swix(OS_Hardware,_INR(0,2)|_INR(8,9)|_OUT(0),r->r[0],r->r[1],&count,OSHW_CallHAL,EntryNo_HAL_VideoIICOp,&r->r[0]);
	r->r[1] += count; /* Advance pointer */
	r->r[2] -= count; /* Bytes not transferred */
	r->r[4] = 0;
}

static void omap3_iicop_tv(overlaytarget target,_kernel_swi_regs *r)
{
	(void) target;
	(void) r;
	/* Don't claim the call */
}

static const lcdtimings_t *omap3_fixedtimings_lcd(overlaytarget target)
{
	(void) target;
	return hwconfig->lcd_configs[current_lcd].lcd_timings;
}

static const lcdtimings_t *omap3_fixedtimings_tv(overlaytarget target)
{
	(void) target;
	return NULL;
}

const headattr_t headattrs[TARGET_MAX] =
{
	{ /* TARGET_LCD */
		omap3_vetmode_lcd,
		omap3_prepmode_lcd,
		omap3_setmode_lcd,
		omap3_setblank_lcd,
		omap3_setbackground,
		omap3_settransparent,
		omap3_iicop_lcd,
		omap3_fixedtimings_lcd,
		omapformats,
		0,
		0,
		HEADATTR_CLAMPTIMINGS
	},
	{ /* TARGET_TV */
		omap3_vetmode_tv,
		omap3_prepmode_tv,
		omap3_setmode_tv,
		omap3_setblank_tv,
		omap3_setbackground,
		omap3_settransparent,
		omap3_iicop_tv,
		omap3_fixedtimings_tv,
		omapformats,
		0,
		FEATURE_CPR+FEATURE_GAMMAHACK,
		HEADATTR_INTERLACED
	}
};

static void omap3_gfx_enable(overlayidx overlay,const lloverlaycfg_t *ll)
{
	(void) overlay;
	volatile gfx_regs_t *r = &dispc->gfx;
	uint32_t attr = r->attributes;
	uint32_t gobits = 0;
	/* If we're moving it from one display to another, we need to update both - so gobits should take into account both the initial and final display */
	if(attr & OVERLAY_ATTRIBUTES_ENABLE)
		gobits = ((attr & OVERLAY_ATTRIBUTES_GFXCHANNELOUT)?DISPC_CONTROL_GODIGITAL:DISPC_CONTROL_GOLCD);
	if(ll->target == TARGET_LCD)
		gobits |= DISPC_CONTROL_GOLCD;
	else
		gobits |= DISPC_CONTROL_GODIGITAL;

	uint32_t format = omapformats[ll->format].omapformat;

	/* Program registers */
	r->ba[0] = ll->ba[0];
	r->ba[1] = ll->ba[1];
	r->position = ll->position;
	r->size = ll->size;
	r->pixel_inc = 1;
	r->row_inc = ll->row_inc;
	uint32_t temp = REG_EXTRACT(r->fifo_size_status,OVERLAY_FIFO_SIZE_STATUS);
	r->fifo_threshold = ((temp-1)<<OVERLAY_FIFOHIGHTHRESHOLD_SHIFT) | ((temp-(16*4))<<OVERLAY_FIFOLOWTHRESHOLD_SHIFT);
	dispc->gfx_preload = fifo_preload_for_lcd[hwconfig->lcd_configs[current_lcd].lcd_type]; /* TODO - What about digital output? What if we add LCD_NONE for no LCD available? */
	r->table_ba = gfx_palette_p;
	r->attributes = OVERLAY_ATTRIBUTES_ENABLE
	              | format
	              | OVERLAY_ATTRIBUTES_ROTATION_0
	              | OVERLAY_ATTRIBUTES_GFXREPLICATIONENABLE
	              | OVERLAY_ATTRIBUTES_GFXBURSTSIZE_16X32
	              | (ll->target == TARGET_TV?OVERLAY_ATTRIBUTES_GFXCHANNELOUT:0)
	              | (ll->highprio ? OVERLAY_ATTRIBUTES_GFXARBITRATION : 0);

	dispc->control |= gobits;
}

static void omap3_gfx_disable(overlayidx overlay)
{
	(void) overlay;
	volatile gfx_regs_t *r = &dispc->gfx;
	uint32_t attr = r->attributes;
	if(attr & OVERLAY_ATTRIBUTES_ENABLE)
	{
		attr &= OVERLAY_ATTRIBUTES_GFXCHANNELOUT;
		uint32_t gobits = (attr?DISPC_CONTROL_GODIGITAL:DISPC_CONTROL_GOLCD);
		r->attributes = attr;
		dispc->control |= gobits;
	}
}

/* Colour convolution + extra flags for all four YUV colour spaces
   Transcribed from OMAP3 TRM */
#define COLOURCONV(RY,RCr,RCb,GY,GCr,GCb,BY,BCr,BCb,flag) { \
  (RY & 0x7ff) + ((RCr & 0x7ff) << 16), \
  (RCb & 0x7ff) + ((GY & 0x7ff) << 16), \
  (GCr & 0x7ff) + ((GCb & 0x7ff) << 16), \
  (BY & 0x7ff) + ((BCr & 0x7ff) << 16), \
  BCb & 0x7ff, \
  OVERLAY_ATTRIBUTES_VIDCOLORCONVENABLE + (flag * OVERLAY_ATTRIBUTES_VIDFULLRANGE), \
}

static const uint32_t colour_conv[4][6] =
{
	COLOURCONV(298,409,0,298,-208,-100,298,0,517,0), /* 601 video */
	COLOURCONV(256,351,0,256,-179,-86,256,0,443,1), /* 601 full */
	COLOURCONV(298,459,0,298,-137,-55,298,0,541,0), /* 709 video */
	COLOURCONV(256,394,0,256,-118,-47,256,0,465,1), /* 709 full */
};

static void omap3_vid_enable(overlayidx overlay,const lloverlaycfg_t *ll)
{
	volatile vid_regs_t *r = (overlay==OVERLAY_VID1?&dispc->vid1:&dispc->vid2);
	uint32_t attr = r->attributes;
	uint32_t gobits = 0;
	/* If we're moving it from one display to another, we need to update both - so gobits should take into account both the initial and final display */
	if(attr & OVERLAY_ATTRIBUTES_ENABLE)
		gobits = ((attr & OVERLAY_ATTRIBUTES_VIDCHANNELOUT)?DISPC_CONTROL_GODIGITAL:DISPC_CONTROL_GOLCD);
	if(ll->target == TARGET_LCD)
		gobits |= DISPC_CONTROL_GOLCD;
	else
		gobits |= DISPC_CONTROL_GODIGITAL;

	uint32_t format = omapformats[ll->format].omapformat;

	/* TODO: Avoid doing this every time */
	if (ll->fir != 0x04000400)
	{
		dispc_program_vid_scale_coefficients(r->fir_coef,dispc->vid_fir_coef_v[overlay-OVERLAY_VID1],(ll->fir & VID_OVERLAY_FIR_HINC_MASK) < (1024<<VID_OVERLAY_FIR_HINC_SHIFT),(ll->fir & VID_OVERLAY_FIR_VINC_MASK) < (1024<<VID_OVERLAY_FIR_VINC_SHIFT),ll->v5tap); 
	}

	r->ba[0] = ll->ba[0];
	r->ba[1] = ll->ba[1];
	r->position = ll->position;
	r->size = ll->size;
	uint32_t row_inc = ll->row_inc;
	r->pixel_inc = 1;
	r->fir = ll->fir;
	r->picture_size = ll->pic_size;
	r->accui[0] = ll->accui[0];
	r->accui[1] = ll->accui[1];
	uint32_t temp = REG_EXTRACT(r->fifo_size_status,OVERLAY_FIFO_SIZE_STATUS);
	r->fifo_threshold = ((temp-1)<<OVERLAY_FIFOHIGHTHRESHOLD_SHIFT) | ((temp-(16*4))<<OVERLAY_FIFOLOWTHRESHOLD_SHIFT);
	dispc->vid_preload[overlay-OVERLAY_VID1] = fifo_preload_for_lcd[hwconfig->lcd_configs[current_lcd].lcd_type];
	uint32_t newattr = OVERLAY_ATTRIBUTES_ENABLE
	                 | format
	                 | OVERLAY_ATTRIBUTES_ROTATION_0
	                 | OVERLAY_ATTRIBUTES_VIDREPLICATIONENABLE
	                 | OVERLAY_ATTRIBUTES_VIDRESIZEENABLE_NONE
	                 | OVERLAY_ATTRIBUTES_VIDBURSTSIZE_16X32
	                 | (ll->target == TARGET_TV?OVERLAY_ATTRIBUTES_VIDCHANNELOUT:0)
	                 | (ll->highprio ? OVERLAY_ATTRIBUTES_VIDARBITRATION : 0)
	                 | ((ll->fir & VID_OVERLAY_FIR_HINC_MASK) != (1024<<VID_OVERLAY_FIR_HINC_SHIFT)?OVERLAY_ATTRIBUTES_VIDRESIZEENABLE_H:0)
	                 | ((ll->fir & VID_OVERLAY_FIR_HINC_MASK) > (1024<<VID_OVERLAY_FIR_HINC_SHIFT)?OVERLAY_ATTRIBUTES_VIDHRESIZECONF:0)
	                 | ((ll->fir & VID_OVERLAY_FIR_VINC_MASK) != (1024<<VID_OVERLAY_FIR_VINC_SHIFT)?OVERLAY_ATTRIBUTES_VIDRESIZEENABLE_V:0)
	                 | ((ll->fir & VID_OVERLAY_FIR_VINC_MASK) > (1024<<VID_OVERLAY_FIR_VINC_SHIFT)?OVERLAY_ATTRIBUTES_VIDVRESIZECONF:0)
	                 | (ll->v5tap ? OVERLAY_ATTRIBUTES_VIDVERTICALTAPS : 0);
	if ((format == OVERLAY_ATTRIBUTES_FORMAT_YUV2) || (format == OVERLAY_ATTRIBUTES_FORMAT_UYVY))
	{
		const uint32_t *settings = colour_conv[omapformats[ll->format].extra_flags & (EXTRAFLAG_FULLRANGE|EXTRAFLAG_709)];
		uint8_t features = features_read_lock()->head_vals[ll->target];
		features_read_unlock();
		if (features & FEATURE_CPR)
		{
			/* Red/blue swap the convolution matrix, to counter the CPR */
			r->conv_coef[0] = settings[3];
			r->conv_coef[1] = settings[4] | (settings[1] & 0xffff0000);
			r->conv_coef[2] = settings[2];
			r->conv_coef[3] = settings[0];
			r->conv_coef[4] = settings[1] & 0xffff;
		}
		else
		{
			r->conv_coef[0] = settings[0];
			r->conv_coef[1] = settings[1];
			r->conv_coef[2] = settings[2];
			r->conv_coef[3] = settings[3];
			r->conv_coef[4] = settings[4];
		}
		newattr |= settings[5];
		switch(ll->rotation)
		{
		case 1:
			newattr |= OVERLAY_ATTRIBUTES_ROTATION_90 | OVERLAY_ATTRIBUTES_VIDROWREPEATENABLE;
			break;
		case 2:
			newattr |= OVERLAY_ATTRIBUTES_ROTATION_180;
			break;
		case 3:
			newattr |= OVERLAY_ATTRIBUTES_ROTATION_270 | OVERLAY_ATTRIBUTES_VIDROWREPEATENABLE;
			break;
		}
	}
	r->row_inc = row_inc;
	r->attributes = newattr;
	dispc->control |= gobits;
}

static void omap3_vid_disable(overlayidx overlay)
{
	volatile vid_regs_t *r = (overlay==OVERLAY_VID1?&dispc->vid1:&dispc->vid2);
	uint32_t attr = r->attributes;
	if(attr & OVERLAY_ATTRIBUTES_ENABLE)
	{
		attr &= OVERLAY_ATTRIBUTES_VIDCHANNELOUT;
		uint32_t gobits = (attr?DISPC_CONTROL_GODIGITAL:DISPC_CONTROL_GOLCD);
		r->attributes = attr;
		dispc->control |= gobits;
	}
}

const overlayattr_t overlayattrs[OVERLAY_MAX] =
{
	{ /* OVERLAY_GFX */
		omap3_gfx_enable,
		omap3_gfx_disable,
	},
	{ /* OVERLAY_VID1 */
		omap3_vid_enable,
		omap3_vid_disable,
	},
	{ /* OVERLAY_VID2 */
		omap3_vid_enable,
		omap3_vid_disable,
	}
};

void omap_pick_overlays(overlaytarget head, pixelformat format, modelocked_t *modelocked)
{
	(void) head;
	/* OMAP3 doesn't have many useful configurations if you want desktop +
	   pointer + YUV overlay.

	   We're going to go with the following scheme:
	   * If we're in a paletted mode, use TRANSPARENCY_TCK_VIDSRC
	     (VID2->VID1->GFX->BGCOL layering), with VID2 for the pointer, VID1
	     for YUV, GFX for desktop. TCK used to give pointer its shape.
	   * If we're in an alpha mode, use TRANSPARENCY_ALPHA
	     (GFX->VID2->VID1->BGCOL layering), with GFX for the pointer, VID2
	     for the desktop, and VID1 for YUV. Alpha used to give pointer its
	     shape.
	   * If we're in a non-alpha mode, use TRANSPARENCY_ALPHA
	     (GFX->VID2->VID1->BGCOL layering), with GFX for the pointer, VID2
	     for YUV, and VID1 for the desktop. Alpha used to give pointer its
	     shape.

	   This somewhat odd setup results in the following:
	   * Paletted & non-alpha modes have a YUV "overlay" which will appear
	     ontop of the desktop (and thus need some careful management to
	     avoid it appearing ontop of other windows).
	   * Alpha modes will have a YUV "underlay" which is underneath the
	     desktop, with the desktop alpha controlling blending with the
	     desktop itself. Pointer uses alpha to give it its shape.
	   * Non-paletted modes can make use of hardware display scaling (once
	     we implement it!) - although pointer scaling may be a bit ugly due
	     to no software scaling being available (as a compromise, we could
	     insert more places where the overlay configurations are changed
	     around, so the pointer is only forced to GFX once an overlay is in
	     use)
	 */
	switch(format)
	{
	default:
	case PIXELFORMAT_1_PAL:
	case PIXELFORMAT_2_PAL:
	case PIXELFORMAT_4_PAL:
	case PIXELFORMAT_8_PAL:
		current_transparencycfgs[head] = TRANSPARENCY_TCK_VIDSRC;
		modelocked->overlay_desktop = OVERLAY_GFX;
		modelocked->overlay_pointer = OVERLAY_VID2;
		current_gvoverlay_mode = GVOverlayType_Basic;
		break;
	case PIXELFORMAT_4444_ABGR:
	case PIXELFORMAT_4444_ARGB:
	case PIXELFORMAT_1555_ABGR:
	case PIXELFORMAT_1555_ARGB:
	case PIXELFORMAT_8888_ABGR:
	case PIXELFORMAT_8888_ARGB:
		current_transparencycfgs[head] = TRANSPARENCY_ALPHA;
		modelocked->overlay_desktop = OVERLAY_VID2;
		modelocked->overlay_pointer = OVERLAY_GFX;
		current_gvoverlay_mode = GVOverlayType_ZOrder;
		break;
	case PIXELFORMAT_4444_TBGR:
	case PIXELFORMAT_4444_TRGB:
	case PIXELFORMAT_1555_TBGR:
	case PIXELFORMAT_1555_TRGB:
	case PIXELFORMAT_565_BGR:
	case PIXELFORMAT_565_RGB:
	case PIXELFORMAT_888_BGR:
	case PIXELFORMAT_888_RGB:
	case PIXELFORMAT_8888_TBGR:
	case PIXELFORMAT_8888_TRGB:
	case PIXELFORMAT_UYVY_601_full:
	case PIXELFORMAT_UYVY_601_video:
	case PIXELFORMAT_UYVY_709_full:
	case PIXELFORMAT_UYVY_709_video:
	case PIXELFORMAT_YUY2_601_full:
	case PIXELFORMAT_YUY2_601_video:
	case PIXELFORMAT_YUY2_709_full:
	case PIXELFORMAT_YUY2_709_video:
		current_transparencycfgs[head] = TRANSPARENCY_ALPHA;
		modelocked->overlay_desktop = OVERLAY_VID1;
		modelocked->overlay_pointer = OVERLAY_GFX;
		current_gvoverlay_mode = GVOverlayType_Basic;
		break;
	}
	omap3_flush_transparency_cfg(true);
}

int omap_scalable_overlays(const modelocked_t *modelocked, overlaytarget target, pixelformat format)
{
	(void) modelocked;
	(void) target;
	/* TCK doesn't play nice with scaling RGB formats */
	uint32_t omapformat = omapformats[format].omapformat;
	if ((omapformat != OVERLAY_ATTRIBUTES_FORMAT_YUV2) && (omapformat != OVERLAY_ATTRIBUTES_FORMAT_UYVY))
	{
		switch (current_transparencycfgs[target])
		{
		case TRANSPARENCY_TCK_VIDSRC:
		case TRANSPARENCY_TCK_GFXSRC:
		case TRANSPARENCY_TCK_GFXDEST:
			return 0;
		}
	}
	/* Only video overlays support scaling */
	return (1<<OVERLAY_VID1) | (1<<OVERLAY_VID2);
}

void omap_set_zorder(const overlayidx *order,int count,const modelocked_t *modelocked)
{
	(void) order;
	(void) count;
	(void) modelocked;
	/* Just ignore the request */
}

static const uint8_t fir_pcd_min[3][5] =
{
	{ 1, 1, 2, 3, 4 },
	{ 1, 1, 2, 3, 4 },
	{ 2, 2, 4, 6, 8 },
};

/* Check if the given FIR values are acceptable for the current mode */
bool omap_check_fir(int fir_x,int fir_y,int buf_h,int scaled_w,int scaled_h,pixelformat format,const modelocked_t *modelocked, overlaytarget target,bool *v5tap)
{
	const int pcd = 2; /* TODO: Read from registers */
	const lcdtimings_t *timings = &modelocked->heads[target].mode;
	/* Work out coordinates in the table */
	int row,col;
	dprintf(("","omap_check_fir: fir_x %d fir_y %d buf_h %d scaled_w %d scaled_h %d format %s\n",fir_x,fir_y,buf_h,scaled_w,scaled_h,pixelformatnames[format]));
	if ((fir_x > 4096) || (fir_y > 4096) || (fir_x < 128) || (fir_y < 128))
		return false; /* Beyond 8x upscale / 4x downscale limits */

	if (fir_x == 1024)
		col = 0;
	else if (fir_x < 1024) /* upscale */
		col = 1;
	else if (fir_x <= 2048) /* 1:1 - 1:2 */
		col = 2;
	else if (fir_x <= 3072) /* 1:2 - 1:3 */
		col = 3;
	else /* 1:3 - 1:4 */
		col = 4;

	if (fir_y == 1024)
		row = 0;
	else if (fir_y < 1024) /* upscale */
		row = 1;
	else if (fir_y <= 2048) /* 1:1 - 1:2 */
		row = 2;
	else /* 1:2 - 1:4 */
		row = 3;

	int PCDmin;
	if (row < 3)
	{
		PCDmin = fir_pcd_min[row][col];
		/* PCDmin of 1 only possible if IPC is clear */
		if ((PCDmin == 1) && (dispc->pol_freq & DISPC_POL_FREQ_IPC))
		{
			PCDmin = 2;
		}
		if ((pcd < PCDmin) && (fir_y > 1024))
		{
			/* Try 5-tap vertical filter, it often has lower PCD requirements */
			row = 3;
		}
	}

	if (row == 3)
	{
		/* h_ratio is used as the denominator when calculating PCDmin, so for safety we want the value to be rounded down (so that our PCD estimate won't be an under-estimate)
		   10 bit fraction used to match up with v_ratio (== fir_y)
		   Cropping the image horizontally will make scaled_w shrink, making h_ratio grow, making the PCD requirement drop - so the value we calculate here will always be an over-estimate
		   However, we also know that the scaled width will never be larger than the screen width, so we can clamp that to a sensible value here as well */
		int h_ratio = (scaled_w >= timings->width ? 1024 : ((timings->width<<10)/scaled_w));
		/* v_ratio is essentially fir_y */
		int v_ratio = fir_y;

#define DIV_ROUND_UP(X,Y) (((X)+(Y)-1)/(Y))

		int PCDmin_v_only = DIV_ROUND_UP(v_ratio,(2*h_ratio));

		if (v_ratio > 2048)
		{
			if (h_ratio <= 1024)
			{
				/* Prevent zero/negative denominator */
				return false;
			}
			PCDmin_v_only = MAX(PCDmin_v_only,DIV_ROUND_UP(v_ratio-2048,2*(h_ratio-1024)));
		}
		if (fir_x > 1024)
		{
			/* H+V downscale */
			/* PCDmin for H can be taken from top row of table */
			PCDmin = MAX(PCDmin_v_only,fir_pcd_min[0][col]);
		}
		else
		{
			PCDmin = PCDmin_v_only;
		}

		/* 32bpp requires double the count if horizontal downscaling also active */
		if ((fir_x > 1024) && (pixel_format_bpp[format] > 16))
		{
			PCDmin *= 2;
		}
	}
	dprintf(("","row %d col %d pcd %d min %d\n",row,col,pcd,PCDmin));
	if (pcd < PCDmin)
	{
		return false;
	}

	/* Use 5-tap vertical filter if necessary */
	if (v5tap)
	{
		*v5tap = (row == 3);
	}

	/* PCD is good, but we also need to worry about the mode timings */
	if (target == TARGET_TV)
	{
		/* Assume TV-out will always be good?
		   TODO - Use proper timings */
		return true;
	}
	int val = (timings->hbp + timings->hsw + timings->hfp) * pcd;
	dprintf(("","val %d\n",val));
	if ((fir_x <= 1024) && (fir_y <= 1024))
	{
		/* No downsampling */
		return (val > 8);
	}
	if ((fir_x > 1024) && (fir_y > 1024))
	{
		/* H+V downsampling */
		return (val > 20);
	}
	/* H or V downsampling */
	return (val > 10);
}

#ifdef DEBUGLIB

void omap_dump_videoregs(void)
{
	DUMPREG(dss,sysconfig);
	DUMPREG(dss,sysstatus);
	DUMPREG(dss,irqstatus);
	DUMPREG(dss,control);
	DUMPREG(dss,sdi_control);
	DUMPREG(dss,pll_control);
	DUMPREG(dss,sdi_status);

	DUMPREG(dispc,sysconfig);
	DUMPREG(dispc,sysstatus);
	DUMPREG(dispc,irqstatus);
	DUMPREG(dispc,irqenable);
	DUMPREG(dispc,control);
	DUMPREG(dispc,config);
	DUMPREG(dispc,default_color[0]);
	DUMPREG(dispc,default_color[1]);
	DUMPREG(dispc,trans_color[0]);
	DUMPREG(dispc,trans_color[1]);
	DUMPREG(dispc,line_status);
	DUMPREG(dispc,line_number);
	DUMPREG(dispc,timing_h);
	DUMPREG(dispc,timing_v);
	DUMPREG(dispc,pol_freq);
	DUMPREG(dispc,divisor);
	DUMPREG(dispc,global_alpha);
	DUMPREG(dispc,size_dig);
	DUMPREG(dispc,size_lcd);

	DUMPREG(dispc,gfx.ba[0]);
	DUMPREG(dispc,gfx.ba[1]);
	DUMPREG(dispc,gfx.position);
	DUMPREG(dispc,gfx.size);
	DUMPREG(dispc,gfx.attributes);
	DUMPREG(dispc,gfx.fifo_threshold);
	DUMPREG(dispc,gfx.fifo_size_status);
	DUMPREG(dispc,gfx.row_inc);
	DUMPREG(dispc,gfx.pixel_inc);
	DUMPREG(dispc,gfx.window_skip);
	DUMPREG(dispc,gfx.table_ba);

	DUMPREG(dispc,vid1.ba[0]);
	DUMPREG(dispc,vid1.ba[1]);
	DUMPREG(dispc,vid1.position);
	DUMPREG(dispc,vid1.size);
	DUMPREG(dispc,vid1.attributes);
	DUMPREG(dispc,vid1.fifo_threshold);
	DUMPREG(dispc,vid1.fifo_size_status);
	DUMPREG(dispc,vid1.row_inc);
	DUMPREG(dispc,vid1.pixel_inc);
	DUMPREG(dispc,vid1.fir);
	DUMPREG(dispc,vid1.picture_size);
	DUMPREG(dispc,vid1.accui[0]);
	DUMPREG(dispc,vid1.accui[1]);
	DUMPREG(dispc,vid1.fir_coef[0].h);
	DUMPREG(dispc,vid1.fir_coef[0].hv);
	DUMPREG(dispc,vid1.fir_coef[1].h);
	DUMPREG(dispc,vid1.fir_coef[1].hv);
	DUMPREG(dispc,vid1.fir_coef[2].h);
	DUMPREG(dispc,vid1.fir_coef[2].hv);
	DUMPREG(dispc,vid1.fir_coef[3].h);
	DUMPREG(dispc,vid1.fir_coef[3].hv);
	DUMPREG(dispc,vid1.fir_coef[4].h);
	DUMPREG(dispc,vid1.fir_coef[4].hv);
	DUMPREG(dispc,vid1.fir_coef[5].h);
	DUMPREG(dispc,vid1.fir_coef[5].hv);
	DUMPREG(dispc,vid1.fir_coef[6].h);
	DUMPREG(dispc,vid1.fir_coef[6].hv);
	DUMPREG(dispc,vid1.fir_coef[7].h);
	DUMPREG(dispc,vid1.fir_coef[7].hv);
	DUMPREG(dispc,vid1.conv_coef[0]);
	DUMPREG(dispc,vid1.conv_coef[1]);
	DUMPREG(dispc,vid1.conv_coef[2]);
	DUMPREG(dispc,vid1.conv_coef[3]);
	DUMPREG(dispc,vid1.conv_coef[4]);

	DUMPREG(dispc,vid2.ba[0]);
	DUMPREG(dispc,vid2.ba[1]);
	DUMPREG(dispc,vid2.position);
	DUMPREG(dispc,vid2.size);
	DUMPREG(dispc,vid2.attributes);
	DUMPREG(dispc,vid2.fifo_threshold);
	DUMPREG(dispc,vid2.fifo_size_status);
	DUMPREG(dispc,vid2.row_inc);
	DUMPREG(dispc,vid2.pixel_inc);
	DUMPREG(dispc,vid2.fir);
	DUMPREG(dispc,vid2.picture_size);
	DUMPREG(dispc,vid2.accui[0]);
	DUMPREG(dispc,vid2.accui[1]);
	DUMPREG(dispc,vid2.fir_coef[0].h);
	DUMPREG(dispc,vid2.fir_coef[0].hv);
	DUMPREG(dispc,vid2.fir_coef[1].h);
	DUMPREG(dispc,vid2.fir_coef[1].hv);
	DUMPREG(dispc,vid2.fir_coef[2].h);
	DUMPREG(dispc,vid2.fir_coef[2].hv);
	DUMPREG(dispc,vid2.fir_coef[3].h);
	DUMPREG(dispc,vid2.fir_coef[3].hv);
	DUMPREG(dispc,vid2.fir_coef[4].h);
	DUMPREG(dispc,vid2.fir_coef[4].hv);
	DUMPREG(dispc,vid2.fir_coef[5].h);
	DUMPREG(dispc,vid2.fir_coef[5].hv);
	DUMPREG(dispc,vid2.fir_coef[6].h);
	DUMPREG(dispc,vid2.fir_coef[6].hv);
	DUMPREG(dispc,vid2.fir_coef[7].h);
	DUMPREG(dispc,vid2.fir_coef[7].hv);
	DUMPREG(dispc,vid2.conv_coef[0]);
	DUMPREG(dispc,vid2.conv_coef[1]);
	DUMPREG(dispc,vid2.conv_coef[2]);
	DUMPREG(dispc,vid2.conv_coef[3]);
	DUMPREG(dispc,vid2.conv_coef[4]);

	DUMPREG(dispc,data_cycle[0]);
	DUMPREG(dispc,data_cycle[1]);
	DUMPREG(dispc,data_cycle[2]);
	DUMPREG(dispc,cpr_coef_r);
	DUMPREG(dispc,cpr_coef_g);
	DUMPREG(dispc,cpr_coef_b);
	DUMPREG(dispc,gfx_preload);
	DUMPREG(dispc,vid_preload[0]);
	DUMPREG(dispc,vid_preload[1]);

	DUMPREG(dsi,ctrl);
	DUMPREG(dsi,clk_ctrl);

	DUMPREG(dsi_pll,control);
	DUMPREG(dsi_pll,status);
	DUMPREG(dsi_pll,go);
	DUMPREG(dsi_pll,configuration1);
	DUMPREG(dsi_pll,configuration2);

	printf("Ban state: %08x\n",ban_hardware_update);
}

void omap_dump_tvregs(void)
{
	DUMPREG(venc,status);
	DUMPREG(venc,f_control);
	DUMPREG(venc,vidout_ctrl);
	DUMPREG(venc,sync_ctrl);
	DUMPREG(venc,llen);
	DUMPREG(venc,flens);
	DUMPREG(venc,hfltr_ctrl);
	DUMPREG(venc,cc_carr_wss_carr);
	DUMPREG(venc,c_phase);
	DUMPREG(venc,gain_u);
	DUMPREG(venc,gain_y);
	DUMPREG(venc,gain_v);
	DUMPREG(venc,black_level);
	DUMPREG(venc,blank_level);
	DUMPREG(venc,x_color);
	DUMPREG(venc,m_control);
	DUMPREG(venc,bstamp_wss_data);
	DUMPREG(venc,s_carr);
	DUMPREG(venc,line21);
	DUMPREG(venc,ln_sel);
	DUMPREG(venc,l21_wc_ctl);
	DUMPREG(venc,htrigger_vtrigger);
	DUMPREG(venc,savid_eavid);
	DUMPREG(venc,flen_fal);
	DUMPREG(venc,lal_phase_reset);
	DUMPREG(venc,hs_int_start_stop_x);
	DUMPREG(venc,hs_ext_start_stop_x);
	DUMPREG(venc,vs_int_start_x);
	DUMPREG(venc,vs_int_stop_x_vs_int_start_y);
	DUMPREG(venc,vs_int_stop_y_vs_ext_start_x);
	DUMPREG(venc,vs_ext_stop_x_vs_ext_start_y);
	DUMPREG(venc,vs_ext_stop_y);
	DUMPREG(venc,avid_start_stop_x);
	DUMPREG(venc,avid_start_stop_y);
	DUMPREG(venc,fid_int_start_x_fid_int_start_y);
	DUMPREG(venc,fid_int_offset_y_fid_ext_start_x);
	DUMPREG(venc,fid_ext_start_y_fid_ext_offset_y);
	DUMPREG(venc,tvdetgp_int_start_stop_x);
	DUMPREG(venc,tvdetgp_int_start_stop_y);
	DUMPREG(venc,gen_ctrl);
	DUMPREG(venc,output_control);
	DUMPREG(venc,output_test);

	DUMPREG(dispc,control);

	DUMPREG(dss,control);
}

#endif
