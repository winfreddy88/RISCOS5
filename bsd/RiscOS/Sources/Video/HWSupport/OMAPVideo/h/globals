/*
 * Copyright (c) 2010, RISC OS Open Ltd
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef OMAPVIDEO_GLOBALS_H
#define OMAPVIDEO_GLOBALS_H

#include <stdbool.h>
#include <stdint.h>

#include "types.h"

#ifdef DEBUGLIB
/* Read microsecond countdown timer value for debugging */
extern uint32_t timer_read(void);
#endif

extern void omap_init(void);

/* Update feature selection based around overlay 'idx' using the given pixel format & being assigned to the given 'target' head
   Must be called whenever the target or format values change, to ensure the head is configured correctly (e.g. CPR, gamma)
   Must only be called from the foreground
   Doesn't need calling for the mouse overlay, since that doesn't request any special features */
extern void omap_update_features(overlayidx idx, overlaytarget target, pixelformat format);

/* Pick the display to use on startup */
extern overlaytarget omap_pick_display(void);

/* Pick the overlays & transparency mode to use when the desktop is using the given head + pixel format */
extern void omap_pick_overlays(overlaytarget head, pixelformat format, modelocked_t *modelocked);

/* Set the Z order for the given overlays. Frontmost = first entry. */
extern void omap_set_zorder(const overlayidx *order,int count,const modelocked_t *modelocked);

/* Check if the given FIR values are acceptable, and calculate whether 5-tap V filter required */
extern bool omap_check_fir(int fir_x,int fir_y,int buf_h,int scaled_w,int scaled_h,pixelformat format,const modelocked_t *modelocked,overlaytarget target,bool *v5tap);

/* Return mask of which overlays can support scaling, for the indicated head & pixel format */
extern int omap_scalable_overlays(const modelocked_t *modelocked, overlaytarget target, pixelformat format);

#if OMAP==3
extern void omap3_flush_transparency_cfg(bool go);
extern void omap3_apply_features(const features_t *features);
#endif

/* Estimate required memory bandwidth for an overlay, in KB/s */
extern uint32_t bandwidth_estimate(const overlaycfg_t *o,const modelocked_t *modelocked);

#endif
