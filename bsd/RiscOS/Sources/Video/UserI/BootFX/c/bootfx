/* @file BootFX.c
 *
 * This module provides features to enhance the existing boot sequence. It should
 * ideally be built into ROM and used in co-operation with a newer version of
 * BootCommands and ScreenFX in order to provide all of its functionality.
 */

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>

#include "Global/RISCOS.h"
#include "Global/NewErrors.h"
#include "Global/Services.h"
#include "Global/Sprite.h"
#include "Global/CMOS.h"
#include "Global/OSMem.h"
#include "Interface/HighFSI.h"
#include "swis.h"
#include "BootFXHdr.h"
#include "bootfx.h"

/** A quick macro to silence compiler warnings about unused parameters. */
#define IGNORE(x) do { (void)(x); } while(0)

/** Trap and return non-NULL RISC OS error block pointers. */
#define ERR(cmd) do { _kernel_oserror *err = cmd; if (err) return err; } while(0)

/** Trap an error and jump to an appropriate label to handle it. */
#define ERR_GOTO(cmd) do { err = cmd; if (err) goto error; } while(0)

/** Free a buffer (if non-NULL). */
#define FREE(ptr) do { if (ptr) { free(ptr); ptr = NULL; } } while (0)

/** Size (bytes) of our CLI buffer. */
#define CLI_BUF_SZ (512)

/** ID word at start of an Acorn Squash file. */
#define SQUASH_HEADER (0x48535153)

/** Filetype for an Acorn Squash file. */
#define TYPE_SQUASH (0xFCA)

/** Filetype for an Acorn Sprite file. */
#define TYPE_SPRITE (0xFF9)

/** Dynamic area name string for unsquashing sprite files. */
#define DA_NAME "BootFX sprites"

/** The root of ResourceFS */
#define RESFS_STR "Resources:$"

/** The location of our resource directory in ResourceFS. */
#define RESFS_PATH RESFS_STR ".Resources.BootFX."

/** Location of our logo JPEG. */
#define LOGO_JPEG_FILE RESFS_PATH "Logo"

/** Time to fade out before plotting splash screen (centiseconds). */
#define FADE_OUT_CS (10)

/** Time to fade in after plotting splash screen (centiseconds). */
#define FADE_IN_CS (200)

/** Flag bit for SWI BootFX_BarUpdate. */
#define FLAG_BarUpdate_NoWait (1)

/** These functions are autogenerated by ResGen, and return a pointer to a ResourceFS resource file data block. */
extern void *Resources(void);

/* Various potentially useful structures */
typedef struct sprite_area_s sprite_area_t;
typedef struct sprite_s sprite_t;
typedef struct mode_s mode_t;
typedef struct gclip_s __packed gclip_t;
typedef struct tclip_s __packed tclip_t;
typedef struct trans_s trans_t;
typedef struct squash_s squash_t;
typedef struct barinfo_s barinfo_t;
typedef struct infochain_s infochain_t;
typedef struct layout_s layout_t;

/** An OS sprite area structure.
 */
struct sprite_area_s
{
  uint32_t size;           /**< Area size (bytes). */
  uint32_t num_spr;        /**< Number of sprites in the area. */
  uint32_t sprite;         /**< Offset to first sprite. */
  uint32_t free;           /**< Offset to first free byte. */
};

/** An OS sprite control block structure.
 */
struct sprite_s
{
  uint32_t next;           /**< Offset to next sprite (bytes). */
  char     name[12];       /**< Sprite name string. */
  uint32_t width;          /**< Width (words) - 1. */
  uint32_t height;         /**< Height (scanlines) - 1. */
  uint32_t first_bit;      /**< First bit used (left). */
  uint32_t last_bit;       /**< Last bit used (right). */
  uint32_t image;          /**< Offset to sprite image (bytes). */
  uint32_t mask;           /**< Offset to sprite mask (bytes). */
  uint32_t type;           /**< Sprite type word. */
};

/** A structure to hold information about the current screen mode.
 */
struct mode_s
{
  int32_t   screen_x;      /**< Width of the current screen mode (OS units). */
  int32_t   screen_y;      /**< Height of the current screen mode (OS units). */
  uint32_t  bpp;           /**< Number of bits per pixel. */
  uint32_t  xeig;          /**< X eigen value. */
  uint32_t  yeig;          /**< Y eigen value. */
};

/** A structure to hold graphics clipping window information.
 */
struct gclip_s
{
  uint8_t vdu;             /**< VDU code (24). */
  int16_t xmin;            /**< Left edge (OS units, inclusive). */
  int16_t ymin;            /**< Bottom edge (OS units, inclusive). */
  int16_t xmax;            /**< Right edge (OS units, inclusive). */
  int16_t ymax;            /**< Top edge (OS units, inclusive). */
};

/** A structure to hold text window information.
 */
struct tclip_s
{
  uint8_t vdu;             /**< VDU code (28). */
  uint8_t xmin;            /**< Left edge (chracters, inclusive). */
  uint8_t ymin;            /**< Bottom edge (characters, inclusive). */
  uint8_t xmax;            /**< Right edge (characters, inclusive). */
  uint8_t ymax;            /**< Top edge (characters, inclusive). */
};

/** JPEG transformatio matrix for plotting scaled.
 */
struct trans_s
{
  int32_t mx;              /**< Horizontal multiplier. */
  int32_t my;              /**< Vertical multiplier. */
  int32_t dx;              /**< Horizontal divider. */
  int32_t dy;              /**< Vertical divider. */
};

/** Structure of a squash file header.
 */
struct squash_s
{
  uint32_t id;             /**< ID word "SQSH". */
  uint32_t size;           /**< Uncompressed size (bytes). */
  uint32_t load;           /**< Load address. */
  uint32_t exec;           /**< Exec address. */
  uint32_t attr;           /**< Attributes. */
};

/** Block of progress bar information.
 */
struct barinfo_s
{
  int32_t        x;                /**< Origin co-ordinates for progress bar (OS units). */
  int32_t        y;                /**< Origin co-ordinates for progress bar (OS units). */
  uint32_t       val;              /**< Percentage value for progress bar. */
  uint32_t       width;            /**< Width of the progress bar (OS units). */
  uint32_t       height;           /**< Height of the progress bar (OS units). */
  uint32_t       danum;            /**< Dynamic area number for the sprite area (if we unsquashed into a DA). */
  bool           resfs;            /**< Set to true when spr_area is pointing to a sprite area in ResourceFS. */
  sprite_area_t *spr_area;         /**< Progress bar sprite area pointer. */
  sprite_t      *border_spr;       /**< Progress bar 'border' sprite pointer. */
  sprite_t      *fill_spr;         /**< Progress bar 'fill' sprite pointer. */
  sprite_t      *bar_spr;          /**< Progress bar 'bar' sprite pointer. */
  uint32_t       user_scale[4];    /**< User-supplied scale factor block. */
  uint32_t       scale_matrix[4];  /**< Scale factor block (for current mode). */
  uint32_t       pixel_trans[4];   /**< Pixel translation table (for current mode). */
};

/** A node in the doubly-linked list of barinfo structures.
 */
struct infochain_s
{
  barinfo_t    info;
  infochain_t *prev;
  infochain_t *next;
};

/** Layout parameters
 */
struct layout_s
{
  uint16_t dimensions[2];      /**< Dimensions of layout (OS units) */
  uint16_t splash_x, splash_y; /**< Bottom-left corner of splash (OS units) */
  uint16_t splash_scale[2];    /**< Scale factor for splash */
  uint16_t bar_x, bar_y;       /**< Bottom-left corner of bar (OS units) */
  uint16_t bar_scale[2];       /**< Scale factor for bar */
  tclip_t  text_window;        /**< Text window to use (assuming 16x16 OS unit font) */
  uint8_t  min_row, min_col;   /**< Minimum text window size to consider acceptable */
  const char * splash_file;    /**< Path to splash file */
  const char * bar_file;       /**< Path to bar file */ 
};

/** The text window that we set up after the first mode change depends upon the UserIF at build time.
 */
#if (defined UserIF_Raspberry)
static const layout_t layouts[] =
{
  {
    .dimensions = {3840, 2160},
    .splash_x = 0,
    .splash_y = 0,
    .splash_scale = {1, 1},
    .bar_x = 1280,
    .bar_y = 786,
    .bar_scale = {1, 1},
    .text_window = {28, 80, 125, 159, 94},
    .min_row = 10,
    .min_col = 30,
    .splash_file = RESFS_PATH "1920x1080",
    .bar_file = RESFS_PATH "Bar24",
  },
  {
    .dimensions = {3840, 2880},
    .splash_x = 0,
    .splash_y = 1152,
    .splash_scale = {1, 1},
    .bar_x = 640,
    .bar_y = 1720,
    .bar_scale = {2, 1},
    .text_window = {28, 0, 179, 239, 108},
    .min_row = 10,
    .min_col = 30,
    .splash_file = RESFS_PATH "1920x1080",
    .bar_file = RESFS_PATH "Bar24",
  },
};
#else
static const layout_t layouts[] = {};
#endif

static _kernel_oserror *swi_bar_display(const uint32_t flags, barinfo_t * const barinfo, const int32_t x, const int32_t y);
static _kernel_oserror *swi_bar_load(const uint32_t flags, const char * const file, const uint32_t * const user_scale, barinfo_t **handle);

static mode_t         mode_info;               /**< Current screen mode information. */
static barinfo_t     *bootbar        = NULL;   /**< Default progress bar (during the boot sequence). */
static char          *msg_desc       = NULL;   /**< Messages file decriptor. */
static char          *cli_buf        = NULL;   /**< Buffer for CLI commands. */
static void          *logo_jpeg      = NULL;   /**< Pointer to the logo image JPEG data (NULL if none). */
static size_t         logo_size      = 0;      /**< Size (bytes) of the logo image JPEG data. */
static void          *splash_jpeg    = NULL;   /**< Pointer to the splash screen JPEG data (NULL if none). */
static size_t         splash_size    = 0;      /**< Size (bytes) of the splash screen JPEG data. */
static bool           splash_disable = false;  /**< BootFX has disabled its splash screen (and mode change) behaviour */
static void          *Workspace      = NULL;   /**< Module workspace pointer. */
static infochain_t   *infochain      = NULL;   /**< List of all allocated progress bar info blocks. */
static layout_t       layout;                  /**< Layout to use */


/********************************************************************************
 *
 * GENERAL STATIC FUNCTIONS
 *
 ********************************************************************************/


/** Perform a look-up of the specified token in our internationalised Messages file.
 *
 *  @param token Pointer to zero-terminated message token to look-up.
 *
 *  @return Pointer to buffer containing the look-up result (or an error message if the look-up failed).
 *
 *  Note: the string returned will only persist until the next call to this function,
 *  at which point the buffer contents are overwritten.
 */
static const char * const msg(const char * const token)
{
  static char buf[252];
  _kernel_oserror *err;
  uint32_t         length;

  err = _swix(MessageTrans_Lookup, _INR(0,7) | _OUT(3), msg_desc, token, buf, sizeof(buf), 0, 0, 0, 0, &length);
  if (err)
    return &(err->errmess[0]);

  buf[length] = '\0';

  return buf;
}


/** Perform a look-up of an internationalised error message and return the corresponding RISC OS error block.
 *
 *  @param offset Handle of the error token to look-up.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 *
 *  Note: the error block returned will only persist until the next call to this
 *  function, at which point the buffer contents are overwritten.
 */
static _kernel_oserror *eblk(const uint8_t offset)
{
  static _kernel_oserror blk;
  char                   token[12];

  snprintf(token, sizeof(token), "E%02X", offset);

  blk.errnum = ErrorBase_BootFX + offset;
  strcpy(blk.errmess, msg(token));

  return &blk;
}


/** Attempt to allocate some memory and return an appropriate error block pointer if we fail.
 *
 *  @param ptr  Pointer to the buffer pointer (updated by this function).
 *  @param size Number of bytes to allocate (must be non-zero).
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *my_malloc(void **ptr, const size_t size)
{
  *ptr = size ? malloc(size) : NULL;

  return *ptr ? NULL : eblk(BOOTFX_ERR_MALLOC_FAIL);
}


/** Read information about the specified file.
 *
 *  @param fname Pointer to zero-terminated filename string.
 *  @param obj   Pointer to variable used to return the object type.
 *  @param size  Pointer to variable used to return the object size (bytes).
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *file_info(const char * const fname, uint32_t *obj, size_t *size, uint32_t *type)
{
  /* Check the file exists and is non-zero size */
  ERR(_swix(OS_File, _INR(0,1) | _OUT(0) | _OUT(2) | _OUT(4), OSFile_ReadNoPath, fname, obj, type, size));

  *type = (*type << 12) >> 20;
  return NULL;
}


/** Return a pointer and size for a file in ResourceFS (to save pointless loading into RAM).
 *
 *  @param fname Filename for the file to load (zero-terminated).
 *  @param jpg   Returned as a pointer to the file contents (NULL if failed).
 *  @param size  Returned as the size of the file contents (bytes).
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *resfs_file_to_ptr_and_size(const char * const fname, void **ptr, size_t *size)
{
  uint32_t handle;
  uint32_t *addr;

  /* If anything goes wrong, ptr and size should be returned as NULL and 0 respectively */
  *ptr  = NULL;
  *size = 0;

  /* Hack - but the Wimp does it so it must be OK */
  ERR(_swix(OS_Find, _INR(0,1) | _OUT(0), OSFind_OpenIn, fname, &handle));
  ERR(_swix(OS_FSControl, _INR(0,1) | _OUT(1), FSControl_ReadFSHandle, handle, &addr));
  ERR(_swix(OS_Find, _INR(0,1), OSFind_Close, handle));

  /* Now we have a pointer direct to the file contents in ResourceFS... */
  *ptr = addr;

  /* ...and the size of the file in bytes */
  *size = addr[-1] - 4;

  return NULL;
}


/** Check to see if an object is not in ResourceFS.
 *
 *  @param obj File or directory name (zero-terminated).
 *
 *  @return Non-zero if not in ResourceFS, else return zero (in ResourceFS).
 */
static int32_t not_in_resourcefs(const char * const obj)
{
  _kernel_oserror *err;
  char            *buf = NULL;
  int32_t          ans;
  size_t           size;

  /* Canonicalise the object passed into this function */
  err = _swix(OS_FSControl, _INR(0,5) | _OUT(5), 37, obj, 0, 0, 0, 0, &size);
  if (err)
  {
    size = sizeof(RESFS_STR);
  }
  else
  {
    size = -size + 1;
  }

  /* Allocate a buffer to canonicalise (or copy) into */
  ERR_GOTO(my_malloc((void **)&buf, size));

  /* If this fails, we just copy the first part of the input string */
  err = _swix(OS_FSControl, _INR(0,5), 37, obj, buf, 0, 0, size);
  if (err)
  {
    (void) snprintf(buf, sizeof(RESFS_STR), "%s", obj);
  }
  else
  {
    /* Terminate to the same length as the string we're comparing against */
    if (size >= sizeof(RESFS_STR))
    {
      buf[sizeof(RESFS_STR) - 1] = '\0';
    }
  }

  /* Case-insensitive string compare */
  ERR_GOTO(_swix(Territory_Collate, _INR(0,3) | _OUT(0), -1, buf, RESFS_STR, 1, &ans));

  FREE(buf);

  return ans;

error:
  FREE(buf);
  return -1;
}


/** Load a squashed sprites file into memory and then decompress it.
 *
 *  @param arg_string Pointer to argument string.
 *  @param size       Size (bytes) of the file to load.
 *  @param area       Returned: pointer to the sprite area pointer to return from this function.
 *  @param danum      Returned: dynamic area number.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *load_squashed_sprites(const char *arg_string, const size_t size, sprite_area_t **area, uint32_t *danum)
{
  _kernel_oserror *err = NULL;
  char            *buf = NULL;
  uint32_t        *out = NULL;
  void            *wsp = NULL;
  squash_t        *hdr;
  uint32_t         out_sz;
  uint32_t         wsp_sz;
  uint32_t         status;

  *area  = NULL;
  *danum = 0;

  /* Allocate a buffer to load the squashed file into */
  ERR(my_malloc((void **)&buf, size));

  /* Load the file into our buffer */
  ERR_GOTO(_swix(OS_File, _INR(0,3), OSFile_LoadNoPath, arg_string, buf, 0));

  /* Check the squash file header looks sensible */
  hdr = (squash_t *)buf;
  if (
       (hdr->id != SQUASH_HEADER)
       ||
       (hdr->size < 16)
       ||
       (TYPE_SPRITE != ((hdr->load << 12) >> 20))
     )
  {
    ERR_GOTO(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }

  /* Allocate a buffer to unsquash the sprites into */
  out_sz = 64 + hdr->size;
  ERR(_swix(OS_DynamicArea, _INR(0,8) | _OUT(1) | _OUT(3), DAReason_Create, -1, out_sz, -1, 1<<7, out_sz, NULL, NULL, DA_NAME, danum, &out));

  /* Check how much workspace the decompress SWI needs */
  ERR_GOTO(_swix(Squash_Decompress, _INR(0,1) | _OUT(0), 1<<3, -1, &wsp_sz));

  /* Allocate some workspace */
  ERR_GOTO(my_malloc(&wsp, wsp_sz));

  /* Decompress the sprites into the output buffer */
  ERR_GOTO(_swix(Squash_Decompress, _INR(0,5) | _OUT(0), 1<<2, wsp, buf + sizeof(squash_t), size - sizeof(squash_t), out + 1, out_sz - sizeof(uint32_t), &status));

  /* Barf if the decompression failed */
  if (status)
  {
    ERR_GOTO(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }

  /* Free the input buffer and the workspace */
  FREE(buf);
  FREE(wsp);

  /* The first word of the output buffer is the sprite area size */
  *out  = out_sz;
  *area = (sprite_area_t *)out;

  return NULL;

error:
  FREE(wsp);
  FREE(buf);
  if (*danum)
  {
    (void) _swix(OS_DynamicArea, _INR(0,1), DAReason_Remove, *danum);
    *danum = 0;
  }
  return err;
}


/** Plot a JPEG at its mormal size, centred on screen.
 *
 *  @param jpeg Pointer to the loaded JPEG data (NULL if failed).
 *  @param size Size (bytes) of the JPEG data.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *plot_centred_jpeg(const void * const jpeg, const size_t size)
{
  int32_t j_width, j_height, j_xdpi, j_ydpi;
  int32_t x, y;
  trans_t trans;

  ERR(_swix(JPEG_Info, _INR(0,2) | _OUTR(2,5), 1, jpeg, size, &j_width, &j_height, &j_xdpi, &j_ydpi));

  trans.mx = 180 / (1 << mode_info.xeig);
  trans.my = 180 / (1 << mode_info.yeig);
  trans.dx = j_xdpi;
  trans.dy = j_ydpi;

  /* Convert screen dimensions from OS units to pixels */
  x          = mode_info.screen_x >> mode_info.xeig;
  y          = mode_info.screen_y >> mode_info.yeig;

  /* Convert JPEG pixel dimensions to the same DPI as the screen */
  j_width    = (j_width  * trans.mx) / trans.dx;
  j_height   = (j_height * trans.my) / trans.dy;

  /* Calculate the origin for a centred plot */
  x          = (x - j_width) >> 1;
  y          = (y - j_height) >> 1;

  /* Convert back up to OS units */
  x        <<= mode_info.xeig;
  y        <<= mode_info.yeig;

  return _swix(JPEG_PlotScaled, _INR(0,5), jpeg, x, y, &trans, size, 3);
}


/** Plot a JPEG, scaled and positioned for use as the splash image.
 *
 *  @param jpeg Pointer to the loaded JPEG data (NULL if failed).
 *  @param size Size (bytes) of the JPEG data.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *plot_splash_jpeg(const void * const jpeg, const size_t size)
{
  trans_t trans;

  trans.mx = layout.splash_scale[0];
  trans.my = layout.splash_scale[0];
  trans.dx = layout.splash_scale[1];
  trans.dy = layout.splash_scale[1];

  return _swix(JPEG_PlotScaled, _INR(0,5), jpeg, layout.splash_x, layout.splash_y, &trans, size, 3);
}


/** Create a new bar information structure (by adding a new node into the info chain).
 *
 *  @param handle Returned: pointer to the bar info structure.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 *
 *  Side-effect: infochain updated to point at the new (head) node.
 */
static _kernel_oserror *new_barinfo(barinfo_t **handle)
{
  infochain_t *node = NULL;

  *handle = NULL;

  /* Claim a new node on the info chain */
  ERR(my_malloc((void **)&node, sizeof(infochain_t)));

  /* Initialise the node and link into the chain */
  if (NULL != infochain)
    infochain->prev = node;
  node->prev = NULL;
  node->next = infochain;
  infochain  = node;

  /* Initialise the barinfo part of the node */
  node->info.x          = 0;
  node->info.y          = 0;
  node->info.val        = 0;
  node->info.width      = 0;
  node->info.height     = 0;
  node->info.danum      = 0;
  node->info.resfs      = false;
  node->info.spr_area   = NULL;
  node->info.border_spr = NULL;
  node->info.fill_spr   = NULL;
  node->info.bar_spr    = NULL;

  /* Return a pointer to the barinfo structure */
  *handle = &node->info;

  return NULL;
}


/** Update the scale factors and pixel translation table for the specified progress bar.
 *
 *  @param barinfo Pointer to the bar info structure.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *udpate_barinfo_for_mode(barinfo_t *barinfo)
{
  if (NULL != barinfo)
  {
    ERR(_swix(Wimp_ReadPixTrans, _INR(0,2) | _INR(6,7), 0x200 + SpriteReason_PutSpriteScaled, barinfo->spr_area, barinfo->border_spr, barinfo->scale_matrix, barinfo->pixel_trans));
    barinfo->scale_matrix[0] *= barinfo->user_scale[0];
    barinfo->scale_matrix[1] *= barinfo->user_scale[1];
    barinfo->scale_matrix[2] *= barinfo->user_scale[2];
    barinfo->scale_matrix[3] *= barinfo->user_scale[3];
  }
  return NULL;
}


/** Update scale factors and pixel translation tables for all active progress bars.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *update_infochain_for_mode(void)
{
  infochain_t *node = infochain;

  while (node)
  {
    ERR(udpate_barinfo_for_mode((barinfo_t *)node));
    node = node->next;
  }
  return NULL;
}


/** Remove an info chain node and release any memory associated with it.
 *
 *  @param node Pointer to the info chain node to be removed.
 *
 *  Side-effect: infochain will be updated if it was the head node that was removed.
 */
static void remove_info_node(infochain_t *node)
{
  infochain_t *prev = node->prev;
  infochain_t *next = node->next;

  /* Delink */
  if (NULL != prev)
  {
    prev->next = next;
  }
  else
  {
    infochain = next;
  }
  if (NULL != next)
  {
    next->prev = prev;
  }

  /* Free */
  FREE(node);
}


/** Release all memory associated with the info chain.
 *
 *  Side-effect: infochain and bootbar are both set to NULL.
 */
static void release_infochain(void)
{
  while (NULL != infochain)
  {
    infochain_t *node = infochain->next;

    FREE(infochain);
    infochain = node;
  }
  bootbar = NULL;
}


/** Free and reset everything relating to the loaded progress bar sprites.
 *
 *  @param barinfo Pointer to the bar info structure.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *free_sprites(barinfo_t *barinfo)
{
  _kernel_oserror *err = NULL;

  if (NULL != barinfo)
  {
    if (!barinfo->resfs)
    {
      if (barinfo->danum)
      {
        err               = _swix(OS_DynamicArea, _INR(0,1), DAReason_Remove, barinfo->danum);
        barinfo->danum    = 0;
        barinfo->spr_area = NULL;
      }
      else
      {
        FREE(barinfo->spr_area);
      }
    }

    /* Reset lots of stuff to defaults */
    barinfo->resfs      = false;

    barinfo->spr_area   = NULL;

    barinfo->border_spr = NULL;
    barinfo->fill_spr   = NULL;
    barinfo->bar_spr    = NULL;

    barinfo->width      = 0;
    barinfo->height     = 0;
    barinfo->val        = 0;
    barinfo->x          = 0;
    barinfo->y          = 0;

    /* Delink and remove this node from the info chain */
    remove_info_node((infochain_t *)barinfo);
  }
  return err;
}


/** Update some stored information about the current screen mode.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *read_mode_info(void)
{
  static const int32_t vdu_vars[] = { 11, 12, 4, 5, 9, -1 };
  static int32_t vdu_vals[sizeof vdu_vars];

  /* Read some mode variables */
  ERR(_swix(OS_ReadVduVariables, _INR(0,1), &vdu_vars, &vdu_vals));

  /* Record interesting information about the current screen mode */
  mode_info.xeig     = vdu_vals[2];
  mode_info.yeig     = vdu_vals[3];
  mode_info.screen_x = (1 + vdu_vals[0]) << mode_info.xeig;
  mode_info.screen_y = (1 + vdu_vals[1]) << mode_info.yeig;
  mode_info.bpp      = vdu_vals[4];

  return NULL;
}


/** Calculate the layout parameters for the current mode, based around the given template
 *
 *  @param template Pointer to layout parameters to use as a template.
 *
 *  @return Calculated layout parameters for the current mode.
 */
static layout_t calculate_layout(const layout_t * const template)
{
  layout_t ret = *template;
  ret.dimensions[0] = mode_info.screen_x;
  ret.dimensions[1] = mode_info.screen_y;
  uint16_t scale[2];
  uint16_t offset[2];
  /* Scale the reference layout, while maintaining aspect ratio */
  if (template->dimensions[0] * ret.dimensions[1] > template->dimensions[1] * ret.dimensions[0])
  {
    /* Screen aspect is taller, scale to fit width */
    scale[0] = ret.dimensions[0];
    scale[1] = template->dimensions[0];
    offset[0] = 0;
    offset[1] = (ret.dimensions[1]-((template->dimensions[1]*scale[0])/scale[1]))/2;
  }
  else
  {
    /* Screen aspect is wider, scale to fit height */
    scale[0] = ret.dimensions[1];
    scale[1] = template->dimensions[1];
    offset[0] = (ret.dimensions[0]-((template->dimensions[0]*scale[0])/scale[1]))/2;
    offset[1] = 0;
  }
  /* Adjust parameters */
  ret.splash_x = ((template->splash_x*scale[0])/scale[1])+offset[0];
  ret.splash_y = ((template->splash_y*scale[0])/scale[1])+offset[1];
  ret.splash_scale[0] *= scale[0];
  ret.splash_scale[1] *= scale[1];
  ret.bar_x = ((template->bar_x*scale[0])/scale[1])+offset[0];
  ret.bar_y = ((template->bar_y*scale[0])/scale[1])+offset[1];
  ret.bar_scale[0] *= scale[0];
  ret.bar_scale[1] *= scale[1];
  ret.text_window.xmin = ((template->text_window.xmin*scale[0])/scale[1])+(offset[0]>>4);
  uint32_t ymin = ((template->text_window.ymin*scale[0])/scale[1])+(offset[1]>>4);
  uint32_t xmax = ((template->text_window.xmax*scale[0])/scale[1])+(offset[0]>>4);
  ret.text_window.ymax = ((template->text_window.ymax*scale[0])/scale[1])+(offset[1]>>4);
  /* Currently the only way of setting the text window coordinates is via VDU 28, which uses bytes for the coordinate values. This causes problems for large modes (dimensions > 2048)
     Detect out-of-range values and set a zero-size window, this will cause us to fail the size check in pick_layout */
  if ((ymin > 255) || (xmax > 255))
  {
    ret.text_window.ymin = ret.text_window.ymax;
    ret.text_window.xmax = ret.text_window.xmin;
  }
  else
  {
    ret.text_window.ymin = ymin;
    ret.text_window.xmax = xmax;
  }
  return ret;
}

/** Return true if we are not in the desktop.
 *
 *  @return As above. Also, if anything goes wrong, return false.
 */
static bool not_in_desktop(void)
{
  _kernel_oserror *err;
  uint32_t         state;

  err = _swix(Wimp_ReadSysInfo, _IN(0) | _OUT(0), 3, &state);
  return (err || state == 1) ? false : true;
}


/** Return true if the configured language is the "Desktop" module.
 *
 *  @return as above. Also, if anything goes wrong, return false.
 */
static bool conf_lang_is_desktop(void)
{
  uint32_t desk_num;
  uint32_t lang_num;

  /* Look up the module number of the "Desktop" module - indexed from module 0 (Kernel) */
  if (_swix(OS_Module, _INR(0,1) | _OUT(1), ModHandReason_LookupName, "Desktop", &desk_num))
  {
    return false;
  }

  /* Read the configured 'language' (a module number, helpfully indexed from 1 - doh!) */
  if (_swix(OS_Byte, _INR(0,1) | _OUT(2), ReadCMOS, LanguageCMOS, &lang_num))
  {
    return false;
  }
  return desk_num == lang_num - 1;
}


/** Create a text window of the desired size.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *set_text_window(void)
{
  /* Set the text window */
  ERR(_swix(OS_WriteN, _INR(0,1), &layout.text_window, sizeof(layout.text_window)));

  /* Clear the text window to the text background colour */
  ERR(_swix(OS_WriteI+12, 0));

  return NULL;
}

/** Pick a layout to use for the current mode.
 *
 *  @return True if a suitable layout was selected
 */
static bool pick_layout(void)
{
  /* Forget any current splash */
  splash_jpeg = NULL;
  splash_size = 0;

  /* Pick the layout that has the closest aspect ratio to the current mode and which passes our criteria */
  uint32_t mode_aspect = (mode_info.screen_x<<16)/mode_info.screen_y;
  int32_t best_diff = INT32_MAX;

  for (int i=0;i < sizeof(layouts)/sizeof(layouts[0]); i++)
  {
    /* Check aspect ratio */
    uint32_t candidate_aspect = (layouts[i].dimensions[0]<<16)/layouts[i].dimensions[1];
    int32_t diff = candidate_aspect - mode_aspect;
    if (diff < 0)
    {
      diff = -diff;
    }
    if (diff >= best_diff)
    {
      continue;
    }

    layout_t candidate = calculate_layout(&layouts[i]);

    /* Check layout criteria */
    if ((candidate.text_window.xmax+1-candidate.text_window.xmin < candidate.min_col)
     || (candidate.text_window.ymin+1-candidate.text_window.ymax < candidate.min_row))
    {
      continue;
    }

    layout = candidate;
    best_diff = diff;
  }

  if (best_diff != INT32_MAX)
  {
    /* Try and load the relevant files */
    free_sprites(bootbar);
    bootbar = NULL;
    uint32_t scale[4];
    scale[0] = scale[1] = layout.bar_scale[0];
    scale[2] = scale[3] = layout.bar_scale[1];
    if (swi_bar_load(1, layout.bar_file, scale, &bootbar) != NULL)
    {
      goto fail;
    }

    if (resfs_file_to_ptr_and_size(layout.splash_file, &splash_jpeg, &splash_size) != NULL)
    {
      goto fail;
    }
    
    return true;
  }

fail:
  /* Set some default scale factors for safety */
  layout = (layout_t) {
    .splash_scale = {1, 1},
    .bar_scale = {1, 1},
  };

  return false;
}


/** Do all sorts of stuff on a mode change.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 *
 *  Note: we ignore errors from the ScreenFX module in case it simply isn't present.
 */
static _kernel_oserror *mode_has_changed(void)
{
  _kernel_oserror *err;
  bool             predesk = not_in_desktop();

  /* Re-cache our mode information when there's a mode change */
  ERR(read_mode_info());

  /* Update the scale factors and pixel translation tables for all loaded progress bars  */
  ERR(update_infochain_for_mode());

  /* Exit here if we're in the desktop */
  if (!predesk || splash_disable)
  {
    return NULL;
  }

  /* Don't do anything special for this mode if we can't find a suitable layout */
  if (!pick_layout())
  {
    return NULL;
  }

  /* Fade quickly to black */
  (void) _swix(ScreenFX_Fade, _INR(0,3), 1, 0, 0, FADE_OUT_CS);

  /* Plot the splash screen JPEG full-screen */
  if (splash_jpeg)
  {
    ERR_GOTO(plot_splash_jpeg(splash_jpeg, splash_size));
  }

  /* Plot the booting progress bar at the default position */
  if (bootbar)
  {
    ERR(swi_bar_display(0, bootbar, layout.bar_x, layout.bar_y));
  }

  /* Fade in from black (more slowly and in the background) */
  (void) _swix(ScreenFX_Fade, _INR(0,3), 0, 0, 0xFFFFFF00, FADE_IN_CS);

  /* Set up the text window and fade (quickly) to black */
  ERR(set_text_window());

  return NULL;

error:
  (void) _swix(ScreenFX_Fade, _INR(0,3), 1, 0, 0xFFFFFF00, 1);
  return err;
}


/********************************************************************************
 *
 * SOFTWARE INTERRUPTS
 *
 ********************************************************************************/


/** Load some progress bar sprites and return a handle for this progress bar.
 *
 *  @param flags      Flags word.
 *  @param file       Pointer to zero-terminated filename string.
 *  @param user_scale User-provided scale factors (optional)
 *  @param handle     Returned: pointer to the progress bar information block.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *swi_bar_load(const uint32_t flags, const char * const file, const uint32_t * const user_scale, barinfo_t **handle)
{
  _kernel_oserror *err = NULL;
  barinfo_t       *barinfo;
  uint32_t         obj;
  size_t           size;
  uint32_t         type;

  /* If anything goes wrong, make sure we return a null handle */
  *handle = NULL;

  /* Create the empty barinfo structure */
  ERR(new_barinfo(&barinfo));

  /* Check the file exists and is non-zero size */
  ERR(file_info(file, &obj, &size, &type));

  /* Sanity checks */
  if (obj != object_file || !size)
  {
    ERR(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }

  /* Treat squashed sprites as a special case */
  if (type == TYPE_SQUASH)
  {
    ERR(load_squashed_sprites(file, size, &barinfo->spr_area, &barinfo->danum));
  }
  else if (type == TYPE_SPRITE)
  {
    /* If we're loading our sprites from ResourcesFS, we don't really need to load them */
    if (not_in_resourcefs(file))
    {
      /* Allocate some memory for the sprite area */
      size += 64;
      ERR(my_malloc((void **)&barinfo->spr_area, size));

      /* Initialise the sprite area */
      barinfo->spr_area->size    = size;
      barinfo->spr_area->num_spr = 0;
      barinfo->spr_area->sprite  = 16;
      barinfo->spr_area->free    = 16;

      /* Load the sprite file into our sprite area */
      ERR_GOTO(_swix(OS_SpriteOp, _INR(0,2), 256 + SpriteReason_LoadSpriteFile, barinfo->spr_area, file));
    }
    else
    {
      void *ptr;

      ERR(resfs_file_to_ptr_and_size(file, &ptr, &size));
      barinfo->resfs    = true;
      barinfo->spr_area = (sprite_area_t *)((uint32_t)ptr - 4);
    }
  }
  else
  {
    ERR(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }

  /* Verify the sprite area */
  ERR_GOTO(_swix(OS_SpriteOp, _INR(0,1), 256 + SpriteReason_CheckSpriteArea, barinfo->spr_area));

  /* Look-up the address of the two sprites we're interested in */
  (void) _swix(OS_SpriteOp, _INR(0,2) | _OUT(2), 256 + SpriteReason_SelectSprite, barinfo->spr_area, "border", &barinfo->border_spr);
  (void) _swix(OS_SpriteOp, _INR(0,2) | _OUT(2), 256 + SpriteReason_SelectSprite, barinfo->spr_area, "fill", &barinfo->fill_spr);
  (void) _swix(OS_SpriteOp, _INR(0,2) | _OUT(2), 256 + SpriteReason_SelectSprite, barinfo->spr_area, "bar", &barinfo->bar_spr);

  if (!barinfo->border_spr || !barinfo->fill_spr || !barinfo->bar_spr)
  {
    ERR_GOTO(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }

  /* Read the dimensions of the border sprite */
  ERR_GOTO(_swix(OS_SpriteOp, _INR(0,2) | _OUTR(3,4), 512 + SpriteReason_ReadSpriteSize, barinfo->spr_area, barinfo->border_spr, &barinfo->width, &barinfo->height));

  /* Initialise the scale factors and pixel translation table for plotting this progress bar */
  if (flags & 1)
  {
    barinfo->user_scale[0] = user_scale[0];
    barinfo->user_scale[1] = user_scale[1];
    barinfo->user_scale[2] = user_scale[2];
    barinfo->user_scale[3] = user_scale[3];
  }
  else
  {
    barinfo->user_scale[0] = barinfo->user_scale[1] = barinfo->user_scale[2] = barinfo->user_scale[3] = 1;
  }
  ERR_GOTO(udpate_barinfo_for_mode(barinfo));

  *handle = barinfo;

  return NULL;

error:
  (void) free_sprites(barinfo);
  return err;
}


/** Update the progress bar to the specified %age position.
 *
 *  @param flags   Flags word (currently unused).
 *  @param barinfo Pointer to the progress bar information block.
 *  @param percent Percentage value to update the progress bar to.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 *
 *  TODO: this function can't yet cope with the progress bar moving downwards to a lower %age.
 */
static _kernel_oserror *swi_bar_update(const uint32_t flags, barinfo_t * barinfo, int32_t percent)
{
  int32_t offset;
  gclip_t vdu;

  /* Cludge: this magic value is used by BootCommands to update the booting progress bar using
   * a SWI call rather than the CLI command.
   */
  if (BOOTFX_MAGIC_HANDLE == (uint32_t)barinfo)
  {
    barinfo = bootbar;
  }

  if (NULL == barinfo)
  {
    ERR(eblk(BOOTFX_ERR_BAD_BAR_HANDLE));
  }

  /* A bit of over-engineering */
  if (!barinfo->fill_spr)
    return eblk(BOOTFX_ERR_NO_SPRITES);

  /* Range checks */
  if (percent < 0)
    percent = 0;
  else if (percent > 100)
    percent = 100;

  /* Calculate scaled bar size */
  int32_t width = (barinfo->width*barinfo->user_scale[0])/barinfo->user_scale[2];
  int32_t height = (barinfo->height*barinfo->user_scale[1])/barinfo->user_scale[3];

  /* Calculate how far back (pixels) the bar needs to be plotted from the origin of the border */
  offset       = -width + ((width * percent) / 100);
  barinfo->val = (int32_t)percent;

  /* Create the graphics clipping rectangle */
  vdu.vdu  = 24;
  vdu.xmin = barinfo->x;
  vdu.ymin = barinfo->y;
  vdu.xmax = barinfo->x + ((width + offset) << mode_info.xeig);
  vdu.ymax = barinfo->y + (height << mode_info.yeig);

  /* Set the graphics clipping rectangle */
  ERR(_swix(OS_WriteN, _INR(0,1), &vdu, sizeof(vdu)));

  /* Wait for a vsync */
  if (0 == (flags & FLAG_BarUpdate_NoWait))
  {
    ERR(_swix(OS_Byte, _IN(0), 19));
  }

  /* Plot the background fill */
  ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, barinfo->spr_area, barinfo->fill_spr, barinfo->x, barinfo->y, 8, barinfo->scale_matrix, barinfo->pixel_trans));

  /* Plot the progress bar */
  ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, barinfo->spr_area, barinfo->bar_spr, barinfo->x + (offset << mode_info.xeig), barinfo->y, 8, barinfo->scale_matrix, barinfo->pixel_trans));

  /* Plot the border */
  ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, barinfo->spr_area, barinfo->border_spr, barinfo->x, barinfo->y, 8, barinfo->scale_matrix, barinfo->pixel_trans));

  return NULL;
}


/** Display the progress bar at the specified co-ordinates.
 *
 *  @param flags   Flags word (currently unused).
 *  @param barinfo Pointer to the progress bar information block.
 *  @param x       Position of left edge (OS units).
 *  @param y       Position of bottom edge (OS units).
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *swi_bar_display(const uint32_t flags, barinfo_t * const barinfo, const int32_t x, const int32_t y)
{
  IGNORE(flags);

  if (NULL == barinfo)
  {
    ERR(eblk(BOOTFX_ERR_BAD_BAR_HANDLE));
  }

  if (barinfo->spr_area)
  {
    barinfo->x = x;
    barinfo->y = y;

    /* (Re)plot the progress bar border and fill */
    ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, barinfo->spr_area, barinfo->border_spr, barinfo->x, barinfo->y, 8, barinfo->scale_matrix, barinfo->pixel_trans));
    ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, barinfo->spr_area, barinfo->fill_spr, barinfo->x, barinfo->y, 8, barinfo->scale_matrix, barinfo->pixel_trans));

    /* If the progress bar is at a non-zero position, replot it */
    if (barinfo->val)
    {
      ERR(swi_bar_update(0, barinfo, barinfo->val));
    }
  }
  return NULL;
}


/** Free any memory associated with this progress bar.
 *
 *  @param flags   Flags word (currently unused).
 *  @param barinfo Pointer to the progress bar information block.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *swi_bar_free(const uint32_t flags, barinfo_t * const barinfo)
{
  IGNORE(flags);

  if (NULL == barinfo)
  {
    ERR(eblk(BOOTFX_ERR_BAD_BAR_HANDLE));
  }
  return free_sprites(barinfo);
}


/** Return information about the specified progress bar.
 *
 *  @param flags   Flags word (currently unused).
 *  @param barinfo Pointer to the progress bar information block.
 *  @param val     Returned: current percentage.
 *  @param x       Returned: current left edge (OS units).
 *  @param y       Returned: current bottom edge (OS units).
 *  @param width   Returned: total width (OS units).
 *  @param height  Returned: total height (OS units).
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *swi_bar_readinfo(const uint32_t flags, barinfo_t * const barinfo, int32_t *val, int32_t *x, int32_t *y, int32_t *width, int32_t *height)
{
  IGNORE(flags);

  if (NULL == barinfo)
  {
    ERR(eblk(BOOTFX_ERR_BAD_BAR_HANDLE));
  }

  *val    = barinfo->val;
  *x      = barinfo->x;
  *y      = barinfo->y;
  *width  = (barinfo->width*barinfo->user_scale[0])/barinfo->user_scale[2];
  *height = (barinfo->height*barinfo->user_scale[1])/barinfo->user_scale[3];

  return NULL;
}


/********************************************************************************
 *
 * CLI COMMANDS
 *
 ********************************************************************************/


/** Discard any memory associated with the progress bar graphics and reset its state.
 *
 *  @param arg_string Pointer to argument string.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *cli_bar_free(const char *arg_string)
{
  IGNORE(arg_string);

  ERR(free_sprites(bootbar));
  bootbar = NULL;

  return NULL;
}


/** Load a sprite file containing the graphics to use for the progress bar.
 *
 *  @param arg_string Pointer to argument string.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *cli_bar_load(const char *arg_string)
{
  ERR(free_sprites(bootbar));
  bootbar = NULL;

  return swi_bar_load(0, arg_string, NULL, &bootbar);
}


/** Display the progress bar at the specified co-ordinates.
 *
 *  @param arg_string Pointer to argument string.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *cli_bar_display(const char *arg_string)
{
  int32_t x, y;
  int     ret = sscanf(arg_string, "%d %d", &x, &y);

  if (ret != 2)
  {
    ERR(eblk(BOOTFX_ERR_SYN_POS));
  }
  return swi_bar_display(0, bootbar, x, y);
}


/** Command handler to update the position of the progress bar.
 *
 *  @param arg_string Pointer to argument string.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *cli_bar_update(const char *arg_string)
{
  int32_t val;
  int     ret = sscanf(arg_string, "%d", &val);

  if (ret != 1)
  {
    ERR(eblk(BOOTFX_ERR_SYN_PLOT));
  }
  return swi_bar_update(0, bootbar, val);
}


/** Output some internal debugging information.
 *
 *  @param arg_string Pointer to argument string.
 *
 *  @return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *cli_debug(const char *arg_string)
{
  IGNORE(arg_string);

  printf("BootFX state:\n");
  printf("  splash is %sdisabled\n", splash_disable ? "" : "not ");
  printf("  conf lang is%s desktop, ", conf_lang_is_desktop() ? "" : " not");
  printf("%sin desktop now\n", not_in_desktop() ? "not " : "");
  if (NULL == bootbar)
  {
    printf("  bar sprites not loaded\n");
  }
  else
  {
    printf("  bar sprites at &%08X (%sin resfs, DA num %u)\n", (uint32_t)bootbar->spr_area, bootbar->resfs ? "" : "not ", bootbar->danum);
  }
  printf("  logo JPEG at &%08X size = %d\n", (uint32_t)logo_jpeg, logo_size);
  printf("  splash JPEG at &%08X size = %d\n", (uint32_t)splash_jpeg, splash_size);
  printf("  layout:\n");
  printf("    dims %dx%d\n", layout.dimensions[0], layout.dimensions[1]);
  printf("    splash %d,%d scale %d:%d\n", layout.splash_x, layout.splash_y, layout.splash_scale[0], layout.splash_scale[1]);
  printf("    bar %d,%d scale %d:%d\n", layout.bar_x, layout.bar_y, layout.bar_scale[0], layout.bar_scale[1]);
  printf("    text window %d,%d %d,%d\n", layout.text_window.xmin, layout.text_window.ymin, layout.text_window.xmax, layout.text_window.ymax);
  return NULL;
}


/********************************************************************************
 *
 * MAIN EXTERN FUNCTIONS (see h.bootfxHdr)
 *
 ********************************************************************************/


/********************************************************************************
 */
_kernel_oserror *Module_Init(const char *cmd_tail, int podule_base, void *pw)
{
  static _kernel_oserror mfail = { 0, "Failed to claim RMA for message descriptor block" };
  _kernel_oserror *err;
  int8_t cursoff[] = { 23, 1, 0, 0, 0, 0, 0, 0, 0, 0 };

  IGNORE(cmd_tail);
  IGNORE(podule_base);

  /* Make a note of our private word pointer for vector handlers */
  Workspace = pw;

#ifndef ROM_MODULE
  /* In RAM builds, all resource files live in the module binary and need to be added to ResourceFS.
   * ROM builds don't need to do this because this module's resources are part of the Messages module.
   */
  ERR(_swix(ResourceFS_RegisterFiles, _IN(0), Resources()));
#endif

  /* Read information about the current screen mode */
  ERR(read_mode_info());

  /* Allocate a buffer for CLI processing */
  ERR(my_malloc((void **)&cli_buf, CLI_BUF_SZ));

  /* Allocate a message file descriptor block */
  msg_desc = malloc(16 + strlen(Module_MessagesFile) + 1);
  if (!msg_desc)
  {
    return &mfail;
  }
  strcpy(msg_desc + 16, Module_MessagesFile);

  /* Open our messages file */
  err = _swix(MessageTrans_OpenFile, _INR(0,2), msg_desc, msg_desc + 16, 0);
  if (err)
  {
    FREE(msg_desc);
    return err;
  }

  /* Set the BootFX path variable */
  ERR(_swix(OS_SetVarVal, _INR(0,4), BOOTFX_SYSVAR, RESFS_PATH, strlen(RESFS_PATH), 0, 0));

  /* We only do splash screen stuff if the machine is configured to boot in the normal way */
  if (conf_lang_is_desktop())
  {
    /* Look for the logo JPEG */
    if (NULL == resfs_file_to_ptr_and_size(LOGO_JPEG_FILE, &logo_jpeg, &logo_size))
    {
      /* If we're outside the desktop, we'll assume it's the ROMInit stage of booting */
      if (not_in_desktop())
      {
        /* Switch the cursor off */
        ERR(_swix(OS_WriteN, _INR(0,1), cursoff, sizeof cursoff));

        /* Plot the logo image */
        ERR(plot_centred_jpeg(logo_jpeg, logo_size));
      }
      else
      {
        splash_disable = true;
      }
    }
    else
    {
      splash_disable = true;
    }
  }
  return err;
}


/********************************************************************************
 */
_kernel_oserror *Module_Final(int fatal, int podule, void *pw)
{
  IGNORE(fatal);
  IGNORE(podule);
  IGNORE(pw);

  /* Close our messages file */
  (void) _swix(MessageTrans_CloseFile, _IN(0), msg_desc);

  /* Free various buffers and lists */
  FREE(msg_desc);
  FREE(cli_buf);
  release_infochain();

  /* Deregister our ResourceFS stuff (in RAM builds only) */
#ifndef ROM_MODULE
  (void) _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());

  /* For RAM builds, we should also unset the BootFX path variable */
  (void) _swix(OS_SetVarVal, _INR(0,4), BOOTFX_SYSVAR, NULL, -1, 0, 0);
#endif

  return NULL;
}


/********************************************************************************
 */
void Module_Service(int service_number, _kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);

  switch (service_number)
  {
    case Service_ModeChange:
    {
      (void) mode_has_changed();
      break;
    }
    case Service_DesktopWelcome:
    {
      /* Stop doing splash screen plotting */
      if (splash_jpeg)
      {
        (void) plot_splash_jpeg(splash_jpeg, splash_size);
        splash_jpeg = NULL;
        splash_size = 0;
      }

      /* Discard the progress bar sprite data (and free the buffer) */
      (void) free_sprites(bootbar);
      bootbar = NULL;

      /* Remember that the desktop has now been reached */
      splash_disable = true;

      /* Claim this service call to stop the desktop banner window */
      r->r[1] = 0;
      break;
    }
  }
}


/********************************************************************************
 */
_kernel_oserror *Module_SWI(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);

  /* Call the appropriate handler function */
  switch (swi_offset)
  {
    case BootFX_BarLoad - BootFX_00:
    {
      barinfo_t *handle = NULL;

      ERR(swi_bar_load(r->r[0], (char *)r->r[1], (const uint32_t * const)r->r[2], &handle));
      r->r[0] = (int32_t)handle;

      return NULL;
    }
    case BootFX_BarDisplay - BootFX_00:
    {
      return swi_bar_display(r->r[0], (barinfo_t *)r->r[1], r->r[2], r->r[3]);
    }
    case BootFX_BarUpdate - BootFX_00:
    {
      return swi_bar_update(r->r[0], (barinfo_t *)r->r[1], r->r[2]);
    }
    case BootFX_BarFree - BootFX_00:
    {
      ERR(swi_bar_free(r->r[0], (barinfo_t *)r->r[1]));
      r->r[1] = 0;

      return NULL;
    }
    case BootFX_BarReadInfo - BootFX_00:
    {
      return swi_bar_readinfo(r->r[0], (barinfo_t *)r->r[1], &r->r[0], &r->r[1], &r->r[2], &r->r[3], &r->r[4]);
    }
  }
  return error_BAD_SWI;
}


/********************************************************************************
 */
_kernel_oserror *Module_Cmd(const char *arg_string, int argc, int cmd_no, void *pw)
{
  char *ptr;
  char *end = cli_buf + CLI_BUF_SZ;

  IGNORE(argc);
  IGNORE(pw);

  /* IMPORTANT NOTE: The arg_string may not be zero-terminated! */
  ptr = cli_buf;
  while (ptr < end && *arg_string >= ' ')
  {
    *ptr++ = *arg_string++;
  }
  *ptr = '\0';

  /* Call the appropriate handler function */
  switch (cmd_no)
  {
    case CMD_BootFX_BarFree:
      return cli_bar_free(cli_buf);
    case CMD_BootFX_BarLoad:
      return cli_bar_load(cli_buf);
    case CMD_BootFX_BarDisplay:
      return cli_bar_display(cli_buf);
    case CMD_BootFX_BarUpdate:
      return cli_bar_update(cli_buf);
    case CMD_BootFX_Debug:
      return cli_debug(cli_buf);
  }
  return NULL;
}
