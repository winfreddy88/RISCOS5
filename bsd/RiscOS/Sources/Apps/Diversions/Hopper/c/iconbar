/*
 * Copyright (c) 1994, Simon Foster
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
  Handle the iconbar
  iconbar.c
*/

#include <string.h>
#include "wimp.h"
#include "macros.h"

#include "iconbar.h"
#include "memory.h"
#include "menu.h"
#include "exit.h"
#include "templates.h"
#include "keys.h"
#include "hopper.h"
#include "messages.h"


/* Globals */
wimp_MENU(iconbar_NUM_ENTRIES)  iconbar_menu ;
wimp_i	  	 		iconbar_icon_hnd ;
char				ind_info[20], ind_prefs[20], ind_quit[20];


/* Initialise the iconbar, i.e. the sprite on the iconbar */
void iconbar_initialise ( void )
{
  wimp_icon_create  *my_icon ;

  my_icon = (wimp_icon_create *) memory_alloc ( sizeof (wimp_icon_create), "iconbar icon" ) ;
  my_icon -> w = wimp_ICON_BAR_RIGHT ;
  my_icon -> icon.extent.x0 = 0 ;
  my_icon -> icon.extent.y0 = 0 ;
  my_icon -> icon.extent.x1 = 68 ;
  my_icon -> icon.extent.y1 = 68 ;
  my_icon -> icon.flags = wimp_ICON_SPRITE | wimp_ICON_HCENTRED |
                                                        wimp_ICON_VCENTRED |
                          wimp_BUTTON_CLICK << wimp_ICON_BUTTON_TYPE_SHIFT ;
  strcpy ( my_icon -> icon.data.sprite, "!" info_APPNAME ) ;

  iconbar_icon_hnd = wimp_create_icon ( my_icon ) ;
}



/* Create the menu structure */
void iconbar_create_menu ( void )
{
  static const char *ind_validation = "A0-9;KR" ;
  int width;

  strcpy ( iconbar_menu.title_data.text, info_APPNAME ) ;
  width = strlen ( info_APPNAME );

  iconbar_menu.entries[iconbar_MENU_INFO].menu_flags = 0x00u ;
  iconbar_menu.entries[iconbar_MENU_INFO].sub_menu =
                                             (wimp_menu *) proginfo_hnd ;
  iconbar_menu.entries[iconbar_MENU_INFO].icon_flags = wimp_ICON_TEXT |
                                   wimp_ICON_FILLED | wimp_ICON_INDIRECTED |
                          wimp_BUTTON_CLICK << wimp_ICON_BUTTON_TYPE_SHIFT |
                            wimp_COLOUR_BLACK << wimp_ICON_FG_COLOUR_SHIFT |
                            wimp_COLOUR_WHITE << wimp_ICON_BG_COLOUR_SHIFT ;
  strcpy ( ind_info, messages_xlate_text ( "M00", NULL, NULL ) ) ;
  iconbar_menu.entries[iconbar_MENU_INFO].data.indirected_text.text =
                                                                  ind_info ;
  iconbar_menu.entries[iconbar_MENU_INFO].data.indirected_text.validation =
  	                                           (char *) ind_validation ;
  iconbar_menu.entries[iconbar_MENU_KEYS].data.indirected_text.size =
                                                       strlen ( ind_info ) ;
  width = MAX ( width, strlen (ind_info) );

  iconbar_menu.entries[iconbar_MENU_KEYS].menu_flags = 0x00u ;
  iconbar_menu.entries[iconbar_MENU_KEYS].sub_menu = wimp_NO_SUB_MENU ;
  iconbar_menu.entries[iconbar_MENU_KEYS].icon_flags = wimp_ICON_TEXT |
                                   wimp_ICON_FILLED | wimp_ICON_INDIRECTED |
                          wimp_BUTTON_CLICK << wimp_ICON_BUTTON_TYPE_SHIFT |
                            wimp_COLOUR_BLACK << wimp_ICON_FG_COLOUR_SHIFT |
                            wimp_COLOUR_WHITE << wimp_ICON_BG_COLOUR_SHIFT ;
  strcpy ( ind_prefs, messages_xlate_text ( "M01", NULL, NULL ) ) ;
  iconbar_menu.entries[iconbar_MENU_KEYS].data.indirected_text.text =
  	                                                         ind_prefs ;
  iconbar_menu.entries[iconbar_MENU_KEYS].data.indirected_text.validation =
  	                                           (char *) ind_validation ;
  iconbar_menu.entries[iconbar_MENU_KEYS].data.indirected_text.size =
                                                      strlen ( ind_prefs ) ;
  width = MAX ( width, strlen (ind_prefs) );

  iconbar_menu.entries[iconbar_MENU_QUIT].menu_flags = wimp_MENU_LAST ;
  iconbar_menu.entries[iconbar_MENU_QUIT].sub_menu = wimp_NO_SUB_MENU ;
  iconbar_menu.entries[iconbar_MENU_QUIT].icon_flags = wimp_ICON_TEXT |
                                   wimp_ICON_FILLED | wimp_ICON_INDIRECTED |
                          wimp_BUTTON_CLICK << wimp_ICON_BUTTON_TYPE_SHIFT |
                            wimp_COLOUR_BLACK << wimp_ICON_FG_COLOUR_SHIFT |
                            wimp_COLOUR_WHITE << wimp_ICON_BG_COLOUR_SHIFT ;
  strcpy ( ind_quit, messages_xlate_text ( "M02", NULL, NULL ) ) ;
  iconbar_menu.entries[iconbar_MENU_QUIT].data.indirected_text.text =
  	                                                          ind_quit ;
  iconbar_menu.entries[iconbar_MENU_QUIT].data.indirected_text.validation =
  	                                           (char *) ind_validation ;
  iconbar_menu.entries[iconbar_MENU_QUIT].data.indirected_text.size =
                                                       strlen ( ind_quit ) ;
  width = MAX ( width, strlen (ind_quit) );

  iconbar_menu.title_fg = wimp_COLOUR_BLACK ;
  iconbar_menu.title_bg = wimp_COLOUR_LIGHT_GREY ;
  iconbar_menu.work_fg  = wimp_COLOUR_BLACK ;
  iconbar_menu.work_bg  = wimp_COLOUR_WHITE ;
  iconbar_menu.width    = (1 + width) * 16 ;
  iconbar_menu.height   = 44 ;
  iconbar_menu.gap      = 0 ;
}



/* Display the menu on the screen */
void iconbar_display_menu ( wimp_block *my_block )
{
  menu_create_menu ( my_block, (wimp_menu *) &iconbar_menu,
                                       iconbar_NUM_ENTRIES, iconbar_MENU ) ;
}



/* Mouse click detected on iconbar, now process according to the button */
void iconbar_clicked ( wimp_block *my_block )
{
  switch ( my_block -> pointer.buttons ) {
    case wimp_CLICK_SELECT :
    case wimp_CLICK_ADJUST :
      hopper_go () ;
      break ;
    case wimp_CLICK_MENU :
      iconbar_create_menu () ;
      iconbar_display_menu ( my_block ) ;
      break ;
  }
}



/* Decode the menu entry selected on the iconbar menu */
void iconbar_menu_selected ( wimp_block *my_block )
{
  wimp_pointer pinfo ;

  switch ( my_block -> selection.items[0] ) {
    case iconbar_MENU_KEYS :
      keys_show_keys () ;
      break ;
    case iconbar_MENU_QUIT :
      exit_selected () ;
      break ;
  }

  wimp_get_pointer_info ( &pinfo ) ;
  if (pinfo.buttons == wimp_CLICK_ADJUST) {
    iconbar_display_menu ( my_block ) ;
  }
}



